{"repo_name":"root-mirror/root","ref":"refs/heads/master","path":"interpreter/llvm/src/tools/llvm-pdbutil/PrettyExternalSymbolDumper.cpp","copies":"45","language":"C++","content":"//===- PrettyExternalSymbolDumper.cpp -------------------------- *- C++ *-===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#include \"PrettyExternalSymbolDumper.h\"\n#include \"LinePrinter.h\"\n\n#include \"llvm/DebugInfo/PDB/PDBSymbolExe.h\"\n#include \"llvm/DebugInfo/PDB/PDBSymbolPublicSymbol.h\"\n#include \"llvm/Support/Format.h\"\n\nusing namespace llvm;\nusing namespace llvm::pdb;\n\nExternalSymbolDumper::ExternalSymbolDumper(LinePrinter \u0026P)\n    : PDBSymDumper(true), Printer(P) {}\n\nvoid ExternalSymbolDumper::start(const PDBSymbolExe \u0026Symbol) {\n  auto Vars = Symbol.findAllChildren\u003cPDBSymbolPublicSymbol\u003e();\n  while (auto Var = Vars-\u003egetNext())\n    Var-\u003edump(*this);\n}\n\nvoid ExternalSymbolDumper::dump(const PDBSymbolPublicSymbol \u0026Symbol) {\n  std::string LinkageName = Symbol.getName();\n  if (Printer.IsSymbolExcluded(LinkageName))\n    return;\n\n  Printer.NewLine();\n  uint64_t Addr = Symbol.getVirtualAddress();\n\n  Printer \u003c\u003c \"[\";\n  WithColor(Printer, PDB_ColorItem::Address).get() \u003c\u003c format_hex(Addr, 10);\n  Printer \u003c\u003c \"] \";\n  WithColor(Printer, PDB_ColorItem::Identifier).get() \u003c\u003c LinkageName;\n}\n"}
{"repo_name":"regneq/TrinityCore","ref":"refs/heads/3.3.5","path":"src/server/game/Miscellaneous/CommonPredicates.cpp","copies":"11","language":"C++","content":"/*\n * Copyright (C) 2008-2019 TrinityCore \u003chttps://www.trinitycore.org/\u003e\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the\n * Free Software Foundation; either version 2 of the License, or (at your\n * option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n * more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program. If not, see \u003chttp://www.gnu.org/licenses/\u003e.\n */\n\n#include \"CommonPredicates.h\"\n#include \"Common.h\"\n#include \"Unit.h\"\n#include \"SharedDefines.h\"\n\nTrinity::Predicates::IsVictimOf::IsVictimOf(Unit const* attacker) : _victim(attacker ? attacker-\u003eGetVictim() : nullptr) { }\n"}
{"repo_name":"NeuroRoboticTech/AnimatLabPublicSource","ref":"refs/heads/master","path":"Libraries/AnimatCarlSimCUDA/CsClassFactory.cpp","copies":"1","language":"C++","content":"/**\n\\file\tCsClassFactory.cpp\n\n\\brief\tImplements the class factory class.\n**/\n\n#include \"StdAfx.h\"\n\n#include \"CsNeuralModule.h\"\n#include \"CsNeuronGroup.h\"\n#include \"CsSpikeGeneratorGroup.h\"\n#include \"CsSynapseGroup.h\"\n#include \"CsSynapseOneToOne.h\"\n#include \"CsSynapseFull.h\"\n#include \"CsSynapseRandom.h\"\n#include \"CsSynapseIndividual.h\"\n#include \"CsSpikingCurrentSynapse.h\"\n#include \"CsFiringRateStimulus.h\"\n#include \"CsNeuronDataColumn.h\"\n#include \"CsAdapter.h\"\n#include \"CsClassFactory.h\"\n\nnamespace AnimatCarlSim\n{\n\n/**\n\\brief\tDefault constructor.\n\t\n\\author\tdcofer\n\\date\t3/30/2011\n**/\nCsClassFactory::CsClassFactory()\n{\n\n}\n\n/**\n\\brief\tDestructor.\n\n\\author\tdcofer\n\\date\t3/30/2011\n**/\nCsClassFactory::~CsClassFactory()\n{\n\n}\n\nNode *CsClassFactory::CreateNeuron(std::string strType, bool bThrowError)\n{\n\tNode *lpNeuron=NULL;\n\ntry\n{\n\tstrType = Std_ToUpper(Std_Trim(strType));\n\n\tif(strType == \"NEURONGROUP\")\n\t\tlpNeuron = new CsNeuronGroup;\n\telse if(strType == \"SPIKEGENERATORGROUP\")\n\t\tlpNeuron = new CsSpikeGeneratorGroup;\n\telse \n\t{\n\t\tlpNeuron = NULL;\n\t\tif(bThrowError)\n\t\t\tTHROW_PARAM_ERROR(Cs_Err_lInvalidNeuronType, Cs_Err_strInvalidNeuronType, \"NeuronType\", strType);\n\t}\n\n\treturn lpNeuron;\n}\ncatch(CStdErrorInfo oError)\n{\n\tif(lpNeuron) delete lpNeuron;\n\tRELAY_ERROR(oError); \n\treturn NULL;\n}\ncatch(...)\n{\n\tif(lpNeuron) delete lpNeuron;\n\tTHROW_ERROR(Std_Err_lUnspecifiedError, Std_Err_strUnspecifiedError);\n\treturn NULL;\n}\n}\n\n\n// ************* Neuron Type Conversion functions ******************************\n\n\n// ************* Synapse Type Conversion functions ******************************\n\n\nAnimatSim::Link *CsClassFactory::CreateSynapse(std::string strType, bool bThrowError)\n{\n\tAnimatSim::Link *lpSynapse=NULL;\n\ntry\n{\n\tstrType = Std_ToUpper(Std_Trim(strType));\n\n\tif(strType == \"ONETOONESYNAPSE\")\n\t\tlpSynapse = new CsSynapseOneToOne;\n\telse if(strType == \"FULLSYNAPSE\")\n\t\tlpSynapse = new CsSynapseFull;\n\telse if(strType == \"RANDOMSYNAPSE\")\n\t\tlpSynapse = new CsSynapseRandom;\n\telse if(strType == \"INDIVIDUALSYNAPSE\")\n\t\tlpSynapse = new CsSynapseIndividual;\n\telse if(strType == \"SPIKINGCURRENTSYNAPSE\")\n\t\tlpSynapse = new CsSpikingCurrentSynapse;\n\telse\n\t{\n\t\tlpSynapse = NULL;\n\t\tif(bThrowError)\n\t\t\tTHROW_PARAM_ERROR(Cs_Err_lInvalidSynapseType, Cs_Err_strInvalidSynapseType, \"SynapseType\", strType);\n\t}\n\n\treturn lpSynapse;\n}\ncatch(CStdErrorInfo oError)\n{\n\tif(lpSynapse) delete lpSynapse;\n\tRELAY_ERROR(oError); \n\treturn NULL;\n}\ncatch(...)\n{\n\tif(lpSynapse) delete lpSynapse;\n\tTHROW_ERROR(Std_Err_lUnspecifiedError, Std_Err_strUnspecifiedError);\n\treturn NULL;\n}\n}\n\n// ************* Synapse Type Conversion functions ******************************\n\n\n// ************* External Neural Module Conversion functions ******************************\n\n\nNeuralModule *CsClassFactory::CreateNeuralModule(std::string strType, bool bThrowError)\n{\n\tNeuralModule *lpModule=NULL;\n\ntry\n{\n\tstrType = Std_ToUpper(Std_Trim(strType));\n\n\tif(strType == \"CARLSIMNEURALMODULE\")\n\t\tlpModule = new CsNeuralModule;\n\telse\n\t{\n\t\tlpModule = NULL;\n\t\tif(bThrowError)\n\t\t\tTHROW_PARAM_ERROR(Al_Err_lInvalidNeuralModuleType, Al_Err_strInvalidNeuralModuleType, \"NeuralModule\", strType);\n\t}\n\n\treturn lpModule;\n}\ncatch(CStdErrorInfo oError)\n{\n\tif(lpModule) delete lpModule;\n\tRELAY_ERROR(oError); \n\treturn NULL;\n}\ncatch(...)\n{\n\tif(lpModule) delete lpModule;\n\tTHROW_ERROR(Std_Err_lUnspecifiedError, Std_Err_strUnspecifiedError);\n\treturn NULL;\n}\n}\n\n// ************* Neural Module Type Conversion functions ******************************\n\n\n// ************* External Stimulus Type Conversion functions ******************************\n\nExternalStimulus *CsClassFactory::CreateExternalStimulus(std::string strType, bool bThrowError)\n{\n\tExternalStimulus *lpStimulus=NULL;\n\ntry\n{\n\tstrType = Std_ToUpper(Std_Trim(strType));\n\n\tif(strType == \"FIRINGRATE\")\n\t\tlpStimulus = new CsFiringRateStimulus;\n\telse\n\t{\n\t\tlpStimulus = NULL;\n\t\tif(bThrowError)\n\t\t\tTHROW_PARAM_ERROR(Al_Err_lInvalidExternalStimulusType, Al_Err_strInvalidExternalStimulusType, \"ExternalStimulusType\", strType);\n\t}\n\n\treturn lpStimulus;\n}\ncatch(CStdErrorInfo oError)\n{\n\tif(lpStimulus) delete lpStimulus;\n\tRELAY_ERROR(oError); \n\treturn NULL;\n}\ncatch(...)\n{\n\tif(lpStimulus) delete lpStimulus;\n\tTHROW_ERROR(Std_Err_lUnspecifiedError, Std_Err_strUnspecifiedError);\n\treturn NULL;\n}\n}\n\n// ************* External Stimulus Type Conversion functions ******************************\n\n\n// ************* DataColumn Type Conversion functions ******************************\n\nDataColumn *CsClassFactory::CreateDataColumn(std::string strType, bool bThrowError)\n{\n\tDataColumn *lpColumn=NULL;\n\ntry\n{\n\tstrType = Std_ToUpper(Std_Trim(strType));\n\n\tif(strType == \"NEURONDATACOLUMN\")\n\t\tlpColumn = new CsNeuronDataColumn;\n\telse\n\t{\n\t\tlpColumn = NULL;\n\t\tif(bThrowError)\n\t\t\tTHROW_PARAM_ERROR(Al_Err_lInvalidDataColumnType, Al_Err_strInvalidDataColumnType, \"DataColumnType\", strType);\n\t}\n\n\treturn lpColumn;\n}\ncatch(CStdErrorInfo oError)\n{\n\tif(lpColumn) delete lpColumn;\n\tRELAY_ERROR(oError); \n\treturn NULL;\n}\ncatch(...)\n{\n\tif(lpColumn) delete lpColumn;\n\tTHROW_ERROR(Std_Err_lUnspecifiedError, Std_Err_strUnspecifiedError);\n\treturn NULL;\n}\n}\n\n// ************* DataColumn Type Conversion functions ******************************\n\n\n// ************* Adapter Type Conversion functions ******************************\n\nAdapter *CsClassFactory::CreateAdapter(std::string strType, bool bThrowError)\n{\n\tAdapter *lpAdapter=NULL;\n\ntry\n{\n\tstrType = Std_ToUpper(Std_Trim(strType));\n\n\tif(strType == \"NODETONODE\")\n\t\tlpAdapter = new CsAdapter;\n\telse if(strType == \"PHYSICALTONODE\")\n\t\tlpAdapter = new CsAdapter;\n\telse\n\t{\n\t\tlpAdapter = NULL;\n\t\tif(bThrowError)\n\t\t\tTHROW_PARAM_ERROR(Al_Err_lInvalidAdapterType, Al_Err_strInvalidAdapterType, \"AdapterType\", strType);\n\t}\n\n\treturn lpAdapter;\n}\ncatch(CStdErrorInfo oError)\n{\n\tif(lpAdapter) delete lpAdapter;\n\tRELAY_ERROR(oError); \n\treturn NULL;\n}\ncatch(...)\n{\n\tif(lpAdapter) delete lpAdapter;\n\tTHROW_ERROR(Std_Err_lUnspecifiedError, Std_Err_strUnspecifiedError);\n\treturn NULL;\n}\n}\n\n// ************* Adpater Type Conversion functions ******************************\n\n\n\n// ************* IStdCsClassFactory functions ******************************\n\nCStdSerialize *CsClassFactory::CreateObject(std::string strClassType, std::string strObjectType, bool bThrowError)\n{\n\tCStdSerialize *lpObject=NULL;\n\n\tstrClassType = Std_ToUpper(Std_Trim(strClassType));\n\n\tif(strClassType == \"NEURON\")\n\t\tlpObject = CreateNeuron(strObjectType, bThrowError);\n\telse if(strClassType == \"SYNAPSE\")\n\t\tlpObject = CreateSynapse(strObjectType, bThrowError);\n\telse if(strClassType == \"NEURALMODULE\")\n\t\tlpObject = CreateNeuralModule(strObjectType, bThrowError);\n\telse if(strClassType == \"EXTERNALSTIMULUS\")\n\t\tlpObject = CreateExternalStimulus(strObjectType, bThrowError);\n\telse if(strClassType == \"DATACOLUMN\")\n\t\tlpObject = CreateDataColumn(strObjectType, bThrowError);\n\telse if(strClassType == \"ADAPTER\")\n\t\tlpObject = CreateAdapter(strObjectType, bThrowError);\n\telse\n\t{\n\t\tlpObject = NULL;\n\t\tif(bThrowError)\n\t\t\tTHROW_PARAM_ERROR(Std_Err_lInvalidClassType, Std_Err_strInvalidClassType, \"ClassType\", strClassType);\n\t}\n\n\treturn lpObject;\n}\n\n// ************* IStdCsClassFactory functions ******************************\n\n}\t\t\t\t//AnimatCarlSim\n\n#ifdef WIN32\nextern \"C\" __declspec(dllexport) IStdClassFactory* __cdecl GetStdClassFactory() \n#else\nextern \"C\" IStdClassFactory* GetStdClassFactory() \n#endif\n{\n\tIStdClassFactory *lpFactory = new CsClassFactory;\n\treturn lpFactory;\n}\n"}
{"repo_name":"MorcoFreeCode/2015__MorcoEngine3D","ref":"refs/heads/master","path":"MorcoEngine3D v0.13/Source/Libraries/glm/Include/detail/glm.cpp","copies":"299","language":"C++","content":"///////////////////////////////////////////////////////////////////////////////////\n/// OpenGL Mathematics (glm.g-truc.net)\n///\n/// Copyright (c) 2005 - 2014 G-Truc Creation (www.g-truc.net)\n/// Permission is hereby granted, free of charge, to any person obtaining a copy\n/// of this software and associated documentation files (the \"Software\"), to deal\n/// in the Software without restriction, including without limitation the rights\n/// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n/// copies of the Software, and to permit persons to whom the Software is\n/// furnished to do so, subject to the following conditions:\n/// \n/// The above copyright notice and this permission notice shall be included in\n/// all copies or substantial portions of the Software.\n/// \n/// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n/// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n/// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n/// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n/// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n/// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n/// THE SOFTWARE.\n///\n/// @ref core\n/// @file glm/glm.cpp\n/// @date 2013-04-22 / 2013-04-22\n/// @author Christophe Riccio\n///////////////////////////////////////////////////////////////////////////////////\n\n#include \u003cglm/glm.hpp\u003e\n#include \u003cglm/gtc/quaternion.hpp\u003e\n#include \u003cglm/gtx/dual_quaternion.hpp\u003e\n\nnamespace glm{\nnamespace detail\n{\n// tvec1 type explicit instantiation\n/*\ntemplate struct tvec1\u003cuint8, lowp\u003e;\ntemplate struct tvec1\u003cuint16, lowp\u003e;\ntemplate struct tvec1\u003cuint32, lowp\u003e;\ntemplate struct tvec1\u003cuint64, lowp\u003e;\ntemplate struct tvec1\u003cint8, lowp\u003e;\ntemplate struct tvec1\u003cint16, lowp\u003e;\ntemplate struct tvec1\u003cint32, lowp\u003e;\ntemplate struct tvec1\u003cint64, lowp\u003e;\ntemplate struct tvec1\u003cfloat16, lowp\u003e;\ntemplate struct tvec1\u003cfloat32, lowp\u003e;\ntemplate struct tvec1\u003cfloat64, lowp\u003e;\n\ntemplate struct tvec1\u003cuint8, mediump\u003e;\ntemplate struct tvec1\u003cuint16, mediump\u003e;\ntemplate struct tvec1\u003cuint32, mediump\u003e;\ntemplate struct tvec1\u003cuint64, mediump\u003e;\ntemplate struct tvec1\u003cint8, mediump\u003e;\ntemplate struct tvec1\u003cint16, mediump\u003e;\ntemplate struct tvec1\u003cint32, mediump\u003e;\ntemplate struct tvec1\u003cint64, mediump\u003e;\ntemplate struct tvec1\u003cfloat16, mediump\u003e;\ntemplate struct tvec1\u003cfloat32, mediump\u003e;\ntemplate struct tvec1\u003cfloat64, mediump\u003e;\n\ntemplate struct tvec1\u003cuint8, highp\u003e;\ntemplate struct tvec1\u003cuint16, highp\u003e;\ntemplate struct tvec1\u003cuint32, highp\u003e;\ntemplate struct tvec1\u003cuint64, highp\u003e;\ntemplate struct tvec1\u003cint8, highp\u003e;\ntemplate struct tvec1\u003cint16, highp\u003e;\ntemplate struct tvec1\u003cint32, highp\u003e;\ntemplate struct tvec1\u003cint64, highp\u003e;\ntemplate struct tvec1\u003cfloat16, highp\u003e;\ntemplate struct tvec1\u003cfloat32, highp\u003e;\ntemplate struct tvec1\u003cfloat64, highp\u003e;\n*/\n// tvec2 type explicit instantiation\ntemplate struct tvec2\u003cuint8, lowp\u003e;\ntemplate struct tvec2\u003cuint16, lowp\u003e;\ntemplate struct tvec2\u003cuint32, lowp\u003e;\ntemplate struct tvec2\u003cuint64, lowp\u003e;\ntemplate struct tvec2\u003cint8, lowp\u003e;\ntemplate struct tvec2\u003cint16, lowp\u003e;\ntemplate struct tvec2\u003cint32, lowp\u003e;\ntemplate struct tvec2\u003cint64, lowp\u003e;\ntemplate struct tvec2\u003cfloat32, lowp\u003e;\ntemplate struct tvec2\u003cfloat64, lowp\u003e;\n\ntemplate struct tvec2\u003cuint8, mediump\u003e;\ntemplate struct tvec2\u003cuint16, mediump\u003e;\ntemplate struct tvec2\u003cuint32, mediump\u003e;\ntemplate struct tvec2\u003cuint64, mediump\u003e;\ntemplate struct tvec2\u003cint8, mediump\u003e;\ntemplate struct tvec2\u003cint16, mediump\u003e;\ntemplate struct tvec2\u003cint32, mediump\u003e;\ntemplate struct tvec2\u003cint64, mediump\u003e;\ntemplate struct tvec2\u003cfloat32, mediump\u003e;\ntemplate struct tvec2\u003cfloat64, mediump\u003e;\n\ntemplate struct tvec2\u003cuint8, highp\u003e;\ntemplate struct tvec2\u003cuint16, highp\u003e;\ntemplate struct tvec2\u003cuint32, highp\u003e;\ntemplate struct tvec2\u003cuint64, highp\u003e;\ntemplate struct tvec2\u003cint8, highp\u003e;\ntemplate struct tvec2\u003cint16, highp\u003e;\ntemplate struct tvec2\u003cint32, highp\u003e;\ntemplate struct tvec2\u003cint64, highp\u003e;\ntemplate struct tvec2\u003cfloat32, highp\u003e;\ntemplate struct tvec2\u003cfloat64, highp\u003e;\n\n// tvec3 type explicit instantiation\ntemplate struct tvec3\u003cuint8, lowp\u003e;\ntemplate struct tvec3\u003cuint16, lowp\u003e;\ntemplate struct tvec3\u003cuint32, lowp\u003e;\ntemplate struct tvec3\u003cuint64, lowp\u003e;\ntemplate struct tvec3\u003cint8, lowp\u003e;\ntemplate struct tvec3\u003cint16, lowp\u003e;\ntemplate struct tvec3\u003cint32, lowp\u003e;\ntemplate struct tvec3\u003cint64, lowp\u003e;\ntemplate struct tvec3\u003cfloat32, lowp\u003e;\ntemplate struct tvec3\u003cfloat64, lowp\u003e;\n\ntemplate struct tvec3\u003cuint8, mediump\u003e;\ntemplate struct tvec3\u003cuint16, mediump\u003e;\ntemplate struct tvec3\u003cuint32, mediump\u003e;\ntemplate struct tvec3\u003cuint64, mediump\u003e;\ntemplate struct tvec3\u003cint8, mediump\u003e;\ntemplate struct tvec3\u003cint16, mediump\u003e;\ntemplate struct tvec3\u003cint32, mediump\u003e;\ntemplate struct tvec3\u003cint64, mediump\u003e;\ntemplate struct tvec3\u003cfloat32, mediump\u003e;\ntemplate struct tvec3\u003cfloat64, mediump\u003e;\n\ntemplate struct tvec3\u003cuint8, highp\u003e;\ntemplate struct tvec3\u003cuint16, highp\u003e;\ntemplate struct tvec3\u003cuint32, highp\u003e;\ntemplate struct tvec3\u003cuint64, highp\u003e;\ntemplate struct tvec3\u003cint8, highp\u003e;\ntemplate struct tvec3\u003cint16, highp\u003e;\ntemplate struct tvec3\u003cint32, highp\u003e;\ntemplate struct tvec3\u003cint64, highp\u003e;\ntemplate struct tvec3\u003cfloat32, highp\u003e;\ntemplate struct tvec3\u003cfloat64, highp\u003e;\n\n// tvec4 type explicit instantiation\ntemplate struct tvec4\u003cuint8, lowp\u003e;\ntemplate struct tvec4\u003cuint16, lowp\u003e;\ntemplate struct tvec4\u003cuint32, lowp\u003e;\ntemplate struct tvec4\u003cuint64, lowp\u003e;\ntemplate struct tvec4\u003cint8, lowp\u003e;\ntemplate struct tvec4\u003cint16, lowp\u003e;\ntemplate struct tvec4\u003cint32, lowp\u003e;\ntemplate struct tvec4\u003cint64, lowp\u003e;\ntemplate struct tvec4\u003cfloat32, lowp\u003e;\ntemplate struct tvec4\u003cfloat64, lowp\u003e;\n\ntemplate struct tvec4\u003cuint8, mediump\u003e;\ntemplate struct tvec4\u003cuint16, mediump\u003e;\ntemplate struct tvec4\u003cuint32, mediump\u003e;\ntemplate struct tvec4\u003cuint64, mediump\u003e;\ntemplate struct tvec4\u003cint8, mediump\u003e;\ntemplate struct tvec4\u003cint16, mediump\u003e;\ntemplate struct tvec4\u003cint32, mediump\u003e;\ntemplate struct tvec4\u003cint64, mediump\u003e;\ntemplate struct tvec4\u003cfloat32, mediump\u003e;\ntemplate struct tvec4\u003cfloat64, mediump\u003e;\n\ntemplate struct tvec4\u003cuint8, highp\u003e;\ntemplate struct tvec4\u003cuint16, highp\u003e;\ntemplate struct tvec4\u003cuint32, highp\u003e;\ntemplate struct tvec4\u003cuint64, highp\u003e;\ntemplate struct tvec4\u003cint8, highp\u003e;\ntemplate struct tvec4\u003cint16, highp\u003e;\ntemplate struct tvec4\u003cint32, highp\u003e;\ntemplate struct tvec4\u003cint64, highp\u003e;\ntemplate struct tvec4\u003cfloat32, highp\u003e;\ntemplate struct tvec4\u003cfloat64, highp\u003e;\n\n// tmat2x2 type explicit instantiation\ntemplate struct tmat2x2\u003cfloat32, lowp\u003e;\ntemplate struct tmat2x2\u003cfloat64, lowp\u003e;\n\ntemplate struct tmat2x2\u003cfloat32, mediump\u003e;\ntemplate struct tmat2x2\u003cfloat64, mediump\u003e;\n\ntemplate struct tmat2x2\u003cfloat32, highp\u003e;\ntemplate struct tmat2x2\u003cfloat64, highp\u003e;\n\n// tmat2x3 type explicit instantiation\ntemplate struct tmat2x3\u003cfloat32, lowp\u003e;\ntemplate struct tmat2x3\u003cfloat64, lowp\u003e;\n\ntemplate struct tmat2x3\u003cfloat32, mediump\u003e;\ntemplate struct tmat2x3\u003cfloat64, mediump\u003e;\n\ntemplate struct tmat2x3\u003cfloat32, highp\u003e;\ntemplate struct tmat2x3\u003cfloat64, highp\u003e;\n\n// tmat2x4 type explicit instantiation\ntemplate struct tmat2x4\u003cfloat32, lowp\u003e;\ntemplate struct tmat2x4\u003cfloat64, lowp\u003e;\n\ntemplate struct tmat2x4\u003cfloat32, mediump\u003e;\ntemplate struct tmat2x4\u003cfloat64, mediump\u003e;\n\ntemplate struct tmat2x4\u003cfloat32, highp\u003e;\ntemplate struct tmat2x4\u003cfloat64, highp\u003e;\n\n// tmat3x2 type explicit instantiation\ntemplate struct tmat3x2\u003cfloat32, lowp\u003e;\ntemplate struct tmat3x2\u003cfloat64, lowp\u003e;\n\ntemplate struct tmat3x2\u003cfloat32, mediump\u003e;\ntemplate struct tmat3x2\u003cfloat64, mediump\u003e;\n\ntemplate struct tmat3x2\u003cfloat32, highp\u003e;\ntemplate struct tmat3x2\u003cfloat64, highp\u003e;\n\n// tmat3x3 type explicit instantiation\ntemplate struct tmat3x3\u003cfloat32, lowp\u003e;\ntemplate struct tmat3x3\u003cfloat64, lowp\u003e;\n\ntemplate struct tmat3x3\u003cfloat32, mediump\u003e;\ntemplate struct tmat3x3\u003cfloat64, mediump\u003e;\n\ntemplate struct tmat3x3\u003cfloat32, highp\u003e;\ntemplate struct tmat3x3\u003cfloat64, highp\u003e;\n\n// tmat3x4 type explicit instantiation\ntemplate struct tmat3x4\u003cfloat32, lowp\u003e;\ntemplate struct tmat3x4\u003cfloat64, lowp\u003e;\n\ntemplate struct tmat3x4\u003cfloat32, mediump\u003e;\ntemplate struct tmat3x4\u003cfloat64, mediump\u003e;\n\ntemplate struct tmat3x4\u003cfloat32, highp\u003e;\ntemplate struct tmat3x4\u003cfloat64, highp\u003e;\n\n// tmat4x2 type explicit instantiation\ntemplate struct tmat4x2\u003cfloat32, lowp\u003e;\ntemplate struct tmat4x2\u003cfloat64, lowp\u003e;\n\ntemplate struct tmat4x2\u003cfloat32, mediump\u003e;\ntemplate struct tmat4x2\u003cfloat64, mediump\u003e;\n\ntemplate struct tmat4x2\u003cfloat32, highp\u003e;\ntemplate struct tmat4x2\u003cfloat64, highp\u003e;\n\n// tmat4x3 type explicit instantiation\ntemplate struct tmat4x3\u003cfloat32, lowp\u003e;\ntemplate struct tmat4x3\u003cfloat64, lowp\u003e;\n\ntemplate struct tmat4x3\u003cfloat32, mediump\u003e;\ntemplate struct tmat4x3\u003cfloat64, mediump\u003e;\n\ntemplate struct tmat4x3\u003cfloat32, highp\u003e;\ntemplate struct tmat4x3\u003cfloat64, highp\u003e;\n\n// tmat4x4 type explicit instantiation\ntemplate struct tmat4x4\u003cfloat32, lowp\u003e;\ntemplate struct tmat4x4\u003cfloat64, lowp\u003e;\n\ntemplate struct tmat4x4\u003cfloat32, mediump\u003e;\ntemplate struct tmat4x4\u003cfloat64, mediump\u003e;\n\ntemplate struct tmat4x4\u003cfloat32, highp\u003e;\ntemplate struct tmat4x4\u003cfloat64, highp\u003e;\n\n// tquat type explicit instantiation\ntemplate struct tquat\u003cfloat32, lowp\u003e;\ntemplate struct tquat\u003cfloat64, lowp\u003e;\n\ntemplate struct tquat\u003cfloat32, mediump\u003e;\ntemplate struct tquat\u003cfloat64, mediump\u003e;\n\ntemplate struct tquat\u003cfloat32, highp\u003e;\ntemplate struct tquat\u003cfloat64, highp\u003e;\n\n//tdualquat type explicit instantiation\ntemplate struct tdualquat\u003cfloat32, lowp\u003e;\ntemplate struct tdualquat\u003cfloat64, lowp\u003e;\n\ntemplate struct tdualquat\u003cfloat32, mediump\u003e;\ntemplate struct tdualquat\u003cfloat64, mediump\u003e;\n\ntemplate struct tdualquat\u003cfloat32, highp\u003e;\ntemplate struct tdualquat\u003cfloat64, highp\u003e;\n\n}//namespace detail\n}//namespace glm\n\n"}
{"repo_name":"Dmitry-Me/coreclr","ref":"refs/heads/master","path":"src/jit/lowerarm.cpp","copies":"4","language":"C++","content":"// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\n// See the LICENSE file in the project root for more information.\n\n/*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXX                                                                           XX\nXX                           Lowering for ARM                                XX\nXX                                                                           XX\nXX  This encapsulates all the logic for lowering trees for the ARM           XX\nXX  architecture.  For a more detailed view of what is lowering, please      XX\nXX  take a look at Lower.cpp                                                 XX\nXX                                                                           XX\nXX                                                                           XX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n*/\n\n#include \"jitpch.h\"\n#ifdef _MSC_VER\n#pragma hdrstop\n#endif\n\n#ifndef LEGACY_BACKEND // This file is ONLY used for the RyuJIT backend that uses the linear scan register allocator\n\n// The ARM backend is not yet implemented, so the methods here are all NYI.\n// TODO-ARM-NYI: Lowering for ARM.\n#ifdef _TARGET_ARM_\n\n#include \"jit.h\"\n#include \"sideeffects.h\"\n#include \"lower.h\"\n#include \"lsra.h\"\n\n/* Lowering of GT_CAST nodes */\nvoid Lowering::LowerCast(GenTree* tree)\n{\n    NYI_ARM(\"ARM Lowering for cast\");\n}\n\nvoid Lowering::LowerRotate(GenTreePtr tree)\n{\n    NYI_ARM(\"ARM Lowering for ROL and ROR\");\n}\n\nvoid Lowering::TreeNodeInfoInit(GenTree* stmt)\n{\n    NYI(\"ARM TreeNodInfoInit\");\n}\n\n// returns true if the tree can use the read-modify-write memory instruction form\nbool Lowering::isRMWRegOper(GenTreePtr tree)\n{\n    return false;\n}\n\nbool Lowering::IsCallTargetInRange(void* addr)\n{\n    return comp-\u003ecodeGen-\u003evalidImmForBL((ssize_t)addr);\n}\n\n// return true if the immediate can be folded into an instruction, for example small enough and non-relocatable\nbool Lowering::IsContainableImmed(GenTree* parentNode, GenTree* childNode)\n{\n    NYI_ARM(\"ARM IsContainableImmed\");\n    return false;\n}\n\n#endif // _TARGET_ARM_\n\n#endif // !LEGACY_BACKEND\n"}
{"repo_name":"lopezloo/mtasa-blue","ref":"refs/heads/master","path":"Client/mods/deathmatch/logic/CCustomData.cpp","copies":"8","language":"C++","content":"/*****************************************************************************\n *\n *  PROJECT:     Multi Theft Auto v1.0\n *               (Shared logic for modifications)\n *  LICENSE:     See LICENSE in the top level directory\n *  FILE:        mods/shared_logic/CCustomData.cpp\n *  PURPOSE:     Custom data storage class\n *\n *****************************************************************************/\n\n#include \"StdInc.h\"\n#define DECLARE_PROFILER_SECTION_CCustomData\n#include \"profiler/SharedUtil.Profiler.h\"\n\nvoid CCustomData::Copy(CCustomData* pCustomData)\n{\n    std::map\u003cstd::string, SCustomData\u003e::const_iterator iter = pCustomData-\u003eIterBegin();\n    for (; iter != pCustomData-\u003eIterEnd(); iter++)\n    {\n        Set(iter-\u003efirst.c_str(), iter-\u003esecond.Variable);\n    }\n}\n\nSCustomData* CCustomData::Get(const char* szName)\n{\n    assert(szName);\n\n    std::map\u003cstd::string, SCustomData\u003e::iterator it = m_Data.find(szName);\n    if (it != m_Data.end())\n        return \u0026it-\u003esecond;\n\n    return NULL;\n}\n\nvoid CCustomData::Set(const char* szName, const CLuaArgument\u0026 Variable, bool bSynchronized)\n{\n    assert(szName);\n\n    // Grab the item with the given name\n    SCustomData* pData = Get(szName);\n    if (pData)\n    {\n        // Update existing\n        pData-\u003eVariable = Variable;\n        pData-\u003ebSynchronized = bSynchronized;\n    }\n    else\n    {\n        // Add new\n        SCustomData newData;\n        newData.Variable = Variable;\n        newData.bSynchronized = bSynchronized;\n        m_Data[szName] = newData;\n    }\n}\n\nbool CCustomData::Delete(const char* szName)\n{\n    // Find the item and delete it\n    std::map\u003cstd::string, SCustomData\u003e::iterator it = m_Data.find(szName);\n    if (it != m_Data.end())\n    {\n        m_Data.erase(it);\n        return true;\n    }\n\n    // Didn't exist\n    return false;\n}\n"}
{"repo_name":"pete318/TrinityCore","ref":"refs/heads/3.3.5","path":"src/server/scripts/Northrend/FrozenHalls/HallsOfReflection/halls_of_reflection.cpp","copies":"10","language":"C++","content":"/*\n * Copyright (C) 2008-2019 TrinityCore \u003chttps://www.trinitycore.org/\u003e\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the\n * Free Software Foundation; either version 2 of the License, or (at your\n * option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n * more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program. If not, see \u003chttp://www.gnu.org/licenses/\u003e.\n */\n\n#include \"halls_of_reflection.h\"\n#include \"Creature.h\"\n#include \"EventProcessor.h\"\n#include \"InstanceScript.h\"\n#include \"MotionMaster.h\"\n#include \"MoveSplineInit.h\"\n#include \"ObjectAccessor.h\"\n#include \"ObjectGuid.h\"\n#include \"Player.h\"\n#include \"ScriptedCreature.h\"\n#include \"ScriptedGossip.h\"\n#include \"ScriptMgr.h\"\n#include \"Spell.h\"\n#include \"SpellInfo.h\"\n#include \"SpellScript.h\"\n#include \"TemporarySummon.h\"\n#include \"Transport.h\"\n#include \"Unit.h\"\n\nenum Text\n{\n    SAY_JAINA_INTRO_1                   = 0,\n    SAY_JAINA_INTRO_2                   = 1,\n    SAY_JAINA_INTRO_3                   = 2,\n    SAY_JAINA_INTRO_4                   = 3,\n    SAY_JAINA_INTRO_5                   = 4,\n    SAY_JAINA_INTRO_6                   = 5,\n    SAY_JAINA_INTRO_7                   = 6,\n    SAY_JAINA_INTRO_8                   = 7,\n    SAY_JAINA_INTRO_9                   = 8,\n    SAY_JAINA_INTRO_10                  = 9,\n    SAY_JAINA_INTRO_11                  = 10,\n    SAY_JAINA_INTRO_END                 = 11,\n\n    SAY_SYLVANAS_INTRO_1                = 0,\n    SAY_SYLVANAS_INTRO_2                = 1,\n    SAY_SYLVANAS_INTRO_3                = 2,\n    SAY_SYLVANAS_INTRO_4                = 3,\n    SAY_SYLVANAS_INTRO_5                = 4,\n    SAY_SYLVANAS_INTRO_6                = 5,\n    SAY_SYLVANAS_INTRO_7                = 6,\n    SAY_SYLVANAS_INTRO_8                = 7,\n    SAY_SYLVANAS_INTRO_END              = 8,\n\n    SAY_UTHER_INTRO_A2_1                = 0,\n    SAY_UTHER_INTRO_A2_2                = 1,\n    SAY_UTHER_INTRO_A2_3                = 2,\n    SAY_UTHER_INTRO_A2_4                = 3,\n    SAY_UTHER_INTRO_A2_5                = 4,\n    SAY_UTHER_INTRO_A2_6                = 5,\n    SAY_UTHER_INTRO_A2_7                = 6,\n    SAY_UTHER_INTRO_A2_8                = 7,\n    SAY_UTHER_INTRO_A2_9                = 8,\n    SAY_UTHER_INTRO_H2_1                = 9,\n    SAY_UTHER_INTRO_H2_2                = 10,\n    SAY_UTHER_INTRO_H2_3                = 11,\n    SAY_UTHER_INTRO_H2_4                = 12,\n    SAY_UTHER_INTRO_H2_5                = 13,\n    SAY_UTHER_INTRO_H2_6                = 14,\n    SAY_UTHER_INTRO_H2_7                = 15,\n\n    SAY_LK_INTRO_1                      = 0,\n    SAY_LK_INTRO_2                      = 1,\n    SAY_LK_INTRO_3                      = 2,\n    SAY_LK_JAINA_INTRO_END              = 3,\n    SAY_LK_SYLVANAS_INTRO_END           = 4,\n\n    SAY_JAINA_SYLVANAS_ESCAPE_1         = 0,\n    SAY_JAINA_SYLVANAS_ESCAPE_2         = 1,\n    SAY_JAINA_SYLVANAS_ESCAPE_3         = 2,\n    SAY_JAINA_SYLVANAS_ESCAPE_4         = 3,\n    SAY_JAINA_SYLVANAS_ESCAPE_5         = 4,\n    SAY_JAINA_SYLVANAS_ESCAPE_6         = 5,\n    SAY_JAINA_SYLVANAS_ESCAPE_7         = 6, // unused\n    SAY_JAINA_SYLVANAS_ESCAPE_8         = 7,\n\n    SAY_JAINA_ESCAPE_9                  = 8,\n    SAY_JAINA_ESCAPE_10                 = 9,\n\n    SAY_SYLVANAS_ESCAPE_9               = 8,\n\n    SAY_LK_ESCAPE_1                     = 0,\n    SAY_LK_ESCAPE_2                     = 1,\n    SAY_LK_ESCAPE_ICEWALL_SUMMONED_1    = 2,\n    SAY_LK_ESCAPE_ICEWALL_SUMMONED_2    = 3,\n    SAY_LK_ESCAPE_ICEWALL_SUMMONED_3    = 4,\n    SAY_LK_ESCAPE_ICEWALL_SUMMONED_4    = 5,\n    SAY_LK_ESCAPE_GHOULS                = 6,\n    SAY_LK_ESCAPE_ABOMINATION           = 7,\n    SAY_LK_ESCAPE_WINTER                = 8,\n    SAY_LK_ESCAPE_HARVEST_SOUL          = 9,\n\n    SAY_FALRIC_INTRO_1                  = 5,\n    SAY_FALRIC_INTRO_2                  = 6,\n\n    SAY_MARWYN_INTRO_1                  = 4\n};\n\nenum Events\n{\n    EVENT_WALK_INTRO1                   = 1,\n    EVENT_WALK_INTRO2,\n    EVENT_START_INTRO,\n    EVENT_SKIP_INTRO,\n\n    EVENT_INTRO_A2_1,\n    EVENT_INTRO_A2_2,\n    EVENT_INTRO_A2_3,\n    EVENT_INTRO_A2_4,\n    EVENT_INTRO_A2_5,\n    EVENT_INTRO_A2_6,\n    EVENT_INTRO_A2_7,\n    EVENT_INTRO_A2_8,\n    EVENT_INTRO_A2_9,\n    EVENT_INTRO_A2_10,\n    EVENT_INTRO_A2_11,\n    EVENT_INTRO_A2_12,\n    EVENT_INTRO_A2_13,\n    EVENT_INTRO_A2_14,\n    EVENT_INTRO_A2_15,\n    EVENT_INTRO_A2_16,\n    EVENT_INTRO_A2_17,\n    EVENT_INTRO_A2_18,\n    EVENT_INTRO_A2_19,\n\n    EVENT_INTRO_H2_1,\n    EVENT_INTRO_H2_2,\n    EVENT_INTRO_H2_3,\n    EVENT_INTRO_H2_4,\n    EVENT_INTRO_H2_5,\n    EVENT_INTRO_H2_6,\n    EVENT_INTRO_H2_7,\n    EVENT_INTRO_H2_8,\n    EVENT_INTRO_H2_9,\n    EVENT_INTRO_H2_10,\n    EVENT_INTRO_H2_11,\n    EVENT_INTRO_H2_12,\n    EVENT_INTRO_H2_13,\n    EVENT_INTRO_H2_14,\n    EVENT_INTRO_H2_15,\n\n    EVENT_INTRO_LK_1,\n    EVENT_INTRO_LK_2,\n    EVENT_INTRO_LK_3,\n    EVENT_INTRO_LK_4,\n    EVENT_INTRO_LK_5,\n    EVENT_INTRO_LK_6,\n    EVENT_INTRO_LK_7,\n    EVENT_INTRO_LK_8,\n    EVENT_INTRO_LK_9,\n    EVENT_INTRO_LK_10,\n    EVENT_INTRO_LK_11,\n\n    EVENT_INTRO_END,\n\n    EVENT_ESCAPE,\n    EVENT_ESCAPE_1,\n    EVENT_ESCAPE_2,\n    EVENT_ESCAPE_3,\n    EVENT_ESCAPE_4,\n    EVENT_ESCAPE_5,\n    EVENT_ESCAPE_6,\n    EVENT_ESCAPE_7,\n    EVENT_ESCAPE_8,\n    EVENT_ESCAPE_9,\n    EVENT_ESCAPE_10,\n    EVENT_ESCAPE_11,\n    EVENT_ESCAPE_12,\n    EVENT_ESCAPE_13,\n    EVENT_ESCAPE_14,\n    EVENT_ESCAPE_15,\n    EVENT_ESCAPE_16,\n    EVENT_ESCAPE_17,\n\n    EVENT_REMORSELESS_WINTER,\n    EVENT_ESCAPE_SUMMON_GHOULS,\n    EVENT_ESCAPE_SUMMON_WITCH_DOCTOR,\n    EVENT_ESCAPE_SUMMON_LUMBERING_ABOMINATION,\n\n    EVENT_OPEN_IMPENETRABLE_DOOR,\n    EVENT_CLOSE_IMPENETRABLE_DOOR,\n    EVENT_KORELN_LORALEN_DEATH\n};\n\nenum Misc\n{\n    ACTION_START_INTRO,\n    ACTION_SKIP_INTRO,\n\n    JAINA_SYLVANAS_MAX_HEALTH          = 252000,\n\n    POINT_SHADOW_THRONE_DOOR           = 1,\n    POINT_ATTACK_ICEWALL               = 2,\n    POINT_TRAP                         = 3,\n\n    SOUND_LK_SLAY_1                    = 17214,\n    SOUND_LK_SLAY_2                    = 17215,\n    SOUND_LK_FURY_OF_FROSTMOURNE       = 17224\n};\n\nenum Spells\n{\n    // Misc\n    SPELL_TAKE_FROSTMOURNE             = 72729,\n    SPELL_FROSTMOURNE_DESPAWN          = 72726,\n    SPELL_FROSTMOURNE_VISUAL           = 73220,\n    SPELL_FROSTMOURNE_SOUNDS           = 70667,\n    SPELL_BOSS_SPAWN_AURA              = 72712, // Falric and Marwyn\n    SPELL_UTHER_DESPAWN                = 70693,\n\n    // Jaina, Sylvanas\n    SPELL_CAST_VISUAL                  = 65633, // wrong\n    SPELL_SUMMON_SOULS                 = 72711,\n    SPELL_TAUNT_ARTHAS                 = 69857,\n    SPELL_JAINA_ICE_BARRIER            = 69787, // Jaina Ice Barrier\n    SPELL_JAINA_ICE_PRISON             = 69708, // Jaina Ice Prison\n    SPELL_JAINA_DESTROY_ICE_WALL       = 69784, // Jaina\n    SPELL_SYLVANAS_CLOAK_OF_DARKNESS   = 70188, // Sylvanas Cloak of Darkness\n    SPELL_SYLVANAS_DARK_BINDING        = 70194, // Sylvanas Dark Binding\n    SPELL_SYLVANAS_DESTROY_ICE_WALL    = 70224, // Sylvanas\n    SPELL_SYLVANAS_BLINDING_RETREAT    = 70199, // Sylvanas Blinding Retreat\n\n    // Lich King\n    SPELL_REMORSELESS_WINTER           = 69780, // Lich King Remorseless Winter\n    SPELL_SOUL_REAPER                  = 69409, // Lich King Soul Reaper\n    SPELL_FURY_OF_FROSTMOURNE          = 70063, // Lich King Fury of Frostmourne\n    SPELL_RAISE_DEAD                   = 69818,\n    SPELL_SUMMON_RISEN_WITCH_DOCTOR    = 69836,\n    SPELL_SUMMON_LUMBERING_ABOMINATION = 69835,\n    SPELL_SUMMON_ICE_WALL              = 69768, // Visual effect and icewall summoning\n    SPELL_PAIN_AND_SUFFERING           = 74115, // Lich King Pain and Suffering\n    SPELL_STUN_BREAK_JAINA             = 69764, // Lich King visual spell, another Stun Break is 69763, should remove the stun effect\n    SPELL_STUN_BREAK_SYLVANAS          = 70200,\n    SPELL_HARVEST_SOUL                 = 69866, // Lich King Harvest Soul\n\n    // Koreln, Loralen\n    SPELL_FEIGN_DEATH                  = 29266,\n\n    // Raging Ghoul\n    SPELL_GHOUL_JUMP                   = 70150,\n    SPELL_RAGING_GHOUL_SPAWN           = 69636,\n\n    // Risen Witch Doctor\n    SPELL_CURSE_OF_DOOM                = 70144,\n    SPELL_SHADOW_BOLT_VOLLEY           = 70145,\n    SPELL_SHADOW_BOLT                  = 70080,\n    SPELL_RISEN_WITCH_DOCTOR_SPAWN     = 69639,\n\n    // Lumbering Abomination\n    SPELL_CLEAVE                       = 40505,\n    SPELL_VOMIT_SPRAY                  = 70176\n};\n\nenum HorGossipMenu\n{\n    GOSSIP_MENU_JAINA_FINAL            = 10930,\n    GOSSIP_MENU_SYLVANAS_FINAL         = 10931\n};\n\nPosition const NpcJainaOrSylvanasEscapeRoute[] =\n{\n    { 5601.217285f, 2207.652832f, 731.541931f, 5.223304f }, // leave the throne room\n    { 5607.224375f, 2173.913330f, 731.126038f, 2.608723f }, // adjust route\n    { 5583.427246f, 2138.784180f, 731.150391f, 4.260901f }, // stop for talking\n    { 5560.281738f, 2104.025635f, 731.410889f, 4.058383f }, // attack the first icewall\n    { 5510.990723f, 2000.772217f, 734.716064f, 3.973213f }, // attack the second icewall\n    { 5452.641113f, 1905.762329f, 746.530579f, 4.118834f }, // attack the third icewall\n    { 5338.126953f, 1768.429810f, 767.237244f, 3.855189f }, // attack the fourth icewall\n    { 5259.06f,     1669.27f,     784.3008f,   0.0f      }, // trap (sniffed)\n    { 5265.53f,     1681.6f,      784.2947f,   4.13643f  }  // final position (sniffed)\n};\n\nPosition const LichKingMoveAwayPos      = { 5400.069824f, 2102.7131689f, 707.69525f, 0.843803f }; // Lich King walks away\nPosition const LichKingFirstSummon      = { 5600.076172f, 2192.270996f, 731.750488f, 4.330935f }; // Lich King First summons\nPosition const JainaSylvanasShadowThroneDoor = { 5577.243f, 2235.852f, 733.0128f, 2.209562f }; // Jaina/Sylvanas move to door\nPosition const LichKingFinalPos         = { 5283.742188f, 1706.335693f, 783.293518f, 4.138510f }; // Lich King Final Pos\n\n// sniffed\nPosition const KorelnOrLoralenPos[] =\n{\n    { 5253.061f, 1953.616f, 707.6948f, 0.8377581f },\n    { 5283.226f, 1992.300f, 707.7445f, 0.8377581f },\n    { 5360.711f, 2064.797f, 707.6948f, 0.0f }\n};\n\nPosition const SylvanasIntroPosition[] =\n{\n    { 0.0f,     0.0f,     0.0f,      0.0f       }, // 0 - Spawn\n    { 5263.2f,  1950.96f, 707.6948f, 0.8028514f }, // 1 - Move to Door\n    { 5306.82f, 1998.17f, 709.341f,  1.239184f  }, // 2 - Move to Frostmourne\n};\n\nPosition const JainaIntroPosition[] =\n{\n    { 0.0f,     0.0f,     0.0f,      0.0f      }, // 0 - Spawn\n    { 5265.89f, 1952.98f, 707.6978f, 0.0f      }, // 1 - Move to Door\n    { 5306.95f, 1998.49f, 709.3414f, 1.277278f }  // 2 - Move to Frostmourne\n};\n\nPosition const UtherSpawnPos = { 5307.814f, 2003.168f, 709.4244f, 4.537856f };\n\nPosition const LichKingIntroPosition[] =\n{\n    { 5362.463f, 2062.693f, 707.7781f, 3.944444f }, // 0 - Spawn\n    { 5332.83f,  2031.24f,  707.6948f, 0.0f      }, // 1 - Door\n    { 5312.93f,  2010.24f,  709.34f,   0.0f      }, // 2 - Move to Frostmourne\n    { 5319.028f, 2016.662f, 707.6948f, 0.0f      }, // 3 - Move back\n    { 5332.285f, 2030.832f, 707.6948f, 0.0f      }, // 4 - Move back 2\n    { 5355.488f, 2055.149f, 707.6907f, 0.0f      }  // 5 - Move back 3\n};\n\nPosition const FalricPosition[] =\n{\n    { 5276.583f, 2037.45f, 709.4025f, 5.532694f }, // 0 - Spawn\n    { 5283.95f,  2030.53f, 709.3191f, 0.0f      }  // 1 - Intro\n};\n\nPosition const MarwynPosition[] =\n{\n    { 5342.232f, 1975.696f, 709.4025f, 2.391101f }, // 0 - Spawn\n    { 5335.01f,  1982.37f,  709.3191f, 0.0f      }  // 1 - Intro\n};\n\nPosition const SylvanasShadowThroneDoorPosition = { 5576.79f, 2235.73f, 733.0029f, 2.687807f };\n\nPosition const IceWallTargetPosition[] =\n{\n    { 5547.833f, 2083.701f, 731.4332f, 1.029744f  }, // 1st Icewall\n    { 5503.213f, 1969.547f, 737.0245f, 1.27409f   }, // 2nd Icewall\n    { 5439.976f, 1879.005f, 752.7048f, 1.064651f  }, // 3rd Icewall\n    { 5318.289f, 1749.184f, 771.9423f, 0.8726646f }  // 4th Icewall\n};\n\nclass npc_jaina_or_sylvanas_intro_hor : public CreatureScript\n{\n    public:\n        npc_jaina_or_sylvanas_intro_hor() : CreatureScript(\"npc_jaina_or_sylvanas_intro_hor\") { }\n\n        struct npc_jaina_or_sylvanas_intro_horAI : public ScriptedAI\n        {\n            npc_jaina_or_sylvanas_intro_horAI(Creature* creature) : ScriptedAI(creature)\n            {\n                _instance = me-\u003eGetInstanceScript();\n            }\n\n            bool GossipHello(Player* player) override\n            {\n                // override default gossip\n                if (_instance-\u003eGetData(DATA_QUEL_DELAR_EVENT) == IN_PROGRESS || _instance-\u003eGetData(DATA_QUEL_DELAR_EVENT) == SPECIAL)\n                {\n                    ClearGossipMenuFor(player);\n                    return true;\n                }\n\n                // load default gossip\n                return false;\n            }\n\n            bool GossipSelect(Player* player, uint32 /*menuId*/, uint32 gossipListId) override\n            {\n                ClearGossipMenuFor(player);\n\n                switch (gossipListId)\n                {\n                    case 0:\n                        player-\u003ePlayerTalkClass-\u003eSendCloseGossip();\n                        _events.ScheduleEvent(EVENT_START_INTRO, 1s);\n                        me-\u003eRemoveFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_GOSSIP | UNIT_NPC_FLAG_QUESTGIVER);\n                        break;\n                    case 1:\n                        player-\u003ePlayerTalkClass-\u003eSendCloseGossip();\n                        _events.ScheduleEvent(EVENT_SKIP_INTRO, 1s);\n                        me-\u003eRemoveFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_GOSSIP | UNIT_NPC_FLAG_QUESTGIVER);\n                        break;\n                    default:\n                        break;\n                }\n                return false;\n            }\n\n            void Reset() override\n            {\n                _events.Reset();\n\n                _utherGUID.Clear();\n                _lichkingGUID.Clear();\n\n                me-\u003eRemoveFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_GOSSIP | UNIT_NPC_FLAG_QUESTGIVER);\n                me-\u003eSetStandState(UNIT_STAND_STATE_STAND);\n                _events.ScheduleEvent(EVENT_WALK_INTRO1, 3000);\n            }\n\n            void UpdateAI(uint32 diff) override\n            {\n                _events.Update(diff);\n\n                switch (_events.ExecuteEvent())\n                {\n                    case EVENT_WALK_INTRO1:\n                        if (Creature* korelnOrLoralen = ObjectAccessor::GetCreature(*me, _instance-\u003eGetGuidData(DATA_KORELN_LORALEN)))\n                            korelnOrLoralen-\u003eGetMotionMaster()-\u003eMovePoint(0, KorelnOrLoralenPos[0]);\n\n                        if (_instance-\u003eGetData(DATA_TEAM_IN_INSTANCE) == ALLIANCE)\n                        {\n                            me-\u003eGetMotionMaster()-\u003eMovePoint(0, JainaIntroPosition[1]);\n                            Talk(SAY_JAINA_INTRO_1);\n                            _events.ScheduleEvent(EVENT_WALK_INTRO2, 7000);\n                        }\n                        else\n                        {\n                            me-\u003eGetMotionMaster()-\u003eMovePoint(0, SylvanasIntroPosition[1]);\n                            Talk(SAY_SYLVANAS_INTRO_1);\n                            _events.ScheduleEvent(EVENT_WALK_INTRO2, 9000);\n                        }\n                        break;\n                    case EVENT_WALK_INTRO2:\n                        if (_instance-\u003eGetData(DATA_TEAM_IN_INSTANCE) == ALLIANCE)\n                            Talk(SAY_JAINA_INTRO_2);\n                        else\n                            Talk(SAY_SYLVANAS_INTRO_2);\n                        me-\u003eSetFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_GOSSIP | UNIT_NPC_FLAG_QUESTGIVER);\n                        break;\n                    case EVENT_START_INTRO:\n                        if (Creature* korelnOrLoralen = ObjectAccessor::GetCreature(*me, _instance-\u003eGetGuidData(DATA_KORELN_LORALEN)))\n                            korelnOrLoralen-\u003eGetMotionMaster()-\u003eMovePoint(0, KorelnOrLoralenPos[1]);\n                        // Begining of intro is differents between factions as the speech sequence and timers are differents.\n                        if (_instance-\u003eGetData(DATA_TEAM_IN_INSTANCE) == ALLIANCE)\n                        {\n                            me-\u003eGetMotionMaster()-\u003eMovePoint(0, JainaIntroPosition[2]);\n                            _events.ScheduleEvent(EVENT_INTRO_A2_1, 0);\n                        }\n                        else\n                        {\n                            me-\u003eGetMotionMaster()-\u003eMovePoint(0, SylvanasIntroPosition[2]);\n                            _events.ScheduleEvent(EVENT_INTRO_H2_1, 0);\n                        }\n                        break;\n                    // A2 Intro Events\n                    case EVENT_INTRO_A2_1:\n                        Talk(SAY_JAINA_INTRO_3);\n                        _events.ScheduleEvent(EVENT_INTRO_A2_2, 7000);\n                        break;\n                    case EVENT_INTRO_A2_2:\n                        Talk(SAY_JAINA_INTRO_4);\n                        _events.ScheduleEvent(EVENT_INTRO_A2_3, 10000);\n                        break;\n                    case EVENT_INTRO_A2_3:\n                        me-\u003eCastSpell(me, SPELL_CAST_VISUAL, false);\n                        me-\u003eCastSpell(me, SPELL_FROSTMOURNE_SOUNDS, true);\n                        _instance-\u003eHandleGameObject(_instance-\u003eGetGuidData(DATA_FROSTMOURNE), true);\n                        _events.ScheduleEvent(EVENT_INTRO_A2_4, 10000);\n                        break;\n                    case EVENT_INTRO_A2_4:\n                        if (Creature* uther = me-\u003eSummonCreature(NPC_UTHER, UtherSpawnPos, TEMPSUMMON_MANUAL_DESPAWN))\n                            _utherGUID = uther-\u003eGetGUID();\n                        _events.ScheduleEvent(EVENT_INTRO_A2_5, 2000);\n                        break;\n                    case EVENT_INTRO_A2_5:\n                        if (Creature* uther = ObjectAccessor::GetCreature(*me, _utherGUID))\n                            uther-\u003eAI()-\u003eTalk(SAY_UTHER_INTRO_A2_1);\n                        _events.ScheduleEvent(EVENT_INTRO_A2_6, 3000);\n                        break;\n                    case EVENT_INTRO_A2_6:\n                        Talk(SAY_JAINA_INTRO_5);\n                        _events.ScheduleEvent(EVENT_INTRO_A2_7, 7000);\n                        break;\n                    case EVENT_INTRO_A2_7:\n                        if (Creature* uther = ObjectAccessor::GetCreature(*me, _utherGUID))\n                            uther-\u003eAI()-\u003eTalk(SAY_UTHER_INTRO_A2_2);\n                        _events.ScheduleEvent(EVENT_INTRO_A2_8, 7000);\n                        break;\n                    case EVENT_INTRO_A2_8:\n                        Talk(SAY_JAINA_INTRO_6);\n                        _events.ScheduleEvent(EVENT_INTRO_A2_9, 1200);\n                        break;\n                    case EVENT_INTRO_A2_9:\n                        if (Creature* uther = ObjectAccessor::GetCreature(*me, _utherGUID))\n                            uther-\u003eAI()-\u003eTalk(SAY_UTHER_INTRO_A2_3);\n                        _events.ScheduleEvent(EVENT_INTRO_A2_10, 11000);\n                        break;\n                    case EVENT_INTRO_A2_10:\n                        Talk(SAY_JAINA_INTRO_7);\n                        _events.ScheduleEvent(EVENT_INTRO_A2_11, 6000);\n                        break;\n                    case EVENT_INTRO_A2_11:\n                        if (Creature* uther = ObjectAccessor::GetCreature(*me, _utherGUID))\n                            uther-\u003eAI()-\u003eTalk(SAY_UTHER_INTRO_A2_4);\n                        _events.ScheduleEvent(EVENT_INTRO_A2_12, 12000);\n                        break;\n                    case EVENT_INTRO_A2_12:\n                        Talk(SAY_JAINA_INTRO_8);\n                        _events.ScheduleEvent(EVENT_INTRO_A2_13, 6000);\n                        break;\n                    case EVENT_INTRO_A2_13:\n                        if (Creature* uther = ObjectAccessor::GetCreature(*me, _utherGUID))\n                            uther-\u003eAI()-\u003eTalk(SAY_UTHER_INTRO_A2_5);\n                        _events.ScheduleEvent(EVENT_INTRO_A2_14, 13000);\n                        break;\n                    case EVENT_INTRO_A2_14:\n                        Talk(SAY_JAINA_INTRO_9);\n                        _events.ScheduleEvent(EVENT_INTRO_A2_15, 12000);\n                        break;\n                    case EVENT_INTRO_A2_15:\n                        if (Creature* uther = ObjectAccessor::GetCreature(*me, _utherGUID))\n                            uther-\u003eAI()-\u003eTalk(SAY_UTHER_INTRO_A2_6);\n                        _events.ScheduleEvent(EVENT_INTRO_A2_16, 25000);\n                        break;\n                    case EVENT_INTRO_A2_16:\n                        if (Creature* uther = ObjectAccessor::GetCreature(*me, _utherGUID))\n                            uther-\u003eAI()-\u003eTalk(SAY_UTHER_INTRO_A2_7);\n                        _events.ScheduleEvent(EVENT_INTRO_A2_17, 6000);\n                        break;\n                    case EVENT_INTRO_A2_17:\n                        Talk(SAY_JAINA_INTRO_10);\n                        _events.ScheduleEvent(EVENT_INTRO_A2_18, 5000);\n                        break;\n                    case EVENT_INTRO_A2_18:\n                        if (Creature* uther = ObjectAccessor::GetCreature(*me, _utherGUID))\n                        {\n                            uther-\u003eHandleEmoteCommand(EMOTE_ONESHOT_NO);\n                            uther-\u003eAI()-\u003eTalk(SAY_UTHER_INTRO_A2_8);\n                        }\n                        _events.ScheduleEvent(EVENT_INTRO_A2_19, 12000);\n                        break;\n                    case EVENT_INTRO_A2_19:\n                        Talk(SAY_JAINA_INTRO_11);\n                        _events.ScheduleEvent(EVENT_INTRO_LK_1, 3000);\n                        break;\n                    // H2 Intro Events\n                    case EVENT_INTRO_H2_1:\n                        Talk(SAY_SYLVANAS_INTRO_1);\n                        _events.ScheduleEvent(EVENT_INTRO_H2_2, 8000);\n                        break;\n                    case EVENT_INTRO_H2_2:\n                        Talk(SAY_SYLVANAS_INTRO_2);\n                        _events.ScheduleEvent(EVENT_INTRO_H2_3, 6000);\n                        break;\n                    case EVENT_INTRO_H2_3:\n                        Talk(SAY_SYLVANAS_INTRO_3);\n                        me-\u003eCastSpell(me, SPELL_CAST_VISUAL, false);\n                        me-\u003eCastSpell(me, SPELL_FROSTMOURNE_SOUNDS, true);\n                        _instance-\u003eHandleGameObject(_instance-\u003eGetGuidData(DATA_FROSTMOURNE), true);\n                        _events.ScheduleEvent(EVENT_INTRO_H2_4, 6000);\n                        break;\n                    case EVENT_INTRO_H2_4:\n                        // spawn UTHER during speach 2\n                        if (Creature* uther = me-\u003eSummonCreature(NPC_UTHER, UtherSpawnPos, TEMPSUMMON_MANUAL_DESPAWN))\n                            _utherGUID = uther-\u003eGetGUID();\n                        _events.ScheduleEvent(EVENT_INTRO_H2_5, 2000);\n                        break;\n                    case EVENT_INTRO_H2_5:\n                        if (Creature* uther = ObjectAccessor::GetCreature(*me, _utherGUID))\n                            uther-\u003eAI()-\u003eTalk(SAY_UTHER_INTRO_H2_1);\n                        _events.ScheduleEvent(EVENT_INTRO_H2_6, 11000);\n                        break;\n                    case EVENT_INTRO_H2_6:\n                        Talk(SAY_SYLVANAS_INTRO_4);\n                        _events.ScheduleEvent(EVENT_INTRO_H2_7, 3000);\n                        break;\n                    case EVENT_INTRO_H2_7:\n                        if (Creature* uther = ObjectAccessor::GetCreature(*me, _utherGUID))\n                            uther-\u003eAI()-\u003eTalk(SAY_UTHER_INTRO_H2_2);\n                        _events.ScheduleEvent(EVENT_INTRO_H2_8, 6000);\n                        break;\n                    case EVENT_INTRO_H2_8:\n                        Talk(SAY_SYLVANAS_INTRO_5);\n                        _events.ScheduleEvent(EVENT_INTRO_H2_9, 5000);\n                        break;\n                    case EVENT_INTRO_H2_9:\n                        if (Creature* uther = ObjectAccessor::GetCreature(*me, _utherGUID))\n                            uther-\u003eAI()-\u003eTalk(SAY_UTHER_INTRO_H2_3);\n                        _events.ScheduleEvent(EVENT_INTRO_H2_10, 19000);\n                        break;\n                    case EVENT_INTRO_H2_10:\n                        Talk(SAY_SYLVANAS_INTRO_6);\n                        _events.ScheduleEvent(EVENT_INTRO_H2_11, 1500);\n                        break;\n                    case EVENT_INTRO_H2_11:\n                        if (Creature* uther = ObjectAccessor::GetCreature(*me, _utherGUID))\n                            uther-\u003eAI()-\u003eTalk(SAY_UTHER_INTRO_H2_4);\n                        _events.ScheduleEvent(EVENT_INTRO_H2_12, 19500);\n                        break;\n                    case EVENT_INTRO_H2_12:\n                        Talk(SAY_SYLVANAS_INTRO_7);\n                        _events.ScheduleEvent(EVENT_INTRO_H2_13, 2000);\n                        break;\n                    case EVENT_INTRO_H2_13:\n                        if (Creature* uther = ObjectAccessor::GetCreature(*me, _utherGUID))\n                        {\n                            uther-\u003eHandleEmoteCommand(EMOTE_ONESHOT_NO);\n                            uther-\u003eAI()-\u003eTalk(SAY_UTHER_INTRO_H2_5);\n                        }\n                        _events.ScheduleEvent(EVENT_INTRO_H2_14, 12000);\n                        break;\n                    case EVENT_INTRO_H2_14:\n                        if (Creature* uther = ObjectAccessor::GetCreature(*me, _utherGUID))\n                            uther-\u003eAI()-\u003eTalk(SAY_UTHER_INTRO_H2_6);\n                        _events.ScheduleEvent(EVENT_INTRO_H2_15, 8000);\n                        break;\n                    case EVENT_INTRO_H2_15:\n                        Talk(SAY_SYLVANAS_INTRO_8);\n                        _events.ScheduleEvent(EVENT_INTRO_LK_1, 2000);\n                        break;\n                    // Remaining Intro Events common for both faction\n                    case EVENT_INTRO_LK_1:\n                        // Spawn LK in front of door, and make him move to the sword.\n                        if (Creature* lichking = me-\u003eSummonCreature(NPC_THE_LICH_KING_INTRO, LichKingIntroPosition[0], TEMPSUMMON_MANUAL_DESPAWN))\n                        {\n                            lichking-\u003eSetWalk(true);\n                            lichking-\u003eGetMotionMaster()-\u003eMovePoint(0, LichKingIntroPosition[2]);\n                            _lichkingGUID = lichking-\u003eGetGUID();\n                            _events.ScheduleEvent(EVENT_OPEN_IMPENETRABLE_DOOR, 0);\n                            _events.ScheduleEvent(EVENT_CLOSE_IMPENETRABLE_DOOR, 4s);\n                        }\n                        if (Creature* uther = ObjectAccessor::GetCreature(*me, _utherGUID))\n                        {\n                            uther-\u003eSetUInt32Value(UNIT_NPC_EMOTESTATE, EMOTE_STATE_COWER);\n                            if (_instance-\u003eGetData(DATA_TEAM_IN_INSTANCE) == ALLIANCE)\n                                uther-\u003eAI()-\u003eTalk(SAY_UTHER_INTRO_A2_9);\n                            else\n                                uther-\u003eAI()-\u003eTalk(SAY_UTHER_INTRO_H2_7);\n                        }\n                        _events.ScheduleEvent(EVENT_INTRO_LK_2, 10000);\n                        break;\n                    case EVENT_INTRO_LK_2:\n                        if (Creature* lichking = ObjectAccessor::GetCreature(*me, _lichkingGUID))\n                            lichking-\u003eAI()-\u003eTalk(SAY_LK_INTRO_1);\n                        _events.ScheduleEvent(EVENT_INTRO_LK_3, 1000);\n                        break;\n                    case EVENT_INTRO_LK_3:\n                        // The Lich King banishes Uther to the abyss.\n                        if (Creature* uther = ObjectAccessor::GetCreature(*me, _utherGUID))\n                        {\n                            uther-\u003eCastSpell(uther, SPELL_UTHER_DESPAWN, true);\n                            uther-\u003eDespawnOrUnsummon(5000);\n                            _utherGUID.Clear();\n                        }\n                        _events.ScheduleEvent(EVENT_INTRO_LK_4, 9000);\n                        break;\n                    case EVENT_INTRO_LK_4:\n                        // He steps forward and removes the runeblade from the heap of skulls.\n                        if (Creature* lichking = ObjectAccessor::GetCreature(*me, _lichkingGUID))\n                        {\n                            if (GameObject* frostmourne = ObjectAccessor::GetGameObject(*me, _instance-\u003eGetGuidData(DATA_FROSTMOURNE)))\n                                frostmourne-\u003eSetPhaseMask(2, true);\n                            lichking-\u003eCastSpell(lichking, SPELL_TAKE_FROSTMOURNE, true);\n                            lichking-\u003eCastSpell(lichking, SPELL_FROSTMOURNE_VISUAL, true);\n                        }\n                        _events.ScheduleEvent(EVENT_INTRO_LK_5, 8000);\n                        break;\n                    case EVENT_INTRO_LK_5:\n                        if (Creature* lichking = ObjectAccessor::GetCreature(*me, _lichkingGUID))\n                            lichking-\u003eAI()-\u003eTalk(SAY_LK_INTRO_2);\n                        _events.ScheduleEvent(EVENT_INTRO_LK_6, 10000);\n                        break;\n                    case EVENT_INTRO_LK_6:\n                        // summon Falric and Marwyn. then go back to the door\n                        if (Creature* falric = ObjectAccessor::GetCreature(*me, _instance-\u003eGetGuidData(DATA_FALRIC)))\n                        {\n                            falric-\u003eCastSpell(falric, SPELL_BOSS_SPAWN_AURA, true);\n                            falric-\u003eSetVisible(true);\n                        }\n                        if (Creature* marwyn = ObjectAccessor::GetCreature(*me, _instance-\u003eGetGuidData(DATA_MARWYN)))\n                        {\n                            marwyn-\u003eCastSpell(marwyn, SPELL_BOSS_SPAWN_AURA, true);\n                            marwyn-\u003eSetVisible(true);\n                        }\n                        if (Creature* lichking = ObjectAccessor::GetCreature(*me, _lichkingGUID))\n                        {\n                            lichking-\u003eAI()-\u003eTalk(SAY_LK_INTRO_3);\n                            lichking-\u003eSetWalk(true);\n                            lichking-\u003eGetMotionMaster()-\u003eMovePoint(0, LichKingMoveAwayPos);\n                        }\n                        _events.ScheduleEvent(EVENT_INTRO_LK_7, 10000);\n                        _events.ScheduleEvent(EVENT_OPEN_IMPENETRABLE_DOOR, 5s);\n                        break;\n                    case EVENT_INTRO_LK_7:\n                        if (Creature* marwyn = ObjectAccessor::GetCreature(*me, _instance-\u003eGetGuidData(DATA_MARWYN)))\n                        {\n                            marwyn-\u003eAI()-\u003eTalk(SAY_MARWYN_INTRO_1);\n                            marwyn-\u003eSetWalk(true);\n                            marwyn-\u003eGetMotionMaster()-\u003eMovePoint(0, MarwynPosition[1]);\n                        }\n                        _events.ScheduleEvent(EVENT_INTRO_LK_8, 1000);\n                        break;\n                    case EVENT_INTRO_LK_8:\n                        if (Creature* falric = ObjectAccessor::GetCreature(*me, _instance-\u003eGetGuidData(DATA_FALRIC)))\n                        {\n                            falric-\u003eAI()-\u003eTalk(SAY_FALRIC_INTRO_1);\n                            falric-\u003eSetWalk(true);\n                            falric-\u003eGetMotionMaster()-\u003eMovePoint(0, FalricPosition[1]);\n                        }\n                        _events.ScheduleEvent(EVENT_INTRO_LK_9, 5000);\n                        break;\n                    case EVENT_INTRO_LK_9:\n                        if (Creature* falric = ObjectAccessor::GetCreature(*me, _instance-\u003eGetGuidData(DATA_FALRIC)))\n                            falric-\u003eAI()-\u003eTalk(SAY_FALRIC_INTRO_2);\n                        _instance-\u003eProcessEvent(0, EVENT_SPAWN_WAVES);\n                        _events.ScheduleEvent(EVENT_INTRO_LK_10, 4000);\n                        break;\n                    case EVENT_INTRO_LK_10:\n                        if (_instance-\u003eGetData(DATA_TEAM_IN_INSTANCE) == ALLIANCE)\n                            Talk(SAY_JAINA_INTRO_END);\n                        else\n                            Talk(SAY_SYLVANAS_INTRO_END);\n                        me-\u003eGetMotionMaster()-\u003eMovePoint(0, LichKingMoveAwayPos);\n                        /// @todo: needs some improvements\n                        if (Creature* korelnOrLoralen = ObjectAccessor::GetCreature(*me, _instance-\u003eGetGuidData(DATA_KORELN_LORALEN)))\n                            korelnOrLoralen-\u003eGetMotionMaster()-\u003eMovePoint(1, KorelnOrLoralenPos[2]);\n                        _events.ScheduleEvent(EVENT_INTRO_LK_11, 5000);\n                        break;\n                    case EVENT_INTRO_LK_11:\n                        if (Creature* lichking = ObjectAccessor::GetCreature(*me, _lichkingGUID))\n                        {\n                            if (_instance-\u003eGetData(DATA_TEAM_IN_INSTANCE) == ALLIANCE)\n                                lichking-\u003eAI()-\u003eTalk(SAY_LK_JAINA_INTRO_END);\n                            else\n                                lichking-\u003eAI()-\u003eTalk(SAY_LK_SYLVANAS_INTRO_END);\n                        }\n                        _events.ScheduleEvent(EVENT_INTRO_END, 5s);\n                        break;\n                    case EVENT_INTRO_END:\n                        _instance-\u003eSetData(DATA_INTRO_EVENT, DONE);\n                        _events.ScheduleEvent(EVENT_KORELN_LORALEN_DEATH, 8s);\n                        if (Creature* lichking = ObjectAccessor::GetCreature(*me, _lichkingGUID))\n                        {\n                            lichking-\u003eDespawnOrUnsummon(5000);\n                            _lichkingGUID.Clear();\n                        }\n                        me-\u003eDespawnOrUnsummon(10000);\n                        _events.ScheduleEvent(EVENT_CLOSE_IMPENETRABLE_DOOR, 7s);\n                        break;\n                    case EVENT_SKIP_INTRO:\n                        if (_instance-\u003eGetData(DATA_TEAM_IN_INSTANCE) == ALLIANCE)\n                            me-\u003eGetMotionMaster()-\u003eMovePoint(0, JainaIntroPosition[2]);\n                        else\n                            me-\u003eGetMotionMaster()-\u003eMovePoint(0, SylvanasIntroPosition[2]);\n\n                        if (Creature* korelnOrLoralen = ObjectAccessor::GetCreature(*me, _instance-\u003eGetGuidData(DATA_KORELN_LORALEN)))\n                            korelnOrLoralen-\u003eGetMotionMaster()-\u003eMovePoint(0, KorelnOrLoralenPos[1]);\n\n                        if (Creature* lichking = me-\u003eSummonCreature(NPC_THE_LICH_KING_INTRO, LichKingIntroPosition[0], TEMPSUMMON_MANUAL_DESPAWN))\n                        {\n                            lichking-\u003eSetWalk(true);\n                            lichking-\u003eGetMotionMaster()-\u003eMovePoint(0, LichKingIntroPosition[2]);\n                            lichking-\u003eSetReactState(REACT_PASSIVE);\n                            _lichkingGUID = lichking-\u003eGetGUID();\n                            _events.ScheduleEvent(EVENT_OPEN_IMPENETRABLE_DOOR, 0);\n                            _events.ScheduleEvent(EVENT_CLOSE_IMPENETRABLE_DOOR, 4s);\n                        }\n                        _events.ScheduleEvent(EVENT_INTRO_LK_4, 15000);\n                        break;\n                    case EVENT_OPEN_IMPENETRABLE_DOOR:\n                        _instance-\u003eHandleGameObject(_instance-\u003eGetGuidData(DATA_IMPENETRABLE_DOOR), true);\n                        break;\n                    case EVENT_CLOSE_IMPENETRABLE_DOOR:\n                        _instance-\u003eHandleGameObject(_instance-\u003eGetGuidData(DATA_IMPENETRABLE_DOOR), false);\n                        break;\n                    case EVENT_KORELN_LORALEN_DEATH:\n                        if (Creature* korelnOrLoralen = ObjectAccessor::GetCreature(*me, _instance-\u003eGetGuidData(DATA_KORELN_LORALEN)))\n                            korelnOrLoralen-\u003eCastSpell(korelnOrLoralen, SPELL_FEIGN_DEATH);\n                        break;\n                    default:\n                        break;\n                }\n            }\n\n        private:\n            InstanceScript* _instance;\n            EventMap _events;\n            ObjectGuid _utherGUID;\n            ObjectGuid _lichkingGUID;\n        };\n\n        CreatureAI* GetAI(Creature* creature) const override\n        {\n            return GetHallsOfReflectionAI\u003cnpc_jaina_or_sylvanas_intro_horAI\u003e(creature);\n        }\n};\n\nclass HoRGameObjectDeleteDelayEvent : public BasicEvent\n{\n    public:\n        explicit HoRGameObjectDeleteDelayEvent(Unit* owner, ObjectGuid gameObjectGUID) : _owner(owner), _gameObjectGUID(gameObjectGUID) { }\n\n        void DeleteGameObject()\n        {\n            if (GameObject* go = ObjectAccessor::GetGameObject(*_owner, _gameObjectGUID))\n                go-\u003eDelete();\n        }\n\n        bool Execute(uint64 /*execTime*/, uint32 /*diff*/) override\n        {\n            DeleteGameObject();\n            return true;\n        }\n\n        void Abort(uint64 /*execTime*/) override\n        {\n            DeleteGameObject();\n        }\n\n    private:\n        Unit* _owner;\n        ObjectGuid _gameObjectGUID;\n};\n\nclass npc_jaina_or_sylvanas_escape_hor : public CreatureScript\n{\n    public:\n        npc_jaina_or_sylvanas_escape_hor() : CreatureScript(\"npc_jaina_or_sylvanas_escape_hor\") { }\n\n        struct npc_jaina_or_sylvanas_escape_horAI : public ScriptedAI\n        {\n            npc_jaina_or_sylvanas_escape_horAI(Creature* creature) : ScriptedAI(creature),\n                _instance(creature-\u003eGetInstanceScript()), _icewall(0), _prefight(false), _invincibility(true) { }\n\n            void Reset() override\n            {\n                _events.Reset();\n                _icewall = 0;\n                _events.ScheduleEvent(EVENT_ESCAPE, 1s);\n                _instance-\u003eDoStopTimedAchievement(ACHIEVEMENT_TIMED_TYPE_EVENT, ACHIEV_NOT_RETREATING_EVENT);\n            }\n\n            void JustDied(Unit* /*killer*/) override\n            {\n                if (Creature* lichking = ObjectAccessor::GetCreature(*me, _instance-\u003eGetGuidData(DATA_THE_LICH_KING_ESCAPE)))\n                    lichking-\u003eAI()-\u003eEnterEvadeMode(); // event failed\n            }\n\n            void DamageTaken(Unit* /*attacker*/, uint32\u0026 damage) override\n            {\n                if (damage \u003e= me-\u003eGetHealth() \u0026\u0026 _invincibility)\n                    damage = me-\u003eGetHealth() - 1;\n            }\n\n            void DoAction(int32 actionId) override\n            {\n                switch (actionId)\n                {\n                    case ACTION_START_PREFIGHT:\n                        if (_prefight)\n                            return;\n                        _prefight = true;\n                        _events.ScheduleEvent(EVENT_ESCAPE_1, 1000);\n                        break;\n                    case ACTION_WALL_BROKEN:\n                        ++_icewall;\n                        if (_icewall \u003c 4)\n                            _events.ScheduleEvent(EVENT_ESCAPE_13, 3000);\n                        else\n                            _events.ScheduleEvent(EVENT_ESCAPE_15, 3000);\n                        break;\n                    case ACTION_GUNSHIP_ARRIVAL:\n                        _events.ScheduleEvent(EVENT_ESCAPE_16, 5000);\n                        break;\n                    case ACTION_GUNSHIP_ARRIVAL_2:\n                        _events.ScheduleEvent(EVENT_ESCAPE_17, 5000);\n                        break;\n                    default:\n                        break;\n                }\n            }\n\n            bool GossipHello(Player* player) override\n            {\n                // override default gossip\n                if (_instance-\u003eGetBossState(DATA_THE_LICH_KING_ESCAPE) == DONE)\n                {\n                    player-\u003ePrepareGossipMenu(me, me-\u003eGetEntry() == NPC_JAINA_ESCAPE ? GOSSIP_MENU_JAINA_FINAL : GOSSIP_MENU_SYLVANAS_FINAL, true);\n                    player-\u003eSendPreparedGossip(me);\n                    return true;\n                }\n\n                // load default gossip\n                return false;\n            }\n\n            bool GossipSelect(Player* player, uint32 /*menuId*/, uint32 gossipListId) override\n            {\n                ClearGossipMenuFor(player);\n\n                switch (gossipListId)\n                {\n                    case 0:\n                        player-\u003ePlayerTalkClass-\u003eSendCloseGossip();\n                        me-\u003eRemoveFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_GOSSIP);\n                        _events.ScheduleEvent(EVENT_ESCAPE_6, 0);\n                        break;\n                    default:\n                        break;\n                }\n                return false;\n            }\n\n            void DestroyIceWall()\n            {\n                if (_instance-\u003eGetData(DATA_TEAM_IN_INSTANCE) == ALLIANCE)\n                    me-\u003eRemoveAurasDueToSpell(SPELL_JAINA_DESTROY_ICE_WALL);\n                else\n                    me-\u003eRemoveAurasDueToSpell(SPELL_SYLVANAS_DESTROY_ICE_WALL);\n\n                _instance-\u003eHandleGameObject(_instance-\u003eGetGuidData(DATA_ICEWALL), true);\n                me-\u003em_Events.AddEvent(new HoRGameObjectDeleteDelayEvent(me, _instance-\u003eGetGuidData(DATA_ICEWALL)), me-\u003em_Events.CalculateTime(5000));\n\n                if (Creature* wallTarget = ObjectAccessor::GetCreature(*me, _instance-\u003eGetGuidData(DATA_ICEWALL_TARGET)))\n                    wallTarget-\u003eDespawnOrUnsummon();\n            }\n\n            void SummonIceWall()\n            {\n                if (_icewall \u003c 4)\n                {\n                    if (Creature* lichking = ObjectAccessor::GetCreature(*me, _instance-\u003eGetGuidData(DATA_THE_LICH_KING_ESCAPE)))\n                    {\n                        lichking-\u003eStopMoving();\n                        if (Creature* wallTarget = me-\u003eSummonCreature(NPC_ICE_WALL_TARGET, IceWallTargetPosition[_icewall], TEMPSUMMON_MANUAL_DESPAWN, 720000))\n                            lichking-\u003eCastSpell(wallTarget, SPELL_SUMMON_ICE_WALL);\n\n                        lichking-\u003eAI()-\u003eSetData(DATA_ICEWALL, _icewall);\n                    }\n                }\n            }\n\n            void AttackIceWall()\n            {\n                if (_icewall \u003c 4)\n                    Talk(SAY_JAINA_SYLVANAS_ESCAPE_2 + _icewall);\n\n                if (Creature* wallTarget = ObjectAccessor::GetCreature(*me, _instance-\u003eGetGuidData(DATA_ICEWALL_TARGET)))\n                    me-\u003eSetFacingToObject(wallTarget);\n\n                if (_instance-\u003eGetData(DATA_TEAM_IN_INSTANCE) == ALLIANCE)\n                    DoCast(me, SPELL_JAINA_DESTROY_ICE_WALL, true);\n                else\n                    DoCast(me, SPELL_SYLVANAS_DESTROY_ICE_WALL, true);\n            }\n\n            void MovementInform(uint32 type, uint32 pointId) override\n            {\n                if (type != POINT_MOTION_TYPE)\n                    return;\n\n                switch (pointId)\n                {\n                    case POINT_SHADOW_THRONE_DOOR:\n                        if (me-\u003eGetEntry() == NPC_JAINA_ESCAPE)\n                            me-\u003eRemoveAurasDueToSpell(SPELL_JAINA_ICE_BARRIER);\n                        else\n                            me-\u003eRemoveAurasDueToSpell(SPELL_SYLVANAS_CLOAK_OF_DARKNESS);\n                        me-\u003eSetFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_GOSSIP);\n                        me-\u003eSetHealth(JAINA_SYLVANAS_MAX_HEALTH);\n                        me-\u003eSetFacingTo(SylvanasShadowThroneDoorPosition.GetOrientation());\n                        break;\n                    case POINT_ATTACK_ICEWALL:\n                        AttackIceWall();\n                        break;\n                    case POINT_TRAP:\n                        Talk(SAY_JAINA_SYLVANAS_ESCAPE_8);\n                        if (Creature* lichking = ObjectAccessor::GetCreature(*me, _instance-\u003eGetGuidData(DATA_THE_LICH_KING_ESCAPE)))\n                            me-\u003eSetFacingToObject(lichking);\n                        break;\n                    default:\n                        break;\n                }\n            }\n\n            void DeleteAllFromThreatList(Unit* target, ObjectGuid except)\n            {\n                for (ThreatReference* ref : target-\u003eGetThreatManager().GetModifiableThreatList())\n                  if (ref-\u003eGetVictim()-\u003eGetGUID() != except)\n                    ref-\u003eClearThreat();\n            }\n\n            void UpdateAI(uint32 diff) override\n            {\n                _events.Update(diff);\n\n                while (uint32 event = _events.ExecuteEvent())\n                {\n                    switch (event)\n                    {\n                        case EVENT_ESCAPE:\n                            if (_instance-\u003eGetData(DATA_TEAM_IN_INSTANCE) == ALLIANCE)\n                                DoCast(me, SPELL_JAINA_ICE_BARRIER);\n                            else\n                                DoCast(me, SPELL_SYLVANAS_CLOAK_OF_DARKNESS);\n\n                            if (Creature* lichking = ObjectAccessor::GetCreature(*me, _instance-\u003eGetGuidData(DATA_THE_LICH_KING_ESCAPE)))\n                            {\n                                me-\u003eCastSpell(lichking, SPELL_TAUNT_ARTHAS, true);\n                                lichking-\u003eApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_TAUNT, true);\n                                lichking-\u003eApplySpellImmune(0, IMMUNITY_EFFECT, SPELL_EFFECT_ATTACK_ME, true);\n                                AttackStart(lichking);\n                                lichking-\u003eAI()-\u003eAttackStart(me);\n                            }\n                            me-\u003eSetHealth(JAINA_SYLVANAS_MAX_HEALTH);\n                            me-\u003eRemoveFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_GOSSIP | UNIT_NPC_FLAG_QUESTGIVER);\n                            break;\n                        case EVENT_ESCAPE_1:\n                            if (Creature* lichking = ObjectAccessor::GetCreature(*me, _instance-\u003eGetGuidData(DATA_THE_LICH_KING_ESCAPE)))\n                            {\n                                if (_instance-\u003eGetData(DATA_TEAM_IN_INSTANCE) == ALLIANCE)\n                                    lichking-\u003eAI()-\u003eTalk(SAY_LK_ESCAPE_1);\n                                else\n                                    lichking-\u003eAI()-\u003eTalk(SAY_LK_ESCAPE_2);\n                                _events.ScheduleEvent(EVENT_ESCAPE_2, 8000);\n                            }\n                            break;\n                        case EVENT_ESCAPE_2:\n                            me-\u003eAttackStop();\n                            me-\u003eStopMoving();\n                            me-\u003eSetReactState(REACT_PASSIVE);\n\n                            if (_instance-\u003eGetData(DATA_TEAM_IN_INSTANCE) == ALLIANCE)\n                                DoCast(me, SPELL_JAINA_ICE_PRISON, false);\n                            else\n                                DoCast(me, SPELL_SYLVANAS_BLINDING_RETREAT, true);\n\n                            if (Creature* lichking = ObjectAccessor::GetCreature(*me, _instance-\u003eGetGuidData(DATA_THE_LICH_KING_ESCAPE)))\n                            {\n                                lichking-\u003eSetReactState(REACT_PASSIVE);\n                                lichking-\u003eSetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PACIFIED);\n                            }\n\n                            _events.ScheduleEvent(EVENT_ESCAPE_3, 1500);\n                            break;\n                        case EVENT_ESCAPE_3:\n                            if (_instance-\u003eGetData(DATA_TEAM_IN_INSTANCE) == HORDE)\n                                DoCastAOE(SPELL_SYLVANAS_DARK_BINDING, true);\n                            _events.ScheduleEvent(EVENT_ESCAPE_4, 1000);\n                            break;\n                        case EVENT_ESCAPE_4:\n                            if (_instance-\u003eGetData(DATA_TEAM_IN_INSTANCE) == ALLIANCE)\n                                DoCast(me, SPELL_CREDIT_FINDING_JAINA);\n                            else\n                                DoCast(me, SPELL_CREDIT_FINDING_SYLVANAS);\n                            Talk(SAY_JAINA_SYLVANAS_ESCAPE_1);\n\n                            if (Creature* lichking = ObjectAccessor::GetCreature(*me, _instance-\u003eGetGuidData(DATA_THE_LICH_KING_ESCAPE)))\n                            {\n                                lichking-\u003eSetImmuneToPC(true);\n                                lichking-\u003eRemoveAllAttackers();\n\n                                DeleteAllFromThreatList(lichking, me-\u003eGetGUID());\n                            }\n\n                            _events.ScheduleEvent(EVENT_ESCAPE_5, 2000);\n                            break;\n                        case EVENT_ESCAPE_5:\n                            me-\u003eGetMotionMaster()-\u003eMovePoint(POINT_SHADOW_THRONE_DOOR, SylvanasShadowThroneDoorPosition);\n                            break;\n                        case EVENT_ESCAPE_6:\n                            if (Creature* lichking = ObjectAccessor::GetCreature(*me, _instance-\u003eGetGuidData(DATA_THE_LICH_KING_ESCAPE)))\n                            {\n                                lichking-\u003eRemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PACIFIED);\n                                lichking-\u003eSetImmuneToPC(false);\n\n                                if (_instance-\u003eGetData(DATA_TEAM_IN_INSTANCE) == ALLIANCE)\n                                {\n                                    lichking-\u003eCastSpell(lichking, SPELL_STUN_BREAK_JAINA);\n                                    lichking-\u003eRemoveAurasDueToSpell(SPELL_JAINA_ICE_PRISON);\n                                }\n                                else\n                                {\n                                    lichking-\u003eCastSpell(lichking, SPELL_STUN_BREAK_SYLVANAS);\n                                    lichking-\u003eRemoveAurasDueToSpell(SPELL_SYLVANAS_DARK_BINDING);\n                                }\n                            }\n                            _invincibility = false;\n                            _instance-\u003eDoStartTimedAchievement(ACHIEVEMENT_TIMED_TYPE_EVENT, ACHIEV_NOT_RETREATING_EVENT);\n                            _events.ScheduleEvent(EVENT_ESCAPE_7, 1000);\n                            break;\n                        case EVENT_ESCAPE_7:\n                            if (Creature* lichking = ObjectAccessor::GetCreature(*me, _instance-\u003eGetGuidData(DATA_THE_LICH_KING_ESCAPE)))\n                                lichking-\u003eHandleEmoteCommand(TEXT_EMOTE_ROAR);\n                            me-\u003eGetMotionMaster()-\u003eMovePoint(0, NpcJainaOrSylvanasEscapeRoute[0]);\n                            _events.ScheduleEvent(EVENT_ESCAPE_8, 3000);\n                            break;\n                        case EVENT_ESCAPE_8:\n                            if (Creature* lichking = ObjectAccessor::GetCreature(*me, _instance-\u003eGetGuidData(DATA_THE_LICH_KING_ESCAPE)))\n                                lichking-\u003eGetMotionMaster()-\u003eMovePoint(0, NpcJainaOrSylvanasEscapeRoute[0]);\n                            _events.ScheduleEvent(EVENT_ESCAPE_9, 1000);\n                            break;\n                        case EVENT_ESCAPE_9:\n                            me-\u003eGetMotionMaster()-\u003eMovePoint(0, NpcJainaOrSylvanasEscapeRoute[1]);\n                            _events.ScheduleEvent(EVENT_ESCAPE_10, 5000);\n                            break;\n                        case EVENT_ESCAPE_10:\n                            me-\u003eGetMotionMaster()-\u003eMovePoint(0, NpcJainaOrSylvanasEscapeRoute[2]);\n                            if (Creature* lichking = ObjectAccessor::GetCreature(*me, _instance-\u003eGetGuidData(DATA_THE_LICH_KING_ESCAPE)))\n                                lichking-\u003eGetMotionMaster()-\u003eMovePoint(1, LichKingFirstSummon);\n                            _events.ScheduleEvent(EVENT_ESCAPE_11, 6000);\n                            break;\n                        case EVENT_ESCAPE_11:\n                            SummonIceWall();\n                            _events.ScheduleEvent(EVENT_ESCAPE_12, 4000);\n                            break;\n                        case EVENT_ESCAPE_12:\n                            if (Creature* lichking = ObjectAccessor::GetCreature(*me, _instance-\u003eGetGuidData(DATA_THE_LICH_KING_ESCAPE)))\n                                lichking-\u003eCastSpell(lichking, SPELL_PAIN_AND_SUFFERING, true);\n\n                            me-\u003eGetMotionMaster()-\u003eMovePoint(POINT_ATTACK_ICEWALL, NpcJainaOrSylvanasEscapeRoute[3]);\n                            break;\n                        case EVENT_ESCAPE_13: // ICEWALL BROKEN\n                            DestroyIceWall();\n\n                            if (_icewall \u0026\u0026 _icewall \u003c 4)\n                                me-\u003eGetMotionMaster()-\u003eMovePoint(POINT_ATTACK_ICEWALL, NpcJainaOrSylvanasEscapeRoute[_icewall + 3]);\n                            _events.ScheduleEvent(EVENT_ESCAPE_14, 8000);\n                            break;\n                        case EVENT_ESCAPE_14:\n                            SummonIceWall();\n                            break;\n                        case EVENT_ESCAPE_15: // FINAL PART\n                            DestroyIceWall();\n\n                            Talk(SAY_JAINA_SYLVANAS_ESCAPE_6);\n\n                            if (Creature* lichking = ObjectAccessor::GetCreature(*me, _instance-\u003eGetGuidData(DATA_THE_LICH_KING_ESCAPE)))\n                            {\n                                lichking-\u003eGetMotionMaster()-\u003eMovePoint(2, LichKingFinalPos);\n                                lichking-\u003eRemoveAurasDueToSpell(SPELL_REMORSELESS_WINTER);\n                            }\n                            me-\u003eGetMotionMaster()-\u003eMovePoint(POINT_TRAP, NpcJainaOrSylvanasEscapeRoute[7]);\n                            break;\n                        case EVENT_ESCAPE_16:\n                            me-\u003eRemoveAurasDueToSpell(SPELL_HARVEST_SOUL);\n                            if (_instance-\u003eGetData(DATA_TEAM_IN_INSTANCE) == ALLIANCE)\n                                Talk(SAY_JAINA_ESCAPE_9);\n                            if (Transport* gunship = ObjectAccessor::GetTransport(*me, _instance-\u003eGetGuidData(DATA_GUNSHIP)))\n                                gunship-\u003eEnableMovement(true);\n                            _instance-\u003eSetBossState(DATA_THE_LICH_KING_ESCAPE, DONE);\n                            break;\n                        case EVENT_ESCAPE_17:\n                            if (_instance-\u003eGetData(DATA_TEAM_IN_INSTANCE) == ALLIANCE)\n                                Talk(SAY_JAINA_ESCAPE_10);\n                            else\n                                Talk(SAY_SYLVANAS_ESCAPE_9);\n                            DoCast(me, SPELL_CREDIT_ESCAPING_ARTHAS);\n                            me-\u003eSetFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_GOSSIP | UNIT_NPC_FLAG_QUESTGIVER);\n                            break;\n                        default:\n                            break;\n                    }\n                }\n\n                DoMeleeAttackIfReady();\n            }\n\n        private:\n            InstanceScript* _instance;\n            EventMap _events;\n            uint32 _icewall; // icewall number\n            bool _prefight;\n            bool _invincibility;\n        };\n\n        CreatureAI* GetAI(Creature* creature) const override\n        {\n            return GetHallsOfReflectionAI\u003cnpc_jaina_or_sylvanas_escape_horAI\u003e(creature);\n        }\n};\n\nclass npc_the_lich_king_escape_hor : public CreatureScript\n{\n    public:\n        npc_the_lich_king_escape_hor() : CreatureScript(\"npc_the_lich_king_escape_hor\") { }\n\n        struct npc_the_lich_king_escape_horAI : public ScriptedAI\n        {\n            npc_the_lich_king_escape_horAI(Creature* creature) : ScriptedAI(creature)\n            {\n                _instance = me-\u003eGetInstanceScript();\n                _instance-\u003eSetBossState(DATA_THE_LICH_KING_ESCAPE, NOT_STARTED);\n                _summonsCount = 0;\n                _icewall = 0;\n                _despawn = false;\n            }\n\n            void DamageTaken(Unit* /*attacker*/, uint32\u0026 damage) override\n            {\n                if (damage \u003e= me-\u003eGetHealth())\n                    damage = me-\u003eGetHealth() - 1;\n            }\n\n            void MovementInform(uint32 type, uint32 pointId) override\n            {\n                if (type == POINT_MOTION_TYPE)\n                {\n                    switch (pointId)\n                    {\n                        case 1:\n                            if (Creature* target = ObjectAccessor::GetCreature(*me, _instance-\u003eGetGuidData(DATA_ESCAPE_LEADER)))\n                                me-\u003eGetMotionMaster()-\u003eMoveChase(target);\n                            break;\n                        case 2:\n                            Talk(SAY_LK_ESCAPE_HARVEST_SOUL);\n\n                            if (Creature* target = ObjectAccessor::GetCreature(*me, _instance-\u003eGetGuidData(DATA_ESCAPE_LEADER)))\n                                DoCast(target, SPELL_HARVEST_SOUL);\n\n                            if (Transport* gunship = ObjectAccessor::GetTransport(*me, _instance-\u003eGetGuidData(DATA_GUNSHIP)))\n                                gunship-\u003eEnableMovement(true);\n                            break;\n                        default:\n                            break;\n                    }\n                }\n            }\n\n            void JustSummoned(Creature* /*summon*/) override\n            {\n                ++_summonsCount;\n            }\n\n            void SummonedCreatureDies(Creature* /*summon*/, Unit* /*killer*/) override\n            {\n                // should never happen\n                if (!_summonsCount)\n                    return;\n\n                --_summonsCount;\n\n                // All summons dead and no summon events scheduled\n                if (!_summonsCount \u0026\u0026 _events.Empty())\n                {\n                    if (Creature* jainaOrSylvanas = ObjectAccessor::GetCreature(*me, _instance-\u003eGetGuidData(DATA_ESCAPE_LEADER)))\n                        jainaOrSylvanas-\u003eAI()-\u003eDoAction(ACTION_WALL_BROKEN);\n                }\n            }\n\n            void KilledUnit(Unit* who) override\n            {\n                if (who-\u003eGetTypeId() == TYPEID_PLAYER)\n                    DoPlaySoundToSet(me, RAND(SOUND_LK_SLAY_1, SOUND_LK_SLAY_2));\n            }\n\n            void SetData(uint32 type, uint32 data) override\n            {\n                if (type != DATA_ICEWALL)\n                    return;\n\n                _icewall = data;\n\n                switch (_icewall)\n                {\n                    case 0: // 6 Ghouls, 1 Witch Doctor\n                        DoZoneInCombat();\n                        _events.ScheduleEvent(EVENT_REMORSELESS_WINTER, 0);\n                        _events.ScheduleEvent(EVENT_ESCAPE_SUMMON_GHOULS, 8s);\n                        _events.ScheduleEvent(EVENT_ESCAPE_SUMMON_WITCH_DOCTOR, 14s);\n                        Talk(SAY_LK_ESCAPE_ICEWALL_SUMMONED_1);\n                        break;\n                    case 1: // 6 Ghouls, 2 Witch Doctor, 1 Lumbering Abomination\n                        _events.ScheduleEvent(EVENT_ESCAPE_SUMMON_GHOULS, 8s);\n                        _events.ScheduleEvent(EVENT_ESCAPE_SUMMON_LUMBERING_ABOMINATION, 13s);\n                        _events.ScheduleEvent(EVENT_ESCAPE_SUMMON_WITCH_DOCTOR, 15s);\n                        _events.ScheduleEvent(EVENT_ESCAPE_SUMMON_WITCH_DOCTOR, 18s);\n                        Talk(SAY_LK_ESCAPE_ICEWALL_SUMMONED_2);\n                        break;\n                    case 2: // 6 Ghouls, 2 Witch Doctor, 2 Lumbering Abomination\n                        _events.ScheduleEvent(EVENT_ESCAPE_SUMMON_GHOULS, 9s);\n                        _events.ScheduleEvent(EVENT_ESCAPE_SUMMON_LUMBERING_ABOMINATION, 14s);\n                        _events.ScheduleEvent(EVENT_ESCAPE_SUMMON_WITCH_DOCTOR, 15s);\n                        _events.ScheduleEvent(EVENT_ESCAPE_SUMMON_LUMBERING_ABOMINATION, 19s);\n                        _events.ScheduleEvent(EVENT_ESCAPE_SUMMON_WITCH_DOCTOR, 39s);\n                        Talk(SAY_LK_ESCAPE_ICEWALL_SUMMONED_3);\n                        break;\n                    case 3: // 12 Ghouls, 4 Witch Doctor, 3 Lumbering Abomination\n                        _events.ScheduleEvent(EVENT_ESCAPE_SUMMON_GHOULS, 9s);\n                        _events.ScheduleEvent(EVENT_ESCAPE_SUMMON_WITCH_DOCTOR, 15s);\n                        _events.ScheduleEvent(EVENT_ESCAPE_SUMMON_WITCH_DOCTOR, 19s);\n                        _events.ScheduleEvent(EVENT_ESCAPE_SUMMON_LUMBERING_ABOMINATION, 40s);\n                        _events.ScheduleEvent(EVENT_ESCAPE_SUMMON_LUMBERING_ABOMINATION, 45s);\n                        _events.ScheduleEvent(EVENT_ESCAPE_SUMMON_GHOULS, 55s);\n                        _events.ScheduleEvent(EVENT_ESCAPE_SUMMON_WITCH_DOCTOR, 62s);\n                        _events.ScheduleEvent(EVENT_ESCAPE_SUMMON_WITCH_DOCTOR, 65s);\n                        _events.ScheduleEvent(EVENT_ESCAPE_SUMMON_LUMBERING_ABOMINATION, 14s);\n                        Talk(SAY_LK_ESCAPE_ICEWALL_SUMMONED_4);\n                        break;\n                    default:\n                        break;\n                }\n            }\n\n            void EnterEvadeMode(EvadeReason /*why*/) override\n            {\n                if (_despawn)\n                    return;\n\n                _instance-\u003eSetBossState(DATA_THE_LICH_KING_ESCAPE, FAIL);\n                me-\u003eStopMoving();\n                DoPlaySoundToSet(me, SOUND_LK_FURY_OF_FROSTMOURNE);\n                DoCastAOE(SPELL_FURY_OF_FROSTMOURNE);\n                me-\u003eDespawnOrUnsummon(12000);\n                _despawn = true;\n            }\n\n            void UpdateAI(uint32 diff) override\n            {\n                if (!SelectVictim())\n                    return;\n\n                _events.Update(diff);\n\n                if (me-\u003eHasUnitState(UNIT_STATE_CASTING))\n                    return;\n\n                while (uint32 event = _events.ExecuteEvent())\n                {\n                    switch (event)\n                    {\n                        case EVENT_REMORSELESS_WINTER:\n                            me-\u003eStopMoving();\n                            Talk(SAY_LK_ESCAPE_WINTER);\n                            DoCast(me, SPELL_REMORSELESS_WINTER);\n                            break;\n                        case EVENT_ESCAPE_SUMMON_GHOULS:\n                            me-\u003eStopMoving();\n                            Talk(SAY_LK_ESCAPE_GHOULS);\n                            DoCast(me, SPELL_RAISE_DEAD);\n                            break;\n                        case EVENT_ESCAPE_SUMMON_WITCH_DOCTOR:\n                            DoCast(me, SPELL_SUMMON_RISEN_WITCH_DOCTOR);\n                            break;\n                        case EVENT_ESCAPE_SUMMON_LUMBERING_ABOMINATION:\n                            Talk(SAY_LK_ESCAPE_ABOMINATION);\n                            DoCast(me, SPELL_SUMMON_LUMBERING_ABOMINATION);\n                            break;\n                        default:\n                            break;\n                    }\n                }\n\n                DoMeleeAttackIfReady();\n            }\n\n        private:\n            bool SelectVictim()\n            {\n                if (!me-\u003eIsInCombat())\n                    return false;\n\n                if (!me-\u003eHasReactState(REACT_PASSIVE))\n                {\n                    if (Unit* victim = me-\u003eSelectVictim())\n                        if (!me-\u003eHasSpellFocus() \u0026\u0026 victim != me-\u003eGetVictim())\n                            AttackStart(victim);\n                    return me-\u003eGetVictim() != nullptr;\n                }\n                else if (me-\u003eGetCombatManager().GetPvECombatRefs().size() \u003c 2 \u0026\u0026 me-\u003eHasAura(SPELL_REMORSELESS_WINTER))\n                {\n                    EnterEvadeMode(EVADE_REASON_OTHER);\n                    return false;\n                }\n\n                return true;\n            }\n\n            InstanceScript* _instance;\n            EventMap _events;\n            uint8 _icewall;\n            uint32 _summonsCount;\n            bool _despawn;\n        };\n\n        CreatureAI* GetAI(Creature* creature) const override\n        {\n            return GetHallsOfReflectionAI\u003cnpc_the_lich_king_escape_horAI\u003e(creature);\n        }\n};\n\nenum TrashSpells\n{\n    // Ghostly Priest\n    SPELL_SHADOW_WORD_PAIN                        = 72318,\n    SPELL_CIRCLE_OF_DESTRUCTION                   = 72320,\n    SPELL_COWER_IN_FEAR                           = 72321,\n    SPELL_DARK_MENDING                            = 72322,\n\n    // Phantom Mage\n    SPELL_FIREBALL                                = 72163,\n    SPELL_FLAMESTRIKE                             = 72169,\n    SPELL_FROSTBOLT                               = 72166,\n    SPELL_CHAINS_OF_ICE                           = 72121,\n    SPELL_HALLUCINATION                           = 72342,\n    AURA_HALLUCINATION                            = 72343,\n\n    // Phantom Hallucination (same as phantom mage + HALLUCINATION_2 when dies)\n    SPELL_HALLUCINATION_2                         = 72344,\n\n    // Shadowy Mercenary\n    SPELL_SHADOW_STEP                             = 72326,\n    SPELL_DEADLY_POISON                           = 72329,\n    SPELL_ENVENOMED_DAGGER_THROW                  = 72333,\n    SPELL_KIDNEY_SHOT                             = 72335,\n\n    // Spectral Footman\n    SPELL_SPECTRAL_STRIKE                         = 72198,\n    SPELL_SHIELD_BASH                             = 72194,\n    SPELL_TORTURED_ENRAGE                         = 72203,\n\n    // Tortured Rifleman\n    SPELL_SHOOT                                   = 72208,\n    SPELL_CURSED_ARROW                            = 72222,\n    SPELL_FROST_TRAP                              = 72215,\n    SPELL_ICE_SHOT                                = 72268\n};\n\nenum TrashEvents\n{\n    EVENT_TRASH_NONE,\n\n    // Ghostly Priest\n    EVENT_SHADOW_WORD_PAIN,\n    EVENT_CIRCLE_OF_DESTRUCTION,\n    EVENT_COWER_IN_FEAR,\n    EVENT_DARK_MENDING,\n\n    // Phantom Mage\n    EVENT_FIREBALL,\n    EVENT_FLAMESTRIKE,\n    EVENT_FROSTBOLT,\n    EVENT_CHAINS_OF_ICE,\n    EVENT_HALLUCINATION,\n\n    // Shadowy Mercenary\n    EVENT_SHADOW_STEP,\n    EVENT_DEADLY_POISON,\n    EVENT_ENVENOMED_DAGGER_THROW,\n    EVENT_KIDNEY_SHOT,\n\n    // Spectral Footman\n    EVENT_SPECTRAL_STRIKE,\n    EVENT_SHIELD_BASH,\n    EVENT_TORTURED_ENRAGE,\n\n    // Tortured Rifleman\n    EVENT_SHOOT,\n    EVENT_CURSED_ARROW,\n    EVENT_FROST_TRAP,\n    EVENT_ICE_SHOT\n};\n\nstruct npc_gauntlet_trash : public ScriptedAI\n{\n    npc_gauntlet_trash(Creature* creature) : ScriptedAI(creature),\n        _instance(creature-\u003eGetInstanceScript()), InternalWaveId(0) { }\n\n    void Reset() override\n    {\n        me-\u003eCastSpell(me, SPELL_WELL_OF_SOULS, true);\n        _events.Reset();\n    }\n\n    void EnterEvadeMode(EvadeReason /*why*/) override\n    {\n        if (_instance-\u003eGetData(DATA_WAVE_COUNT) != NOT_STARTED)\n            _instance-\u003eSetData(DATA_WAVE_COUNT, NOT_STARTED);\n    }\n\n    void SetData(uint32 type, uint32 value) override\n    {\n        if (type)\n            return;\n\n        InternalWaveId = value;\n    }\n\n    uint32 GetData(uint32 type) const override\n    {\n        if (type)\n            return 0;\n\n        return InternalWaveId;\n    }\n\nprotected:\n    EventMap _events;\n    InstanceScript* _instance;\n    uint32 InternalWaveId;\n};\n\nclass npc_ghostly_priest : public CreatureScript\n{\n    public:\n        npc_ghostly_priest() : CreatureScript(\"npc_ghostly_priest\") { }\n\n        struct npc_ghostly_priestAI : public npc_gauntlet_trash\n        {\n            npc_ghostly_priestAI(Creature* creature) : npc_gauntlet_trash(creature) { }\n\n            void JustEngagedWith(Unit* /*who*/) override\n            {\n                _events.ScheduleEvent(EVENT_SHADOW_WORD_PAIN, 6s, 15s);\n                _events.ScheduleEvent(EVENT_CIRCLE_OF_DESTRUCTION, 12s);\n                _events.ScheduleEvent(EVENT_COWER_IN_FEAR, 10s);\n                _events.ScheduleEvent(EVENT_DARK_MENDING, 20s);\n            }\n\n            void UpdateAI(uint32 diff) override\n            {\n                if (!UpdateVictim())\n                    return;\n\n                _events.Update(diff);\n\n                if (me-\u003eHasUnitState(UNIT_STATE_CASTING))\n                    return;\n\n                switch (_events.ExecuteEvent())\n                {\n                    case EVENT_SHADOW_WORD_PAIN:\n                        if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 0, 40.0f, true))\n                            DoCast(target, SPELL_SHADOW_WORD_PAIN);\n                        _events.ScheduleEvent(EVENT_SHADOW_WORD_PAIN, 6s, 15s);\n                        break;\n                    case EVENT_CIRCLE_OF_DESTRUCTION:\n                        if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 0, 10.0f, true))\n                            DoCast(target, SPELL_CIRCLE_OF_DESTRUCTION);\n                        _events.ScheduleEvent(EVENT_CIRCLE_OF_DESTRUCTION, 12s);\n                        break;\n                    case EVENT_COWER_IN_FEAR:\n                        if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 0, 20.0f, true))\n                            DoCast(target, SPELL_COWER_IN_FEAR);\n                        _events.ScheduleEvent(EVENT_COWER_IN_FEAR, 10s);\n                        break;\n                    case EVENT_DARK_MENDING:\n                        // find an ally with missing HP\n                        if (Unit* target = DoSelectLowestHpFriendly(40, DUNGEON_MODE(30000, 50000)))\n                        {\n                            DoCast(target, SPELL_DARK_MENDING);\n                            _events.ScheduleEvent(EVENT_DARK_MENDING, 20s);\n                        }\n                        else\n                        {\n                            // no friendly unit with missing hp. re-check in just 5 sec.\n                            _events.ScheduleEvent(EVENT_DARK_MENDING, 5s);\n                        }\n                        break;\n                    default:\n                        break;\n                }\n\n                DoMeleeAttackIfReady();\n            }\n        };\n\n        CreatureAI* GetAI(Creature* creature) const override\n        {\n            return GetHallsOfReflectionAI\u003cnpc_ghostly_priestAI\u003e(creature);\n        }\n};\n\nclass npc_phantom_mage : public CreatureScript\n{\n    public:\n        npc_phantom_mage() : CreatureScript(\"npc_phantom_mage\") { }\n\n        struct npc_phantom_mageAI : public npc_gauntlet_trash\n        {\n            npc_phantom_mageAI(Creature* creature) : npc_gauntlet_trash(creature) { }\n\n            void EnterEvadeMode(EvadeReason why) override\n            {\n                if (!me-\u003eHasAura(AURA_HALLUCINATION))\n                    npc_gauntlet_trash::EnterEvadeMode(why);\n            }\n\n            void JustEngagedWith(Unit* /*who*/) override\n            {\n                _events.ScheduleEvent(EVENT_FIREBALL, 3s);\n                _events.ScheduleEvent(EVENT_FLAMESTRIKE, 6s);\n                _events.ScheduleEvent(EVENT_FROSTBOLT, 9s);\n                _events.ScheduleEvent(EVENT_CHAINS_OF_ICE, 12s);\n                _events.ScheduleEvent(EVENT_HALLUCINATION, 40s);\n            }\n\n            void UpdateAI(uint32 diff) override\n            {\n                if (!UpdateVictim())\n                    return;\n\n                _events.Update(diff);\n\n                if (me-\u003eHasUnitState(UNIT_STATE_CASTING))\n                    return;\n\n                switch (_events.ExecuteEvent())\n                {\n                    case EVENT_FIREBALL:\n                        if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 0, 40.0f, true))\n                            DoCast(target, SPELL_FIREBALL);\n                        _events.ScheduleEvent(EVENT_FIREBALL, 15s);\n                        break;\n                    case EVENT_FLAMESTRIKE:\n                        if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 0, 40.0f, true))\n                            DoCast(target, SPELL_FLAMESTRIKE);\n                        _events.ScheduleEvent(EVENT_FLAMESTRIKE, 15s);\n                        break;\n                    case EVENT_FROSTBOLT:\n                        if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 0, 40.0f, true))\n                            DoCast(target, SPELL_FROSTBOLT);\n                        _events.ScheduleEvent(EVENT_FROSTBOLT, 15s);\n                        break;\n                    case EVENT_CHAINS_OF_ICE:\n                        if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM))\n                            DoCast(target, SPELL_CHAINS_OF_ICE);\n                        _events.ScheduleEvent(EVENT_CHAINS_OF_ICE, 15s);\n                        break;\n                    case EVENT_HALLUCINATION:\n                        // removing any dots on mage or else the invisibility spell will break duration\n                        me-\u003eRemoveAllAuras();\n                        DoCast(me, SPELL_HALLUCINATION);\n                        break;\n                    default:\n                        break;\n                }\n\n                DoMeleeAttackIfReady();\n            }\n        };\n\n        CreatureAI* GetAI(Creature* creature) const override\n        {\n            return GetHallsOfReflectionAI\u003cnpc_phantom_mageAI\u003e(creature);\n        }\n};\n\nclass npc_phantom_hallucination : public CreatureScript\n{\n    public:\n        npc_phantom_hallucination() : CreatureScript(\"npc_phantom_hallucination\") { }\n\n        struct npc_phantom_hallucinationAI : public npc_phantom_mage::npc_phantom_mageAI\n        {\n            npc_phantom_hallucinationAI(Creature* creature) : npc_phantom_mage::npc_phantom_mageAI(creature) { }\n\n            void Reset() override\n            {\n                DoZoneInCombat(me);\n            }\n\n            void EnterEvadeMode(EvadeReason why) override\n            {\n                if (me-\u003eGetOwner() \u0026\u0026 !me-\u003eGetOwner()-\u003eHasAura(AURA_HALLUCINATION))\n                    npc_phantom_mage::npc_phantom_mageAI::EnterEvadeMode(why);\n            }\n\n            void JustDied(Unit* /*killer*/) override\n            {\n                DoCastAOE(SPELL_HALLUCINATION_2);\n            }\n        };\n\n        CreatureAI* GetAI(Creature* creature) const override\n        {\n            return GetHallsOfReflectionAI\u003cnpc_phantom_hallucinationAI\u003e(creature);\n        }\n};\n\nclass npc_shadowy_mercenary : public CreatureScript\n{\n    public:\n        npc_shadowy_mercenary() : CreatureScript(\"npc_shadowy_mercenary\") { }\n\n        struct npc_shadowy_mercenaryAI : public npc_gauntlet_trash\n        {\n            npc_shadowy_mercenaryAI(Creature* creature) : npc_gauntlet_trash(creature) { }\n\n            void JustEngagedWith(Unit* /*who*/) override\n            {\n                _events.ScheduleEvent(EVENT_SHADOW_STEP, 23s);\n                _events.ScheduleEvent(EVENT_DEADLY_POISON, 5s);\n                _events.ScheduleEvent(EVENT_ENVENOMED_DAGGER_THROW, 10s);\n                _events.ScheduleEvent(EVENT_KIDNEY_SHOT, 12s);\n            }\n\n            void UpdateAI(uint32 diff) override\n            {\n                if (!UpdateVictim())\n                    return;\n\n                _events.Update(diff);\n\n                if (me-\u003eHasUnitState(UNIT_STATE_CASTING))\n                    return;\n\n                switch (_events.ExecuteEvent())\n                {\n                    case EVENT_SHADOW_STEP:\n                        if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 0, 100.0f, true))\n                            DoCast(target, SPELL_SHADOW_STEP);\n                        _events.ScheduleEvent(EVENT_SHADOW_STEP, 8s);\n                        break;\n                    case EVENT_DEADLY_POISON:\n                        DoCastVictim(SPELL_DEADLY_POISON);\n                        _events.ScheduleEvent(EVENT_DEADLY_POISON, 10s);\n                        break;\n                    case EVENT_ENVENOMED_DAGGER_THROW:\n                        if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 0, 40.0f, true))\n                            DoCast(target, SPELL_ENVENOMED_DAGGER_THROW);\n                        _events.ScheduleEvent(EVENT_ENVENOMED_DAGGER_THROW, 10s);\n                        break;\n                    case EVENT_KIDNEY_SHOT:\n                        DoCastVictim(SPELL_KIDNEY_SHOT);\n                        _events.ScheduleEvent(EVENT_KIDNEY_SHOT, 10s);\n                        break;\n                    default:\n                        break;\n                }\n\n                DoMeleeAttackIfReady();\n            }\n        };\n\n        CreatureAI* GetAI(Creature* creature) const override\n        {\n            return GetHallsOfReflectionAI\u003cnpc_shadowy_mercenaryAI\u003e(creature);\n        }\n};\n\nclass npc_spectral_footman : public CreatureScript\n{\n    public:\n        npc_spectral_footman() : CreatureScript(\"npc_spectral_footman\") { }\n\n        struct npc_spectral_footmanAI : public npc_gauntlet_trash\n        {\n            npc_spectral_footmanAI(Creature* creature) : npc_gauntlet_trash(creature) { }\n\n            void JustEngagedWith(Unit* /*who*/) override\n            {\n                _events.ScheduleEvent(EVENT_SPECTRAL_STRIKE, 14s);\n                _events.ScheduleEvent(EVENT_SHIELD_BASH, 10s);\n                _events.ScheduleEvent(EVENT_TORTURED_ENRAGE, 15s);\n            }\n\n            void UpdateAI(uint32 diff) override\n            {\n                if (!UpdateVictim())\n                    return;\n\n                _events.Update(diff);\n\n                if (me-\u003eHasUnitState(UNIT_STATE_CASTING))\n                    return;\n\n                switch (_events.ExecuteEvent())\n                {\n                    case EVENT_SPECTRAL_STRIKE:\n                        DoCastVictim(SPELL_SPECTRAL_STRIKE);\n                        _events.ScheduleEvent(EVENT_SPECTRAL_STRIKE, 5s);\n                        break;\n                    case EVENT_SHIELD_BASH:\n                        DoCastVictim(SPELL_SHIELD_BASH);\n                        _events.ScheduleEvent(EVENT_SHIELD_BASH, 5s);\n                        break;\n                    case EVENT_TORTURED_ENRAGE:\n                        DoCast(me, SPELL_TORTURED_ENRAGE);\n                        _events.ScheduleEvent(EVENT_TORTURED_ENRAGE, 15s);\n                        break;\n                    default:\n                        break;\n                }\n\n                DoMeleeAttackIfReady();\n            }\n        };\n\n        CreatureAI* GetAI(Creature* creature) const override\n        {\n            return GetHallsOfReflectionAI\u003cnpc_spectral_footmanAI\u003e(creature);\n        }\n};\n\nclass npc_tortured_rifleman : public CreatureScript\n{\n    public:\n        npc_tortured_rifleman() : CreatureScript(\"npc_tortured_rifleman\") { }\n\n        struct npc_tortured_riflemanAI : public npc_gauntlet_trash\n        {\n            npc_tortured_riflemanAI(Creature* creature) : npc_gauntlet_trash(creature) { }\n\n            void JustEngagedWith(Unit* /*who*/) override\n            {\n                _events.ScheduleEvent(EVENT_SHOOT, 1);\n                _events.ScheduleEvent(EVENT_CURSED_ARROW, 7s);\n                _events.ScheduleEvent(EVENT_FROST_TRAP, 10s);\n                _events.ScheduleEvent(EVENT_ICE_SHOT, 15s);\n            }\n\n            void UpdateAI(uint32 diff) override\n            {\n                if (!UpdateVictim())\n                    return;\n\n                _events.Update(diff);\n\n                if (me-\u003eHasUnitState(UNIT_STATE_CASTING))\n                    return;\n\n                switch (_events.ExecuteEvent())\n                {\n                    case EVENT_SHOOT:\n                        if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 0, 40.0f, true))\n                            DoCast(target, SPELL_SHOOT);\n                        _events.ScheduleEvent(EVENT_SHOOT, 2s);\n                        break;\n                    case EVENT_CURSED_ARROW:\n                        if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 0, 40.0f, true))\n                            DoCast(target, SPELL_CURSED_ARROW);\n                        _events.ScheduleEvent(EVENT_CURSED_ARROW, 10s);\n                        break;\n                    case EVENT_FROST_TRAP:\n                        DoCast(me, SPELL_FROST_TRAP);\n                        _events.ScheduleEvent(EVENT_FROST_TRAP, 30s);\n                        break;\n                    case EVENT_ICE_SHOT:\n                        if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 0, 40.0f, true))\n                            DoCast(target, SPELL_ICE_SHOT);\n                        _events.ScheduleEvent(EVENT_ICE_SHOT, 15s);\n                        break;\n                    default:\n                        break;\n                }\n\n                DoMeleeAttackIfReady();\n            }\n        };\n\n        CreatureAI* GetAI(Creature* creature) const override\n        {\n            return GetHallsOfReflectionAI\u003cnpc_tortured_riflemanAI\u003e(creature);\n        }\n};\n\nenum FrostswornGeneral\n{\n    // General\n    EVENT_SHIELD                 = 1,\n    EVENT_SPIKE                  = 2,\n    EVENT_CLONE                  = 3,\n\n    SAY_AGGRO                    = 0,\n    SAY_DEATH                    = 1,\n\n    SPELL_SHIELD_THROWN          = 69222,\n    SPELL_SPIKE                  = 69184,\n    SPELL_CLONE                  = 69828,\n    SPELL_GHOST_VISUAL           = 69861,\n\n    // Reflection\n    EVENT_BALEFUL_STRIKE         = 1,\n\n    SPELL_BALEFUL_STRIKE         = 69933,\n    SPELL_SPIRIT_BURST           = 69900\n};\n\nclass npc_frostsworn_general : public CreatureScript\n{\n    public:\n        npc_frostsworn_general() : CreatureScript(\"npc_frostsworn_general\") { }\n\n        struct npc_frostsworn_generalAI : public ScriptedAI\n        {\n            npc_frostsworn_generalAI(Creature* creature) : ScriptedAI(creature)\n            {\n                _instance = creature-\u003eGetInstanceScript();\n            }\n\n            void Reset() override\n            {\n                _events.Reset();\n                _instance-\u003eSetData(DATA_FROSTSWORN_GENERAL, NOT_STARTED);\n            }\n\n            void JustDied(Unit* /*killer*/) override\n            {\n                Talk(SAY_DEATH);\n                _events.Reset();\n                _instance-\u003eSetData(DATA_FROSTSWORN_GENERAL, DONE);\n            }\n\n            void JustEngagedWith(Unit* /*victim*/) override\n            {\n                Talk(SAY_AGGRO);\n                DoZoneInCombat();\n                _events.ScheduleEvent(EVENT_SHIELD, 5s);\n                _events.ScheduleEvent(EVENT_SPIKE, 14s);\n                _events.ScheduleEvent(EVENT_CLONE, 22s);\n                _instance-\u003eSetData(DATA_FROSTSWORN_GENERAL, IN_PROGRESS);\n            }\n\n            void UpdateAI(uint32 diff) override\n            {\n                if (!UpdateVictim())\n                    return;\n\n                _events.Update(diff);\n\n                if (me-\u003eHasUnitState(UNIT_STATE_CASTING))\n                    return;\n\n                while (uint32 event = _events.ExecuteEvent())\n                {\n                    switch (event)\n                    {\n                        case EVENT_SHIELD:\n                            if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 0, 45.0f, true))\n                                DoCast(target, SPELL_SHIELD_THROWN);\n                            _events.ScheduleEvent(EVENT_SHIELD, 8s, 12s);\n                            break;\n                        case EVENT_SPIKE:\n                            if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 0, 45.0f, true))\n                                DoCast(target, SPELL_SPIKE);\n                            _events.ScheduleEvent(EVENT_SPIKE, 15s, 20s);\n                            break;\n                        case EVENT_CLONE:\n                            SummonClones();\n                            _events.ScheduleEvent(EVENT_CLONE, 1min);\n                            break;\n                        default:\n                            break;\n                    }\n                }\n                DoMeleeAttackIfReady();\n            }\n\n            void SummonClones()\n            {\n                std::list\u003cUnit*\u003e playerList;\n                SelectTargetList(playerList, 5, SELECT_TARGET_MAXTHREAT, 0, 0.0f, true);\n                for (Unit* target : playerList)\n                {\n                    if (Creature* reflection = me-\u003eSummonCreature(NPC_REFLECTION, *target, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 3000))\n                    {\n                        reflection-\u003eSetImmuneToPC(false);\n                        target-\u003eCastSpell(reflection, SPELL_CLONE, true);\n                        target-\u003eCastSpell(reflection, SPELL_GHOST_VISUAL, true);\n                        reflection-\u003eAI()-\u003eAttackStart(target);\n                    }\n                }\n            }\n\n        private:\n            InstanceScript* _instance;\n            EventMap _events;\n        };\n\n        CreatureAI* GetAI(Creature* creature) const override\n        {\n            return GetHallsOfReflectionAI\u003cnpc_frostsworn_generalAI\u003e(creature);\n        }\n};\n\nclass npc_spiritual_reflection : public CreatureScript\n{\n    public:\n        npc_spiritual_reflection() : CreatureScript(\"npc_spiritual_reflection\") { }\n\n        struct npc_spiritual_reflectionAI : public ScriptedAI\n        {\n            npc_spiritual_reflectionAI(Creature *creature) : ScriptedAI(creature) { }\n\n            void Reset() override\n            {\n                _events.Reset();\n            }\n\n            void JustEngagedWith(Unit* /*victim*/) override\n            {\n                _events.ScheduleEvent(EVENT_BALEFUL_STRIKE, 3s);\n            }\n\n            void JustDied(Unit* /*killer*/) override\n            {\n                DoCastAOE(SPELL_SPIRIT_BURST);\n            }\n\n            void UpdateAI(uint32 diff) override\n            {\n                if (!UpdateVictim())\n                    return;\n\n                _events.Update(diff);\n\n                if (me-\u003eHasUnitState(UNIT_STATE_CASTING))\n                    return;\n\n                switch (_events.ExecuteEvent())\n                {\n                    case EVENT_BALEFUL_STRIKE:\n                        if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 0, 8.0f, true))\n                            DoCast(target, SPELL_BALEFUL_STRIKE);\n                        _events.ScheduleEvent(EVENT_BALEFUL_STRIKE, 3s, 8s);\n                        break;\n                    default:\n                        break;\n                }\n\n                DoMeleeAttackIfReady();\n            }\n\n        private:\n            EventMap _events;\n        };\n\n        CreatureAI* GetAI(Creature* creature) const override\n        {\n            return GetHallsOfReflectionAI\u003cnpc_spiritual_reflectionAI\u003e(creature);\n        }\n};\n\n// 5689\nclass at_hor_intro_start : public AreaTriggerScript\n{\n    public:\n        at_hor_intro_start() : AreaTriggerScript(\"at_hor_intro_start\") { }\n\n        bool OnTrigger(Player* player, AreaTriggerEntry const* /*trigger*/) override\n        {\n            if (player-\u003eIsGameMaster())\n                return true;\n\n            InstanceScript* _instance = player-\u003eGetInstanceScript();\n\n            if (_instance-\u003eGetData(DATA_INTRO_EVENT) == NOT_STARTED)\n                _instance-\u003eSetData(DATA_INTRO_EVENT, IN_PROGRESS);\n\n            if (player-\u003eHasAura(SPELL_QUEL_DELAR_COMPULSION) \u0026\u0026 (player-\u003eGetQuestStatus(QUEST_HALLS_OF_REFLECTION_ALLIANCE) == QUEST_STATUS_INCOMPLETE ||\n                player-\u003eGetQuestStatus(QUEST_HALLS_OF_REFLECTION_HORDE) == QUEST_STATUS_INCOMPLETE) \u0026\u0026 _instance-\u003eGetData(DATA_QUEL_DELAR_EVENT) == NOT_STARTED)\n            {\n                _instance-\u003eSetData(DATA_QUEL_DELAR_EVENT, IN_PROGRESS);\n                _instance-\u003eSetGuidData(DATA_QUEL_DELAR_INVOKER, player-\u003eGetGUID());\n            }\n\n            return true;\n        }\n};\n\nclass at_hor_waves_restarter : public AreaTriggerScript\n{\n    public:\n        at_hor_waves_restarter() : AreaTriggerScript(\"at_hor_waves_restarter\") { }\n\n        bool OnTrigger(Player* player, AreaTriggerEntry const* /*trigger*/) override\n        {\n            if (player-\u003eIsGameMaster())\n                return true;\n\n            InstanceScript* _instance = player-\u003eGetInstanceScript();\n\n            if (_instance-\u003eGetData(DATA_WAVE_COUNT))\n                return true;\n\n            if (_instance-\u003eGetData(DATA_INTRO_EVENT) == DONE \u0026\u0026 _instance-\u003eGetBossState(DATA_MARWYN) != DONE)\n            {\n                _instance-\u003eProcessEvent(0, EVENT_SPAWN_WAVES);\n\n                if (Creature* falric = ObjectAccessor::GetCreature(*player, _instance-\u003eGetGuidData(DATA_FALRIC)))\n                {\n                    falric-\u003eCastSpell(falric, SPELL_BOSS_SPAWN_AURA, true);\n                    falric-\u003eSetVisible(true);\n                }\n                if (Creature* marwyn = ObjectAccessor::GetCreature(*player, _instance-\u003eGetGuidData(DATA_MARWYN)))\n                {\n                    marwyn-\u003eCastSpell(marwyn, SPELL_BOSS_SPAWN_AURA, true);\n                    marwyn-\u003eSetVisible(true);\n                }\n            }\n            return true;\n        }\n};\n\n// 5740\nclass at_hor_impenetrable_door : public AreaTriggerScript\n{\n    public:\n        at_hor_impenetrable_door() : AreaTriggerScript(\"at_hor_impenetrable_door\") { }\n\n        bool OnTrigger(Player* player, AreaTriggerEntry const* /*at*/) override\n        {\n            if (player-\u003eIsGameMaster())\n                return true;\n\n            InstanceScript* _instance = player-\u003eGetInstanceScript();\n            if (_instance-\u003eGetBossState(DATA_MARWYN) == DONE)\n                return true;\n\n            /// return false to handle teleport by db\n            return false;\n        }\n};\n\n// 5605\nclass at_hor_shadow_throne : public AreaTriggerScript\n{\n    public:\n        at_hor_shadow_throne() : AreaTriggerScript(\"at_hor_shadow_throne\") { }\n\n        bool OnTrigger(Player* player, AreaTriggerEntry const* /*at*/) override\n        {\n            if (player-\u003eIsGameMaster())\n                return true;\n\n            InstanceScript* _instance = player-\u003eGetInstanceScript();\n\n            if (_instance-\u003eGetBossState(DATA_THE_LICH_KING_ESCAPE) == NOT_STARTED)\n                _instance-\u003eSetBossState(DATA_THE_LICH_KING_ESCAPE, IN_PROGRESS);\n\n            return true;\n        }\n};\n\nenum EscapeEvents\n{\n    // Raging Ghoul\n    EVENT_RAGING_GHOUL_JUMP = 1,\n\n    // Risen Witch Doctor\n    EVENT_RISEN_WITCH_DOCTOR_CURSE,\n    EVENT_RISEN_WITCH_DOCTOR_SHADOW_BOLT,\n    EVENT_RISEN_WITCH_DOCTOR_SHADOW_BOLT_VOLLEY,\n\n    // Lumbering Abomination\n    EVENT_LUMBERING_ABOMINATION_VOMIT_SPRAY,\n    EVENT_LUMBERING_ABOMINATION_CLEAVE\n};\n\nclass HoRStartMovementEvent : public BasicEvent\n{\n    public:\n        explicit HoRStartMovementEvent(Creature* owner) : _owner(owner) { }\n\n        bool Execute(uint64 /*execTime*/, uint32 /*diff*/) override\n        {\n            _owner-\u003eSetReactState(REACT_AGGRESSIVE);\n            if (Unit* target = _owner-\u003eAI()-\u003eSelectTarget(SELECT_TARGET_RANDOM, 0, 0.0f, true))\n                _owner-\u003eAI()-\u003eAttackStart(target);\n            return true;\n        }\n\n    private:\n        Creature* _owner;\n};\n\nstruct npc_escape_event_trash : public ScriptedAI\n{\n    npc_escape_event_trash(Creature* creature) : ScriptedAI(creature), _instance(creature-\u003eGetInstanceScript()) { }\n\n    void Reset() override\n    {\n        _events.Reset();\n    }\n\n    void UpdateAI(uint32 /*diff*/) override\n    {\n        if (_instance-\u003eGetBossState(DATA_THE_LICH_KING_ESCAPE) == FAIL || _instance-\u003eGetBossState(DATA_THE_LICH_KING_ESCAPE) == NOT_STARTED)\n            me-\u003eDespawnOrUnsummon();\n    }\n\n    void IsSummonedBy(WorldObject* /*summoner*/) override\n    {\n        DoZoneInCombat(me);\n        if (Creature* leader = ObjectAccessor::GetCreature(*me, _instance-\u003eGetGuidData(DATA_ESCAPE_LEADER)))\n        {\n            me-\u003eSetImmuneToPC(false);\n            me-\u003eSetInCombatWith(leader);\n            leader-\u003eSetInCombatWith(me);\n            AddThreat(leader, 0.0f);\n        }\n    }\n\nprotected:\n    EventMap _events;\n    InstanceScript* _instance;\n};\n\nclass npc_raging_ghoul : public CreatureScript\n{\n    public:\n        npc_raging_ghoul() : CreatureScript(\"npc_raging_ghoul\") { }\n\n        struct npc_raging_ghoulAI : public npc_escape_event_trash\n        {\n            npc_raging_ghoulAI(Creature* creature) : npc_escape_event_trash(creature) { }\n\n            void Reset() override\n            {\n                npc_escape_event_trash::Reset();\n                _events.ScheduleEvent(EVENT_RAGING_GHOUL_JUMP, 5s);\n            }\n\n            void IsSummonedBy(WorldObject* summoner) override\n            {\n                me-\u003eCastSpell(me, SPELL_RAGING_GHOUL_SPAWN, true);\n                me-\u003eSetReactState(REACT_PASSIVE);\n                me-\u003eHandleEmoteCommand(EMOTE_ONESHOT_EMERGE);\n                me-\u003em_Events.AddEvent(new HoRStartMovementEvent(me), me-\u003em_Events.CalculateTime(5000));\n\n                npc_escape_event_trash::IsSummonedBy(summoner);\n            }\n\n            void UpdateAI(uint32 diff) override\n            {\n                npc_escape_event_trash::UpdateAI(diff);\n\n                if (!UpdateVictim())\n                    return;\n\n                _events.Update(diff);\n\n                if (me-\u003eHasUnitState(UNIT_STATE_CASTING))\n                    return;\n\n                switch (_events.ExecuteEvent())\n                {\n                    case EVENT_RAGING_GHOUL_JUMP:\n                        if (Unit* victim = me-\u003eGetVictim())\n                        {\n                            if (me-\u003eIsInRange(victim, 5.0f, 30.0f))\n                            {\n                                DoCast(victim, SPELL_GHOUL_JUMP);\n                                return;\n                            }\n                        }\n                        _events.ScheduleEvent(EVENT_RAGING_GHOUL_JUMP, 500ms);\n                        break;\n                    default:\n                        break;\n                }\n\n                DoMeleeAttackIfReady();\n            }\n        };\n\n        CreatureAI* GetAI(Creature* creature) const override\n        {\n            return GetHallsOfReflectionAI\u003cnpc_raging_ghoulAI\u003e(creature);\n        }\n};\n\nclass npc_risen_witch_doctor : public CreatureScript\n{\n    public:\n        npc_risen_witch_doctor() : CreatureScript(\"npc_risen_witch_doctor\") { }\n\n        struct npc_risen_witch_doctorAI : public npc_escape_event_trash\n        {\n            npc_risen_witch_doctorAI(Creature* creature) : npc_escape_event_trash(creature) { }\n\n            void Reset() override\n            {\n                npc_escape_event_trash::Reset();\n                _events.ScheduleEvent(EVENT_RISEN_WITCH_DOCTOR_SHADOW_BOLT, 6s);\n                _events.ScheduleEvent(EVENT_RISEN_WITCH_DOCTOR_SHADOW_BOLT_VOLLEY, 15s);\n                _events.ScheduleEvent(EVENT_RISEN_WITCH_DOCTOR_CURSE, 7s);\n            }\n\n            void IsSummonedBy(WorldObject* summoner) override\n            {\n                me-\u003eCastSpell(me, SPELL_RISEN_WITCH_DOCTOR_SPAWN, true);\n                me-\u003eSetReactState(REACT_PASSIVE);\n                me-\u003eHandleEmoteCommand(EMOTE_ONESHOT_EMERGE);\n                me-\u003em_Events.AddEvent(new HoRStartMovementEvent(me), me-\u003em_Events.CalculateTime(5000));\n\n                npc_escape_event_trash::IsSummonedBy(summoner);\n            }\n\n            void UpdateAI(uint32 diff) override\n            {\n                npc_escape_event_trash::UpdateAI(diff);\n\n                if (!UpdateVictim())\n                    return;\n\n                _events.Update(diff);\n\n                if (me-\u003eHasUnitState(UNIT_STATE_CASTING))\n                    return;\n\n                switch (_events.ExecuteEvent())\n                {\n                    case EVENT_RISEN_WITCH_DOCTOR_CURSE:\n                        if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 0, 30.0f, true))\n                            DoCast(target, SPELL_CURSE_OF_DOOM);\n                        _events.ScheduleEvent(EVENT_RISEN_WITCH_DOCTOR_CURSE, 10s, 15s);\n                        break;\n                    case EVENT_RISEN_WITCH_DOCTOR_SHADOW_BOLT:\n                        if (Unit* target = SelectTarget(SELECT_TARGET_MAXTHREAT, 0, 20.0f, true))\n                            DoCast(target, SPELL_SHADOW_BOLT);\n                        _events.ScheduleEvent(EVENT_RISEN_WITCH_DOCTOR_SHADOW_BOLT, 2s, 3s);\n                        break;\n                    case EVENT_RISEN_WITCH_DOCTOR_SHADOW_BOLT_VOLLEY:\n                        if (SelectTarget(SELECT_TARGET_RANDOM, 0, 30.0f, true))\n                            DoCastAOE(SPELL_SHADOW_BOLT_VOLLEY);\n                        _events.ScheduleEvent(EVENT_RISEN_WITCH_DOCTOR_SHADOW_BOLT_VOLLEY, 15s, 22s);\n                        break;\n                    default:\n                        break;\n                }\n\n                DoMeleeAttackIfReady();\n            }\n        };\n\n        CreatureAI* GetAI(Creature* creature) const override\n        {\n            return GetHallsOfReflectionAI\u003cnpc_risen_witch_doctorAI\u003e(creature);\n        }\n};\n\nclass npc_lumbering_abomination : public CreatureScript\n{\n    public:\n        npc_lumbering_abomination() : CreatureScript(\"npc_lumbering_abomination\") { }\n\n        struct npc_lumbering_abominationAI : public npc_escape_event_trash\n        {\n            npc_lumbering_abominationAI(Creature* creature) : npc_escape_event_trash(creature) { }\n\n            void Reset() override\n            {\n                npc_escape_event_trash::Reset();\n                _events.ScheduleEvent(EVENT_LUMBERING_ABOMINATION_VOMIT_SPRAY, 15s);\n                _events.ScheduleEvent(EVENT_LUMBERING_ABOMINATION_CLEAVE, 6s);\n            }\n\n            void UpdateAI(uint32 diff) override\n            {\n                npc_escape_event_trash::UpdateAI(diff);\n\n                if (!UpdateVictim())\n                    return;\n\n                _events.Update(diff);\n\n                if (me-\u003eHasUnitState(UNIT_STATE_CASTING))\n                    return;\n\n                switch (_events.ExecuteEvent())\n                {\n                    case EVENT_LUMBERING_ABOMINATION_VOMIT_SPRAY:\n                        DoCastVictim(SPELL_VOMIT_SPRAY);\n                        _events.ScheduleEvent(EVENT_LUMBERING_ABOMINATION_VOMIT_SPRAY, 15s, 20s);\n                        break;\n                    case EVENT_LUMBERING_ABOMINATION_CLEAVE:\n                        DoCastVictim(SPELL_CLEAVE);\n                        _events.ScheduleEvent(EVENT_LUMBERING_ABOMINATION_CLEAVE, 7s, 9s);\n                        break;\n                    default:\n                        break;\n                }\n\n                DoMeleeAttackIfReady();\n            }\n        };\n\n        CreatureAI* GetAI(Creature* creature) const override\n        {\n            return GetHallsOfReflectionAI\u003cnpc_lumbering_abominationAI\u003e(creature);\n        }\n};\n\nenum QuelDelarUther\n{\n    ACTION_UTHER_START_SCREAM      = 1,\n    ACTION_UTHER_OUTRO             = 2,\n\n    EVENT_UTHER_1                  = 1,\n    EVENT_UTHER_2                  = 2,\n    EVENT_UTHER_3                  = 3,\n    EVENT_UTHER_4                  = 4,\n    EVENT_UTHER_5                  = 5,\n    EVENT_UTHER_6                  = 6,\n    EVENT_UTHER_7                  = 7,\n    EVENT_UTHER_8                  = 8,\n    EVENT_UTHER_9                  = 9,\n    EVENT_UTHER_10                 = 10,\n    EVENT_UTHER_11                 = 11,\n    EVENT_UTHER_FACING             = 12,\n    EVENT_UTHER_KNEEL              = 13,\n\n    SAY_UTHER_QUEL_DELAR_1         = 16,\n    SAY_UTHER_QUEL_DELAR_2         = 17,\n    SAY_UTHER_QUEL_DELAR_3         = 18,\n    SAY_UTHER_QUEL_DELAR_4         = 19,\n    SAY_UTHER_QUEL_DELAR_5         = 20,\n    SAY_UTHER_QUEL_DELAR_6         = 21,\n\n    SPELL_ESSENCE_OF_CAPTURED_1    = 73036\n};\n\nenum QuelDelarSword\n{\n    SPELL_WHIRLWIND_VISUAL         = 70300,\n    SPELL_HEROIC_STRIKE            = 29426,\n    SPELL_WHIRLWIND                = 67716,\n    SPELL_BLADESTORM               = 67541,\n\n    NPC_QUEL_DELAR                 = 37158,\n    POINT_TAKE_OFF                 = 1,\n\n    EVENT_QUEL_DELAR_INIT          = 1,\n    EVENT_QUEL_DELAR_FLIGHT_INIT   = 2,\n    EVENT_QUEL_DELAR_FLIGHT        = 3,\n    EVENT_QUEL_DELAR_LAND          = 4,\n    EVENT_QUEL_DELAR_FIGHT         = 5,\n    EVENT_QUEL_DELAR_BLADESTORM    = 6,\n    EVENT_QUEL_DELAR_HEROIC_STRIKE = 7,\n    EVENT_QUEL_DELAR_WHIRLWIND     = 8,\n\n    SAY_QUEL_DELAR_SWORD           = 0\n};\n\nenum QuelDelarMisc\n{\n    SAY_FROSTMOURNE_BUNNY          = 0,\n    SPELL_QUEL_DELAR_WILL          = 70698\n};\n\nPosition const QuelDelarCenterPos = { 5309.259f, 2006.390f, 718.046f, 0.0f };\nPosition const QuelDelarSummonPos = { 5298.473f, 1994.852f, 709.424f, 3.979351f };\nPosition const QuelDelarMovement[] =\n{\n    { 5292.870f, 1998.950f, 718.046f, 0.0f },\n    { 5295.819f, 1991.912f, 707.707f, 0.0f },\n    { 5295.301f, 1989.782f, 708.696f, 0.0f }\n};\n\nPosition const UtherQuelDelarMovement[] =\n{\n    { 5336.830f, 1981.700f, 709.319f, 0.0f },\n    { 5314.350f, 1993.440f, 707.726f, 0.0f }\n};\n\nclass npc_uther_quel_delar : public CreatureScript\n{\n    public:\n        npc_uther_quel_delar() : CreatureScript(\"npc_uther_quel_delar\") { }\n\n        struct npc_uther_quel_delarAI : public ScriptedAI\n        {\n            npc_uther_quel_delarAI(Creature* creature) : ScriptedAI(creature)\n            {\n                _instance = me-\u003eGetInstanceScript();\n            }\n\n            void Reset() override\n            {\n                // Prevent to break Uther in intro event during instance encounter\n                if (_instance-\u003eGetData(DATA_QUEL_DELAR_EVENT) != IN_PROGRESS \u0026\u0026 _instance-\u003eGetData(DATA_QUEL_DELAR_EVENT) != SPECIAL)\n                    return;\n\n                _events.Reset();\n                _events.ScheduleEvent(EVENT_UTHER_1, 1);\n            }\n\n            void DamageTaken(Unit* /*attacker*/, uint32\u0026 damage) override\n            {\n                if (damage \u003e= me-\u003eGetHealth())\n                    damage = me-\u003eGetHealth() - 1;\n            }\n\n            void DoAction(int32 action) override\n            {\n                switch (action)\n                {\n                    case ACTION_UTHER_START_SCREAM:\n                        _instance-\u003eSetData(DATA_QUEL_DELAR_EVENT, SPECIAL);\n                        _events.ScheduleEvent(EVENT_UTHER_2, 0);\n                        break;\n                    case ACTION_UTHER_OUTRO:\n                        _events.ScheduleEvent(EVENT_UTHER_6, 0);\n                        break;\n                    default:\n                        break;\n                }\n            }\n\n            void MovementInform(uint32 /*type*/, uint32 pointId) override\n            {\n                switch (pointId)\n                {\n                    case 1:\n                        _events.ScheduleEvent(EVENT_UTHER_FACING, 1s);\n                        break;\n                    default:\n                        break;\n                }\n            }\n\n            void UpdateAI(uint32 diff) override\n            {\n                // Prevent to break Uther in intro event during instance encounter\n                if (_instance-\u003eGetData(DATA_QUEL_DELAR_EVENT) != IN_PROGRESS \u0026\u0026 _instance-\u003eGetData(DATA_QUEL_DELAR_EVENT) != SPECIAL)\n                    return;\n\n                _events.Update(diff);\n\n                while (uint32 eventId = _events.ExecuteEvent())\n                {\n                    switch (eventId)\n                    {\n                        case EVENT_UTHER_1:\n                            Talk(SAY_UTHER_QUEL_DELAR_1);\n                            break;\n                        case EVENT_UTHER_2:\n                            if (Creature* bunny = ObjectAccessor::GetCreature(*me, _instance-\u003eGetGuidData(DATA_FROSTMOURNE_ALTAR_BUNNY)))\n                                if (Unit* target = ObjectAccessor::GetPlayer(*me, _instance-\u003eGetGuidData(DATA_QUEL_DELAR_INVOKER)))\n                                    bunny-\u003eCastSpell(target, SPELL_QUEL_DELAR_WILL, true);\n                            _events.ScheduleEvent(EVENT_UTHER_3, 2000);\n                            break;\n                        case EVENT_UTHER_3:\n                            me-\u003eSummonCreature(NPC_QUEL_DELAR, QuelDelarSummonPos);\n                            _events.ScheduleEvent(EVENT_UTHER_4, 2000);\n                            break;\n                        case EVENT_UTHER_4:\n                            Talk(SAY_UTHER_QUEL_DELAR_2);\n                            _events.ScheduleEvent(EVENT_UTHER_5, 8000);\n                            break;\n                        case EVENT_UTHER_5:\n                            me-\u003eGetMotionMaster()-\u003eMovePoint(1, UtherQuelDelarMovement[0]);\n                            break;\n                        case EVENT_UTHER_6:\n                            me-\u003eSetWalk(true);\n                            me-\u003eGetMotionMaster()-\u003eMovePoint(0, UtherQuelDelarMovement[1]);\n                            _events.ScheduleEvent(EVENT_UTHER_7, 5000);\n                            break;\n                        case EVENT_UTHER_7:\n                            Talk(SAY_UTHER_QUEL_DELAR_3);\n                            _events.ScheduleEvent(EVENT_UTHER_8, 12000);\n                            break;\n                        case EVENT_UTHER_8:\n                            Talk(SAY_UTHER_QUEL_DELAR_4);\n                            _events.ScheduleEvent(EVENT_UTHER_9, 7000);\n                            break;\n                        case EVENT_UTHER_9:\n                            Talk(SAY_UTHER_QUEL_DELAR_5);\n                            _events.ScheduleEvent(EVENT_UTHER_10, 10000);\n                            break;\n                        case EVENT_UTHER_10:\n                            Talk(SAY_UTHER_QUEL_DELAR_6);\n                            _events.ScheduleEvent(EVENT_UTHER_11, 5000);\n                            break;\n                        case EVENT_UTHER_11:\n                            DoCast(me, SPELL_ESSENCE_OF_CAPTURED_1, true);\n                            me-\u003eDespawnOrUnsummon(3000);\n                            _instance-\u003eSetData(DATA_QUEL_DELAR_EVENT, DONE);\n                            break;\n                        case EVENT_UTHER_FACING:\n                            if (Creature* bunny = ObjectAccessor::GetCreature(*me, _instance-\u003eGetGuidData(DATA_FROSTMOURNE_ALTAR_BUNNY)))\n                                me-\u003eSetFacingToObject(bunny);\n                            _events.ScheduleEvent(EVENT_UTHER_KNEEL, 1s);\n                            break;\n                        case EVENT_UTHER_KNEEL:\n                            me-\u003eHandleEmoteCommand(EMOTE_STATE_KNEEL);\n                            break;\n                        default:\n                            break;\n                    }\n                }\n            }\n\n        private:\n            EventMap _events;\n            InstanceScript* _instance;\n        };\n\n        CreatureAI* GetAI(Creature* creature) const override\n        {\n            return GetHallsOfReflectionAI\u003cnpc_uther_quel_delarAI\u003e(creature);\n        }\n};\n\nclass npc_quel_delar_sword : public CreatureScript\n{\n    public:\n        npc_quel_delar_sword() : CreatureScript(\"npc_quel_delar_sword\") { }\n\n        struct npc_quel_delar_swordAI : public ScriptedAI\n        {\n            npc_quel_delar_swordAI(Creature* creature) : ScriptedAI(creature)\n            {\n                _instance = me-\u003eGetInstanceScript();\n                me-\u003eSetDisplayId(me-\u003eGetCreatureTemplate()-\u003eModelid2);\n                _intro = true;\n            }\n\n            void Reset() override\n            {\n                _events.Reset();\n                me-\u003eSetSpeedRate(MOVE_FLIGHT, 4.5f);\n                DoCast(SPELL_WHIRLWIND_VISUAL);\n                if (_intro)\n                    _events.ScheduleEvent(EVENT_QUEL_DELAR_INIT, 0);\n                else\n                    me-\u003eSetImmuneToAll(false);\n            }\n\n            void JustEngagedWith(Unit* /*victim*/) override\n            {\n                _events.ScheduleEvent(EVENT_QUEL_DELAR_HEROIC_STRIKE, 4s);\n                _events.ScheduleEvent(EVENT_QUEL_DELAR_BLADESTORM, 6s);\n                _events.ScheduleEvent(EVENT_QUEL_DELAR_WHIRLWIND, 6s);\n            }\n\n            void JustDied(Unit* /*killer*/) override\n            {\n                if (Creature* uther = ObjectAccessor::GetCreature(*me, _instance-\u003eGetGuidData(DATA_UTHER_QUEL_DELAR)))\n                    uther-\u003eAI()-\u003eDoAction(ACTION_UTHER_OUTRO);\n            }\n\n            void MovementInform(uint32 type, uint32 pointId) override\n            {\n                if (type != EFFECT_MOTION_TYPE)\n                    return;\n\n                switch (pointId)\n                {\n                    case POINT_TAKE_OFF:\n                        _events.ScheduleEvent(EVENT_QUEL_DELAR_FLIGHT, 0);\n                        break;\n                    default:\n                        break;\n                }\n            }\n\n            void UpdateAI(uint32 diff) override\n            {\n                _events.Update(diff);\n\n                if (me-\u003eHasUnitState(UNIT_STATE_CASTING))\n                    return;\n\n                if (!UpdateVictim())\n                {\n                    while (uint32 eventId = _events.ExecuteEvent())\n                    {\n                        switch (eventId)\n                        {\n                            case EVENT_QUEL_DELAR_INIT:\n                                if (Creature* bunny = ObjectAccessor::GetCreature(*me, _instance-\u003eGetGuidData(DATA_FROSTMOURNE_ALTAR_BUNNY)))\n                                    bunny-\u003eAI()-\u003eTalk(SAY_FROSTMOURNE_BUNNY);\n                                _intro = false;\n                                _events.ScheduleEvent(EVENT_QUEL_DELAR_FLIGHT_INIT, 2500ms);\n                                break;\n                            case EVENT_QUEL_DELAR_FLIGHT_INIT:\n                                me-\u003eGetMotionMaster()-\u003eMoveTakeoff(POINT_TAKE_OFF, QuelDelarMovement[0]);\n                                break;\n                            case EVENT_QUEL_DELAR_FLIGHT:\n                            {\n                                me-\u003eGetMotionMaster()-\u003eMoveCirclePath(QuelDelarCenterPos.GetPositionX(), QuelDelarCenterPos.GetPositionY(), 718.046f, 18.0f, true, 16);\n                                _events.ScheduleEvent(EVENT_QUEL_DELAR_LAND, 15s);\n                                break;\n                            }\n                            case EVENT_QUEL_DELAR_LAND:\n                                me-\u003eStopMoving();\n                                me-\u003eGetMotionMaster()-\u003eClear();\n                                me-\u003eGetMotionMaster()-\u003eMoveLand(0, QuelDelarMovement[1]);\n                                _events.ScheduleEvent(EVENT_QUEL_DELAR_FIGHT, 6s);\n                                break;\n                            case EVENT_QUEL_DELAR_FIGHT:\n                                Talk(SAY_QUEL_DELAR_SWORD);\n                                me-\u003eGetMotionMaster()-\u003eMovePoint(0, QuelDelarMovement[2]);\n                                me-\u003eSetImmuneToAll(false);\n                                break;\n                            default:\n                                break;\n                        }\n                    }\n                }\n                else\n                {\n                    while (uint32 eventId = _events.ExecuteEvent())\n                    {\n                        switch (eventId)\n                        {\n                            case EVENT_QUEL_DELAR_BLADESTORM:\n                                DoCast(me, SPELL_BLADESTORM);\n                                _events.ScheduleEvent(EVENT_QUEL_DELAR_BLADESTORM, 10s);\n                                break;\n                            case EVENT_QUEL_DELAR_HEROIC_STRIKE:\n                                DoCastVictim(SPELL_HEROIC_STRIKE);\n                                _events.ScheduleEvent(EVENT_QUEL_DELAR_HEROIC_STRIKE, 6s);\n                                break;\n                            case EVENT_QUEL_DELAR_WHIRLWIND:\n                                DoCastAOE(SPELL_WHIRLWIND);\n                                _events.ScheduleEvent(EVENT_QUEL_DELAR_WHIRLWIND, 1s);\n                                break;\n                            default:\n                                break;\n                        }\n                    }\n\n                    DoMeleeAttackIfReady();\n                }\n            }\n\n        private:\n            EventMap _events;\n            InstanceScript* _instance;\n            bool _intro;\n        };\n\n        CreatureAI* GetAI(Creature* creature) const override\n        {\n            return GetHallsOfReflectionAI\u003cnpc_quel_delar_swordAI\u003e(creature);\n        }\n};\n\n// 5660\nclass at_hor_uther_quel_delar_start : public AreaTriggerScript\n{\n    public:\n        at_hor_uther_quel_delar_start() : AreaTriggerScript(\"at_hor_uther_quel_delar_start\") { }\n\n        bool OnTrigger(Player* player, AreaTriggerEntry const* /*trigger*/) override\n        {\n            if (player-\u003eIsGameMaster())\n                return true;\n\n            InstanceScript* _instance = player-\u003eGetInstanceScript();\n\n            if (_instance-\u003eGetData(DATA_QUEL_DELAR_EVENT) == IN_PROGRESS)\n                if (Creature* uther = ObjectAccessor::GetCreature(*player, _instance-\u003eGetGuidData(DATA_UTHER_QUEL_DELAR)))\n                    uther-\u003eAI()-\u003eDoAction(ACTION_UTHER_START_SCREAM);\n\n            return true;\n        }\n};\n\n// 72900 - Start Halls of Reflection Quest AE\nclass spell_hor_start_halls_of_reflection_quest_ae : public SpellScriptLoader\n{\n    public:\n        spell_hor_start_halls_of_reflection_quest_ae() : SpellScriptLoader(\"spell_hor_start_halls_of_reflection_quest_ae\") { }\n\n        class spell_hor_start_halls_of_reflection_quest_ae_SpellScript : public SpellScript\n        {\n            PrepareSpellScript(spell_hor_start_halls_of_reflection_quest_ae_SpellScript);\n\n            void StartQuests(SpellEffIndex /*effIndex*/)\n            {\n                if (Player* target = GetHitPlayer())\n                {\n                    // CanTakeQuest and CanAddQuest checks done in spell effect execution\n                    if (target-\u003eGetTeam() == ALLIANCE)\n                        target-\u003eCastSpell(target, SPELL_START_HALLS_OF_REFLECTION_QUEST_A, true);\n                    else\n                        target-\u003eCastSpell(target, SPELL_START_HALLS_OF_REFLECTION_QUEST_H, true);\n                }\n            }\n\n            void Register() override\n            {\n                OnEffectHitTarget += SpellEffectFn(spell_hor_start_halls_of_reflection_quest_ae_SpellScript::StartQuests, EFFECT_0, SPELL_EFFECT_SCRIPT_EFFECT);\n            }\n        };\n\n        SpellScript* GetSpellScript() const override\n        {\n            return new spell_hor_start_halls_of_reflection_quest_ae_SpellScript();\n        }\n};\n\n// 70190 - Evasion\nclass spell_hor_evasion : public SpellScriptLoader\n{\n    public:\n        spell_hor_evasion() : SpellScriptLoader(\"spell_hor_evasion\") { }\n\n        class spell_hor_evasion_SpellScript : public SpellScript\n        {\n            PrepareSpellScript(spell_hor_evasion_SpellScript);\n\n            bool Load() override\n            {\n                return GetCaster()-\u003eGetTypeId() == TYPEID_UNIT;\n            }\n\n            void SetDest(SpellDestination\u0026 dest)\n            {\n                WorldObject* target = GetExplTargetWorldObject();\n                Position pos(*target);\n                Position home = GetCaster()-\u003eToCreature()-\u003eGetHomePosition();\n\n                // prevent evasion outside the room\n                if (pos.IsInDist2d(\u0026home, 15.0f))\n                    return;\n\n                float angle = pos.GetAbsoluteAngle(\u0026home);\n                float dist = GetSpellInfo()-\u003eEffects[EFFECT_0].CalcRadius(GetCaster());\n                target-\u003eMovePosition(pos, dist, angle);\n\n                dest.Relocate(pos);\n            }\n\n            void Register() override\n            {\n                OnDestinationTargetSelect += SpellDestinationTargetSelectFn(spell_hor_evasion_SpellScript::SetDest, EFFECT_0, TARGET_DEST_TARGET_RADIUS);\n            }\n        };\n\n        SpellScript* GetSpellScript() const override\n        {\n            return new spell_hor_evasion_SpellScript();\n        }\n};\n\n// 70017 - Gunship Cannon Fire\nclass spell_hor_gunship_cannon_fire : public SpellScriptLoader\n{\n    public:\n        spell_hor_gunship_cannon_fire() : SpellScriptLoader(\"spell_hor_gunship_cannon_fire\") { }\n\n        class spell_hor_gunship_cannon_fire_AuraScript : public AuraScript\n        {\n            PrepareAuraScript(spell_hor_gunship_cannon_fire_AuraScript);\n\n            void HandlePeriodic(AuraEffect const* /*aurEff*/)\n            {\n                if (!urand(0, 2))\n                {\n                    if (GetTarget()-\u003eGetEntry() == NPC_GUNSHIP_CANNON_HORDE)\n                        GetTarget()-\u003eCastSpell(nullptr, SPELL_GUNSHIP_CANNON_FIRE_MISSILE_HORDE, true);\n                    else\n                        GetTarget()-\u003eCastSpell(nullptr, SPELL_GUNSHIP_CANNON_FIRE_MISSILE_ALLIANCE, true);\n                }\n            }\n\n            void Register() override\n            {\n                OnEffectPeriodic += AuraEffectPeriodicFn(spell_hor_gunship_cannon_fire_AuraScript::HandlePeriodic, EFFECT_0, SPELL_AURA_PERIODIC_TRIGGER_SPELL);\n            }\n        };\n\n        AuraScript* GetAuraScript() const override\n        {\n            return new spell_hor_gunship_cannon_fire_AuraScript();\n        }\n};\n\n// 70698 - Quel'Delar's Will\nclass spell_hor_quel_delars_will : public SpellScript\n{\n    PrepareSpellScript(spell_hor_quel_delars_will);\n\n    bool Validate(SpellInfo const* spellInfo) override\n    {\n        return ValidateSpellInfo({ spellInfo-\u003eEffects[EFFECT_0].TriggerSpell });\n    }\n\n    void HandleReagent(SpellEffIndex effIndex)\n    {\n        PreventHitDefaultEffect(effIndex);\n\n        // dummy spell consumes reagent, don't ignore it\n        GetHitUnit()-\u003eCastSpell(GetCaster(), GetSpellInfo()-\u003eEffects[effIndex].TriggerSpell, TriggerCastFlags(TRIGGERED_FULL_MASK \u0026 ~TRIGGERED_IGNORE_POWER_AND_REAGENT_COST));\n    }\n\n    void Register() override\n    {\n        OnEffectHitTarget += SpellEffectFn(spell_hor_quel_delars_will::HandleReagent, EFFECT_0, SPELL_EFFECT_FORCE_CAST);\n    }\n};\n\nvoid AddSC_halls_of_reflection()\n{\n    new at_hor_intro_start();\n    new at_hor_waves_restarter();\n    new at_hor_impenetrable_door();\n    new at_hor_shadow_throne();\n    new at_hor_uther_quel_delar_start();\n    new npc_jaina_or_sylvanas_intro_hor();\n    new npc_jaina_or_sylvanas_escape_hor();\n    new npc_the_lich_king_escape_hor();\n    new npc_ghostly_priest();\n    new npc_phantom_mage();\n    new npc_phantom_hallucination();\n    new npc_shadowy_mercenary();\n    new npc_spectral_footman();\n    new npc_tortured_rifleman();\n    new npc_frostsworn_general();\n    new npc_spiritual_reflection();\n    new npc_raging_ghoul();\n    new npc_risen_witch_doctor();\n    new npc_lumbering_abomination();\n    new npc_uther_quel_delar();\n    new npc_quel_delar_sword();\n    new spell_hor_start_halls_of_reflection_quest_ae();\n    new spell_hor_evasion();\n    new spell_hor_gunship_cannon_fire();\n    RegisterSpellScript(spell_hor_quel_delars_will);\n}\n"}
{"repo_name":"esqudo/cymrucoin","ref":"refs/heads/master","path":"src/qt/aboutdialog.cpp","copies":"7","language":"C++","content":"#include \"aboutdialog.h\"\n#include \"ui_aboutdialog.h\"\n\n#include \"clientmodel.h\"\n#include \"clientversion.h\"\n\n// Copyright year (2009-this)\n// Todo: update this when changing our copyright comments in the source\nconst int ABOUTDIALOG_COPYRIGHT_YEAR = 2014;\n\nAboutDialog::AboutDialog(QWidget *parent) :\n    QDialog(parent),\n    ui(new Ui::AboutDialog)\n{\n    ui-\u003esetupUi(this);\n\n    // Set current copyright year\n    ui-\u003ecopyrightLabel-\u003esetText(tr(\"Copyright\") + QString(\" \u0026copy; 2009-%1 \").arg(COPYRIGHT_YEAR) + tr(\"The Bitcoin developers\") + QString(\"\u003cbr\u003e\") + tr(\"Copyright\") + QString(\" \u0026copy; \") + tr(\"%1 StartJOIN\").arg(ABOUTDIALOG_COPYRIGHT_YEAR));\n}\n\nvoid AboutDialog::setModel(ClientModel *model)\n{\n    if(model)\n    {\n        ui-\u003eversionLabel-\u003esetText(model-\u003eformatFullVersion());\n    }\n}\n\nAboutDialog::~AboutDialog()\n{\n    delete ui;\n}\n\nvoid AboutDialog::on_buttonBox_accepted()\n{\n    close();\n}\n"}
{"repo_name":"station7/xbmc","ref":"refs/heads/master","path":"xbmc/platform/android/jni/System.cpp","copies":"28","language":"C++","content":"/*\n *      Copyright (C) 2013 Team XBMC\n *      http://xbmc.org\n *\n *  This Program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  This Program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with XBMC; see the file COPYING.  If not, see\n *  \u003chttp://www.gnu.org/licenses/\u003e.\n *\n */\n\n#include \"System.h\"\n#include \"jutils/jutils-details.hpp\"\n\nusing namespace jni;\n\nstd::string CJNISystem::getProperty(const std::string \u0026property)\n{\n  return jcast\u003cstd::string\u003e(call_static_method\u003cjhstring\u003e(\"java/lang/System\",\n    \"getProperty\", \"(Ljava/lang/String;)Ljava/lang/String;\",\n    jcast\u003cjhstring\u003e(property)));\n}\n\nstd::string CJNISystem::getProperty(const std::string \u0026property, const std::string \u0026defaultValue)\n{\n  return jcast\u003cstd::string\u003e(call_static_method\u003cjhstring\u003e(\"java/lang/System\",\n    \"getProperty\", \"(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;\",\n    jcast\u003cjhstring\u003e(property), jcast\u003cjhstring\u003e(defaultValue)));\n}\n\nstd::string CJNISystem::setProperty(const std::string \u0026property, const std::string \u0026defaultValue)\n{\n  return jcast\u003cstd::string\u003e(call_static_method\u003cjhstring\u003e(\"java/lang/System\",\n    \"setProperty\", \"(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;\",\n    jcast\u003cjhstring\u003e(property), jcast\u003cjhstring\u003e(defaultValue)));\n}\n\nstd::string CJNISystem::clearProperty(const std::string \u0026property)\n{\n  return jcast\u003cstd::string\u003e(call_static_method\u003cjhstring\u003e(\"java/lang/System\",\n    \"clearProperty\", \"(Ljava/lang/String;)Ljava/lang/String;\",\n    jcast\u003cjhstring\u003e(property)));\n}\n\nint64_t CJNISystem::nanoTime()\n{\n  return call_static_method\u003cjlong\u003e(\"java/lang/System\",\n                           \"nanoTime\",\n                           \"()J\");\n}\n"}
{"repo_name":"celeron55/clementine","ref":"refs/heads/master","path":"3rdparty/libprojectm/Renderer/Pipeline.cpp","copies":"41","language":"C++","content":"/*\n * Pipeline.cpp\n *\n *  Created on: Jun 17, 2008\n *      Author: pete\n */\n#include \"Pipeline.hpp\"\n#include \"wipemalloc.h\"\n\nPipeline::Pipeline() : staticPerPixel(false),gx(0),gy(0),blur1n(1), blur2n(1), blur3n(1),\nblur1x(1), blur2x(1), blur3x(1),\nblur1ed(1){}\n\nvoid Pipeline::setStaticPerPixel(int gx, int gy)\n{\n\t staticPerPixel = true;\n\t this-\u003egx = gx;\n\t this-\u003egy = gy;\n\n\t\tthis-\u003ex_mesh= ( float ** ) wipemalloc ( gx * sizeof ( float * ) );\n\t\tfor ( int x = 0; x \u003c gx; x++ )\n\t\t{\n\t\t\tthis-\u003ex_mesh[x] = ( float * ) wipemalloc ( gy * sizeof ( float ) );\n\t\t}\n\t\tthis-\u003ey_mesh= ( float ** ) wipemalloc ( gx * sizeof ( float * ) );\n\t\tfor ( int x = 0; x \u003c gx; x++ )\n\t\t{\n\t\t\tthis-\u003ey_mesh[x] = ( float * ) wipemalloc ( gy * sizeof ( float ) );\n\t\t}\n\n}\n\nPipeline::~Pipeline()\n{\nif (staticPerPixel)\n{\n\tfor ( int x = 0; x \u003c this-\u003egx; x++ )\n\t{\n\t\tfree(this-\u003ex_mesh[x]);\n\t\tfree(this-\u003ey_mesh[x]);\n\t}\n\tfree(x_mesh);\n\tfree(y_mesh);\n}\n}\n\n//void Pipeline::Render(const BeatDetect \u0026music, const PipelineContext \u0026context){}\nPixelPoint Pipeline::PerPixel(PixelPoint p, const PerPixelContext context)\n{return p;}\n"}
{"repo_name":"phamelin/ardupilot","ref":"refs/heads/master","path":"libraries/AP_Frsky_Telem/AP_Frsky_Telem.cpp","copies":"5","language":"C++","content":"/*\n\n   Inspired by work done here https://github.com/PX4/Firmware/tree/master/src/drivers/frsky_telemetry from Stefan Rado \u003cpx4@sradonia.net\u003e\n\n   This program is free software: you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation, either version 3 of the License, or\n   (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program.  If not, see \u003chttp://www.gnu.org/licenses/\u003e.\n*/\n\n/* \n   FRSKY Telemetry library\n*/\n\n#include \"AP_Frsky_Telem.h\"\n\n#include \u003cAP_InertialSensor/AP_InertialSensor.h\u003e\n#include \u003cGCS_MAVLink/GCS.h\u003e\n\n#include \u003cstdio.h\u003e\n\nextern const AP_HAL::HAL\u0026 hal;\n\nObjectArray\u003cmavlink_statustext_t\u003e AP_Frsky_Telem::_statustext_queue(FRSKY_TELEM_PAYLOAD_STATUS_CAPACITY);\n\n//constructor\nAP_Frsky_Telem::AP_Frsky_Telem(AP_AHRS \u0026ahrs, const AP_BattMonitor \u0026battery, const RangeFinder \u0026rng) :\n    _ahrs(ahrs),\n    _battery(battery),\n    _rng(rng)\n    {}\n\n/*\n * init - perform required initialisation\n */\nvoid AP_Frsky_Telem::init(const AP_SerialManager \u0026serial_manager,\n                          const uint8_t mav_type,\n                          const uint32_t *ap_valuep)\n{\n    // check for protocol configured for a serial port - only the first serial port with one of these protocols will then run (cannot have FrSky on multiple serial ports)\n    if ((_port = serial_manager.find_serial(AP_SerialManager::SerialProtocol_FrSky_D, 0))) {\n        _protocol = AP_SerialManager::SerialProtocol_FrSky_D; // FrSky D protocol (D-receivers)\n    } else if ((_port = serial_manager.find_serial(AP_SerialManager::SerialProtocol_FrSky_SPort, 0))) {\n        _protocol = AP_SerialManager::SerialProtocol_FrSky_SPort; // FrSky SPort protocol (X-receivers)\n    } else if ((_port = serial_manager.find_serial(AP_SerialManager::SerialProtocol_FrSky_SPort_Passthrough, 0))) {\n        _protocol = AP_SerialManager::SerialProtocol_FrSky_SPort_Passthrough; // FrSky SPort and SPort Passthrough (OpenTX) protocols (X-receivers)\n        // make frsky_telemetry available to GCS_MAVLINK (used to queue statustext messages from GCS_MAVLINK)\n        gcs().register_frsky_telemetry_callback(this);\n        // add firmware and frame info to message queue\n        if (_frame_string == nullptr) {\n            queue_message(MAV_SEVERITY_INFO, AP::fwversion().fw_string);\n        } else {\n            char firmware_buf[MAVLINK_MSG_STATUSTEXT_FIELD_TEXT_LEN+1];\n            snprintf(firmware_buf, sizeof(firmware_buf), \"%s %s\", AP::fwversion().fw_string, _frame_string);\n            queue_message(MAV_SEVERITY_INFO, firmware_buf);\n        }\n        // save main parameters locally\n        _params.mav_type = mav_type; // frame type (see MAV_TYPE in Mavlink definition file common.h)\n        if (ap_valuep == nullptr) { // ap bit-field\n            _ap.value = 0x2000; // set \"initialised\" to 1 for rover and plane\n            _ap.valuep = \u0026_ap.value;\n        } else {\n            _ap.valuep = ap_valuep;\n        }\n    }\n    \n    if (_port != nullptr) {\n        hal.scheduler-\u003eregister_io_process(FUNCTOR_BIND_MEMBER(\u0026AP_Frsky_Telem::tick, void));\n        // we don't want flow control for either protocol\n        _port-\u003eset_flow_control(AP_HAL::UARTDriver::FLOW_CONTROL_DISABLE);\n    }\n}\n\n\n/*\n * send telemetry data\n * for FrSky SPort Passthrough (OpenTX) protocol (X-receivers)\n */\nvoid AP_Frsky_Telem::send_SPort_Passthrough(void)\n{\n    int16_t numc;\n    numc = _port-\u003eavailable();\n\n    // check if available is negative\n    if (numc \u003c 0) {\n        return;\n    }\n\n    // this is the constant for hub data frame\n    if (_port-\u003etxspace() \u003c 19) {\n        return;\n    }\n\n    // keep only the last two bytes of the data found in the serial buffer, as we shouldn't respond to old poll requests\n    uint8_t prev_byte = 0;\n    for (int16_t i = 0; i \u003c numc; i++) {\n        prev_byte = _passthrough.new_byte;\n        _passthrough.new_byte = _port-\u003eread();\n    }\n\n    if ((prev_byte == START_STOP_SPORT) \u0026\u0026 (_passthrough.new_byte == SENSOR_ID_28)) { // byte 0x7E is the header of each poll request\n        if (_passthrough.send_attiandrng) { // skip other data, send attitude (roll, pitch) and range only this iteration\n            _passthrough.send_attiandrng = false; // next iteration, check if we should send something other\n        } else { // send other sensor data if it's time for them, and reset the corresponding timer if sent\n            _passthrough.send_attiandrng = true; // next iteration, send attitude b/c it needs frequent updates to remain smooth\n            uint32_t now = AP_HAL::millis();\n            if ((now - _passthrough.params_timer) \u003e= 1000) {\n                send_uint32(DIY_FIRST_ID+7, calc_param());\n                _passthrough.params_timer = AP_HAL::millis();\n                return;\n            }\n            // build message queue for sensor_status_flags\n            check_sensor_status_flags();\n            // build message queue for ekf_status\n            check_ekf_status();\n            // if there's any message in the queue, start sending them chunk by chunk; three times each chunk\n            if (get_next_msg_chunk()) {\n                send_uint32(DIY_FIRST_ID, _msg_chunk.chunk);\n                return;\n            }\n            if ((now - _passthrough.ap_status_timer) \u003e= 500) {\n                if (((*_ap.valuep) \u0026 AP_INITIALIZED_FLAG) \u003e 0) {  // send ap status only once vehicle has been initialised\n                    send_uint32(DIY_FIRST_ID+1, calc_ap_status());\n                    _passthrough.ap_status_timer = AP_HAL::millis();\n                }\n                return;\n            }\n            if ((now - _passthrough.batt_timer) \u003e= 1000) {\n                send_uint32(DIY_FIRST_ID+3, calc_batt(0));\n                _passthrough.batt_timer = AP_HAL::millis();\n                return;\n            }\n            if (_battery.num_instances() \u003e 1) {\n                if ((now - _passthrough.batt_timer2) \u003e= 1000) {\n                    send_uint32(DIY_FIRST_ID+8, calc_batt(1));\n                    _passthrough.batt_timer2 = AP_HAL::millis();\n                    return;\n                }\n            }\n            if ((now - _passthrough.gps_status_timer) \u003e= 1000) {\n                send_uint32(DIY_FIRST_ID+2, calc_gps_status());\n                _passthrough.gps_status_timer = AP_HAL::millis();\n                return;\n            }\n            if ((now - _passthrough.home_timer) \u003e= 500) {\n                send_uint32(DIY_FIRST_ID+4, calc_home());\n                _passthrough.home_timer = AP_HAL::millis();\n                return;\n            }\n            if ((now - _passthrough.velandyaw_timer) \u003e= 500) {\n                send_uint32(DIY_FIRST_ID+5, calc_velandyaw());\n                _passthrough.velandyaw_timer = AP_HAL::millis();\n                return;\n            }\n            if ((now - _passthrough.gps_latlng_timer) \u003e= 1000) {\n                send_uint32(GPS_LONG_LATI_FIRST_ID, calc_gps_latlng(\u0026_passthrough.send_latitude)); // gps latitude or longitude\n                if (!_passthrough.send_latitude) { // we've cycled and sent one each of longitude then latitude, so reset the timer\n                    _passthrough.gps_latlng_timer = AP_HAL::millis();\n                }\n                return;\n            }\n        }\n        // if nothing else needed to be sent, send attitude (roll, pitch) and range data\n        send_uint32(DIY_FIRST_ID+6, calc_attiandrng());\n    }\n}\n\n/*\n * send telemetry data\n * for FrSky SPort protocol (X-receivers)\n */\nvoid AP_Frsky_Telem::send_SPort(void)\n{\n    int16_t numc;\n    numc = _port-\u003eavailable();\n\n    // check if available is negative\n    if (numc \u003c 0) {\n        return;\n    }\n\n    // this is the constant for hub data frame\n    if (_port-\u003etxspace() \u003c 19) {\n        return;\n    }\n\n    for (int16_t i = 0; i \u003c numc; i++) {\n        int16_t readbyte = _port-\u003eread();\n        if (_SPort.sport_status == false) {\n            if  (readbyte == START_STOP_SPORT) {\n                _SPort.sport_status = true;\n            }\n        } else {\n            switch(readbyte) {\n                case SENSOR_ID_FAS:\n                    switch (_SPort.fas_call) {\n                        case 0:\n                            send_uint32(DATA_ID_FUEL, (uint16_t)roundf(_battery.capacity_remaining_pct())); // send battery remaining\n                            break;\n                        case 1:\n                            send_uint32(DATA_ID_VFAS, (uint16_t)roundf(_battery.voltage() * 10.0f)); // send battery voltage\n                            break;\n                        case 2:\n                            send_uint32(DATA_ID_CURRENT, (uint16_t)roundf(_battery.current_amps() * 10.0f)); // send current consumption\n                            break;\n                    }\n                    if (_SPort.fas_call++ \u003e 2) _SPort.fas_call = 0;\n                    break;\n                case SENSOR_ID_GPS:\n                    switch (_SPort.gps_call) {\n                        case 0:\n                            calc_gps_position(); // gps data is not recalculated until all of it has been sent\n                            send_uint32(DATA_ID_GPS_LAT_BP, _gps.latdddmm); // send gps lattitude degree and minute integer part\n                            break;\n                        case 1:\n                            send_uint32(DATA_ID_GPS_LAT_AP, _gps.latmmmm); // send gps lattitude minutes decimal part\n                            break;\n                        case 2:\n                            send_uint32(DATA_ID_GPS_LAT_NS, _gps.lat_ns); // send gps North / South information\n                            break;\n                        case 3:\n                            send_uint32(DATA_ID_GPS_LONG_BP, _gps.londddmm); // send gps longitude degree and minute integer part\n                            break;\n                        case 4:\n                            send_uint32(DATA_ID_GPS_LONG_AP, _gps.lonmmmm); // send gps longitude minutes decimal part\n                            break;\n                        case 5:\n                            send_uint32(DATA_ID_GPS_LONG_EW, _gps.lon_ew); // send gps East / West information\n                            break;\n                        case 6:\n                            send_uint32(DATA_ID_GPS_SPEED_BP, _gps.speed_in_meter); // send gps speed integer part\n                            break;\n                        case 7:\n                            send_uint32(DATA_ID_GPS_SPEED_AP, _gps.speed_in_centimeter); // send gps speed decimal part\n                            break;\n                        case 8:\n                            send_uint32(DATA_ID_GPS_ALT_BP, _gps.alt_gps_meters); // send gps altitude integer part\n                            break;\n                        case 9:\n                            send_uint32(DATA_ID_GPS_ALT_AP, _gps.alt_gps_cm); // send gps altitude decimals\n                            break;\n                        case 10:\n                            send_uint32(DATA_ID_GPS_COURS_BP, (uint16_t)((_ahrs.yaw_sensor / 100) % 360)); // send heading in degree based on AHRS and not GPS\n                            break;\n                    }\n                    if (_SPort.gps_call++ \u003e 10) _SPort.gps_call = 0;\n                    break;\n                case SENSOR_ID_VARIO:\n                    switch (_SPort.vario_call) {\n                        case 0 :\n                            calc_nav_alt(); // nav altitude is not recalculated until all of it has been sent\n                            send_uint32(DATA_ID_BARO_ALT_BP, _gps.alt_nav_meters); // send altitude integer part\n                            break;\n                        case 1:\n                            send_uint32(DATA_ID_BARO_ALT_AP, _gps.alt_nav_cm); // send altitude decimal part\n                            break;\n                        }\n                    if (_SPort.vario_call++ \u003e 1) _SPort.vario_call = 0;\n                    break;    \n                case SENSOR_ID_SP2UR:\n                    switch (_SPort.various_call) {\n                        case 0 :\n                            send_uint32(DATA_ID_TEMP2, (uint16_t)(AP::gps().num_sats() * 10 + AP::gps().status())); // send GPS status and number of satellites as num_sats*10 + status (to fit into a uint8_t)\n                            break;\n                        case 1:\n                            send_uint32(DATA_ID_TEMP1, _ap.control_mode); // send flight mode\n                            break;\n                    }\n                    if (_SPort.various_call++ \u003e 1) _SPort.various_call = 0;\n                    break;\n            }\n            _SPort.sport_status = false;\n        }\n    }\n}\n\n/*\n * send frame1 and frame2 telemetry data\n * one frame (frame1) is sent every 200ms with baro alt, nb sats, batt volts and amp, control_mode\n * a second frame (frame2) is sent every second (1000ms) with gps position data, and ahrs.yaw_sensor heading (instead of GPS heading)\n * for FrSky D protocol (D-receivers)\n */\nvoid AP_Frsky_Telem::send_D(void)\n{\n    uint32_t now = AP_HAL::millis();\n    // send frame1 every 200ms\n    if (now - _D.last_200ms_frame \u003e= 200) {\n        _D.last_200ms_frame = now;\n        send_uint16(DATA_ID_TEMP2, (uint16_t)(AP::gps().num_sats() * 10 + AP::gps().status())); // send GPS status and number of satellites as num_sats*10 + status (to fit into a uint8_t)\n        send_uint16(DATA_ID_TEMP1, _ap.control_mode); // send flight mode\n        send_uint16(DATA_ID_FUEL, (uint16_t)roundf(_battery.capacity_remaining_pct())); // send battery remaining\n        send_uint16(DATA_ID_VFAS, (uint16_t)roundf(_battery.voltage() * 10.0f)); // send battery voltage\n        send_uint16(DATA_ID_CURRENT, (uint16_t)roundf(_battery.current_amps() * 10.0f)); // send current consumption\n        calc_nav_alt();\n        send_uint16(DATA_ID_BARO_ALT_BP, _gps.alt_nav_meters); // send nav altitude integer part\n        send_uint16(DATA_ID_BARO_ALT_AP, _gps.alt_nav_cm); // send nav altitude decimal part\n    }\n    // send frame2 every second\n    if (now - _D.last_1000ms_frame \u003e= 1000) {\n        _D.last_1000ms_frame = now;\n        send_uint16(DATA_ID_GPS_COURS_BP, (uint16_t)((_ahrs.yaw_sensor / 100) % 360)); // send heading in degree based on AHRS and not GPS\n        calc_gps_position();\n        if (AP::gps().status() \u003e= 3) {\n            send_uint16(DATA_ID_GPS_LAT_BP, _gps.latdddmm); // send gps lattitude degree and minute integer part\n            send_uint16(DATA_ID_GPS_LAT_AP, _gps.latmmmm); // send gps lattitude minutes decimal part\n            send_uint16(DATA_ID_GPS_LAT_NS, _gps.lat_ns); // send gps North / South information\n            send_uint16(DATA_ID_GPS_LONG_BP, _gps.londddmm); // send gps longitude degree and minute integer part\n            send_uint16(DATA_ID_GPS_LONG_AP, _gps.lonmmmm); // send gps longitude minutes decimal part\n            send_uint16(DATA_ID_GPS_LONG_EW, _gps.lon_ew); // send gps East / West information\n            send_uint16(DATA_ID_GPS_SPEED_BP, _gps.speed_in_meter); // send gps speed integer part\n            send_uint16(DATA_ID_GPS_SPEED_AP, _gps.speed_in_centimeter); // send gps speed decimal part\n            send_uint16(DATA_ID_GPS_ALT_BP, _gps.alt_gps_meters); // send gps altitude integer part\n            send_uint16(DATA_ID_GPS_ALT_AP, _gps.alt_gps_cm); // send gps altitude decimal part\n        }\n    }\n}\n\n/*\n * tick - main call to send data to the receiver (called by scheduler at 1kHz)\n */\nvoid AP_Frsky_Telem::tick(void)\n{\n    // check UART has been initialised\n    if (!_initialised_uart) {\n        // initialise uart (this must be called from within tick b/c the UART begin must be called from the same thread as it is used from)\n        if (_protocol == AP_SerialManager::SerialProtocol_FrSky_D) {                    // FrSky D protocol (D-receivers)\n            _port-\u003ebegin(AP_SERIALMANAGER_FRSKY_D_BAUD, AP_SERIALMANAGER_FRSKY_BUFSIZE_RX, AP_SERIALMANAGER_FRSKY_BUFSIZE_TX);\n        } else {                                                                        // FrSky SPort and SPort Passthrough (OpenTX) protocols (X-receivers)\n            _port-\u003ebegin(AP_SERIALMANAGER_FRSKY_SPORT_BAUD, AP_SERIALMANAGER_FRSKY_BUFSIZE_RX, AP_SERIALMANAGER_FRSKY_BUFSIZE_TX);\n        }\n        _initialised_uart = true;// true when we have detected the protocol and UART has been initialised\n    }\n\n    if (_protocol == AP_SerialManager::SerialProtocol_FrSky_D) {                        // FrSky D protocol (D-receivers)\n        send_D();\n    } else if (_protocol == AP_SerialManager::SerialProtocol_FrSky_SPort) {             // FrSky SPort protocol (X-receivers)\n        send_SPort();\n    } else if (_protocol == AP_SerialManager::SerialProtocol_FrSky_SPort_Passthrough) { // FrSky SPort Passthrough (OpenTX) protocol (X-receivers)\n        send_SPort_Passthrough();\n    }\n}\n\n/* \n * build up the frame's crc\n * for FrSky SPort protocol (X-receivers)\n */\nvoid AP_Frsky_Telem::calc_crc(uint8_t byte)\n{\n    _crc += byte; //0-1FF\n    _crc += _crc \u003e\u003e 8; //0-100\n    _crc \u0026= 0xFF;\n}\n\n/*\n * send the frame's crc at the end of the frame\n * for FrSky SPort protocol (X-receivers)\n */\nvoid AP_Frsky_Telem::send_crc(void) \n{\n    send_byte(0xFF - _crc);\n    _crc = 0;\n}\n\n\n/*\n  send 1 byte and do byte stuffing\n*/\nvoid AP_Frsky_Telem::send_byte(uint8_t byte)\n{\n    if (_protocol == AP_SerialManager::SerialProtocol_FrSky_D) { // FrSky D protocol (D-receivers)\n        if (byte == START_STOP_D) {\n            _port-\u003ewrite(0x5D);\n            _port-\u003ewrite(0x3E);\n        } else if (byte == BYTESTUFF_D) {\n            _port-\u003ewrite(0x5D);\n            _port-\u003ewrite(0x3D);\n        } else {\n            _port-\u003ewrite(byte);\n        }\n    } else { // FrSky SPort protocol (X-receivers)\n        if (byte == START_STOP_SPORT) {\n            _port-\u003ewrite(0x7D);\n            _port-\u003ewrite(0x5E);\n        } else if (byte == BYTESTUFF_SPORT) {\n            _port-\u003ewrite(0x7D);\n            _port-\u003ewrite(0x5D);\n        } else {\n            _port-\u003ewrite(byte);\n        }\n        calc_crc(byte);\n    }\n}\n\n/*\n * send one uint32 frame of FrSky data - for FrSky SPort protocol (X-receivers)\n */\nvoid  AP_Frsky_Telem::send_uint32(uint16_t id, uint32_t data)\n{\n    send_byte(0x10); // DATA_FRAME\n    uint8_t *bytes = (uint8_t*)\u0026id;\n    send_byte(bytes[0]); // LSB\n    send_byte(bytes[1]); // MSB\n    bytes = (uint8_t*)\u0026data;\n    send_byte(bytes[0]); // LSB\n    send_byte(bytes[1]);\n    send_byte(bytes[2]);\n    send_byte(bytes[3]); // MSB\n    send_crc();\n}\n\n/*\n * send one uint16 frame of FrSky data - for FrSky D protocol (D-receivers)\n */\nvoid  AP_Frsky_Telem::send_uint16(uint16_t id, uint16_t data)\n{\n    _port-\u003ewrite(START_STOP_D);    // send a 0x5E start byte\n    uint8_t *bytes = (uint8_t*)\u0026id;\n    send_byte(bytes[0]);\n    bytes = (uint8_t*)\u0026data;\n    send_byte(bytes[0]); // LSB\n    send_byte(bytes[1]); // MSB\n}\n\n/*\n * grabs one \"chunk\" (4 bytes) of the queued message to be transmitted\n * for FrSky SPort Passthrough (OpenTX) protocol (X-receivers)\n */\nbool AP_Frsky_Telem::get_next_msg_chunk(void)\n{\n    if (_statustext_queue.empty()) {\n        return false;\n    }\n\n    if (_msg_chunk.repeats == 0) { // if it's the first time get_next_msg_chunk is called for a given chunk\n        uint8_t character = 0;\n        _msg_chunk.chunk = 0; // clear the 4 bytes of the chunk buffer\n\n        for (int i = 3; i \u003e -1 \u0026\u0026 _msg_chunk.char_index \u003c sizeof(_statustext_queue[0]-\u003etext); i--) {\n            character = _statustext_queue[0]-\u003etext[_msg_chunk.char_index++];\n\n            if (!character) {\n                break;\n            }\n\n            _msg_chunk.chunk |= character \u003c\u003c i * 8;\n        }\n\n        if (!character || (_msg_chunk.char_index == sizeof(_statustext_queue[0]-\u003etext))) { // we've reached the end of the message (string terminated by '\\0' or last character of the string has been processed)\n            _msg_chunk.char_index = 0; // reset index to get ready to process the next message\n            // add severity which is sent as the MSB of the last three bytes of the last chunk (bits 24, 16, and 8) since a character is on 7 bits\n            _msg_chunk.chunk |= (_statustext_queue[0]-\u003eseverity \u0026 0x4)\u003c\u003c21;\n            _msg_chunk.chunk |= (_statustext_queue[0]-\u003eseverity \u0026 0x2)\u003c\u003c14;\n            _msg_chunk.chunk |= (_statustext_queue[0]-\u003eseverity \u0026 0x1)\u003c\u003c7;\n        }\n    }\n\n    if (_msg_chunk.repeats++ \u003e 2) { // repeat each message chunk 3 times to ensure transmission\n        _msg_chunk.repeats = 0;\n        if (_msg_chunk.char_index == 0) { // if we're ready for the next message\n            _statustext_queue.remove(0);\n        }\n    }\n    return true;\n}\n\n/*\n * add message to message cue for transmission through FrSky link\n * for FrSky SPort Passthrough (OpenTX) protocol (X-receivers)\n */\nvoid AP_Frsky_Telem::queue_message(MAV_SEVERITY severity, const char *text)\n{\n    mavlink_statustext_t statustext{};\n\n    statustext.severity = severity;\n    strncpy(statustext.text, text, sizeof(statustext.text));\n\n    // The force push will ensure comm links do not block other comm links forever if they fail.\n    // If we push to a full buffer then we overwrite the oldest entry, effectively removing the\n    // block but not until the buffer fills up.\n    _statustext_queue.push_force(statustext);\n}\n\n/*\n * add sensor_status_flags information to message cue, normally passed as sys_status mavlink messages to the GCS, for transmission through FrSky link\n * for FrSky SPort Passthrough (OpenTX) protocol (X-receivers)\n */\nvoid AP_Frsky_Telem::check_sensor_status_flags(void)\n{\n    uint32_t now = AP_HAL::millis();\n\n    if ((now - check_sensor_status_timer) \u003e= 5000) { // prevent repeating any system_status messages unless 5 seconds have passed\n        // only one error is reported at a time (in order of preference). Same setup and displayed messages as Mission Planner.\n        if ((_ap.sensor_status_flags \u0026 MAV_SYS_STATUS_SENSOR_GPS) \u003e 0) {\n            queue_message(MAV_SEVERITY_CRITICAL, \"Bad GPS Health\");\n            check_sensor_status_timer = now;\n        } else if ((_ap.sensor_status_flags \u0026 MAV_SYS_STATUS_SENSOR_3D_GYRO) \u003e 0) {\n            queue_message(MAV_SEVERITY_CRITICAL, \"Bad Gyro Health\");\n            check_sensor_status_timer = now;\n        } else if ((_ap.sensor_status_flags \u0026 MAV_SYS_STATUS_SENSOR_3D_ACCEL) \u003e 0) {\n            queue_message(MAV_SEVERITY_CRITICAL, \"Bad Accel Health\");\n            check_sensor_status_timer = now;\n        } else if ((_ap.sensor_status_flags \u0026 MAV_SYS_STATUS_SENSOR_3D_MAG) \u003e 0) {\n            queue_message(MAV_SEVERITY_CRITICAL, \"Bad Compass Health\");\n            check_sensor_status_timer = now;\n        } else if ((_ap.sensor_status_flags \u0026 MAV_SYS_STATUS_SENSOR_ABSOLUTE_PRESSURE) \u003e 0) {\n            queue_message(MAV_SEVERITY_CRITICAL, \"Bad Baro Health\");\n            check_sensor_status_timer = now;\n        } else if ((_ap.sensor_status_flags \u0026 MAV_SYS_STATUS_SENSOR_LASER_POSITION) \u003e 0) {\n            queue_message(MAV_SEVERITY_CRITICAL, \"Bad LiDAR Health\");\n            check_sensor_status_timer = now;\n        } else if ((_ap.sensor_status_flags \u0026 MAV_SYS_STATUS_SENSOR_OPTICAL_FLOW) \u003e 0) {\n            queue_message(MAV_SEVERITY_CRITICAL, \"Bad OptFlow Health\");\n            check_sensor_status_timer = now;\n        } else if ((_ap.sensor_status_flags \u0026 MAV_SYS_STATUS_TERRAIN) \u003e 0) {\n            queue_message(MAV_SEVERITY_CRITICAL, \"Bad or No Terrain Data\");\n            check_sensor_status_timer = now;\n        } else if ((_ap.sensor_status_flags \u0026 MAV_SYS_STATUS_GEOFENCE) \u003e 0) {\n            queue_message(MAV_SEVERITY_CRITICAL, \"Geofence Breach\");\n            check_sensor_status_timer = now;\n        } else if ((_ap.sensor_status_flags \u0026 MAV_SYS_STATUS_AHRS) \u003e 0) {\n            queue_message(MAV_SEVERITY_CRITICAL, \"Bad AHRS\");\n            check_sensor_status_timer = now;\n        } else if ((_ap.sensor_status_flags \u0026 MAV_SYS_STATUS_SENSOR_RC_RECEIVER) \u003e 0) {\n            queue_message(MAV_SEVERITY_CRITICAL, \"No RC Receiver\");\n            check_sensor_status_timer = now;\n        } else if ((_ap.sensor_status_flags \u0026 MAV_SYS_STATUS_LOGGING) \u003e 0) {\n            queue_message(MAV_SEVERITY_CRITICAL, \"Bad Logging\");\n            check_sensor_status_timer = now;\n        }\n    }\n}\n\n/*\n * add innovation variance information to message cue, normally passed as ekf_status_report mavlink messages to the GCS, for transmission through FrSky link\n * for FrSky SPort Passthrough (OpenTX) protocol (X-receivers)\n */\nvoid AP_Frsky_Telem::check_ekf_status(void)\n{\n    // get variances\n    float velVar, posVar, hgtVar, tasVar;\n    Vector3f magVar;\n    Vector2f offset;\n    if (_ahrs.get_variances(velVar, posVar, hgtVar, magVar, tasVar, offset)) {\n        uint32_t now = AP_HAL::millis();\n        if ((now - check_ekf_status_timer) \u003e= 10000) { // prevent repeating any ekf_status message unless 10 seconds have passed\n            // multiple errors can be reported at a time. Same setup as Mission Planner.\n            if (velVar \u003e= 1) {\n                queue_message(MAV_SEVERITY_CRITICAL, \"Error velocity variance\");\n                check_ekf_status_timer = now;\n            }\n            if (posVar \u003e= 1) {\n                queue_message(MAV_SEVERITY_CRITICAL, \"Error pos horiz variance\");\n                check_ekf_status_timer = now;\n            }\n            if (hgtVar \u003e= 1) {\n                queue_message(MAV_SEVERITY_CRITICAL, \"Error pos vert variance\");\n                check_ekf_status_timer = now;\n            }\n            if (magVar.length() \u003e= 1) {\n                queue_message(MAV_SEVERITY_CRITICAL, \"Error compass variance\");\n                check_ekf_status_timer = now;\n            }\n            if (tasVar \u003e= 1) {\n                queue_message(MAV_SEVERITY_CRITICAL, \"Error terrain alt variance\");\n                check_ekf_status_timer = now;\n            }\n        }\n    }\n}\n      \n/*\n * prepare parameter data\n * for FrSky SPort Passthrough (OpenTX) protocol (X-receivers)\n */\nuint32_t AP_Frsky_Telem::calc_param(void)\n{\n    uint32_t param = 0;\n\n    // cycle through paramIDs\n    if (_paramID \u003e= 5) {\n        _paramID = 0;\n    }\n    _paramID++;\n    switch(_paramID) {\n    case 1:\n        param = _params.mav_type; // frame type (see MAV_TYPE in Mavlink definition file common.h)\n        break;\n    case 2: // was used to send the battery failsafe voltage\n    case 3: // was used to send the battery failsafe capacity in mAh\n        break;\n    case 4:\n        param = (uint32_t)roundf(_battery.pack_capacity_mah(0)); // battery pack capacity in mAh\n        break;\n    case 5:\n        param = (uint32_t)roundf(_battery.pack_capacity_mah(1)); // battery pack capacity in mAh\n        break;\n    }\n    //Reserve first 8 bits for param ID, use other 24 bits to store parameter value\n    param = (_paramID \u003c\u003c PARAM_ID_OFFSET) | (param \u0026 PARAM_VALUE_LIMIT);\n    \n    return param;\n}\n\n/*\n * prepare gps latitude/longitude data\n * for FrSky SPort Passthrough (OpenTX) protocol (X-receivers)\n */\nuint32_t AP_Frsky_Telem::calc_gps_latlng(bool *send_latitude)\n{\n    uint32_t latlng;\n    const Location \u0026loc = AP::gps().location(0); // use the first gps instance (same as in send_mavlink_gps_raw)\n\n    // alternate between latitude and longitude\n    if ((*send_latitude) == true) {\n        if (loc.lat \u003c 0) {\n            latlng = ((labs(loc.lat)/100)*6) | 0x40000000;\n        } else {\n            latlng = ((labs(loc.lat)/100)*6);\n        }\n        (*send_latitude) = false;\n    } else {\n        if (loc.lng \u003c 0) {\n            latlng = ((labs(loc.lng)/100)*6) | 0xC0000000;\n        } else {\n            latlng = ((labs(loc.lng)/100)*6) | 0x80000000;\n        }\n        (*send_latitude) = true;\n    }\n    return latlng;\n}\n\n/*\n * prepare gps status data\n * for FrSky SPort Passthrough (OpenTX) protocol (X-receivers)\n */\nuint32_t AP_Frsky_Telem::calc_gps_status(void)\n{\n    const AP_GPS \u0026gps = AP::gps();\n\n    uint32_t gps_status;\n\n    // number of GPS satellites visible (limit to 15 (0xF) since the value is stored on 4 bits)\n    gps_status = (gps.num_sats() \u003c GPS_SATS_LIMIT) ? gps.num_sats() : GPS_SATS_LIMIT;\n    // GPS receiver status (limit to 0-3 (0x3) since the value is stored on 2 bits: NO_GPS = 0, NO_FIX = 1, GPS_OK_FIX_2D = 2, GPS_OK_FIX_3D or GPS_OK_FIX_3D_DGPS or GPS_OK_FIX_3D_RTK_FLOAT or GPS_OK_FIX_3D_RTK_FIXED = 3)\n    gps_status |= ((gps.status() \u003c GPS_STATUS_LIMIT) ? gps.status() : GPS_STATUS_LIMIT)\u003c\u003cGPS_STATUS_OFFSET;\n    // GPS horizontal dilution of precision in dm\n    gps_status |= prep_number(roundf(gps.get_hdop() * 0.1f),2,1)\u003c\u003cGPS_HDOP_OFFSET; \n    // GPS receiver advanced status (0: no advanced fix, 1: GPS_OK_FIX_3D_DGPS, 2: GPS_OK_FIX_3D_RTK_FLOAT, 3: GPS_OK_FIX_3D_RTK_FIXED)\n    gps_status |= ((gps.status() \u003e GPS_STATUS_LIMIT) ? gps.status()-GPS_STATUS_LIMIT : 0)\u003c\u003cGPS_ADVSTATUS_OFFSET;\n    // Altitude MSL in dm\n    const Location \u0026loc = gps.location();\n    gps_status |= prep_number(roundf(loc.alt * 0.1f),2,2)\u003c\u003cGPS_ALTMSL_OFFSET; \n    return gps_status;\n}\n\n/*\n * prepare battery data\n * for FrSky SPort Passthrough (OpenTX) protocol (X-receivers)\n */\nuint32_t AP_Frsky_Telem::calc_batt(uint8_t instance)\n{\n    uint32_t batt;\n    \n    // battery voltage in decivolts, can have up to a 12S battery (4.25Vx12S = 51.0V)\n    batt = (((uint16_t)roundf(_battery.voltage(instance) * 10.0f)) \u0026 BATT_VOLTAGE_LIMIT);\n    // battery current draw in deciamps\n    batt |= prep_number(roundf(_battery.current_amps(instance) * 10.0f), 2, 1)\u003c\u003cBATT_CURRENT_OFFSET; \n    // battery current drawn since power on in mAh (limit to 32767 (0x7FFF) since value is stored on 15 bits)\n    batt |= ((_battery.consumed_mah(instance) \u003c BATT_TOTALMAH_LIMIT) ? ((uint16_t)roundf(_battery.consumed_mah(instance)) \u0026 BATT_TOTALMAH_LIMIT) : BATT_TOTALMAH_LIMIT)\u003c\u003cBATT_TOTALMAH_OFFSET;\n    return batt;\n}\n\n/*\n * prepare various autopilot status data\n * for FrSky SPort Passthrough (OpenTX) protocol (X-receivers)\n */\nuint32_t AP_Frsky_Telem::calc_ap_status(void)\n{\n    uint32_t ap_status;\n\n    // IMU temperature: offset -19, 0 means temp =\u003c 19°, 63 means temp =\u003e 82°\n    uint8_t imu_temp = (uint8_t) roundf(constrain_float(AP::ins().get_temperature(0), AP_IMU_TEMP_MIN, AP_IMU_TEMP_MAX) - AP_IMU_TEMP_MIN);\n\n    // control/flight mode number (limit to 31 (0x1F) since the value is stored on 5 bits)\n    ap_status = (uint8_t)((_ap.control_mode+1) \u0026 AP_CONTROL_MODE_LIMIT);\n    // simple/super simple modes flags\n    ap_status |= (uint8_t)((*_ap.valuep) \u0026 AP_SSIMPLE_FLAGS)\u003c\u003cAP_SSIMPLE_OFFSET;\n    // is_flying flag\n    ap_status |= (uint8_t)(((*_ap.valuep) \u0026 AP_LANDCOMPLETE_FLAG) ^ AP_LANDCOMPLETE_FLAG);\n    // armed flag\n    ap_status |= (uint8_t)(AP_Notify::flags.armed)\u003c\u003cAP_ARMED_OFFSET;\n    // battery failsafe flag\n    ap_status |= (uint8_t)(AP_Notify::flags.failsafe_battery)\u003c\u003cAP_BATT_FS_OFFSET;\n    // bad ekf flag\n    ap_status |= (uint8_t)(AP_Notify::flags.ekf_bad)\u003c\u003cAP_EKF_FS_OFFSET;\n    // IMU temperature\n    ap_status |= imu_temp \u003c\u003c AP_IMU_TEMP_OFFSET;\n    return ap_status;\n}\n\n/*\n * prepare home position related data\n * for FrSky SPort Passthrough (OpenTX) protocol (X-receivers)\n */\nuint32_t AP_Frsky_Telem::calc_home(void)\n{\n    uint32_t home = 0;\n    Location loc;\n    float _relative_home_altitude = 0;\n    if (_ahrs.get_position(loc)) {            \n        // check home_loc is valid\n        const Location \u0026home_loc = _ahrs.get_home();\n        if (home_loc.lat != 0 || home_loc.lng != 0) {\n            // distance between vehicle and home_loc in meters\n            home = prep_number(roundf(get_distance(home_loc, loc)), 3, 2);\n            // angle from front of vehicle to the direction of home_loc in 3 degree increments (just in case, limit to 127 (0x7F) since the value is stored on 7 bits)\n            home |= (((uint8_t)roundf(get_bearing_cd(loc,home_loc) * 0.00333f)) \u0026 HOME_BEARING_LIMIT)\u003c\u003cHOME_BEARING_OFFSET;\n        }\n        // altitude between vehicle and home_loc\n        _relative_home_altitude = loc.alt;\n        if (!loc.flags.relative_alt) {\n            // loc.alt has home altitude added, remove it\n            _relative_home_altitude -= _ahrs.get_home().alt;\n        }\n    }\n    // altitude above home in decimeters\n    home |= prep_number(roundf(_relative_home_altitude * 0.1f), 3, 2)\u003c\u003cHOME_ALT_OFFSET;\n    return home;\n}\n\n/*\n * prepare velocity and yaw data\n * for FrSky SPort Passthrough (OpenTX) protocol (X-receivers)\n */\nuint32_t AP_Frsky_Telem::calc_velandyaw(void)\n{\n    uint32_t velandyaw;\n    Vector3f velNED {};\n\n    // if we can't get velocity then we use zero for vertical velocity\n    _ahrs.get_velocity_NED(velNED);\n    // vertical velocity in dm/s\n    velandyaw = prep_number(roundf(-velNED.z * 10), 2, 1);\n    // horizontal velocity in dm/s (use airspeed if available and enabled - even if not used - otherwise use groundspeed)\n    const AP_Airspeed *aspeed = _ahrs.get_airspeed();\n    if (aspeed \u0026\u0026 aspeed-\u003eenabled()) {        \n        velandyaw |= prep_number(roundf(aspeed-\u003eget_airspeed() * 10), 2, 1)\u003c\u003cVELANDYAW_XYVEL_OFFSET;\n    } else { // otherwise send groundspeed estimate from ahrs\n        velandyaw |= prep_number(roundf(_ahrs.groundspeed() * 10), 2, 1)\u003c\u003cVELANDYAW_XYVEL_OFFSET;\n    }\n    // yaw from [0;36000] centidegrees to .2 degree increments [0;1800] (just in case, limit to 2047 (0x7FF) since the value is stored on 11 bits)\n    velandyaw |= ((uint16_t)roundf(_ahrs.yaw_sensor * 0.05f) \u0026 VELANDYAW_YAW_LIMIT)\u003c\u003cVELANDYAW_YAW_OFFSET;\n    return velandyaw;\n}\n\n/*\n * prepare attitude (roll, pitch) and range data\n * for FrSky SPort Passthrough (OpenTX) protocol (X-receivers)\n */\nuint32_t AP_Frsky_Telem::calc_attiandrng(void)\n{\n    uint32_t attiandrng;\n\n    // roll from [-18000;18000] centidegrees to unsigned .2 degree increments [0;1800] (just in case, limit to 2047 (0x7FF) since the value is stored on 11 bits)\n    attiandrng = ((uint16_t)roundf((_ahrs.roll_sensor + 18000) * 0.05f) \u0026 ATTIANDRNG_ROLL_LIMIT);\n    // pitch from [-9000;9000] centidegrees to unsigned .2 degree increments [0;900] (just in case, limit to 1023 (0x3FF) since the value is stored on 10 bits)\n    attiandrng |= ((uint16_t)roundf((_ahrs.pitch_sensor + 9000) * 0.05f) \u0026 ATTIANDRNG_PITCH_LIMIT)\u003c\u003cATTIANDRNG_PITCH_OFFSET;\n    // rangefinder measurement in cm\n    attiandrng |= prep_number(_rng.distance_cm_orient(ROTATION_PITCH_270), 3, 1)\u003c\u003cATTIANDRNG_RNGFND_OFFSET;\n    return attiandrng;\n}\n\n/*\n * prepare value for transmission through FrSky link\n * for FrSky SPort Passthrough (OpenTX) protocol (X-receivers)\n */\nuint16_t AP_Frsky_Telem::prep_number(int32_t number, uint8_t digits, uint8_t power)\n{\n    uint16_t res = 0;\n    uint32_t abs_number = abs(number);\n\n    if ((digits == 2) \u0026\u0026 (power == 1)) { // number encoded on 8 bits: 7 bits for digits + 1 for 10^power\n        if (abs_number \u003c 100) {\n            res = abs_number\u003c\u003c1;\n        } else if (abs_number \u003c 1270) {\n            res = ((uint8_t)roundf(abs_number * 0.1f)\u003c\u003c1)|0x1;\n        } else { // transmit max possible value (0x7F x 10^1 = 1270)\n            res = 0xFF;\n        }\n        if (number \u003c 0) { // if number is negative, add sign bit in front\n            res |= 0x1\u003c\u003c8;\n        }\n    } else if ((digits == 2) \u0026\u0026 (power == 2)) { // number encoded on 9 bits: 7 bits for digits + 2 for 10^power\n        if (abs_number \u003c 100) {\n            res = abs_number\u003c\u003c2;\n        } else if (abs_number \u003c 1000) {\n            res = ((uint8_t)roundf(abs_number * 0.1f)\u003c\u003c2)|0x1;\n        } else if (abs_number \u003c 10000) {\n            res = ((uint8_t)roundf(abs_number * 0.01f)\u003c\u003c2)|0x2;\n        } else if (abs_number \u003c 127000) {\n            res = ((uint8_t)roundf(abs_number * 0.001f)\u003c\u003c2)|0x3;\n        } else { // transmit max possible value (0x7F x 10^3 = 127000)\n            res = 0x1FF;\n        }\n        if (number \u003c 0) { // if number is negative, add sign bit in front\n            res |= 0x1\u003c\u003c9;\n        }\n    } else if ((digits == 3) \u0026\u0026 (power == 1)) { // number encoded on 11 bits: 10 bits for digits + 1 for 10^power\n        if (abs_number \u003c 1000) {\n            res = abs_number\u003c\u003c1;\n        } else if (abs_number \u003c 10240) {\n            res = ((uint16_t)roundf(abs_number * 0.1f)\u003c\u003c1)|0x1;\n        } else { // transmit max possible value (0x3FF x 10^1 = 10240)\n            res = 0x7FF;\n        }\n        if (number \u003c 0) { // if number is negative, add sign bit in front\n            res |= 0x1\u003c\u003c11;\n        }\n    } else if ((digits == 3) \u0026\u0026 (power == 2)) { // number encoded on 12 bits: 10 bits for digits + 2 for 10^power\n        if (abs_number \u003c 1000) {\n            res = abs_number\u003c\u003c2;\n        } else if (abs_number \u003c 10000) {\n            res = ((uint16_t)roundf(abs_number * 0.1f)\u003c\u003c2)|0x1;\n        } else if (abs_number \u003c 100000) {\n            res = ((uint16_t)roundf(abs_number * 0.01f)\u003c\u003c2)|0x2;\n        } else if (abs_number \u003c 1024000) {\n            res = ((uint16_t)roundf(abs_number * 0.001f)\u003c\u003c2)|0x3;\n        } else { // transmit max possible value (0x3FF x 10^3 = 127000)\n            res = 0xFFF;\n        }\n        if (number \u003c 0) { // if number is negative, add sign bit in front\n            res |= 0x1\u003c\u003c12;\n        }\n    }\n    return res;\n}\n\n/*\n * prepare altitude between vehicle and home location data\n * for FrSky D and SPort protocols\n */\nvoid AP_Frsky_Telem::calc_nav_alt(void)\n{\n    Location loc;\n    float current_height = 0; // in centimeters above home\n    if (_ahrs.get_position(loc)) {\n        current_height = loc.alt*0.01f;\n        if (!loc.flags.relative_alt) {\n            // loc.alt has home altitude added, remove it\n            current_height -= _ahrs.get_home().alt*0.01f;\n        }\n    }\n    \n    _gps.alt_nav_meters = (int16_t)current_height;\n    _gps.alt_nav_cm = (current_height - _gps.alt_nav_meters) * 100;\n} \n\n/*\n * format the decimal latitude/longitude to the required degrees/minutes\n * for FrSky D and SPort protocols\n */\nfloat AP_Frsky_Telem::format_gps(float dec)\n{\n    uint8_t dm_deg = (uint8_t) dec;\n    return (dm_deg * 100.0f) + (dec - dm_deg) * 60;\n}\n\n/*\n * prepare gps data\n * for FrSky D and SPort protocols\n */\nvoid AP_Frsky_Telem::calc_gps_position(void)\n{\n    float lat;\n    float lon;\n    float alt;\n    float speed;\n\n    if (AP::gps().status() \u003e= 3) {\n        const Location \u0026loc = AP::gps().location(); //get gps instance 0\n        lat = format_gps(fabsf(loc.lat/10000000.0f));\n        _gps.latdddmm = lat;\n        _gps.latmmmm = (lat - _gps.latdddmm) * 10000;\n        _gps.lat_ns = (loc.lat \u003c 0) ? 'S' : 'N';\n\n        lon = format_gps(fabsf(loc.lng/10000000.0f));\n        _gps.londddmm = lon;\n        _gps.lonmmmm = (lon - _gps.londddmm) * 10000;\n        _gps.lon_ew = (loc.lng \u003c 0) ? 'W' : 'E';\n\n        alt = loc.alt * 0.01f;\n        _gps.alt_gps_meters = (int16_t)alt;\n        _gps.alt_gps_cm = (alt - _gps.alt_gps_meters) * 100;\n\n        speed = AP::gps().ground_speed();\n        _gps.speed_in_meter = speed;\n        _gps.speed_in_centimeter = (speed - _gps.speed_in_meter) * 100;\n    } else {\n        _gps.latdddmm = 0;\n        _gps.latmmmm = 0;\n        _gps.lat_ns = 0;\n        _gps.londddmm = 0;\n        _gps.lonmmmm = 0;\n        _gps.alt_gps_meters = 0;\n        _gps.alt_gps_cm = 0;\n        _gps.speed_in_meter = 0;\n        _gps.speed_in_centimeter = 0;\n    }\n}\n"}
{"repo_name":"relipse/onethfour-chess-client","ref":"refs/heads/master","path":"src/quazip/JlCompress.cpp","copies":"8","language":"C++","content":"#include \"JlCompress.h\"\n#include \u003cQDebug\u003e\n\nstatic bool copyData(QIODevice \u0026inFile, QIODevice \u0026outFile)\n{\n    while (!inFile.atEnd()) {\n        char buf[4096];\n        qint64 readLen = inFile.read(buf, 4096);\n        if (readLen \u003c= 0)\n            return false;\n        if (outFile.write(buf, readLen) != readLen)\n            return false;\n    }\n    return true;\n}\n\n/**OK\n * Comprime il file fileName, nell'oggetto zip, con il nome fileDest.\n *\n * La funzione fallisce se:\n * * zip==NULL;\n * * l'oggetto zip e stato aperto in una modalita non compatibile con l'aggiunta di file;\n * * non e possibile aprire il file d'origine;\n * * non e possibile creare il file all'interno dell'oggetto zip;\n * * si e rilevato un errore nella copia dei dati;\n * * non e stato possibile chiudere il file all'interno dell'oggetto zip;\n */\nbool JlCompress::compressFile(QuaZip* zip, QString fileName, QString fileDest) {\n    // zip: oggetto dove aggiungere il file\n    // fileName: nome del file reale\n    // fileDest: nome del file all'interno del file compresso\n\n    // Controllo l'apertura dello zip\n    if (!zip) return false;\n    if (zip-\u003egetMode()!=QuaZip::mdCreate \u0026\u0026\n        zip-\u003egetMode()!=QuaZip::mdAppend \u0026\u0026\n        zip-\u003egetMode()!=QuaZip::mdAdd) return false;\n\n    // Apro il file originale\n    QFile inFile;\n    inFile.setFileName(fileName);\n    if(!inFile.open(QIODevice::ReadOnly)) return false;\n\n    // Apro il file risulato\n    QuaZipFile outFile(zip);\n    if(!outFile.open(QIODevice::WriteOnly, QuaZipNewInfo(fileDest, inFile.fileName()))) return false;\n\n    // Copio i dati\n    if (!copyData(inFile, outFile) || outFile.getZipError()!=UNZ_OK) {\n        return false;\n    }\n\n    // Chiudo i file\n    outFile.close();\n    if (outFile.getZipError()!=UNZ_OK) return false;\n    inFile.close();\n\n    return true;\n}\n\n/**OK\n * Comprime la cartella dir nel file fileCompressed, se recursive e true allora\n * comprime anche le sotto cartelle. I nomi dei file preceduti dal path creato\n * togliendo il pat della cartella origDir al path della cartella dir.\n * Se la funzione fallisce restituisce false e cancella il file che si e tentato\n * di creare.\n *\n * La funzione fallisce se:\n * * zip==NULL;\n * * l'oggetto zip e stato aperto in una modalita non compatibile con l'aggiunta di file;\n * * la cartella dir non esiste;\n * * la compressione di una sotto cartella fallisce (1);\n * * la compressione di un file fallisce;\n * (1) La funzione si richiama in maniera ricorsiva per comprimere le sotto cartelle\n * dunque gli errori di compressione di una sotto cartella sono gli stessi di questa\n * funzione.\n */\nbool JlCompress::compressSubDir(QuaZip* zip, QString dir, QString origDir, bool recursive) {\n    // zip: oggetto dove aggiungere il file\n    // dir: cartella reale corrente\n    // origDir: cartella reale originale\n    // (path(dir)-path(origDir)) = path interno all'oggetto zip\n\n    // Controllo l'apertura dello zip\n    if (!zip) return false;\n    if (zip-\u003egetMode()!=QuaZip::mdCreate \u0026\u0026\n        zip-\u003egetMode()!=QuaZip::mdAppend \u0026\u0026\n        zip-\u003egetMode()!=QuaZip::mdAdd) return false;\n\n    // Controllo la cartella\n    QDir directory(dir);\n    if (!directory.exists()) return false;\n\n    // Se comprimo anche le sotto cartelle\n    if (recursive) {\n        // Per ogni sotto cartella\n        QFileInfoList files = directory.entryInfoList(QDir::AllDirs|QDir::NoDotAndDotDot);\n        Q_FOREACH (QFileInfo file, files) {\n            // Comprimo la sotto cartella\n            if(!compressSubDir(zip,file.absoluteFilePath(),origDir,recursive)) return false;\n        }\n    }\n\n    // Per ogni file nella cartella\n    QFileInfoList files = directory.entryInfoList(QDir::Files);\n    QDir origDirectory(origDir);\n    Q_FOREACH (QFileInfo file, files) {\n        // Se non e un file o e il file compresso che sto creando\n        if(!file.isFile()||file.absoluteFilePath()==zip-\u003egetZipName()) continue;\n\n        // Creo il nome relativo da usare all'interno del file compresso\n        QString filename = origDirectory.relativeFilePath(file.absoluteFilePath());\n\n        // Comprimo il file\n        if (!compressFile(zip,file.absoluteFilePath(),filename)) return false;\n    }\n\n    return true;\n}\n\n/**OK\n * Estrae il file fileName, contenuto nell'oggetto zip, con il nome fileDest.\n * Se la funzione fallisce restituisce false e cancella il file che si e tentato di estrarre.\n *\n * La funzione fallisce se:\n * * zip==NULL;\n * * l'oggetto zip e stato aperto in una modalita non compatibile con l'estrazione di file;\n * * non e possibile aprire il file all'interno dell'oggetto zip;\n * * non e possibile creare il file estratto;\n * * si e rilevato un errore nella copia dei dati (1);\n * * non e stato possibile chiudere il file all'interno dell'oggetto zip (1);\n *\n * (1): prima di uscire dalla funzione cancella il file estratto.\n */\nbool JlCompress::extractFile(QuaZip* zip, QString fileName, QString fileDest) {\n    // zip: oggetto dove aggiungere il file\n    // filename: nome del file reale\n    // fileincompress: nome del file all'interno del file compresso\n\n    // Controllo l'apertura dello zip\n    if (!zip) return false;\n    if (zip-\u003egetMode()!=QuaZip::mdUnzip) return false;\n\n    // Apro il file compresso\n    if (!fileName.isEmpty())\n        zip-\u003esetCurrentFile(fileName);\n    QuaZipFile inFile(zip);\n    if(!inFile.open(QIODevice::ReadOnly) || inFile.getZipError()!=UNZ_OK) return false;\n\n    // Controllo esistenza cartella file risultato\n    QDir curDir;\n    if (!curDir.mkpath(QFileInfo(fileDest).absolutePath())) {\n        return false;\n    }\n\n    if (QFileInfo(fileDest).isDir())\n        return true;\n\n    // Apro il file risultato\n    QFile outFile;\n    outFile.setFileName(fileDest);\n    if(!outFile.open(QIODevice::WriteOnly)) return false;\n\n    // Copio i dati\n    if (!copyData(inFile, outFile) || inFile.getZipError()!=UNZ_OK) {\n        outFile.close();\n        removeFile(QStringList(fileDest));\n        return false;\n    }\n    outFile.close();\n\n    // Chiudo i file\n    inFile.close();\n    if (inFile.getZipError()!=UNZ_OK) {\n        removeFile(QStringList(fileDest));\n        return false;\n    }\n\n    return true;\n}\n\n/**\n * Rimuove i file il cui nome e specificato all'interno di listFile.\n * Restituisce true se tutti i file sono stati cancellati correttamente, attenzione\n * perche puo restituire false anche se alcuni file non esistevano e si e tentato\n * di cancellarli.\n */\nbool JlCompress::removeFile(QStringList listFile) {\n    bool ret = true;\n    // Per ogni file\n    for (int i=0; i\u003clistFile.count(); i++) {\n        // Lo elimino\n        ret = ret \u0026\u0026 QFile::remove(listFile.at(i));\n    }\n    return ret;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n/**OK\n * Comprime il file fileName nel file fileCompressed.\n * Se la funzione fallisce restituisce false e cancella il file che si e tentato\n * di creare.\n *\n * La funzione fallisce se:\n * * non si riesce ad aprire l'oggetto zip;\n * * la compressione del file fallisce;\n * * non si riesce a chiudere l'oggetto zip;\n */\nbool JlCompress::compressFile(QString fileCompressed, QString file) {\n    // Creo lo zip\n    QuaZip zip(fileCompressed);\n    QDir().mkpath(QFileInfo(fileCompressed).absolutePath());\n    if(!zip.open(QuaZip::mdCreate)) {\n        QFile::remove(fileCompressed);\n        return false;\n    }\n\n    // Aggiungo il file\n    if (!compressFile(\u0026zip,file,QFileInfo(file).fileName())) {\n        QFile::remove(fileCompressed);\n        return false;\n    }\n\n    // Chiudo il file zip\n    zip.close();\n    if(zip.getZipError()!=0) {\n        QFile::remove(fileCompressed);\n        return false;\n    }\n\n    return true;\n}\n\n/**OK\n * Comprime i file specificati in files nel file fileCompressed.\n * Se la funzione fallisce restituisce false e cancella il file che si e tentato\n * di creare.\n *\n * La funzione fallisce se:\n * * non si riesce ad aprire l'oggetto zip;\n * * la compressione di un file fallisce;\n * * non si riesce a chiudere l'oggetto zip;\n */\nbool JlCompress::compressFiles(QString fileCompressed, QStringList files) {\n    // Creo lo zip\n    QuaZip zip(fileCompressed);\n    QDir().mkpath(QFileInfo(fileCompressed).absolutePath());\n    if(!zip.open(QuaZip::mdCreate)) {\n        QFile::remove(fileCompressed);\n        return false;\n    }\n\n    // Comprimo i file\n    QFileInfo info;\n    Q_FOREACH (QString file, files) {\n        info.setFile(file);\n        if (!info.exists() || !compressFile(\u0026zip,file,info.fileName())) {\n            QFile::remove(fileCompressed);\n            return false;\n        }\n    }\n\n    // Chiudo il file zip\n    zip.close();\n    if(zip.getZipError()!=0) {\n        QFile::remove(fileCompressed);\n        return false;\n    }\n\n    return true;\n}\n\n/**OK\n * Comprime la cartella dir nel file fileCompressed, se recursive e true allora\n * comprime anche le sotto cartelle.\n * Se la funzione fallisce restituisce false e cancella il file che si e tentato\n * di creare.\n *\n * La funzione fallisce se:\n * * non si riesce ad aprire l'oggetto zip;\n * * la compressione di un file fallisce;\n * * non si riesce a chiudere l'oggetto zip;\n */\nbool JlCompress::compressDir(QString fileCompressed, QString dir, bool recursive) {\n    // Creo lo zip\n    QuaZip zip(fileCompressed);\n    QDir().mkpath(QFileInfo(fileCompressed).absolutePath());\n    if(!zip.open(QuaZip::mdCreate)) {\n        QFile::remove(fileCompressed);\n        return false;\n    }\n\n    // Aggiungo i file e le sotto cartelle\n    if (!compressSubDir(\u0026zip,dir,dir,recursive)) {\n        QFile::remove(fileCompressed);\n        return false;\n    }\n\n    // Chiudo il file zip\n    zip.close();\n    if(zip.getZipError()!=0) {\n        QFile::remove(fileCompressed);\n        return false;\n    }\n\n    return true;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n/**OK\n * Estrae il file fileName, contenuto nel file fileCompressed, con il nome fileDest.\n * Se fileDest = \"\" allora il file viene estratto con lo stesso nome con cui e\n * stato compresso.\n * Se la funzione fallisce cancella il file che si e tentato di estrarre.\n * Restituisce il nome assoluto del file estratto.\n *\n * La funzione fallisce se:\n * * non si riesce ad aprire l'oggetto zip;\n * * l'estrazione del file fallisce;\n * * non si riesce a chiudere l'oggetto zip;\n */\nQString JlCompress::extractFile(QString fileCompressed, QString fileName, QString fileDest) {\n    // Apro lo zip\n    QuaZip zip(fileCompressed);\n    if(!zip.open(QuaZip::mdUnzip)) {\n        return QString();\n    }\n\n    // Estraggo il file\n    if (fileDest.isEmpty()) \n        fileDest = fileName;\n    if (!extractFile(\u0026zip,fileName,fileDest)) {\n        return QString();\n    }\n\n    // Chiudo il file zip\n    zip.close();\n    if(zip.getZipError()!=0) {\n        removeFile(QStringList(fileDest));\n        return QString();\n    }\n    return QFileInfo(fileDest).absoluteFilePath();\n}\n\n/**OK\n * Estrae i file specificati in files, contenuti nel file fileCompressed, nella\n * cartella dir. La struttura a cartelle del file compresso viene rispettata.\n * Se dir = \"\" allora il file viene estratto nella cartella corrente.\n * Se la funzione fallisce cancella i file che si e tentato di estrarre.\n * Restituisce i nomi assoluti dei file estratti.\n *\n * La funzione fallisce se:\n * * non si riesce ad aprire l'oggetto zip;\n * * l'estrazione di un file fallisce;\n * * non si riesce a chiudere l'oggetto zip;\n */\nQStringList JlCompress::extractFiles(QString fileCompressed, QStringList files, QString dir) {\n    // Creo lo zip\n    QuaZip zip(fileCompressed);\n    if(!zip.open(QuaZip::mdUnzip)) {\n        return QStringList();\n    }\n\n    // Estraggo i file\n    QStringList extracted;\n    for (int i=0; i\u003cfiles.count(); i++) {\n        QString absPath = QDir(dir).absoluteFilePath(files.at(i));\n        if (!extractFile(\u0026zip, files.at(i), absPath)) {\n            removeFile(extracted);\n            return QStringList();\n        }\n        extracted.append(absPath);\n    }\n\n    // Chiudo il file zip\n    zip.close();\n    if(zip.getZipError()!=0) {\n        removeFile(extracted);\n        return QStringList();\n    }\n\n    return extracted;\n}\n\n/**OK\n * Estrae il file fileCompressed nella cartella dir.\n * Se dir = \"\" allora il file viene estratto nella cartella corrente.\n * Se la funzione fallisce cancella i file che si e tentato di estrarre.\n * Restituisce i nomi assoluti dei file estratti.\n *\n * La funzione fallisce se:\n * * non si riesce ad aprire l'oggetto zip;\n * * la compressione di un file fallisce;\n * * non si riesce a chiudere l'oggetto zip;\n */\nQStringList JlCompress::extractDir(QString fileCompressed, QString dir) {\n    // Apro lo zip\n    QuaZip zip(fileCompressed);\n    if(!zip.open(QuaZip::mdUnzip)) {\n        return QStringList();\n    }\n\n    QDir directory(dir);\n    QStringList extracted;\n    if (!zip.goToFirstFile()) {\n        return QStringList();\n    }\n    do {\n        QString name = zip.getCurrentFileName();\n        QString absFilePath = directory.absoluteFilePath(name);\n        if (!extractFile(\u0026zip, \"\", absFilePath)) {\n            removeFile(extracted);\n            return QStringList();\n        }\n        extracted.append(absFilePath);\n    } while (zip.goToNextFile());\n\n    // Chiudo il file zip\n    zip.close();\n    if(zip.getZipError()!=0) {\n        removeFile(extracted);\n        return QStringList();\n    }\n\n    return extracted;\n}\n\n/**OK\n * Restituisce la lista dei file resenti nel file compresso fileCompressed.\n * Se la funzione fallisce, restituisce un elenco vuoto.\n *\n * La funzione fallisce se:\n * * non si riesce ad aprire l'oggetto zip;\n * * la richiesta di informazioni di un file fallisce;\n * * non si riesce a chiudere l'oggetto zip;\n */\nQStringList JlCompress::getFileList(QString fileCompressed) {\n    // Apro lo zip\n    QuaZip* zip = new QuaZip(QFileInfo(fileCompressed).absoluteFilePath());\n    if(!zip-\u003eopen(QuaZip::mdUnzip)) {\n        delete zip;\n        return QStringList();\n    }\n\n    // Estraggo i nomi dei file\n    QStringList lst;\n    QuaZipFileInfo info;\n    for(bool more=zip-\u003egoToFirstFile(); more; more=zip-\u003egoToNextFile()) {\n      if(!zip-\u003egetCurrentFileInfo(\u0026info)) {\n          delete zip;\n          return QStringList();\n      }\n      lst \u003c\u003c info.name;\n      //info.name.toLocal8Bit().constData()\n    }\n\n    // Chiudo il file zip\n    zip-\u003eclose();\n    if(zip-\u003egetZipError()!=0) {\n        delete zip;\n        return QStringList();\n    }\n    delete zip;\n\n    return lst;\n}\n\n"}
{"repo_name":"jobermayr/pcsx2","ref":"refs/heads/master","path":"3rdparty/wxwidgets3.0/src/common/filectrlcmn.cpp","copies":"123","language":"C++","content":"///////////////////////////////////////////////////////////////////////////////\n// Name:        src/common/filectrlcmn.cpp\n// Purpose:     Implementation for wxFileCtrlBase and other common functions used by\n//              platform-specific wxFileCtrl's\n// Author:      Diaa M. Sami\n// Created:     2007-07-07\n// Copyright:   (c) Diaa M. Sami\n// Licence:     wxWindows licence\n///////////////////////////////////////////////////////////////////////////////\n\n#include \"wx/wxprec.h\"\n\n#ifdef __BORLANDC__\n#pragma hdrstop\n#endif\n\n#if wxUSE_FILECTRL\n\n#include \"wx/filectrl.h\"\n\n#ifndef WX_PRECOMP\n#    include \"wx/debug.h\"\n#endif\n\nconst char wxFileCtrlNameStr[] = \"wxfilectrl\";\n\nwxDEFINE_EVENT( wxEVT_FILECTRL_SELECTIONCHANGED, wxFileCtrlEvent );\nwxDEFINE_EVENT( wxEVT_FILECTRL_FILEACTIVATED, wxFileCtrlEvent );\nwxDEFINE_EVENT( wxEVT_FILECTRL_FOLDERCHANGED, wxFileCtrlEvent );\nwxDEFINE_EVENT( wxEVT_FILECTRL_FILTERCHANGED, wxFileCtrlEvent );\n\nIMPLEMENT_DYNAMIC_CLASS( wxFileCtrlEvent, wxCommandEvent )\n\n// some helper functions\n\nvoid GenerateFilterChangedEvent( wxFileCtrlBase *fileCtrl, wxWindow *wnd )\n{\n    wxFileCtrlEvent event( wxEVT_FILECTRL_FILTERCHANGED, wnd, wnd-\u003eGetId() );\n\n    event.SetFilterIndex( fileCtrl-\u003eGetFilterIndex() );\n\n    wnd-\u003eGetEventHandler()-\u003eProcessEvent( event );\n}\n\nvoid GenerateFolderChangedEvent( wxFileCtrlBase *fileCtrl, wxWindow *wnd )\n{\n    wxFileCtrlEvent event( wxEVT_FILECTRL_FOLDERCHANGED, wnd, wnd-\u003eGetId() );\n\n    event.SetDirectory( fileCtrl-\u003eGetDirectory() );\n\n    wnd-\u003eGetEventHandler()-\u003eProcessEvent( event );\n}\n\nvoid GenerateSelectionChangedEvent( wxFileCtrlBase *fileCtrl, wxWindow *wnd)\n{\n    wxFileCtrlEvent event( wxEVT_FILECTRL_SELECTIONCHANGED, wnd, wnd-\u003eGetId() );\n    event.SetDirectory( fileCtrl-\u003eGetDirectory() );\n\n    wxArrayString filenames;\n    fileCtrl-\u003eGetFilenames( filenames );\n    event.SetFiles( filenames );\n\n    wnd-\u003eGetEventHandler()-\u003eProcessEvent( event );\n}\n\nvoid GenerateFileActivatedEvent( wxFileCtrlBase *fileCtrl, wxWindow *wnd, const wxString filename )\n{\n    wxFileCtrlEvent event( wxEVT_FILECTRL_FILEACTIVATED, wnd, wnd-\u003eGetId() );\n    event.SetDirectory( fileCtrl-\u003eGetDirectory() );\n\n    wxArrayString filenames;\n\n    if ( filename.empty() )\n    {\n        fileCtrl-\u003eGetFilenames( filenames );\n    }\n    else\n    {\n        filenames.Add( filename );\n    }\n\n    event.SetFiles( filenames );\n\n    wnd-\u003eGetEventHandler()-\u003eProcessEvent( event );\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// wxFileCtrlEvent implementation\n///////////////////////////////////////////////////////////////////////////////\n\nwxString wxFileCtrlEvent::GetFile() const\n{\n    wxASSERT_MSG( !wxDynamicCast( GetEventObject(), wxFileCtrl )-\u003eHasMultipleFileSelection(),\n                  wxT( \"Please use GetFiles() to get all files instead of this function\" ) );\n\n    wxString string;\n    if (m_files.Count() != 0)\n        string = m_files[0];\n    return string;\n}\n\n#endif // wxUSE_FILECTRL\n"}
{"repo_name":"AshamaneProject/AshamaneCore","ref":"refs/heads/master","path":"dep/CascLib/src/CascDecompress.cpp","copies":"5","language":"C++","content":"/*****************************************************************************/\n/* CascDecompress.cpp                     Copyright (c) Ladislav Zezula 2014 */\n/*---------------------------------------------------------------------------*/\n/* Decompression functions                                                   */\n/*---------------------------------------------------------------------------*/\n/*   Date    Ver   Who  Comment                                              */\n/* --------  ----  ---  -------                                              */\n/* 02.05.14  1.00  Lad  The first version of CascDecompress.cpp              */\n/*****************************************************************************/\n\n#define __CASCLIB_SELF__\n#include \"CascLib.h\"\n#include \"CascCommon.h\"\n\n//-----------------------------------------------------------------------------\n// Public functions\n\nDWORD CascDecompress(LPBYTE pbOutBuffer, PDWORD pcbOutBuffer, LPBYTE pbInBuffer, DWORD cbInBuffer)\n{\n    z_stream z;                        // Stream information for zlib\n    DWORD dwErrCode = ERROR_FILE_CORRUPT;\n    uInt cbOutBuffer = *pcbOutBuffer;\n    int nResult;\n\n    // Fill the stream structure for zlib\n    z.next_in   = pbInBuffer;\n    z.avail_in  = cbInBuffer;\n    z.total_in  = cbInBuffer;\n    z.next_out  = pbOutBuffer;\n    z.avail_out = cbOutBuffer;\n    z.total_out = 0;\n    z.zalloc    = NULL;\n    z.zfree     = NULL;\n\n    // Reset the total number of output bytes\n    cbOutBuffer = 0;\n\n    // Initialize the decompression structure\n    if((nResult = inflateInit(\u0026z)) == Z_OK)\n    {\n        // Call zlib to decompress the data\n        nResult = inflate(\u0026z, Z_NO_FLUSH);\n        if (nResult == Z_OK || nResult == Z_STREAM_END)\n        {\n            // Give the size of the uncompressed data\n            cbOutBuffer = z.total_out;\n            dwErrCode = ERROR_SUCCESS;\n        }\n\n        inflateEnd(\u0026z);\n    }\n\n    // Give the caller the number of bytes needed\n    pcbOutBuffer[0] = cbOutBuffer;\n    return dwErrCode;\n}\n"}
{"repo_name":"Riztazz/trinitycore-m4a","ref":"refs/heads/master","path":"src/server/scripts/EasternKingdoms/Stratholme/boss_nerubenkan.cpp","copies":"5","language":"C++","content":"/*\n * Copyright (C) 2008-2013 TrinityCore \u003chttp://www.trinitycore.org/\u003e\n * Copyright (C) 2006-2009 ScriptDev2 \u003chttps://scriptdev2.svn.sourceforge.net/\u003e\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the\n * Free Software Foundation; either version 2 of the License, or (at your\n * option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n * more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program. If not, see \u003chttp://www.gnu.org/licenses/\u003e.\n */\n\n/* ScriptData\nSDName: Boss_Nerubenkan\nSD%Complete: 70\nSDComment:\nSDCategory: Stratholme\nEndScriptData */\n\n#include \"stdafx.hpp\"\n#include \"ScriptMgr.h\"\n#include \"ScriptedCreature.h\"\n#include \"stratholme.h\"\n\nenum Spells\n{\n    SPELL_ENCASINGWEBS          = 4962,\n    SPELL_PIERCEARMOR           = 6016,\n    SPELL_CRYPT_SCARABS         = 31602,\n    SPELL_RAISEUNDEADSCARAB     = 17235\n};\n\nclass boss_nerubenkan : public CreatureScript\n{\npublic:\n    boss_nerubenkan() : CreatureScript(\"boss_nerubenkan\") { }\n\n    CreatureAI* GetAI(Creature* creature) const\n    {\n        return new boss_nerubenkanAI (creature);\n    }\n\n    struct boss_nerubenkanAI : public ScriptedAI\n    {\n        boss_nerubenkanAI(Creature* creature) : ScriptedAI(creature)\n        {\n            instance = me-\u003eGetInstanceScript();\n        }\n\n        InstanceScript* instance;\n\n        uint32 EncasingWebs_Timer;\n        uint32 PierceArmor_Timer;\n        uint32 CryptScarabs_Timer;\n        uint32 RaiseUndeadScarab_Timer;\n\n        void Reset()\n        {\n            CryptScarabs_Timer = 3000;\n            EncasingWebs_Timer = 7000;\n            PierceArmor_Timer = 19000;\n            RaiseUndeadScarab_Timer = 3000;\n        }\n\n        void EnterCombat(Unit* /*who*/)\n        {\n        }\n\n        void JustDied(Unit* /*killer*/)\n        {\n            if (instance)\n                instance-\u003eSetData(TYPE_NERUB, IN_PROGRESS);\n        }\n\n        void RaiseUndeadScarab(Unit* victim)\n        {\n            if (Creature* pUndeadScarab = DoSpawnCreature(10876, float(irand(-9, 9)), float(irand(-9, 9)), 0, 0, TEMPSUMMON_TIMED_OR_CORPSE_DESPAWN, 180000))\n                if (pUndeadScarab-\u003eAI())\n                    pUndeadScarab-\u003eAI()-\u003eAttackStart(victim);\n        }\n\n        void UpdateAI(const uint32 diff)\n        {\n            if (!UpdateVictim())\n                return;\n\n            //EncasingWebs\n            if (EncasingWebs_Timer \u003c= diff)\n            {\n                DoCast(me-\u003egetVictim(), SPELL_ENCASINGWEBS);\n                EncasingWebs_Timer = 30000;\n            } else EncasingWebs_Timer -= diff;\n\n            //PierceArmor\n            if (PierceArmor_Timer \u003c= diff)\n            {\n                if (urand(0, 3) \u003c 2)\n                    DoCast(me-\u003egetVictim(), SPELL_PIERCEARMOR);\n                PierceArmor_Timer = 35000;\n            } else PierceArmor_Timer -= diff;\n\n            //CryptScarabs_Timer\n            if (CryptScarabs_Timer \u003c= diff)\n            {\n                DoCast(me-\u003egetVictim(), SPELL_CRYPT_SCARABS);\n                CryptScarabs_Timer = 20000;\n            } else CryptScarabs_Timer -= diff;\n\n            //RaiseUndeadScarab\n            if (RaiseUndeadScarab_Timer \u003c= diff)\n            {\n                RaiseUndeadScarab(me-\u003egetVictim());\n                RaiseUndeadScarab_Timer = 16000;\n            } else RaiseUndeadScarab_Timer -= diff;\n\n            DoMeleeAttackIfReady();\n        }\n    };\n\n};\n\nvoid AddSC_boss_nerubenkan()\n{\n    new boss_nerubenkan();\n}\n"}
{"repo_name":"atidot3/Orizon-510","ref":"refs/heads/master","path":"src/server/authserver/Main.cpp","copies":"18","language":"C++","content":"/*\n * Copyright (C) 2008-2012 TrinityCore \u003chttp://www.trinitycore.org/\u003e\n * Copyright (C) 2005-2009 MaNGOS \u003chttp://getmangos.com/\u003e\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the\n * Free Software Foundation; either version 2 of the License, or (at your\n * option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n * more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program. If not, see \u003chttp://www.gnu.org/licenses/\u003e.\n */\n/**\n* @file main.cpp\n* @brief Authentication Server main program\n*\n* This file contains the main program for the\n* authentication server\n*/\n#include \u003cace/Dev_Poll_Reactor.h\u003e\n#include \u003cace/TP_Reactor.h\u003e\n#include \u003cace/ACE.h\u003e\n#include \u003cace/Sig_Handler.h\u003e\n#include \u003copenssl/opensslv.h\u003e\n#include \u003copenssl/crypto.h\u003e\n\n#include \"Common.h\"\n#include \"Database/DatabaseEnv.h\"\n#include \"Configuration/Config.h\"\n#include \"Log.h\"\n#include \"SystemConfig.h\"\n#include \"Util.h\"\n#include \"SignalHandler.h\"\n#include \"RealmList.h\"\n#include \"RealmAcceptor.h\"\n\n#ifndef _TRINITY_REALM_CONFIG\n# define _TRINITY_REALM_CONFIG  \"authserver.conf\"\n#endif\n\nbool StartDB();\nvoid StopDB();\n\nbool stopEvent = false;                                     // Setting it to true stops the server\n\nLoginDatabaseWorkerPool LoginDatabase;                      // Accessor to the auth server database\n\n/// Handle authserver's termination signals\nclass AuthServerSignalHandler : public Trinity::SignalHandler\n{\npublic:\n    virtual void HandleSignal(int SigNum)\n    {\n        switch (SigNum)\n        {\n        case SIGINT:\n        case SIGTERM:\n            stopEvent = true;\n            break;\n        }\n    }\n};\n\n/// Print out the usage string for this program on the console.\nvoid usage(const char *prog)\n{\n    sLog-\u003eoutInfo(LOG_FILTER_AUTHSERVER, \"Usage: \\n %s [\u003coptions\u003e]\\n\"\n        \"    -c config_file           use config_file as configuration file\\n\\r\",\n        prog);\n}\n\n/// Launch the auth server\nextern int main(int argc, char **argv)\n{\n    // Command line parsing to get the configuration file name\n    char const* cfg_file = _TRINITY_REALM_CONFIG;\n    int c = 1;\n    while (c \u003c argc)\n    {\n        if (strcmp(argv[c], \"-c\") == 0)\n        {\n            if (++c \u003e= argc)\n            {\n                printf(\"Runtime-Error: -c option requires an input argument\\n\");\n                usage(argv[0]);\n                return 1;\n            }\n            else\n                cfg_file = argv[c];\n        }\n        ++c;\n    }\n\n    if (!ConfigMgr::Load(cfg_file))\n    {\n        printf(\"Invalid or missing configuration file : %s\\n\", cfg_file);\n        printf(\"Verify that the file exists and has \\'[authserver]\\' written in the top of the file!\\n\");\n        return 1;\n    }\n\n    sLog-\u003eoutInfo(LOG_FILTER_AUTHSERVER, \"%s (authserver)\", _FULLVERSION);\n    sLog-\u003eoutInfo(LOG_FILTER_AUTHSERVER, \"\u003cCtrl-C\u003e to stop.\\n\");\n    sLog-\u003eoutInfo(LOG_FILTER_AUTHSERVER, \"Using configuration file %s.\", cfg_file);\n\n    sLog-\u003eoutWarn(LOG_FILTER_AUTHSERVER, \"%s (Library: %s)\", OPENSSL_VERSION_TEXT, SSLeay_version(SSLEAY_VERSION));\n\n#if defined (ACE_HAS_EVENT_POLL) || defined (ACE_HAS_DEV_POLL)\n    ACE_Reactor::instance(new ACE_Reactor(new ACE_Dev_Poll_Reactor(ACE::max_handles(), 1), 1), true);\n#else\n    ACE_Reactor::instance(new ACE_Reactor(new ACE_TP_Reactor(), true), true);\n#endif\n\n    sLog-\u003eoutDebug(LOG_FILTER_AUTHSERVER, \"Max allowed open files is %d\", ACE::max_handles());\n\n    // authserver PID file creation\n    std::string pidfile = ConfigMgr::GetStringDefault(\"PidFile\", \"\");\n    if (!pidfile.empty())\n    {\n        uint32 pid = CreatePIDFile(pidfile);\n        if (!pid)\n        {\n            sLog-\u003eoutError(LOG_FILTER_AUTHSERVER, \"Cannot create PID file %s.\\n\", pidfile.c_str());\n            return 1;\n        }\n        sLog-\u003eoutInfo(LOG_FILTER_AUTHSERVER, \"Daemon PID: %u\\n\", pid);\n    }\n\n    // Initialize the database connection\n    if (!StartDB())\n        return 1;\n\n    sLog-\u003eSetRealmID(0);                                               // ensure we've set realm to 0 (authserver realmid)\n\n    // Get the list of realms for the server\n    sRealmList-\u003eInitialize(ConfigMgr::GetIntDefault(\"RealmsStateUpdateDelay\", 20));\n    if (sRealmList-\u003esize() == 0)\n    {\n        sLog-\u003eoutError(LOG_FILTER_AUTHSERVER, \"No valid realms specified.\");\n        return 1;\n    }\n\n    // Launch the listening network socket\n    RealmAcceptor acceptor;\n\n    int32 rmport = ConfigMgr::GetIntDefault(\"RealmServerPort\", 3724);\n    if (rmport \u003c 0 || rmport \u003e 0xFFFF)\n    {\n        sLog-\u003eoutError(LOG_FILTER_AUTHSERVER, \"Specified port out of allowed range (1-65535)\");\n        return 1;\n    }\n\n    std::string bind_ip = ConfigMgr::GetStringDefault(\"BindIP\", \"0.0.0.0\");\n\n    ACE_INET_Addr bind_addr(uint16(rmport), bind_ip.c_str());\n\n    if (acceptor.open(bind_addr, ACE_Reactor::instance(), ACE_NONBLOCK) == -1)\n    {\n        sLog-\u003eoutError(LOG_FILTER_AUTHSERVER, \"Auth server can not bind to %s:%d\", bind_ip.c_str(), rmport);\n        return 1;\n    }\n\n    // Initialise the signal handlers\n    AuthServerSignalHandler SignalINT, SignalTERM;\n\n    // Register authservers's signal handlers\n    ACE_Sig_Handler Handler;\n    Handler.register_handler(SIGINT, \u0026SignalINT);\n    Handler.register_handler(SIGTERM, \u0026SignalTERM);\n\n    ///- Handle affinity for multiple processors and process priority on Windows\n#ifdef _WIN32\n    {\n        HANDLE hProcess = GetCurrentProcess();\n\n        uint32 Aff = ConfigMgr::GetIntDefault(\"UseProcessors\", 0);\n        if (Aff \u003e 0)\n        {\n            ULONG_PTR appAff;\n            ULONG_PTR sysAff;\n\n            if (GetProcessAffinityMask(hProcess, \u0026appAff, \u0026sysAff))\n            {\n                ULONG_PTR curAff = Aff \u0026 appAff;            // remove non accessible processors\n\n                if (!curAff)\n                    sLog-\u003eoutError(LOG_FILTER_AUTHSERVER, \"Processors marked in UseProcessors bitmask (hex) %x not accessible for authserver. Accessible processors bitmask (hex): %x\", Aff, appAff);\n                else if (SetProcessAffinityMask(hProcess, curAff))\n                    sLog-\u003eoutInfo(LOG_FILTER_AUTHSERVER, \"Using processors (bitmask, hex): %x\", curAff);\n                else\n                    sLog-\u003eoutError(LOG_FILTER_AUTHSERVER, \"Can't set used processors (hex): %x\", curAff);\n            }\n\n        }\n\n        bool Prio = ConfigMgr::GetBoolDefault(\"ProcessPriority\", false);\n\n        if (Prio)\n        {\n            if (SetPriorityClass(hProcess, HIGH_PRIORITY_CLASS))\n                sLog-\u003eoutInfo(LOG_FILTER_AUTHSERVER, \"The auth server process priority class has been set to HIGH\");\n            else\n                sLog-\u003eoutError(LOG_FILTER_AUTHSERVER, \"Can't set auth server process priority class.\");\n\n        }\n    }\n#endif\n\n    // maximum counter for next ping\n    uint32 numLoops = (ConfigMgr::GetIntDefault(\"MaxPingTime\", 30) * (MINUTE * 1000000 / 100000));\n    uint32 loopCounter = 0;\n\n    // Wait for termination signal\n    while (!stopEvent)\n    {\n        // dont move this outside the loop, the reactor will modify it\n        ACE_Time_Value interval(0, 100000);\n\n        if (ACE_Reactor::instance()-\u003erun_reactor_event_loop(interval) == -1)\n            break;\n\n        if ((++loopCounter) == numLoops)\n        {\n            loopCounter = 0;\n            sLog-\u003eoutInfo(LOG_FILTER_AUTHSERVER, \"Ping MySQL to keep connection alive\");\n            LoginDatabase.KeepAlive();\n        }\n    }\n\n    // Close the Database Pool and library\n    StopDB();\n\n    sLog-\u003eoutInfo(LOG_FILTER_AUTHSERVER, \"Halting process...\");\n    return 0;\n}\n\n/// Initialize connection to the database\nbool StartDB()\n{\n    MySQL::Library_Init();\n\n    std::string dbstring = ConfigMgr::GetStringDefault(\"LoginDatabaseInfo\", \"\");\n    if (dbstring.empty())\n    {\n        sLog-\u003eoutError(LOG_FILTER_AUTHSERVER, \"Database not specified\");\n        return false;\n    }\n\n    int32 worker_threads = ConfigMgr::GetIntDefault(\"LoginDatabase.WorkerThreads\", 1);\n    if (worker_threads \u003c 1 || worker_threads \u003e 32)\n    {\n        sLog-\u003eoutError(LOG_FILTER_AUTHSERVER, \"Improper value specified for LoginDatabase.WorkerThreads, defaulting to 1.\");\n        worker_threads = 1;\n    }\n\n    int32 synch_threads = ConfigMgr::GetIntDefault(\"LoginDatabase.SynchThreads\", 1);\n    if (synch_threads \u003c 1 || synch_threads \u003e 32)\n    {\n        sLog-\u003eoutError(LOG_FILTER_AUTHSERVER, \"Improper value specified for LoginDatabase.SynchThreads, defaulting to 1.\");\n        synch_threads = 1;\n    }\n\n    // NOTE: While authserver is singlethreaded you should keep synch_threads == 1. Increasing it is just silly since only 1 will be used ever.\n    if (!LoginDatabase.Open(dbstring.c_str(), uint8(worker_threads), uint8(synch_threads)))\n    {\n        sLog-\u003eoutError(LOG_FILTER_AUTHSERVER, \"Cannot connect to database\");\n        return false;\n    }\n\n    sLog-\u003eoutInfo(LOG_FILTER_AUTHSERVER, \"Started auth database connection pool.\");\n    sLog-\u003eEnableDBAppenders();\n    return true;\n}\n\n/// Close the connection to the database\nvoid StopDB()\n{\n    LoginDatabase.Close();\n    MySQL::Library_End();\n}\n"}
{"repo_name":"daedalus/iodoom3","ref":"refs/heads/master","path":"neo/tools/materialeditor/MaterialDocManager.cpp","copies":"58","language":"C++","content":"/*\n===========================================================================\n\nDoom 3 GPL Source Code\nCopyright (C) 1999-2011 id Software LLC, a ZeniMax Media company. \n\nThis file is part of the Doom 3 GPL Source Code (?Doom 3 Source Code?).  \n\nDoom 3 Source Code is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nDoom 3 Source Code is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Doom 3 Source Code.  If not, see \u003chttp://www.gnu.org/licenses/\u003e.\n\nIn addition, the Doom 3 Source Code is also subject to certain additional terms. You should have received a copy of these additional terms immediately following the terms and conditions of the GNU General Public License which accompanied the Doom 3 Source Code.  If not, please request a copy in writing from id Software at the address below.\n\nIf you have questions concerning this license or the applicable additional terms, you may contact in writing id Software LLC, c/o ZeniMax Media Inc., Suite 120, Rockville, Maryland 20850 USA.\n\n===========================================================================\n*/\n\n#include \"../../idlib/precompiled.h\"\n#pragma hdrstop\n\n#include \"MaterialDocManager.h\"\n#include \"MaterialView.h\"\n\n\n/**\n* Constructor for MaterialDocManager.\n*/\nMaterialDocManager::MaterialDocManager(void) {\n\tcurrentMaterial = NULL;\n\tcutMaterial = false;\n}\n\n/**\n* Destructor for MaterialDocManager.\n*/\nMaterialDocManager::~MaterialDocManager(void) {\n\tUnRegisterAllMaterialViews();\n\n\tClearUndo();\n\tClearRedo();\n}\n\n/**\n* Registers an object to receive notifications about changes made to materials.\n* @param view The object that would like to receive material notifications.\n*/\nvoid MaterialDocManager::RegisterMaterialView(MaterialView* view) {\n\tASSERT(view);\n\tUnRegisterMaterialView(view);\n\tmaterialViews.Append(view);\n\n\t//Notify the view of myself\n\tview-\u003eSetMaterialDocManager(this);\n}\n\n/**\n* Tells the MaterialDocManager to stop sending notifications to a view.\n* @param view The view that no longer wants notifications.\n*/\nvoid MaterialDocManager::UnRegisterMaterialView(MaterialView* view) {\n\tASSERT(view);\n\tmaterialViews.Remove(view);\n\n\t//Remove the reference to myself\n\tview-\u003eSetMaterialDocManager(NULL);\n}\n\n/**\n* Unregisters all of the views that are registered to get material change\n* notifications.\n*/\nvoid MaterialDocManager::UnRegisterAllMaterialViews() {\n\t\n\t//Remove the reference to myself\n\tint c = materialViews.Num();\n\tfor(int i = 0; i \u003c c; i++) {\n\t\tmaterialViews[i]-\u003eSetMaterialDocManager(NULL);\n\t}\n\tmaterialViews.Clear();\n}\n\n/**\n* Tells the MaterialDocManager which material has been selected for editing.\n* @param material The material that has been selected.\n*/\nvoid MaterialDocManager::SetSelectedMaterial(idMaterial* material) {\n\n\tbool change = false;\n\n\t//Do we need to change the material\n\tif(material) {\n\t\tif(currentMaterial) {\n\t\t\tif(strcmp(material-\u003eGetName(), currentMaterial-\u003erenderMaterial-\u003eGetName())) {\n\t\t\t\tchange = true;\n\t\t\t}\n\t\t} else {\n\t\t\tchange = true;\n\t\t}\n\t} else {\n\t\tif(currentMaterial) {\n\t\t\tchange = true;\n\t\t}\n\t}\n\t\n\t//Now make the change\n\tif(change) {\n\t\tif(currentMaterial) {\n\n\t\t\t//Delete the material unless it has been changed\n\t\t\tif(!inProgressMaterials.Get(currentMaterial-\u003ename.c_str())) {\n\t\t\t\tdelete currentMaterial;\n\t\t\t\tcurrentMaterial = NULL;\n\t\t\t}\n\t\t}\n\n\t\tMaterialDoc** tempDoc;\n\t\tif(material \u0026\u0026 inProgressMaterials.Get(material-\u003eGetName(), \u0026tempDoc)) {\n\t\t\tcurrentMaterial = *tempDoc;\n\t\t\t\n\t\t} else {\n\t\t\tcurrentMaterial = CreateMaterialDoc(material);\n\t\t}\n\n\t\tNotifyViews(currentMaterial, SELECTION_CHANGE);\n\t}\n}\n\n/**\n* Returns true if the specified file needs to be applied and false otherwise.\n*/\nbool MaterialDocManager::DoesFileNeedApply(const char* filename) {\n\tfor(int i = 0; i \u003c inProgressMaterials.Num(); i++) {\n\t\tMaterialDoc** pDoc = inProgressMaterials.GetIndex(i);\n\t\tif(!strcmp((*pDoc)-\u003erenderMaterial-\u003eGetFileName(), filename) \u0026\u0026 (*pDoc)-\u003eapplyWaiting)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\n/**\n* Returns true if any material needs to be applied.\n*/\nbool MaterialDocManager::DoesAnyNeedApply() {\n\tfor(int i = 0; i \u003c inProgressMaterials.Num(); i++) {\n\t\tMaterialDoc** pDoc = inProgressMaterials.GetIndex(i);\n\t\tif((*pDoc)-\u003eapplyWaiting)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\n/**\n* Returns true if the specified file has been modified.\n*/\nbool MaterialDocManager::IsFileModified(const char* filename) {\n\tfor(int i = 0; i \u003c inProgressMaterials.Num(); i++) {\n\t\tMaterialDoc** pDoc = inProgressMaterials.GetIndex(i);\n\t\tif(!strcmp((*pDoc)-\u003erenderMaterial-\u003eGetFileName(), filename))\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\n/**\n* Returns true if any material has been modified.\n*/\nbool MaterialDocManager::IsAnyModified() {\n\treturn (inProgressMaterials.Num() \u003e 0);\n}\n\n/**\n* Adds a material.\n* @param name The name of the material.\n* @param filename The file to place the material in.\n* @param sourceText The initial material definition.\n* @param addUndo Can this operation be undone.\n*/\nvoid MaterialDocManager::AddMaterial(const char* name, const char* filename, const char* sourceText, bool addUndo) {\n\t\n\tif(addUndo) {\n\t\tAddMaterialModifier* mod = new AddMaterialModifier(this, name, filename);\n\t\tAddMaterialUndoModifier(mod);\n\t}\n\n\tMaterialDoc* newDoc = new MaterialDoc();\n\tnewDoc-\u003emanager = this;\n\tnewDoc-\u003emodified = true;\n\t\n\tidMaterial* rendMat = (idMaterial*)declManager-\u003eCreateNewDecl(DECL_MATERIAL, name, filename);\n\t\n\tif(sourceText) {\n\t\trendMat-\u003eSetText(sourceText);\n\t}\n\n\tnewDoc-\u003eSetRenderMaterial(rendMat, true, sourceText ? true : false);\n\n\tinProgressMaterials.Set(newDoc-\u003ename.c_str(), newDoc);\n\t\n\tNotifyViews(newDoc, MATERIAL_ADD);\n\n\t//Force an apply so the text will be generated to match the new file\n\tnewDoc-\u003eapplyWaiting = true;\n\tnewDoc-\u003eApplyMaterialChanges();\n}\n\n/**\n* Used to redo an add material and undo a delete material. \n* The undo for adding a material deletes the material. Instead of adding a completely\n* new material RedoAddMaterial finds the one that was just deleted and uses that. \n* @param name The name of the material that was added/deleted.\n* @param clearData Should the material definition be reset to the default definition.\n*/\nvoid MaterialDocManager::RedoAddMaterial(const char* name, bool clearData) {\n\n\tMaterialDoc* newDoc = new MaterialDoc();\n\tnewDoc-\u003emanager = this;\n\tnewDoc-\u003emodified = true;\n\n\tidMaterial* rendMat = const_cast\u003cidMaterial *\u003e(declManager-\u003eFindMaterial(name, false));\n\n\tif(clearData) {\n\t\trendMat-\u003eSetText(rendMat-\u003eDefaultDefinition());\n\t}\n\n\tnewDoc-\u003eSetRenderMaterial(rendMat, true, true);\n\n\tinProgressMaterials.Set(newDoc-\u003ename.c_str(), newDoc);\n\n\tNotifyViews(newDoc, MATERIAL_ADD);\n\n\t//Force an apply so the text will be generated to match the new file\n\tnewDoc-\u003eapplyWaiting = true;\n\tnewDoc-\u003eApplyMaterialChanges();\n}\n\n/**\n* Deletes a material.\n* @param material The material to be deleted.\n* @param addUndo Can this operation be undone.\n*/\nvoid MaterialDocManager::DeleteMaterial(MaterialDoc* material, bool addUndo) {\n\t\n\tassert(material);\n\n\t//This will just flag for delete. The actual delete will happen during the save\n\tmaterial-\u003eDelete();\n\n\tif(addUndo) {\n\t\tDeleteMaterialModifier* mod = new DeleteMaterialModifier(this, material-\u003ename);\n\t\tAddMaterialUndoModifier(mod);\n\t}\n\n\tNotifyViews(material, MATERIAL_DELETE);\n}\n\n/**\n* Applys changes to a material.\n* @param materialDoc The material to be applied.\n*/\nvoid MaterialDocManager::ApplyMaterial(MaterialDoc* materialDoc) {\n\tassert(materialDoc);\n\tmaterialDoc-\u003eApplyMaterialChanges();\n}\n\n/**\n* Applies all materials in the specified filename.\n* @param filename The file to apply.\n*/\nvoid MaterialDocManager::ApplyFile(const char* filename) {\n\t\n\tfor(int i = 0; i \u003c inProgressMaterials.Num(); i++) {\n\t\tMaterialDoc** pDoc = inProgressMaterials.GetIndex(i);\n\t\tif(!strcmp((*pDoc)-\u003erenderMaterial-\u003eGetFileName(), filename))\n\t\t\t(*pDoc)-\u003eApplyMaterialChanges();\n\t}\n}\n\n/**\n* Applies all materials that have been changed.\n*/\nvoid MaterialDocManager::ApplyAll() {\n\tfor(int i = 0; i \u003c inProgressMaterials.Num(); i++) {\n\t\tMaterialDoc** pDoc = inProgressMaterials.GetIndex(i);\n\t\t(*pDoc)-\u003eApplyMaterialChanges();\n\t}\n}\n\n/**\n* Saves a single material.\n* @param material The material to save.\n*/\nvoid MaterialDocManager::SaveMaterial(MaterialDoc* material) {\n\tassert(material);\n\tmaterial-\u003eSave();\n}\n\n/**\n* Saves all materials in the specified file.\n* @param filename The file to save.\n*/\nvoid MaterialDocManager::SaveFile(const char* filename) {\n\t\n\tfor(int i = inProgressMaterials.Num()-1; i \u003e= 0; i--) {\n\t\tMaterialDoc** pDoc = inProgressMaterials.GetIndex(i);\n\t\tif(!strcmp((*pDoc)-\u003erenderMaterial-\u003eGetFileName(), filename))\n\t\t\t(*pDoc)-\u003eSave();\n\t}\n\n\t//Notify everyone\n\tNotifyViews(NULL, MATERIAL_SAVE_FILE, filename);\n}\n\n/**\n* Saves all materials that have been changed.\n*/\nvoid MaterialDocManager::SaveAllMaterials() {\n\tfor(int i = inProgressMaterials.Num()-1; i \u003e= 0; i--) {\n\t\tMaterialDoc** pDoc = inProgressMaterials.GetIndex(i);\n\t\t(*pDoc)-\u003eSave();\n\t}\n}\n\n/**\n* Reloads a specified file.\n* @param filename The file to reload.\n*/\nvoid MaterialDocManager::ReloadFile(const char *filename) {\n\t\n\tdeclManager-\u003eReloadFile(filename, true);\n\t\t\t\n\t//purge the changes of any in progress materials\n\tfor(int j = inProgressMaterials.Num()-1; j \u003e= 0; j--) {\n\t\tMaterialDoc** pDoc = inProgressMaterials.GetIndex(j);\n\t\tif(!strcmp((*pDoc)-\u003erenderMaterial-\u003eGetFileName(), filename)) {\n\t\t\t(*pDoc)-\u003eSetRenderMaterial((*pDoc)-\u003erenderMaterial);\n\t\t\tinProgressMaterials.Remove((*pDoc)-\u003ename);\n\t\t}\n\t}\n\t\n\t//Reparse the current material\n\tif(currentMaterial) {\n\t\tcurrentMaterial-\u003eSetRenderMaterial(currentMaterial-\u003erenderMaterial);\n\n\t\t//Trigger all the views to refresh\n\t\tNotifyViews(currentMaterial, SELECTION_CHANGE);\n\t}\n\n\tNotifyViews(NULL, FILE_RELOAD, filename);\n}\n\n/**\n* Creates a MaterialDoc object for the specified material name. If a MaterialDoc \n* object already exists then it is used.\n* @param materialName The name of the material for which to create a MaterialDoc object.\n*/\nMaterialDoc* MaterialDocManager::CreateMaterialDoc(const char* materialName) {\n\t\n\tconst idMaterial* material = declManager-\u003eFindMaterial(materialName);\n\treturn CreateMaterialDoc(const_cast\u003cidMaterial *\u003e(material));\n}\n\n/**\n* Creates a MaterialDoc object for the specified material. If a MaterialDoc \n* object already exists then it is used.\n* @param material The material for which to create a MaterialDoc object.\n*/\nMaterialDoc* MaterialDocManager::CreateMaterialDoc(idMaterial* material) {\n\n\tMaterialDoc* existingDoc = GetInProgressDoc(material);\n\tif(existingDoc) {\n\t\treturn existingDoc;\n\t}\n\n\tif(currentMaterial \u0026\u0026 material \u0026\u0026 !currentMaterial-\u003ename.Icmp(material-\u003eGetName())) {\n\t\treturn currentMaterial;\n\t}\n\n\tif(material) {\n\t\tMaterialDoc* newDoc = new MaterialDoc();\n\t\tnewDoc-\u003emanager = this;\n\t\tnewDoc-\u003eSetRenderMaterial(material);\n\t\t\n\t\treturn newDoc;\n\t}\n\n\treturn NULL;\n}\n\n/**\n* Checks the current list of in progress MaterialDoc objects to see if\n* a MaterialDoc object already exists.\n* @param material The material to check for.\n*/\nMaterialDoc* MaterialDocManager::GetInProgressDoc(idMaterial* material) {\n\n\tif(material) {\n\t\tfor(int i = 0; i \u003c inProgressMaterials.Num(); i++) {\n\t\t\tMaterialDoc** pDoc = inProgressMaterials.GetIndex(i);\n\n\t\t\tif(!(*pDoc)-\u003ename.Icmp(material-\u003eGetName()))\n\t\t\t\treturn *pDoc;\n\t\t}\n\t}\n\treturn NULL;\n}\n\n/**\n* Prepares a material for a copy/cut and paste operations.\n* @param materialDoc The material to copy.\n* @param cut Is this a cut operation.\n*/\nvoid MaterialDocManager::CopyMaterial(MaterialDoc* materialDoc, bool cut) {\n\t\n\tcutMaterial = cut;\n\n\tif(materialDoc)\n\t\tcopyMaterial = materialDoc-\u003ename;\n\telse\n\t\tClearCopy();\n}\n\n/**\n* Clears the copy buffer for a material.\n*/\nvoid MaterialDocManager::ClearCopy() {\n\tcopyMaterial.Empty();\n}\n\n/**\n* Returns true if there is a material in the copy buffer.\n*/\nbool MaterialDocManager::IsCopyMaterial() {\n\treturn (copyMaterial.Length() ) ? true : false;\n}\n\n/**\n* Returns the name of the material in the copy buffer.\n*/\nidStr MaterialDocManager::GetCopyMaterialName() {\n\treturn copyMaterial;\n}\n\n/**\n* Performs a material paste operation for a material in the copy buffer.\n* @param name The new name for the material that is being copied.\n* @param filename The file to paste the material in.\n*/\nvoid MaterialDocManager::PasteMaterial(const char* name, const char* filename) {\n\t\n\tif(!IsCopyMaterial()) {\n\t\treturn;\n\t}\n\n\t//Apply the material if there are some changes\n\tMaterialDoc* copyMat = CreateMaterialDoc(copyMaterial);\n\tif(copyMat-\u003eapplyWaiting) {\n\t\tcopyMat-\u003eApplyMaterialChanges();\n\t}\n\t//Paste the material\n\tidMaterial* material = copyMat-\u003erenderMaterial;\n\n\t//Add a material with the existing source text\n\tchar *declText = (char *) _alloca( material-\u003eGetTextLength() + 1 );\n\tmaterial-\u003eGetText( declText );\n\n\tAddMaterial(name, filename, declText, !cutMaterial);\n\n\t//If this is a cut then remove the original\n\tif(cutMaterial) {\n\t\tMaterialDoc* cutMaterial = CreateMaterialDoc(material);\n\t\tDeleteMaterial(cutMaterial, false);\n\n\t\tMoveMaterialModifier* mod = new MoveMaterialModifier(this, name, filename, copyMaterial);\n\t\tAddMaterialUndoModifier(mod);\n\n\t\tClearCopy();\n\t}\n\t\n}\n\n/**\n* Prepares a material stage for a copy/paste operation.\n* @param materialDoc The materialDoc that contains the stage to be copied.\n* @param stageNum the stage to copy.\n*/\nvoid MaterialDocManager::CopyStage(MaterialDoc* materialDoc, int stageNum) {\n\n\tassert(materialDoc);\n\n\tcopyStageMaterial = materialDoc-\u003ename;\n\tcopyStage = materialDoc-\u003eGetStage(stageNum);\n\t\n\tidStr stageName = copyStage.stageData.GetString(\"name\");\n}\n\n/**\n* Clears the copy buffer for copied stages.\n*/\nvoid MaterialDocManager::ClearCopyStage() {\n\tcopyStageMaterial.Empty();\n\tcopyStage.stageData.Clear();\n}\n\n/**\n* Returns true if there is a stage in the copy buffer.\n*/\nbool MaterialDocManager::IsCopyStage() {\n\treturn (copyStageMaterial.Length() ) ? true : false;\n}\n\n/**\n* Performs a paste operation of the stage in the copy buffer.\n* @param materialDoc The materialDoc to paste the stage in.\n*/\nvoid MaterialDocManager::PasteStage(MaterialDoc* materialDoc) {\n\n\tassert(materialDoc);\n\n\tint stageType = copyStage.stageData.GetInt(\"stagetype\");\n\n\t//Create a new stage and copy the data\n\tmaterialDoc-\u003eAddStage(stageType, copyStage.stageData.GetString(\"name\"));\n\tmaterialDoc-\u003eSetData(materialDoc-\u003eGetStageCount()-1, \u0026copyStage.stageData);\n}\n\n/**\n* Returns information about the stage in the copy buffer.\n* @param type Holds the type of the stage in the copy buffer.\n* @param name Hold the name of the stage in the copy buffer.\n*/\nvoid MaterialDocManager::GetCopyStageInfo(int\u0026 type, idStr\u0026 name) {\n\tif(IsCopyStage()) {\n\t\ttype = copyStage.stageData.GetInt(\"stagetype\");\n\t\tname = copyStage.stageData.GetString(\"name\");\n\t}\n}\n\n/**\n* Performs the first available undo operation.\n*/\nvoid MaterialDocManager::Undo() {\n\n\tif(IsUndoAvailable()) {\n\t\tMaterialModifier* mod = undoModifiers[undoModifiers.Num()-1];\n\t\tundoModifiers.RemoveIndex(undoModifiers.Num()-1);\n\n\t\tmod-\u003eUndo();\n\n\t\t//Add this modifier to the redo list\n\t\tAddMaterialRedoModifier(mod);\n\t}\n}\n\n/**\n* Returns true if an undo operation is available.\n*/\nbool MaterialDocManager::IsUndoAvailable() {\n\treturn (undoModifiers.Num() \u003e 0);\n}\n\n/**\n* Clears the entire undo buffer.\n*/\nvoid MaterialDocManager::ClearUndo() {\n\n\tint c = undoModifiers.Num();\n\tfor(int i = 0; i \u003c c; i++) {\n\t\tdelete undoModifiers[i];\n\t}\n\tundoModifiers.Clear();\n}\n\n/**\n* Performs the first available redo operation.\n*/\nvoid MaterialDocManager::Redo() {\n\n\tif(IsRedoAvailable()) {\n\t\tMaterialModifier* mod = redoModifiers[redoModifiers.Num()-1];\n\t\tredoModifiers.RemoveIndex(redoModifiers.Num()-1);\n\n\t\tmod-\u003eRedo();\n\n\t\t//Done with the mod because the redo process will set \n\t\t//attributes and create the appropriate redo modifier\n\t\tAddMaterialUndoModifier(mod, false);\t\t\n\t}\n}\n\n/**\n* Returns true if a redo operation is available.\n*/\nbool MaterialDocManager::IsRedoAvailable() {\n\treturn (redoModifiers.Num() \u003e 0);\n}\n\n/**\n* Clears the redo buffer.\n*/\nvoid MaterialDocManager::ClearRedo() {\n\n\tint c = redoModifiers.Num();\n\tfor(int i = 0; i \u003c c; i++) {\n\t\tdelete redoModifiers[i];\n\t}\n\tredoModifiers.Clear();\n}\n\n/**\n* Adds an undo operation to the undo buffer.\n* @param mod The MaterialModifier object that contains the undo data.\n* @param clearRedo Should we clear the redo buffer.\n*/\nvoid  MaterialDocManager::AddMaterialUndoModifier(MaterialModifier* mod, bool clearRedo) {\n\tundoModifiers.Append(mod);\n\n\twhile(undoModifiers.Num() \u003e MAX_UNDOREDO) {\n\t\tundoModifiers.RemoveIndex(0);\n\t}\n\n\tif(clearRedo) {\n\t\tClearRedo();\n\t}\n}\n\n/**\n* Adds a redo operation to the redo buffer.\n* @param mod The MaterialModifier object that contains the redo data.\n*/\nvoid  MaterialDocManager::AddMaterialRedoModifier(MaterialModifier* mod) {\n\tredoModifiers.Append(mod);\n\n\twhile(redoModifiers.Num() \u003e MAX_UNDOREDO) {\n\t\tredoModifiers.RemoveIndex(0);\n\t}\n}\n\n/**\n* Searches for a material that matches the specified search data.\n* @param name The name of the material to search.\n* @param searchData The search parameters.\n* @param checkName If true then the name of the material will be checked along with the material text.\n*/\nbool MaterialDocManager::FindMaterial(const char* name, MaterialSearchData_t* searchData, bool checkName) {\n\n\t//Fast way of finding the material without parsing\n\tconst idMaterial* material = static_cast\u003cconst idMaterial *\u003e(declManager-\u003eFindDeclWithoutParsing(DECL_MATERIAL, name, false));\n\t\t\n\tif(material) {\n\n\t\tint findPos;\n\n\t\tif(checkName) {\n\t\t\t//Check the name\n\t\t\tidStr name = material-\u003eGetName();\n\n\t\t\tfindPos = name.Find(searchData-\u003esearchText, false);\n\t\t\tif(findPos != -1) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\t//Skip to the open braket so the name is not checked\n\t\tchar *declText = (char *) _alloca( material-\u003eGetTextLength() + 1 );\n\t\tmaterial-\u003eGetText( declText );\n\n\t\tidStr text = declText;\n\t\tint start = text.Find(\"{\");\n\t\tif(start != -1) {\n\t\t\ttext = text.Right(text.Length()-start);\n\t\t}\n\t\t\n\t\tfindPos = text.Find(searchData-\u003esearchText, false);\n\t\tif(findPos != -1) {\n\t\t\t//Todo: Include match whole word\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n/**\n* Returns a unique material name given a base name. This is used to resolve materials with the same name.\n* @param name The base name of the material.\n*/\nidStr MaterialDocManager::GetUniqueMaterialName(idStr name) {\n\tint num = 0;\n\twhile(1) {\n\t\tidStr testName;\n\t\tif(num == 0)\n\t\t\ttestName = name;\n\t\telse\n\t\t\ttestName = va(\"%s%d\", name.c_str(), num);\n\n\t\tconst idMaterial* mat = declManager-\u003eFindMaterial(testName.c_str(), false);\n\t\tif(!mat) {\n\t\t\treturn testName;\n\t\t} else {\n\n\t\t\t//We can reuse delete material names\n\t\t\tif(mat-\u003eGetTextLength() \u003c 1)\n\t\t\t\treturn testName;\n\t\t}\n\t\tnum++;\n\t}\n}\n\n/**\n* Notifies all registered views of a material event.\n* @param materialDoc The material that has been affected.\n* @param notifyType The type of event that has occured.\n* @param ... Notification specific data. See MaterialView.\n*/\nvoid MaterialDocManager::NotifyViews(MaterialDoc* materialDoc, int notifyType, ... ) {\n\n\tva_list argptr;\n\n\tint c = materialViews.Num();\n\tfor(int i = 0; i \u003c c; i++) {\n\t\tva_start( argptr, notifyType );\n\t\tswitch(notifyType) {\n\t\t\tcase SELECTION_CHANGE:\n\t\t\t\tmaterialViews[i]-\u003eMV_OnMaterialSelectionChange(materialDoc);\n\t\t\t\tbreak;\n\t\t\tcase MATERIAL_CHANGE:\n\t\t\t\tmaterialViews[i]-\u003eMV_OnMaterialChange(materialDoc);\n\t\t\t\tbreak;\n\t\t\tcase MATERIAL_APPLY:\n\t\t\t\tmaterialViews[i]-\u003eMV_OnMaterialApply(materialDoc);\n\t\t\t\tbreak;\n\t\t\tcase MATERIAL_SAVE:\n\t\t\t\tmaterialViews[i]-\u003eMV_OnMaterialSaved(materialDoc);\n\t\t\t\tbreak;\n\t\t\tcase MATERIAL_SAVE_FILE:\n\t\t\t\tmaterialViews[i]-\u003eMV_OnMaterialSaveFile(va_arg(argptr, const char*));\n\t\t\t\tbreak;\n\t\t\tcase MATERIAL_ADD:\n\t\t\t\tmaterialViews[i]-\u003eMV_OnMaterialAdd(materialDoc);\n\t\t\t\tbreak;\n\t\t\tcase MATERIAL_DELETE:\n\t\t\t\tmaterialViews[i]-\u003eMV_OnMaterialDelete(materialDoc);\n\t\t\t\tbreak;\n\t\t\tcase MATERIAL_ADD_STAGE:\n\t\t\t\tmaterialViews[i]-\u003eMV_OnMaterialStageAdd(materialDoc, va_arg(argptr, int));\n\t\t\t\tbreak;\n\t\t\tcase MATERIAL_DELETE_STAGE:\n\t\t\t\tmaterialViews[i]-\u003eMV_OnMaterialStageDelete(materialDoc, va_arg(argptr, int));\n\t\t\t\tbreak;\n\t\t\tcase MATERIAL_MOVE_STAGE:\n\t\t\t\t{\n\t\t\t\t\tint from = va_arg(argptr, int);\n\t\t\t\t\tint to = va_arg(argptr, int);\n\t\t\t\t\tmaterialViews[i]-\u003eMV_OnMaterialStageMove(materialDoc, from, to);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase MATERIAL_ATTRIBUTE_CHANGE:\n\t\t\t\t{\n\t\t\t\t\tint stage = va_arg(argptr, int);\n\t\t\t\t\tconst char* attribName = va_arg(argptr, const char*);\n\t\t\t\t\tmaterialViews[i]-\u003eMV_OnMaterialAttributeChanged(materialDoc, stage, attribName);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase MATERIAL_NAME_CHANGE:\n\t\t\t\t{\n\t\t\t\t\tconst char* oldName = va_arg(argptr, const char*);\n\t\t\t\t\tmaterialViews[i]-\u003eMV_OnMaterialNameChanged(materialDoc, oldName);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase FILE_RELOAD:\n\t\t\t\t{\n\t\t\t\t\tconst char* filename = va_arg(argptr, const char*);\n\t\t\t\t\tmaterialViews[i]-\u003eMV_OnFileReload(filename);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t\tva_end( argptr );\n\t}\n}\n\n/**\n* Called when a material has been edited and notifies all views of the change.\n* @param materialDoc The material that has changed.\n*/\nvoid MaterialDocManager::MaterialChanged(MaterialDoc* materialDoc) {\n\n\t//Make sure this material is in our list of changed materials\n\tif(!inProgressMaterials.Get(materialDoc-\u003ename.c_str())) {\n\t\tinProgressMaterials.Set(materialDoc-\u003ename.c_str(), materialDoc);\n\t}\n\n\t//Notify everyone\n\tNotifyViews(materialDoc, MATERIAL_CHANGE);\n}\n\n/**\n* Called when a material has been applied and notifies all views of the apply.\n* @param materialDoc The material that has been applied.\n*/\nvoid MaterialDocManager::MaterialApplied(MaterialDoc* materialDoc) {\n\n\t//Notify everyone\n\tNotifyViews(materialDoc, MATERIAL_APPLY);\n}\n\n/**\n* Called when a material has been saved and notifies all views of the save.\n* @param materialDoc The material that has been saved.\n*/\nvoid MaterialDocManager::MaterialSaved(MaterialDoc* materialDoc) {\n\n\tMaterialDoc** tempDoc;\n\tif(inProgressMaterials.Get(materialDoc-\u003ename.c_str(), \u0026tempDoc)) {\n\n\t\tidStr name = materialDoc-\u003ename.c_str();\n\n\t\t//Remove this file from our in progress list\n\t\tinProgressMaterials.Remove(name.c_str());\n\n\t\t//Notify everyone\n\t\tNotifyViews(materialDoc, MATERIAL_SAVE);\n\n\t\tif(materialDoc != currentMaterial)\n\t\t\tdelete materialDoc;\n\t}\n}\n\n/**\n* Called when a material name has been changed and notifies all views of the change.\n* @param materialDoc The material that has changed.\n*/\nvoid MaterialDocManager::MaterialNameChanged(const char* oldName, MaterialDoc* materialDoc) {\n\n\tMaterialDoc** tempDoc;\n\tif(inProgressMaterials.Get(oldName, \u0026tempDoc)) {\n\t\tinProgressMaterials.Set(materialDoc-\u003ename, *tempDoc);\n\t\tinProgressMaterials.Remove(oldName);\n\t}\n\n\tNotifyViews(materialDoc, MATERIAL_NAME_CHANGE, oldName);\n}\n\n/**\n* Called when a stage is added and notifies all views of the addition.\n* @param materialDoc The material that has changed.\n* @param stageNum The stage that was added.\n*/\nvoid MaterialDocManager::StageAdded(MaterialDoc* materialDoc, int stageNum) {\n\t//Notify everyone\n\tNotifyViews(materialDoc, MATERIAL_ADD_STAGE, stageNum);\n}\n\n/**\n* Called when a stage has been deleted and notifies all views of the change.\n* @param materialDoc The material that has changed.\n* @param stageNum The stage that was deleted.\n*/\nvoid MaterialDocManager::StageDeleted(MaterialDoc* materialDoc, int stageNum) {\n\t//Notify everyone\n\tNotifyViews(materialDoc, MATERIAL_DELETE_STAGE, stageNum);\n}\n\n/**\n* Called when a stage has been movied and notifies all views of the change.\n* @param materialDoc The material that has changed.\n* @param from The original position of the stage.\n* @param to The new position of the stage.\n*/\nvoid MaterialDocManager::StageMoved(MaterialDoc* materialDoc, int from, int to) {\n\t//Notify everyone\n\tNotifyViews(materialDoc, MATERIAL_MOVE_STAGE, from, to);\n}\n\n/**\n* Called when a material attribute has been edited and notifies all views of the change.\n* @param materialDoc The material that has changed.\n* @param stage The stage that contains the changed attribute.\n* @param attribName The name of the attribute that changed.\n*/\nvoid MaterialDocManager::AttributeChanged(MaterialDoc* materialDoc, int stage, const char* attribName) {\n\t//Notify everyone\n\tNotifyViews(materialDoc, MATERIAL_ATTRIBUTE_CHANGE, stage, attribName);\n}\n"}
{"repo_name":"doorxp/ccjson","ref":"refs/heads/master","path":"cocos2d/cocos/audio/android/AudioResampler.cpp","copies":"33","language":"C++","content":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#define LOG_TAG \"AudioResampler\"\n//#define LOG_NDEBUG 0\n\n#include \u003cstdint.h\u003e\n#include \u003cstdlib.h\u003e\n#include \u003csys/types.h\u003e\n#include \u003cpthread.h\u003e\n#include \u003cnew\u003e\n#include \"audio/android/cutils/log.h\"\n#include \"audio/android/utils/Utils.h\"\n//#include \u003ccutils/properties.h\u003e\n#include \"audio/android/audio_utils/include/audio_utils/primitives.h\"\n#include \"audio/android/AudioResampler.h\"\n//#include \"audio/android/AudioResamplerSinc.h\"\n#include \"audio/android/AudioResamplerCubic.h\"\n\n\n//#include \"AudioResamplerDyn.h\"\n\n//cjh #ifdef __arm__\n//    #define ASM_ARM_RESAMP1 // enable asm optimisation for ResamplerOrder1\n//#endif\n\n\n\nnamespace cocos2d { namespace experimental {\n\n// ----------------------------------------------------------------------------\n\nclass AudioResamplerOrder1 : public AudioResampler {\npublic:\n    AudioResamplerOrder1(int inChannelCount, int32_t sampleRate) :\n        AudioResampler(inChannelCount, sampleRate, LOW_QUALITY), mX0L(0), mX0R(0) {\n    }\n    virtual size_t resample(int32_t* out, size_t outFrameCount,\n            AudioBufferProvider* provider);\nprivate:\n    // number of bits used in interpolation multiply - 15 bits avoids overflow\n    static const int kNumInterpBits = 15;\n\n    // bits to shift the phase fraction down to avoid overflow\n    static const int kPreInterpShift = kNumPhaseBits - kNumInterpBits;\n\n    void init() {}\n    size_t resampleMono16(int32_t* out, size_t outFrameCount,\n            AudioBufferProvider* provider);\n    size_t resampleStereo16(int32_t* out, size_t outFrameCount,\n            AudioBufferProvider* provider);\n#ifdef ASM_ARM_RESAMP1  // asm optimisation for ResamplerOrder1\n    void AsmMono16Loop(int16_t *in, int32_t* maxOutPt, int32_t maxInIdx,\n            size_t \u0026outputIndex, int32_t* out, size_t \u0026inputIndex, int32_t vl, int32_t vr,\n            uint32_t \u0026phaseFraction, uint32_t phaseIncrement);\n    void AsmStereo16Loop(int16_t *in, int32_t* maxOutPt, int32_t maxInIdx,\n            size_t \u0026outputIndex, int32_t* out, size_t \u0026inputIndex, int32_t vl, int32_t vr,\n            uint32_t \u0026phaseFraction, uint32_t phaseIncrement);\n#endif  // ASM_ARM_RESAMP1\n\n    static inline int32_t Interp(int32_t x0, int32_t x1, uint32_t f) {\n        return x0 + (((x1 - x0) * (int32_t)(f \u003e\u003e kPreInterpShift)) \u003e\u003e kNumInterpBits);\n    }\n    static inline void Advance(size_t* index, uint32_t* frac, uint32_t inc) {\n        *frac += inc;\n        *index += (size_t)(*frac \u003e\u003e kNumPhaseBits);\n        *frac \u0026= kPhaseMask;\n    }\n    int mX0L;\n    int mX0R;\n};\n\n/*static*/\nconst double AudioResampler::kPhaseMultiplier = 1L \u003c\u003c AudioResampler::kNumPhaseBits;\n\nbool AudioResampler::qualityIsSupported(src_quality quality)\n{\n    switch (quality) {\n    case DEFAULT_QUALITY:\n    case LOW_QUALITY:\n    case MED_QUALITY:\n    case HIGH_QUALITY:\n    case VERY_HIGH_QUALITY:\n        return true;\n    default:\n        return false;\n    }\n}\n\n// ----------------------------------------------------------------------------\n\nstatic pthread_once_t once_control = PTHREAD_ONCE_INIT;\nstatic AudioResampler::src_quality defaultQuality = AudioResampler::DEFAULT_QUALITY;\n\nvoid AudioResampler::init_routine()\n{\n    // int resamplerQuality = getSystemProperty(\"af.resampler.quality\");\n    // if (resamplerQuality \u003e 0) {\n    //     defaultQuality = (src_quality) resamplerQuality;\n    //     ALOGD(\"forcing AudioResampler quality to %d\", defaultQuality);\n    //     if (defaultQuality \u003c DEFAULT_QUALITY || defaultQuality \u003e VERY_HIGH_QUALITY) {\n    //         defaultQuality = DEFAULT_QUALITY;\n    //     }\n    // }\n}\n\nuint32_t AudioResampler::qualityMHz(src_quality quality)\n{\n    switch (quality) {\n    default:\n    case DEFAULT_QUALITY:\n    case LOW_QUALITY:\n        return 3;\n    case MED_QUALITY:\n        return 6;\n    case HIGH_QUALITY:\n        return 20;\n    case VERY_HIGH_QUALITY:\n        return 34;\n//    case DYN_LOW_QUALITY:\n//        return 4;\n//    case DYN_MED_QUALITY:\n//        return 6;\n//    case DYN_HIGH_QUALITY:\n//        return 12;\n    }\n}\n\nstatic const uint32_t maxMHz = 130; // an arbitrary number that permits 3 VHQ, should be tunable\nstatic pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\nstatic uint32_t currentMHz = 0;\n\nAudioResampler* AudioResampler::create(audio_format_t format, int inChannelCount,\n        int32_t sampleRate, src_quality quality) {\n\n    bool atFinalQuality;\n    if (quality == DEFAULT_QUALITY) {\n        // read the resampler default quality property the first time it is needed\n        int ok = pthread_once(\u0026once_control, init_routine);\n        if (ok != 0) {\n            ALOGE(\"%s pthread_once failed: %d\", __func__, ok);\n        }\n        quality = defaultQuality;\n        atFinalQuality = false;\n    } else {\n        atFinalQuality = true;\n    }\n\n    /* if the caller requests DEFAULT_QUALITY and af.resampler.property\n     * has not been set, the target resampler quality is set to DYN_MED_QUALITY,\n     * and allowed to \"throttle\" down to DYN_LOW_QUALITY if necessary\n     * due to estimated CPU load of having too many active resamplers\n     * (the code below the if).\n     */\n    if (quality == DEFAULT_QUALITY) {\n//cjh        quality = DYN_MED_QUALITY;\n    }\n\n    // naive implementation of CPU load throttling doesn't account for whether resampler is active\n    pthread_mutex_lock(\u0026mutex);\n    for (;;) {\n        uint32_t deltaMHz = qualityMHz(quality);\n        uint32_t newMHz = currentMHz + deltaMHz;\n        if ((qualityIsSupported(quality) \u0026\u0026 newMHz \u003c= maxMHz) || atFinalQuality) {\n            ALOGV(\"resampler load %u -\u003e %u MHz due to delta +%u MHz from quality %d\",\n                    currentMHz, newMHz, deltaMHz, quality);\n            currentMHz = newMHz;\n            break;\n        }\n        // not enough CPU available for proposed quality level, so try next lowest level\n        switch (quality) {\n        default:\n        case LOW_QUALITY:\n            atFinalQuality = true;\n            break;\n        case MED_QUALITY:\n            quality = LOW_QUALITY;\n            break;\n        case HIGH_QUALITY:\n            quality = MED_QUALITY;\n            break;\n        case VERY_HIGH_QUALITY:\n            quality = HIGH_QUALITY;\n            break;\n//        case DYN_LOW_QUALITY:\n//            atFinalQuality = true;\n//            break;\n//        case DYN_MED_QUALITY:\n//            quality = DYN_LOW_QUALITY;\n//            break;\n//        case DYN_HIGH_QUALITY:\n//            quality = DYN_MED_QUALITY;\n//            break;\n        }\n    }\n    pthread_mutex_unlock(\u0026mutex);\n\n    AudioResampler* resampler;\n\n    switch (quality) {\n    default:\n    case LOW_QUALITY:\n        ALOGV(\"Create linear Resampler\");\n        LOG_ALWAYS_FATAL_IF(format != AUDIO_FORMAT_PCM_16_BIT, \"invalid pcm format\");\n        resampler = new (std::nothrow) AudioResamplerOrder1(inChannelCount, sampleRate);\n        break;\n    case MED_QUALITY:\n        ALOGV(\"Create cubic Resampler\");\n        LOG_ALWAYS_FATAL_IF(format != AUDIO_FORMAT_PCM_16_BIT, \"invalid pcm format\");\n        resampler = new (std::nothrow) AudioResamplerCubic(inChannelCount, sampleRate);\n        break;\n    case HIGH_QUALITY:\n        ALOGV(\"Create HIGH_QUALITY sinc Resampler\");\n        LOG_ALWAYS_FATAL_IF(format != AUDIO_FORMAT_PCM_16_BIT, \"invalid pcm format\");\n        ALOG_ASSERT(false, \"HIGH_QUALITY isn't supported\");\n        // Cocos2d-x only uses MED_QUALITY, so we could remove Sinc relative files\n//        resampler = new (std::nothrow) AudioResamplerSinc(inChannelCount, sampleRate);\n        break;\n    case VERY_HIGH_QUALITY:\n        ALOGV(\"Create VERY_HIGH_QUALITY sinc Resampler = %d\", quality);\n        LOG_ALWAYS_FATAL_IF(format != AUDIO_FORMAT_PCM_16_BIT, \"invalid pcm format\");\n        // Cocos2d-x only uses MED_QUALITY, so we could remove Sinc relative files\n//        resampler = new (std::nothrow) AudioResamplerSinc(inChannelCount, sampleRate, quality);\n        ALOG_ASSERT(false, \"VERY_HIGH_QUALITY isn't supported\");\n        break;\n    }\n\n    // initialize resampler\n    resampler-\u003einit();\n    return resampler;\n}\n\nAudioResampler::AudioResampler(int inChannelCount,\n        int32_t sampleRate, src_quality quality) :\n        mChannelCount(inChannelCount),\n        mSampleRate(sampleRate), mInSampleRate(sampleRate), mInputIndex(0),\n        mPhaseFraction(0), mLocalTimeFreq(0),\n        mPTS(AudioBufferProvider::kInvalidPTS), mQuality(quality) {\n\n    const int maxChannels = 2;//cjh quality \u003c DYN_LOW_QUALITY ? 2 : 8;\n    if (inChannelCount \u003c 1\n            || inChannelCount \u003e maxChannels) {\n        LOG_ALWAYS_FATAL(\"Unsupported sample format %d quality %d channels\",\n                quality, inChannelCount);\n    }\n    if (sampleRate \u003c= 0) {\n        LOG_ALWAYS_FATAL(\"Unsupported sample rate %d Hz\", sampleRate);\n    }\n\n    // initialize common members\n    mVolume[0] = mVolume[1] = 0;\n    mBuffer.frameCount = 0;\n}\n\nAudioResampler::~AudioResampler() {\n    pthread_mutex_lock(\u0026mutex);\n    src_quality quality = getQuality();\n    uint32_t deltaMHz = qualityMHz(quality);\n    int32_t newMHz = currentMHz - deltaMHz;\n    ALOGV(\"resampler load %u -\u003e %d MHz due to delta -%u MHz from quality %d\",\n            currentMHz, newMHz, deltaMHz, quality);\n    LOG_ALWAYS_FATAL_IF(newMHz \u003c 0, \"negative resampler load %d MHz\", newMHz);\n    currentMHz = newMHz;\n    pthread_mutex_unlock(\u0026mutex);\n}\n\nvoid AudioResampler::setSampleRate(int32_t inSampleRate) {\n    mInSampleRate = inSampleRate;\n    mPhaseIncrement = (uint32_t)((kPhaseMultiplier * inSampleRate) / mSampleRate);\n}\n\nvoid AudioResampler::setVolume(float left, float right) {\n    // TODO: Implement anti-zipper filter\n    // convert to U4.12 for internal integer use (round down)\n    // integer volume values are clamped to 0 to UNITY_GAIN.\n    mVolume[0] = u4_12_from_float(clampFloatVol(left));\n    mVolume[1] = u4_12_from_float(clampFloatVol(right));\n}\n\nvoid AudioResampler::setLocalTimeFreq(uint64_t freq) {\n    mLocalTimeFreq = freq;\n}\n\nvoid AudioResampler::setPTS(int64_t pts) {\n    mPTS = pts;\n}\n\nint64_t AudioResampler::calculateOutputPTS(int outputFrameIndex) {\n\n    if (mPTS == AudioBufferProvider::kInvalidPTS) {\n        return AudioBufferProvider::kInvalidPTS;\n    } else {\n        return mPTS + ((outputFrameIndex * mLocalTimeFreq) / mSampleRate);\n    }\n}\n\nvoid AudioResampler::reset() {\n    mInputIndex = 0;\n    mPhaseFraction = 0;\n    mBuffer.frameCount = 0;\n}\n\n// ----------------------------------------------------------------------------\n\nsize_t AudioResamplerOrder1::resample(int32_t* out, size_t outFrameCount,\n        AudioBufferProvider* provider) {\n\n    // should never happen, but we overflow if it does\n    // ALOG_ASSERT(outFrameCount \u003c 32767);\n\n    // select the appropriate resampler\n    switch (mChannelCount) {\n    case 1:\n        return resampleMono16(out, outFrameCount, provider);\n    case 2:\n        return resampleStereo16(out, outFrameCount, provider);\n    default:\n        LOG_ALWAYS_FATAL(\"invalid channel count: %d\", mChannelCount);\n        return 0;\n    }\n}\n\nsize_t AudioResamplerOrder1::resampleStereo16(int32_t* out, size_t outFrameCount,\n        AudioBufferProvider* provider) {\n\n    int32_t vl = mVolume[0];\n    int32_t vr = mVolume[1];\n\n    size_t inputIndex = mInputIndex;\n    uint32_t phaseFraction = mPhaseFraction;\n    uint32_t phaseIncrement = mPhaseIncrement;\n    size_t outputIndex = 0;\n    size_t outputSampleCount = outFrameCount * 2;\n    size_t inFrameCount = getInFrameCountRequired(outFrameCount);\n\n    // ALOGE(\"starting resample %d frames, inputIndex=%d, phaseFraction=%d, phaseIncrement=%d\",\n    //      outFrameCount, inputIndex, phaseFraction, phaseIncrement);\n\n    while (outputIndex \u003c outputSampleCount) {\n\n        // buffer is empty, fetch a new one\n        while (mBuffer.frameCount == 0) {\n            mBuffer.frameCount = inFrameCount;\n            provider-\u003egetNextBuffer(\u0026mBuffer,\n                                    calculateOutputPTS(outputIndex / 2));\n            if (mBuffer.raw == NULL) {\n                goto resampleStereo16_exit;\n            }\n\n            // ALOGE(\"New buffer fetched: %d frames\", mBuffer.frameCount);\n            if (mBuffer.frameCount \u003e inputIndex) break;\n\n            inputIndex -= mBuffer.frameCount;\n            mX0L = mBuffer.i16[mBuffer.frameCount*2-2];\n            mX0R = mBuffer.i16[mBuffer.frameCount*2-1];\n            provider-\u003ereleaseBuffer(\u0026mBuffer);\n            // mBuffer.frameCount == 0 now so we reload a new buffer\n        }\n\n        int16_t *in = mBuffer.i16;\n\n        // handle boundary case\n        while (inputIndex == 0) {\n            // ALOGE(\"boundary case\");\n            out[outputIndex++] += vl * Interp(mX0L, in[0], phaseFraction);\n            out[outputIndex++] += vr * Interp(mX0R, in[1], phaseFraction);\n            Advance(\u0026inputIndex, \u0026phaseFraction, phaseIncrement);\n            if (outputIndex == outputSampleCount) {\n                break;\n            }\n        }\n\n        // process input samples\n        // ALOGE(\"general case\");\n\n#ifdef ASM_ARM_RESAMP1  // asm optimisation for ResamplerOrder1\n        if (inputIndex + 2 \u003c mBuffer.frameCount) {\n            int32_t* maxOutPt;\n            int32_t maxInIdx;\n\n            maxOutPt = out + (outputSampleCount - 2);   // 2 because 2 frames per loop\n            maxInIdx = mBuffer.frameCount - 2;\n            AsmStereo16Loop(in, maxOutPt, maxInIdx, outputIndex, out, inputIndex, vl, vr,\n                    phaseFraction, phaseIncrement);\n        }\n#endif  // ASM_ARM_RESAMP1\n\n        while (outputIndex \u003c outputSampleCount \u0026\u0026 inputIndex \u003c mBuffer.frameCount) {\n            out[outputIndex++] += vl * Interp(in[inputIndex*2-2],\n                    in[inputIndex*2], phaseFraction);\n            out[outputIndex++] += vr * Interp(in[inputIndex*2-1],\n                    in[inputIndex*2+1], phaseFraction);\n            Advance(\u0026inputIndex, \u0026phaseFraction, phaseIncrement);\n        }\n\n        // ALOGE(\"loop done - outputIndex=%d, inputIndex=%d\", outputIndex, inputIndex);\n\n        // if done with buffer, save samples\n        if (inputIndex \u003e= mBuffer.frameCount) {\n            inputIndex -= mBuffer.frameCount;\n\n            // ALOGE(\"buffer done, new input index %d\", inputIndex);\n\n            mX0L = mBuffer.i16[mBuffer.frameCount*2-2];\n            mX0R = mBuffer.i16[mBuffer.frameCount*2-1];\n            provider-\u003ereleaseBuffer(\u0026mBuffer);\n\n            // verify that the releaseBuffer resets the buffer frameCount\n            // ALOG_ASSERT(mBuffer.frameCount == 0);\n        }\n    }\n\n    // ALOGE(\"output buffer full - outputIndex=%d, inputIndex=%d\", outputIndex, inputIndex);\n\nresampleStereo16_exit:\n    // save state\n    mInputIndex = inputIndex;\n    mPhaseFraction = phaseFraction;\n    return outputIndex / 2 /* channels for stereo */;\n}\n\nsize_t AudioResamplerOrder1::resampleMono16(int32_t* out, size_t outFrameCount,\n        AudioBufferProvider* provider) {\n\n    int32_t vl = mVolume[0];\n    int32_t vr = mVolume[1];\n\n    size_t inputIndex = mInputIndex;\n    uint32_t phaseFraction = mPhaseFraction;\n    uint32_t phaseIncrement = mPhaseIncrement;\n    size_t outputIndex = 0;\n    size_t outputSampleCount = outFrameCount * 2;\n    size_t inFrameCount = getInFrameCountRequired(outFrameCount);\n\n    // ALOGE(\"starting resample %d frames, inputIndex=%d, phaseFraction=%d, phaseIncrement=%d\",\n    //      outFrameCount, inputIndex, phaseFraction, phaseIncrement);\n    while (outputIndex \u003c outputSampleCount) {\n        // buffer is empty, fetch a new one\n        while (mBuffer.frameCount == 0) {\n            mBuffer.frameCount = inFrameCount;\n            provider-\u003egetNextBuffer(\u0026mBuffer,\n                                    calculateOutputPTS(outputIndex / 2));\n            if (mBuffer.raw == NULL) {\n                mInputIndex = inputIndex;\n                mPhaseFraction = phaseFraction;\n                goto resampleMono16_exit;\n            }\n            // ALOGE(\"New buffer fetched: %d frames\", mBuffer.frameCount);\n            if (mBuffer.frameCount \u003e  inputIndex) break;\n\n            inputIndex -= mBuffer.frameCount;\n            mX0L = mBuffer.i16[mBuffer.frameCount-1];\n            provider-\u003ereleaseBuffer(\u0026mBuffer);\n            // mBuffer.frameCount == 0 now so we reload a new buffer\n        }\n        int16_t *in = mBuffer.i16;\n\n        // handle boundary case\n        while (inputIndex == 0) {\n            // ALOGE(\"boundary case\");\n            int32_t sample = Interp(mX0L, in[0], phaseFraction);\n            out[outputIndex++] += vl * sample;\n            out[outputIndex++] += vr * sample;\n            Advance(\u0026inputIndex, \u0026phaseFraction, phaseIncrement);\n            if (outputIndex == outputSampleCount) {\n                break;\n            }\n        }\n\n        // process input samples\n        // ALOGE(\"general case\");\n\n#ifdef ASM_ARM_RESAMP1  // asm optimisation for ResamplerOrder1\n        if (inputIndex + 2 \u003c mBuffer.frameCount) {\n            int32_t* maxOutPt;\n            int32_t maxInIdx;\n\n            maxOutPt = out + (outputSampleCount - 2);\n            maxInIdx = (int32_t)mBuffer.frameCount - 2;\n                AsmMono16Loop(in, maxOutPt, maxInIdx, outputIndex, out, inputIndex, vl, vr,\n                        phaseFraction, phaseIncrement);\n        }\n#endif  // ASM_ARM_RESAMP1\n\n        while (outputIndex \u003c outputSampleCount \u0026\u0026 inputIndex \u003c mBuffer.frameCount) {\n            int32_t sample = Interp(in[inputIndex-1], in[inputIndex],\n                    phaseFraction);\n            out[outputIndex++] += vl * sample;\n            out[outputIndex++] += vr * sample;\n            Advance(\u0026inputIndex, \u0026phaseFraction, phaseIncrement);\n        }\n\n\n        // ALOGE(\"loop done - outputIndex=%d, inputIndex=%d\", outputIndex, inputIndex);\n\n        // if done with buffer, save samples\n        if (inputIndex \u003e= mBuffer.frameCount) {\n            inputIndex -= mBuffer.frameCount;\n\n            // ALOGE(\"buffer done, new input index %d\", inputIndex);\n\n            mX0L = mBuffer.i16[mBuffer.frameCount-1];\n            provider-\u003ereleaseBuffer(\u0026mBuffer);\n\n            // verify that the releaseBuffer resets the buffer frameCount\n            // ALOG_ASSERT(mBuffer.frameCount == 0);\n        }\n    }\n\n    // ALOGE(\"output buffer full - outputIndex=%d, inputIndex=%d\", outputIndex, inputIndex);\n\nresampleMono16_exit:\n    // save state\n    mInputIndex = inputIndex;\n    mPhaseFraction = phaseFraction;\n    return outputIndex;\n}\n\n#ifdef ASM_ARM_RESAMP1  // asm optimisation for ResamplerOrder1\n\n/*******************************************************************\n*\n*   AsmMono16Loop\n*   asm optimized monotonic loop version; one loop is 2 frames\n*   Input:\n*       in : pointer on input samples\n*       maxOutPt : pointer on first not filled\n*       maxInIdx : index on first not used\n*       outputIndex : pointer on current output index\n*       out : pointer on output buffer\n*       inputIndex : pointer on current input index\n*       vl, vr : left and right gain\n*       phaseFraction : pointer on current phase fraction\n*       phaseIncrement\n*   Output:\n*       outputIndex :\n*       out : updated buffer\n*       inputIndex : index of next to use\n*       phaseFraction : phase fraction for next interpolation\n*\n*******************************************************************/\n__attribute__((noinline))\nvoid AudioResamplerOrder1::AsmMono16Loop(int16_t *in, int32_t* maxOutPt, int32_t maxInIdx,\n            size_t \u0026outputIndex, int32_t* out, size_t \u0026inputIndex, int32_t vl, int32_t vr,\n            uint32_t \u0026phaseFraction, uint32_t phaseIncrement)\n{\n    (void)maxOutPt; // remove unused parameter warnings\n    (void)maxInIdx;\n    (void)outputIndex;\n    (void)out;\n    (void)inputIndex;\n    (void)vl;\n    (void)vr;\n    (void)phaseFraction;\n    (void)phaseIncrement;\n    (void)in;\n#define MO_PARAM5   \"36\"        // offset of parameter 5 (outputIndex)\n\n    asm(\n        \"stmfd  sp!, {r4, r5, r6, r7, r8, r9, r10, r11, lr}\\n\"\n        // get parameters\n        \"   ldr r6, [sp, #\" MO_PARAM5 \" + 20]\\n\"    // \u0026phaseFraction\n        \"   ldr r6, [r6]\\n\"                         // phaseFraction\n        \"   ldr r7, [sp, #\" MO_PARAM5 \" + 8]\\n\"     // \u0026inputIndex\n        \"   ldr r7, [r7]\\n\"                         // inputIndex\n        \"   ldr r8, [sp, #\" MO_PARAM5 \" + 4]\\n\"     // out\n        \"   ldr r0, [sp, #\" MO_PARAM5 \" + 0]\\n\"     // \u0026outputIndex\n        \"   ldr r0, [r0]\\n\"                         // outputIndex\n        \"   add r8, r8, r0, asl #2\\n\"               // curOut\n        \"   ldr r9, [sp, #\" MO_PARAM5 \" + 24]\\n\"    // phaseIncrement\n        \"   ldr r10, [sp, #\" MO_PARAM5 \" + 12]\\n\"   // vl\n        \"   ldr r11, [sp, #\" MO_PARAM5 \" + 16]\\n\"   // vr\n\n        // r0 pin, x0, Samp\n\n        // r1 in\n        // r2 maxOutPt\n        // r3 maxInIdx\n\n        // r4 x1, i1, i3, Out1\n        // r5 out0\n\n        // r6 frac\n        // r7 inputIndex\n        // r8 curOut\n\n        // r9 inc\n        // r10 vl\n        // r11 vr\n\n        // r12\n        // r13 sp\n        // r14\n\n        // the following loop works on 2 frames\n\n        \"1:\\n\"\n        \"   cmp r8, r2\\n\"                   // curOut - maxCurOut\n        \"   bcs 2f\\n\"\n\n#define MO_ONE_FRAME \\\n    \"   add r0, r1, r7, asl #1\\n\"       /* in + inputIndex */\\\n    \"   ldrsh r4, [r0]\\n\"               /* in[inputIndex] */\\\n    \"   ldr r5, [r8]\\n\"                 /* out[outputIndex] */\\\n    \"   ldrsh r0, [r0, #-2]\\n\"          /* in[inputIndex-1] */\\\n    \"   bic r6, r6, #0xC0000000\\n\"      /* phaseFraction \u0026 ... */\\\n    \"   sub r4, r4, r0\\n\"               /* in[inputIndex] - in[inputIndex-1] */\\\n    \"   mov r4, r4, lsl #2\\n\"           /* \u003c\u003c2 */\\\n    \"   smulwt r4, r4, r6\\n\"            /* (x1-x0)*.. */\\\n    \"   add r6, r6, r9\\n\"               /* phaseFraction + phaseIncrement */\\\n    \"   add r0, r0, r4\\n\"               /* x0 - (..) */\\\n    \"   mla r5, r0, r10, r5\\n\"          /* vl*interp + out[] */\\\n    \"   ldr r4, [r8, #4]\\n\"             /* out[outputIndex+1] */\\\n    \"   str r5, [r8], #4\\n\"             /* out[outputIndex++] = ... */\\\n    \"   mla r4, r0, r11, r4\\n\"          /* vr*interp + out[] */\\\n    \"   add r7, r7, r6, lsr #30\\n\"      /* inputIndex + phaseFraction\u003e\u003e30 */\\\n    \"   str r4, [r8], #4\\n\"             /* out[outputIndex++] = ... */\n\n        MO_ONE_FRAME    // frame 1\n        MO_ONE_FRAME    // frame 2\n\n        \"   cmp r7, r3\\n\"                   // inputIndex - maxInIdx\n        \"   bcc 1b\\n\"\n        \"2:\\n\"\n\n        \"   bic r6, r6, #0xC0000000\\n\"             // phaseFraction \u0026 ...\n        // save modified values\n        \"   ldr r0, [sp, #\" MO_PARAM5 \" + 20]\\n\"    // \u0026phaseFraction\n        \"   str r6, [r0]\\n\"                         // phaseFraction\n        \"   ldr r0, [sp, #\" MO_PARAM5 \" + 8]\\n\"     // \u0026inputIndex\n        \"   str r7, [r0]\\n\"                         // inputIndex\n        \"   ldr r0, [sp, #\" MO_PARAM5 \" + 4]\\n\"     // out\n        \"   sub r8, r0\\n\"                           // curOut - out\n        \"   asr r8, #2\\n\"                           // new outputIndex\n        \"   ldr r0, [sp, #\" MO_PARAM5 \" + 0]\\n\"     // \u0026outputIndex\n        \"   str r8, [r0]\\n\"                         // save outputIndex\n\n        \"   ldmfd   sp!, {r4, r5, r6, r7, r8, r9, r10, r11, pc}\\n\"\n    );\n}\n\n/*******************************************************************\n*\n*   AsmStereo16Loop\n*   asm optimized stereo loop version; one loop is 2 frames\n*   Input:\n*       in : pointer on input samples\n*       maxOutPt : pointer on first not filled\n*       maxInIdx : index on first not used\n*       outputIndex : pointer on current output index\n*       out : pointer on output buffer\n*       inputIndex : pointer on current input index\n*       vl, vr : left and right gain\n*       phaseFraction : pointer on current phase fraction\n*       phaseIncrement\n*   Output:\n*       outputIndex :\n*       out : updated buffer\n*       inputIndex : index of next to use\n*       phaseFraction : phase fraction for next interpolation\n*\n*******************************************************************/\n__attribute__((noinline))\nvoid AudioResamplerOrder1::AsmStereo16Loop(int16_t *in, int32_t* maxOutPt, int32_t maxInIdx,\n            size_t \u0026outputIndex, int32_t* out, size_t \u0026inputIndex, int32_t vl, int32_t vr,\n            uint32_t \u0026phaseFraction, uint32_t phaseIncrement)\n{\n    (void)maxOutPt; // remove unused parameter warnings\n    (void)maxInIdx;\n    (void)outputIndex;\n    (void)out;\n    (void)inputIndex;\n    (void)vl;\n    (void)vr;\n    (void)phaseFraction;\n    (void)phaseIncrement;\n    (void)in;\n#define ST_PARAM5    \"40\"     // offset of parameter 5 (outputIndex)\n    asm(\n        \"stmfd  sp!, {r4, r5, r6, r7, r8, r9, r10, r11, r12, lr}\\n\"\n        // get parameters\n        \"   ldr r6, [sp, #\" ST_PARAM5 \" + 20]\\n\"    // \u0026phaseFraction\n        \"   ldr r6, [r6]\\n\"                         // phaseFraction\n        \"   ldr r7, [sp, #\" ST_PARAM5 \" + 8]\\n\"     // \u0026inputIndex\n        \"   ldr r7, [r7]\\n\"                         // inputIndex\n        \"   ldr r8, [sp, #\" ST_PARAM5 \" + 4]\\n\"     // out\n        \"   ldr r0, [sp, #\" ST_PARAM5 \" + 0]\\n\"     // \u0026outputIndex\n        \"   ldr r0, [r0]\\n\"                         // outputIndex\n        \"   add r8, r8, r0, asl #2\\n\"               // curOut\n        \"   ldr r9, [sp, #\" ST_PARAM5 \" + 24]\\n\"    // phaseIncrement\n        \"   ldr r10, [sp, #\" ST_PARAM5 \" + 12]\\n\"   // vl\n        \"   ldr r11, [sp, #\" ST_PARAM5 \" + 16]\\n\"   // vr\n\n        // r0 pin, x0, Samp\n\n        // r1 in\n        // r2 maxOutPt\n        // r3 maxInIdx\n\n        // r4 x1, i1, i3, out1\n        // r5 out0\n\n        // r6 frac\n        // r7 inputIndex\n        // r8 curOut\n\n        // r9 inc\n        // r10 vl\n        // r11 vr\n\n        // r12 temporary\n        // r13 sp\n        // r14\n\n        \"3:\\n\"\n        \"   cmp r8, r2\\n\"                   // curOut - maxCurOut\n        \"   bcs 4f\\n\"\n\n#define ST_ONE_FRAME \\\n    \"   bic r6, r6, #0xC0000000\\n\"      /* phaseFraction \u0026 ... */\\\n\\\n    \"   add r0, r1, r7, asl #2\\n\"       /* in + 2*inputIndex */\\\n\\\n    \"   ldrsh r4, [r0]\\n\"               /* in[2*inputIndex] */\\\n    \"   ldr r5, [r8]\\n\"                 /* out[outputIndex] */\\\n    \"   ldrsh r12, [r0, #-4]\\n\"         /* in[2*inputIndex-2] */\\\n    \"   sub r4, r4, r12\\n\"              /* in[2*InputIndex] - in[2*InputIndex-2] */\\\n    \"   mov r4, r4, lsl #2\\n\"           /* \u003c\u003c2 */\\\n    \"   smulwt r4, r4, r6\\n\"            /* (x1-x0)*.. */\\\n    \"   add r12, r12, r4\\n\"             /* x0 - (..) */\\\n    \"   mla r5, r12, r10, r5\\n\"         /* vl*interp + out[] */\\\n    \"   ldr r4, [r8, #4]\\n\"             /* out[outputIndex+1] */\\\n    \"   str r5, [r8], #4\\n\"             /* out[outputIndex++] = ... */\\\n\\\n    \"   ldrsh r12, [r0, #+2]\\n\"         /* in[2*inputIndex+1] */\\\n    \"   ldrsh r0, [r0, #-2]\\n\"          /* in[2*inputIndex-1] */\\\n    \"   sub r12, r12, r0\\n\"             /* in[2*InputIndex] - in[2*InputIndex-2] */\\\n    \"   mov r12, r12, lsl #2\\n\"         /* \u003c\u003c2 */\\\n    \"   smulwt r12, r12, r6\\n\"          /* (x1-x0)*.. */\\\n    \"   add r12, r0, r12\\n\"             /* x0 - (..) */\\\n    \"   mla r4, r12, r11, r4\\n\"         /* vr*interp + out[] */\\\n    \"   str r4, [r8], #4\\n\"             /* out[outputIndex++] = ... */\\\n\\\n    \"   add r6, r6, r9\\n\"               /* phaseFraction + phaseIncrement */\\\n    \"   add r7, r7, r6, lsr #30\\n\"      /* inputIndex + phaseFraction\u003e\u003e30 */\n\n    ST_ONE_FRAME    // frame 1\n    ST_ONE_FRAME    // frame 1\n\n        \"   cmp r7, r3\\n\"                       // inputIndex - maxInIdx\n        \"   bcc 3b\\n\"\n        \"4:\\n\"\n\n        \"   bic r6, r6, #0xC0000000\\n\"              // phaseFraction \u0026 ...\n        // save modified values\n        \"   ldr r0, [sp, #\" ST_PARAM5 \" + 20]\\n\"    // \u0026phaseFraction\n        \"   str r6, [r0]\\n\"                         // phaseFraction\n        \"   ldr r0, [sp, #\" ST_PARAM5 \" + 8]\\n\"     // \u0026inputIndex\n        \"   str r7, [r0]\\n\"                         // inputIndex\n        \"   ldr r0, [sp, #\" ST_PARAM5 \" + 4]\\n\"     // out\n        \"   sub r8, r0\\n\"                           // curOut - out\n        \"   asr r8, #2\\n\"                           // new outputIndex\n        \"   ldr r0, [sp, #\" ST_PARAM5 \" + 0]\\n\"     // \u0026outputIndex\n        \"   str r8, [r0]\\n\"                         // save outputIndex\n\n        \"   ldmfd   sp!, {r4, r5, r6, r7, r8, r9, r10, r11, r12, pc}\\n\"\n    );\n}\n\n#endif  // ASM_ARM_RESAMP1\n\n\n// ----------------------------------------------------------------------------\n\n}} // namespace cocos2d { namespace experimental {\n"}
{"repo_name":"hkarim/JUCE-Graph-Component","ref":"refs/heads/master","path":"JuceLibraryCode/modules/juce_gui_basics/filebrowser/juce_ImagePreviewComponent.cpp","copies":"24","language":"C++","content":"/*\r\n  ==============================================================================\r\n\r\n   This file is part of the JUCE library.\r\n   Copyright (c) 2015 - ROLI Ltd.\r\n\r\n   Permission is granted to use this software under the terms of either:\r\n   a) the GPL v2 (or any later version)\r\n   b) the Affero GPL v3\r\n\r\n   Details of these licenses can be found at: www.gnu.org/licenses\r\n\r\n   JUCE is distributed in the hope that it will be useful, but WITHOUT ANY\r\n   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\r\n   A PARTICULAR PURPOSE.  See the GNU General Public License for more details.\r\n\r\n   ------------------------------------------------------------------------------\r\n\r\n   To release a closed-source product which uses JUCE, commercial licenses are\r\n   available: visit www.juce.com for more information.\r\n\r\n  ==============================================================================\r\n*/\r\n\r\nImagePreviewComponent::ImagePreviewComponent()\r\n{\r\n}\r\n\r\nImagePreviewComponent::~ImagePreviewComponent()\r\n{\r\n}\r\n\r\n//==============================================================================\r\nvoid ImagePreviewComponent::getThumbSize (int\u0026 w, int\u0026 h) const\r\n{\r\n    const int availableW = proportionOfWidth (0.97f);\r\n    const int availableH = getHeight() - 13 * 4;\r\n\r\n    const double scale = jmin (1.0,\r\n                               availableW / (double) w,\r\n                               availableH / (double) h);\r\n\r\n    w = roundToInt (scale * w);\r\n    h = roundToInt (scale * h);\r\n}\r\n\r\nvoid ImagePreviewComponent::selectedFileChanged (const File\u0026 file)\r\n{\r\n    if (fileToLoad != file)\r\n    {\r\n        fileToLoad = file;\r\n        startTimer (100);\r\n    }\r\n}\r\n\r\nvoid ImagePreviewComponent::timerCallback()\r\n{\r\n    stopTimer();\r\n\r\n    currentThumbnail = Image();\r\n    currentDetails.clear();\r\n    repaint();\r\n\r\n    ScopedPointer\u003cFileInputStream\u003e in (fileToLoad.createInputStream());\r\n\r\n    if (in != nullptr)\r\n    {\r\n        if (ImageFileFormat* const format = ImageFileFormat::findImageFormatForStream (*in))\r\n        {\r\n            currentThumbnail = format-\u003edecodeImage (*in);\r\n\r\n            if (currentThumbnail.isValid())\r\n            {\r\n                int w = currentThumbnail.getWidth();\r\n                int h = currentThumbnail.getHeight();\r\n\r\n                currentDetails\r\n                    \u003c\u003c fileToLoad.getFileName() \u003c\u003c \"\\n\"\r\n                    \u003c\u003c format-\u003egetFormatName() \u003c\u003c \"\\n\"\r\n                    \u003c\u003c w \u003c\u003c \" x \" \u003c\u003c h \u003c\u003c \" pixels\\n\"\r\n                    \u003c\u003c File::descriptionOfSizeInBytes (fileToLoad.getSize());\r\n\r\n                getThumbSize (w, h);\r\n\r\n                currentThumbnail = currentThumbnail.rescaled (w, h);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nvoid ImagePreviewComponent::paint (Graphics\u0026 g)\r\n{\r\n    if (currentThumbnail.isValid())\r\n    {\r\n        g.setFont (13.0f);\r\n\r\n        int w = currentThumbnail.getWidth();\r\n        int h = currentThumbnail.getHeight();\r\n        getThumbSize (w, h);\r\n\r\n        const int numLines = 4;\r\n        const int totalH = 13 * numLines + h + 4;\r\n        const int y = (getHeight() - totalH) / 2;\r\n\r\n        g.drawImageWithin (currentThumbnail,\r\n                           (getWidth() - w) / 2, y, w, h,\r\n                           RectanglePlacement::centred | RectanglePlacement::onlyReduceInSize,\r\n                           false);\r\n\r\n        g.drawFittedText (currentDetails,\r\n                          0, y + h + 4, getWidth(), 100,\r\n                          Justification::centredTop, numLines);\r\n    }\r\n}\r\n"}
{"repo_name":"PKRoma/poedit","ref":"refs/heads/master","path":"deps/boost/libs/phoenix/test/container/container_tests8a.cpp","copies":"6","language":"C++","content":"/*=============================================================================\n    Copyright (c) 2004 Angus Leeming\n    Copyright (c) 2017 Kohei Takahashi\n\n    Distributed under the Boost Software License, Version 1.0. (See accompanying \n    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n==============================================================================*/\n#include \"container_tests.hpp\"\n#include \u003cboost/static_assert.hpp\u003e\n\nstd::set\u003cint\u003e const build_set()\n{\n    typedef std::set\u003cint\u003e int_set;\n    typedef std::vector\u003cint\u003e int_vector;\n\n    int_set result;\n    int_vector const data = build_vector();\n    int_vector::const_iterator it = data.begin();\n    int_vector::const_iterator const end = data.end();\n    result.insert(it, end);\n    return result;\n}\n\nstd::multiset\u003cint\u003e const build_multiset()\n{\n    typedef std::set\u003cint\u003e int_set;\n    typedef std::multiset\u003cint\u003e int_multiset;\n    int_set const data = build_set();\n    return int_multiset(data.begin(), data.end());\n}\n\nstd::vector\u003cint\u003e const init_vector()\n{\n    typedef std::vector\u003cint\u003e int_vector;\n    int const data[] = { -4, -3, -2, -1, 0 };\n    int_vector::size_type const data_size = sizeof(data) / sizeof(data[0]);\n    return int_vector(data, data + data_size);\n}\n\nstd::vector\u003cint\u003e const build_vector()\n{\n    typedef std::vector\u003cint\u003e int_vector;\n    static int_vector data = init_vector();\n    int_vector::size_type const size = data.size();\n    int_vector::iterator it = data.begin();\n    int_vector::iterator const end = data.end();\n    for (; it != end; ++it)\n        *it += size;\n    return data;\n}\n\nint\nmain()\n{\n    BOOST_STATIC_ASSERT((!phx::stl::has_mapped_type\u003cstd::multiset\u003cint\u003e \u003e::value));\n    BOOST_STATIC_ASSERT((phx::stl::has_key_type\u003cstd::multiset\u003cint\u003e \u003e::value));\n\n    std::multiset\u003cint\u003e const data = build_multiset();\n    test_begin(data);\n    test_clear(data);\n    test_empty(data);\n    test_end(data);\n    test_set_erase(data);\n    test_get_allocator(data);\n    return boost::report_errors();\n}\n\n\n\n\n"}
{"repo_name":"syslover33/ctank","ref":"refs/heads/master","path":"java/android-sdk-linux_r24.4.1_src/ndk-bundle_r11c/sources/cxx-stl/llvm-libc++/libcxx/test/localization/locales/locale.convenience/conversions/conversions.buffer/pbackfail.pass.cpp","copies":"46","language":"C++","content":"//===----------------------------------------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n// \u003clocale\u003e\n\n// wbuffer_convert\u003cCodecvt, Elem, Tr\u003e\n\n// int_type pbackfail(int_type c = traits::eof());\n\n// This test is not entirely portable\n\n#include \u003clocale\u003e\n#include \u003ccodecvt\u003e\n#include \u003cfstream\u003e\n#include \u003ccassert\u003e\n\nstruct test_buf\n    : public std::wbuffer_convert\u003cstd::codecvt_utf8\u003cwchar_t\u003e \u003e\n{\n    typedef std::wbuffer_convert\u003cstd::codecvt_utf8\u003cwchar_t\u003e \u003e base;\n    typedef base::char_type   char_type;\n    typedef base::int_type    int_type;\n    typedef base::traits_type traits_type;\n\n    explicit test_buf(std::streambuf* sb) : base(sb) {}\n\n    char_type* eback() const {return base::eback();}\n    char_type* gptr()  const {return base::gptr();}\n    char_type* egptr() const {return base::egptr();}\n    void gbump(int n) {base::gbump(n);}\n\n    virtual int_type pbackfail(int_type c = traits_type::eof()) {return base::pbackfail(c);}\n};\n\nint main()\n{\n    {\n        std::ifstream bs(\"underflow.dat\");\n        test_buf f(bs.rdbuf());\n        assert(f.sbumpc() == L'1');\n        assert(f.sgetc() == L'2');\n        assert(f.pbackfail(L'a') == test_buf::traits_type::eof());\n    }\n    {\n        std::fstream bs(\"underflow.dat\");\n        test_buf f(bs.rdbuf());\n        assert(f.sbumpc() == L'1');\n        assert(f.sgetc() == L'2');\n        assert(f.pbackfail(L'a') == test_buf::traits_type::eof());\n        assert(f.sbumpc() == L'2');\n        assert(f.sgetc() == L'3');\n    }\n}\n"}
{"repo_name":"Microsoft/PTVS","ref":"refs/heads/master","path":"Python/Tests/GlassTests/PythonTests/Python/StepPythonToNative_IterNext/cpp_mod.cpp","copies":"4","language":"C++","content":"#pragma optimize(\"\", off)\n#include \u003cpython.h\u003e\n\nstruct CppObj {\n    PyObject_HEAD\n};\n\nPyObject* CppObj_iternext(PyObject* self) {\n    Py_RETURN_NONE;\n}\n\nPyTypeObject* CppObj_type() {\n    static PyTypeObject t = { PyVarObject_HEAD_INIT(NULL, 0) };\n    t.tp_name = \"cpp_mod.CppObj\";\n    t.tp_basicsize = sizeof CppObj;\n    t.tp_flags = Py_TPFLAGS_DEFAULT;\n    t.tp_iternext = CppObj_iternext;\n    return \u0026t;\n}\n\nPyMethodDef methods[] = { NULL };\n\nPyTypeObject* types[] = {\n    CppObj_type(),\n    NULL\n};\n"}
{"repo_name":"Distrotech/xbmc","ref":"refs/heads/distrotech-xbmc","path":"xbmc/android/jni/BaseColumns.cpp","copies":"161","language":"C++","content":"/*\n *      Copyright (C) 2013 Team XBMC\n *      http://xbmc.org\n *\n *  This Program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  This Program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with XBMC; see the file COPYING.  If not, see\n *  \u003chttp://www.gnu.org/licenses/\u003e.\n *\n */\n\n#include \"BaseColumns.h\"\n#include \"jutils/jutils-details.hpp\"\n\nusing namespace jni;\n\nstd::string CJNIBaseColumns::_ID;\nstd::string CJNIBaseColumns::_COUNT;\n\nvoid CJNIBaseColumns::PopulateStaticFields()\n{\n  jhclass clazz = find_class(\"android/provider/BaseColumns\");\n  _ID    = (jcast\u003cstd::string\u003e(get_static_field\u003cjhstring\u003e(clazz, \"_ID\")));\n  _COUNT = (jcast\u003cstd::string\u003e(get_static_field\u003cjhstring\u003e(clazz, \"_COUNT\")));\n}\n"}
{"repo_name":"Chilledheart/vbox","ref":"refs/heads/master","path":"src/libs/xpcom18a4/nsprpub/pr/src/cplus/rcinrval.cpp","copies":"30","language":"C++","content":"/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*- */\n/* ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0/LGPL 2.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is the Netscape Portable Runtime (NSPR).\n *\n * The Initial Developer of the Original Code is\n * Netscape Communications Corporation.\n * Portions created by the Initial Developer are Copyright (C) 1998-2000\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU General Public License Version 2 or later (the \"GPL\"), or\n * the GNU Lesser General Public License Version 2.1 or later (the \"LGPL\"),\n * in which case the provisions of the GPL or the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of either the GPL or the LGPL, and not to allow others to\n * use your version of this file under the terms of the MPL, indicate your\n * decision by deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL or the LGPL. If you do not delete\n * the provisions above, a recipient may use your version of this file under\n * the terms of any one of the MPL, the GPL or the LGPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\n/*\n** C++ interval times (ref: prinrval.h)\n**\n**  An interval is a period of time. The start of the interval (epoch)\n**  must be defined by the application. The unit of time of an interval\n**  is platform dependent, therefore so is the maximum interval that is\n**  representable. However, that interval is never less that ~12 hours.\n*/\n\n#include \"rcinrval.h\"\n\nRCInterval::~RCInterval() { }\n\nRCInterval::RCInterval(RCInterval::RCReservedInterval special): RCBase()\n{\n    switch (special)\n    {\n    case RCInterval::now:\n        interval = PR_IntervalNow();\n        break;\n    case RCInterval::no_timeout:\n        interval = PR_INTERVAL_NO_TIMEOUT;\n        break;\n    case RCInterval::no_wait:\n        interval = PR_INTERVAL_NO_WAIT;\n        break;\n    default:\n        break;\n    }\n}  /* RCInterval::RCInterval */\n\n/* rcinrval.cpp */\n"}
{"repo_name":"cristal/Patch","ref":"refs/heads/patches","path":"dep/acelite/ace/Parse_Node.cpp","copies":"540","language":"C++","content":"// $Id: Parse_Node.cpp 91368 2010-08-16 13:03:34Z mhengstmengel $\n#include \"ace/Parse_Node.h\"\n\n#if (ACE_USES_CLASSIC_SVC_CONF == 1)\n\n#include \"ace/Service_Config.h\"\n#include \"ace/Service_Repository.h\"\n#include \"ace/Service_Types.h\"\n#include \"ace/Task.h\"\n#include \"ace/DLL.h\"\n#include \"ace/ACE.h\"\n#include \"ace/OS_NS_string.h\"\n#include \"ace/ARGV.h\"\n\n#include \u003clist\u003e\n\nACE_BEGIN_VERSIONED_NAMESPACE_DECL\n\nACE_ALLOC_HOOK_DEFINE (ACE_Stream_Node)\n\n// Provide the class hierarchy that defines the parse tree of Service\n// Nodes.\n\nvoid\nACE_Stream_Node::dump (void) const\n{\n#if defined (ACE_HAS_DUMP)\n  ACE_TRACE (\"ACE_Stream_Node::dump\");\n#endif /* ACE_HAS_DUMP */\n}\n\nvoid\nACE_Stream_Node::apply (ACE_Service_Gestalt *config, int \u0026yyerrno)\n{\n  ACE_TRACE (\"ACE_Stream_Node::apply\");\n\n  const ACE_Service_Type *sst = this-\u003enode_-\u003erecord (config);\n  if (sst == 0)\n    const_cast\u003cACE_Static_Node *\u003e (this-\u003enode_)-\u003eapply (config, yyerrno);\n\n  if (yyerrno != 0) return;\n\n  sst = this-\u003enode_-\u003erecord (config);\n  ACE_Stream_Type *st =\n      dynamic_cast\u003cACE_Stream_Type *\u003e (const_cast\u003cACE_Service_Type_Impl *\u003e (sst-\u003etype ()));\n\n  // The modules were linked as popped off the yacc stack, so they're in\n  // reverse order from the way they should be pushed onto the stream.\n  // So traverse mods_ and and reverse the list, then iterate over it to push\n  // the modules in the stream in the correct order.\n  std::list\u003cconst ACE_Static_Node *\u003e mod_list;\n  const ACE_Static_Node *module;\n  for (module = dynamic_cast\u003cconst ACE_Static_Node*\u003e (this-\u003emods_);\n       module != 0;\n       module = dynamic_cast\u003cACE_Static_Node*\u003e (module-\u003elink()))\n    mod_list.push_front (module);\n\n  std::list\u003cconst ACE_Static_Node *\u003e::const_iterator iter;\n  for (iter = mod_list.begin (); iter != mod_list.end (); ++iter)\n    {\n      module = *iter;\n      ACE_ARGV args (module-\u003eparameters ());\n\n      const ACE_Service_Type *mst = module-\u003erecord (config);\n      if (mst == 0)\n        const_cast\u003cACE_Static_Node *\u003e (module)-\u003eapply (config, yyerrno);\n\n      if (yyerrno != 0)\n        {\n          if (ACE::debug ())\n            {\n              ACE_ERROR ((LM_ERROR,\n                          ACE_TEXT (\"dynamic initialization failed for Module %s\\n\"),\n                          module-\u003ename ()));\n            }\n          ++yyerrno;\n          continue;     // Don't try anything else with this one\n        }\n\n      ACE_Module_Type const * const mt1 =\n        static_cast \u003cACE_Module_Type const *\u003e (module-\u003erecord (config)-\u003etype());\n\n      ACE_Module_Type *mt = const_cast\u003cACE_Module_Type *\u003e(mt1);\n\n      if (st-\u003epush (mt) == -1)\n        {\n          if (ACE::debug ())\n            {\n              ACE_ERROR ((LM_ERROR,\n                          ACE_TEXT (\"dynamic initialization failed for Stream %s\\n\"),\n                          this-\u003enode_-\u003ename ()));\n            }\n          ++yyerrno;\n        }\n\n    }\n\n#ifndef ACE_NLOGGING\n  if (ACE::debug ())\n    ACE_DEBUG ((LM_DEBUG,\n                ACE_TEXT (\"(%P|%t) Did stream on %s, error = %d\\n\"),\n                this-\u003enode_-\u003ename (),\n                yyerrno));\n#endif /* ACE_NLOGGING */\n}\n\nACE_ALLOC_HOOK_DEFINE (ACE_Parse_Node)\n\n  void\nACE_Parse_Node::dump (void) const\n{\n#if defined (ACE_HAS_DUMP)\n  ACE_TRACE (\"ACE_Parse_Node::dump\");\n#endif /* ACE_HAS_DUMP */\n}\n\nconst ACE_TCHAR *\nACE_Parse_Node::name (void) const\n{\n  ACE_TRACE (\"ACE_Parse_Node::name\");\n  return this-\u003ename_;\n}\n\nACE_Parse_Node *\nACE_Parse_Node::link (void) const\n{\n  ACE_TRACE (\"ACE_Parse_Node::link\");\n  return this-\u003enext_;\n}\n\nvoid\nACE_Parse_Node::link (ACE_Parse_Node *n)\n{\n  ACE_TRACE (\"ACE_Parse_Node::link\");\n\n  // Find the last list entry (if any) ...\n  ACE_Parse_Node *t = this;\n  while (t-\u003enext_ != 0)\n      t = t-\u003enext_;\n\n  // ... and insert n there.\n  t-\u003enext_ = n;\n}\n\nACE_Stream_Node::ACE_Stream_Node (const ACE_Static_Node *str_ops,\n                                  const ACE_Parse_Node *str_mods)\n    : ACE_Parse_Node ((str_ops == 0 ? ACE_TEXT (\"\u003cunknown\u003e\") : str_ops-\u003ename ())),\n      node_ (str_ops),\n      mods_ (str_mods)\n{\n  ACE_TRACE (\"ACE_Stream_Node::ACE_Stream_Node\");\n}\n\n\nACE_Stream_Node::~ACE_Stream_Node (void)\n{\n  ACE_TRACE (\"ACE_Stream_Node::~ACE_Stream_Node\");\n  ACE_Static_Node *n = const_cast\u003cACE_Static_Node *\u003e (this-\u003enode_);\n  delete n;\n  ACE_Parse_Node *m = const_cast\u003cACE_Parse_Node *\u003e (this-\u003emods_);\n  delete m;\n}\n\nACE_Parse_Node::ACE_Parse_Node (void)\n  : name_ (0),\n    next_ (0)\n{\n  ACE_TRACE (\"ACE_Parse_Node::ACE_Parse_Node\");\n}\n\n\nACE_Parse_Node::ACE_Parse_Node (const ACE_TCHAR *nm)\n  : name_ (ACE::strnew (nm)),\n    next_ (0)\n{\n  ACE_TRACE (\"ACE_Parse_Node::ACE_Parse_Node\");\n}\n\nvoid\nACE_Parse_Node::print (void) const\n{\n  ACE_TRACE (\"ACE_Parse_Node::print\");\n\n  ACE_DEBUG ((LM_DEBUG,\n              ACE_TEXT (\"svc = %s\\n\"),\n              this-\u003ename ()));\n\n  if (this-\u003enext_)\n    this-\u003enext_-\u003eprint ();\n}\n\n\nACE_Parse_Node::~ACE_Parse_Node (void)\n{\n  ACE_TRACE (\"ACE_Parse_Node::~ACE_Parse_Node\");\n  delete[] const_cast\u003cACE_TCHAR*\u003e (this-\u003ename_);\n  delete this-\u003enext_;\n}\n\nACE_ALLOC_HOOK_DEFINE (ACE_Suspend_Node)\n\n  void\nACE_Suspend_Node::dump (void) const\n{\n#if defined (ACE_HAS_DUMP)\n  ACE_TRACE (\"ACE_Suspend_Node::dump\");\n#endif /* ACE_HAS_DUMP */\n}\n\nACE_Suspend_Node::ACE_Suspend_Node (const ACE_TCHAR *name)\n  : ACE_Parse_Node (name)\n{\n  ACE_TRACE (\"ACE_Suspend_Node::ACE_Suspend_Node\");\n}\n\nACE_Suspend_Node::~ACE_Suspend_Node (void)\n{\n}\n\nACE_ALLOC_HOOK_DEFINE (ACE_Resume_Node)\n\n  void\nACE_Resume_Node::dump (void) const\n{\n#if defined (ACE_HAS_DUMP)\n  ACE_TRACE (\"ACE_Resume_Node::dump\");\n#endif /* ACE_HAS_DUMP */\n}\n\nACE_Resume_Node::ACE_Resume_Node (const ACE_TCHAR *name)\n  : ACE_Parse_Node (name)\n{\n  ACE_TRACE (\"ACE_Resume_Node::ACE_Resume_Node\");\n}\n\nACE_Resume_Node::~ACE_Resume_Node (void)\n{\n}\n\nvoid\nACE_Suspend_Node::apply (ACE_Service_Gestalt *config, int \u0026yyerrno)\n{\n  ACE_TRACE (\"ACE_Suspend_Node::apply\");\n\n  if (config-\u003esuspend (this-\u003ename ()) == -1)\n    ++yyerrno;\n\n#ifndef ACE_NLOGGING\n  if (ACE::debug ())\n    ACE_DEBUG ((LM_DEBUG,\n                ACE_TEXT (\"did suspend on %s, error = %d\\n\"),\n                this-\u003ename (),\n                yyerrno));\n#endif /* ACE_NLOGGING */\n}\n\nvoid\nACE_Resume_Node::apply (ACE_Service_Gestalt *config, int \u0026yyerrno)\n{\n  ACE_TRACE (\"ACE_Resume_Node::apply\");\n\n  if (config-\u003eresume (this-\u003ename ()) == -1)\n    ++yyerrno;\n\n#ifndef ACE_NLOGGING\n  if (ACE::debug ())\n    ACE_DEBUG ((LM_DEBUG,\n                ACE_TEXT (\"did resume on %s, error = %d\\n\"),\n                this-\u003ename (),\n                yyerrno));\n#endif /* ACE_NLOGGING */\n}\n\nACE_ALLOC_HOOK_DEFINE (ACE_Remove_Node)\n\n  void\nACE_Remove_Node::dump (void) const\n{\n#if defined (ACE_HAS_DUMP)\n  ACE_TRACE (\"ACE_Remove_Node::dump\");\n#endif /* ACE_HAS_DUMP */\n}\n\nACE_Remove_Node::ACE_Remove_Node (const ACE_TCHAR *name)\n  : ACE_Parse_Node (name)\n{\n  ACE_TRACE (\"ACE_Remove_Node::ACE_Remove_Node\");\n}\n\nACE_Remove_Node::~ACE_Remove_Node (void)\n{\n}\n\nvoid\nACE_Remove_Node::apply (ACE_Service_Gestalt *config, int \u0026yyerrno)\n{\n  ACE_TRACE (\"ACE_Remove_Node::apply\");\n\n  if (config-\u003eremove (this-\u003ename ()) == -1)\n    ++yyerrno;\n\n#ifndef ACE_NLOGGING\n  if (ACE::debug ())\n    ACE_DEBUG ((LM_DEBUG,\n                ACE_TEXT (\"ACE (%P|%t) Remove_Node::apply\")\n                ACE_TEXT (\" - did remove on %s, error = %d\\n\"),\n                this-\u003ename (),\n                yyerrno));\n#endif /* ACE_NLOGGING */\n}\n\n\nACE_Dynamic_Node::ACE_Dynamic_Node (ACE_Service_Type_Factory const *stf,\n                                    ACE_TCHAR *parms)\n  : ACE_Static_Node (stf-\u003ename (), parms)\n  , factory_ (stf)\n{\n  ACE_TRACE (\"ACE_Dynamic_Node::ACE_Dynamic_Node\");\n}\n\nvoid\nACE_Dynamic_Node::apply (ACE_Service_Gestalt *config, int \u0026yyerrno)\n{\n  ACE_TRACE (\"ACE_Dynamic_Node::apply\");\n\n  if (config-\u003einitialize (this-\u003efactory_.get (),\n                          this-\u003eparameters ()) == -1)\n    ++yyerrno;\n\n#ifndef ACE_NLOGGING\n  if (ACE::debug ())\n    ACE_DEBUG ((LM_DEBUG,\n                ACE_TEXT (\"ACE (%P|%t) Dynamic_Node::apply\")\n                ACE_TEXT (\" - Did dynamic on %s (yyerrno=%d)\\n\"),\n                this-\u003ename (),\n                yyerrno));\n#endif /* ACE_NLOGGING */\n}\n\nACE_ALLOC_HOOK_DEFINE (ACE_Dynamic_Node)\n\n  void\nACE_Dynamic_Node::dump (void) const\n{\n#if defined (ACE_HAS_DUMP)\n  ACE_TRACE (\"ACE_Dynamic_Node::dump\");\n#endif /* ACE_HAS_DUMP */\n}\n\nACE_Dynamic_Node::~ACE_Dynamic_Node (void)\n{\n  ACE_TRACE (\"ACE_Dynamic_Node::~ACE_Dynamic_Node\");\n}\n\nACE_ALLOC_HOOK_DEFINE (ACE_Static_Node)\n\n  void\nACE_Static_Node::dump (void) const\n{\n#if defined (ACE_HAS_DUMP)\n  ACE_TRACE (\"ACE_Static_Node::dump\");\n#endif /* ACE_HAS_DUMP */\n}\n\nACE_Static_Node::ACE_Static_Node (const ACE_TCHAR *nm,\n                                  ACE_TCHAR *params)\n  : ACE_Parse_Node (nm),\n    parameters_ (ACE::strnew (params))\n{\n  ACE_TRACE (\"ACE_Static_Node::ACE_Static_Node\");\n}\n\nconst ACE_Service_Type *\nACE_Static_Node::record (const ACE_Service_Gestalt *config) const\n{\n  ACE_TRACE (\"ACE_Static_Node::record\");\n  ACE_Service_Type *sr = 0;\n\n  if (config-\u003efind (this-\u003ename (), (const ACE_Service_Type **) \u0026sr) == -1)\n    return 0;\n\n  return sr;\n}\n\nACE_TCHAR *\nACE_Static_Node::parameters (void) const\n{\n  ACE_TRACE (\"ACE_Static_Node::parameters\");\n  return this-\u003eparameters_;\n}\n\nvoid\nACE_Static_Node::apply (ACE_Service_Gestalt *config, int \u0026yyerrno)\n{\n  ACE_TRACE (\"ACE_Static_Node::apply\");\n  if (config-\u003einitialize (this-\u003ename (),\n        this-\u003eparameters ()) == -1)\n    ++yyerrno;\n\n#ifndef ACE_NLOGGING\n  if (ACE::debug ())\n    ACE_DEBUG ((LM_DEBUG,\n                ACE_TEXT (\"ACE (%P|%t) Static_Node::apply -\")\n                ACE_TEXT (\" Did static on %s (yyerrno=%d)\\n\"),\n                this-\u003ename (),\n                yyerrno));\n#endif /* ACE_NLOGGING */\n}\n\nACE_Static_Node::~ACE_Static_Node (void)\n{\n  ACE_TRACE (\"ACE_Static_Node::~ACE_Static_Node\");\n  delete[] this-\u003eparameters_;\n}\n\n\nACE_ALLOC_HOOK_DEFINE (ACE_Location_Node)\n\n  void\nACE_Location_Node::dump (void) const\n{\n#if defined (ACE_HAS_DUMP)\n  ACE_TRACE (\"ACE_Location_Node::dump\");\n#endif /* ACE_HAS_DUMP */\n}\n\nACE_Location_Node::ACE_Location_Node (void)\n  : pathname_ (0),\n    dll_ (),\n    symbol_ (0)\n{\n  ACE_TRACE (\"ACE_Location_Node::ACE_Location_Node\");\n}\n\nACE_Location_Node::~ACE_Location_Node (void)\n{\n  ACE_TRACE (\"ACE_Location_Node::~ACE_Location_Node\");\n}\n\nconst ACE_DLL \u0026\nACE_Location_Node::dll (void)\n{\n  return this-\u003edll_;\n}\n\nconst ACE_TCHAR *\nACE_Location_Node::pathname (void) const\n{\n  ACE_TRACE (\"ACE_Location_Node::pathname\");\n  return this-\u003epathname_;\n}\n\nvoid\nACE_Location_Node::pathname (const ACE_TCHAR *p)\n{\n  ACE_TRACE (\"ACE_Location_Node::pathname\");\n  this-\u003epathname_ = p;\n}\n\nint\nACE_Location_Node::dispose (void) const\n{\n  ACE_TRACE (\"ACE_Location_Node::dispose\");\n  return this-\u003emust_delete_;\n}\n\nint\nACE_Location_Node::open_dll (int \u0026 yyerrno)\n{\n  ACE_TRACE (\"ACE_Location_Node::open_dll\");\n\n#ifndef ACE_NLOGGING\n  if (ACE::debug ())\n    ACE_DEBUG ((LM_DEBUG,\n                ACE_TEXT (\"ACE (%P|%t) LN::open_dll - path=%s\\n\"),\n                this-\u003epathname ()));\n#endif /* ACE_NLOGGING */\n\n  if (-1 == this-\u003edll_.open (this-\u003epathname ()))\n    {\n      ++yyerrno;\n\n#ifndef ACE_NLOGGING\n      if (ACE::debug ())\n        {\n          ACE_TCHAR *errmsg = this-\u003edll_.error ();\n          ACE_ERROR ((LM_ERROR,\n                      ACE_TEXT (\"ACE (%P|%t) LN::open_dll - Failed to open %s: %s\\n\"),\n                      this-\u003epathname (),\n                      errmsg ? errmsg : ACE_TEXT (\"no error reported\")));\n        }\n#endif /* ACE_NLOGGING */\n\n      return -1;\n    }\n\n  return 0;\n\n}\n\nvoid\nACE_Location_Node::set_symbol (void *s)\n{\n  ACE_TRACE (\"ACE_Location_Node::set_symbol\");\n  this-\u003esymbol_ = s;\n}\n\nACE_ALLOC_HOOK_DEFINE (ACE_Object_Node)\n\n  void\nACE_Object_Node::dump (void) const\n{\n#if defined (ACE_HAS_DUMP)\n  ACE_TRACE (\"ACE_Object_Node::dump\");\n#endif /* ACE_HAS_DUMP */\n}\n\nACE_Object_Node::ACE_Object_Node (const ACE_TCHAR *path,\n                                  const ACE_TCHAR *obj_name)\n  : object_name_ (ACE::strnew (obj_name))\n{\n  ACE_TRACE (\"ACE_Object_Node::ACE_Object_Node\");\n  this-\u003epathname (ACE::strnew (path));\n  this-\u003emust_delete_ = 0;\n}\n\nvoid *\nACE_Object_Node::symbol (ACE_Service_Gestalt *,\n                         int \u0026yyerrno,\n                         ACE_Service_Object_Exterminator *)\n{\n  ACE_TRACE (\"ACE_Object_Node::symbol\");\n  if (this-\u003eopen_dll (yyerrno) == 0)\n    {\n      ACE_TCHAR *object_name = const_cast\u003cACE_TCHAR *\u003e (this-\u003eobject_name_);\n\n      this-\u003esymbol_ = this-\u003edll_.symbol (object_name);\n      if (this-\u003esymbol_ == 0)\n        {\n          ++yyerrno;\n\n#ifndef ACE_NLOGGING\n          if (ACE::debug ())\n            {\n              ACE_TCHAR *errmsg = this-\u003edll_.error ();\n              ACE_ERROR ((LM_ERROR,\n                          ACE_TEXT (\"ACE (%P|%t) DLL::symbol -\")\n                          ACE_TEXT (\" Failed for object %s: %s\\n\"),\n                          object_name,\n                          errmsg ? errmsg : ACE_TEXT (\"no error reported\")));\n            }\n#endif /* ACE_NLOGGING */\n\n          return 0;\n        }\n\n      return this-\u003esymbol_;\n    }\n\n  return 0;\n}\n\nACE_Object_Node::~ACE_Object_Node (void)\n{\n  ACE_TRACE (\"ACE_Object_Node::~ACE_Object_Node\");\n  delete[] const_cast\u003cACE_TCHAR *\u003e (this-\u003eobject_name_);\n}\n\nACE_ALLOC_HOOK_DEFINE (ACE_Function_Node)\n\n  void\nACE_Function_Node::dump (void) const\n{\n#if defined (ACE_HAS_DUMP)\n  ACE_TRACE (\"ACE_Function_Node::dump\");\n#endif /* ACE_HAS_DUMP */\n}\n\nACE_Function_Node::ACE_Function_Node (const ACE_TCHAR *path,\n                                      const ACE_TCHAR *func_name)\n  : function_name_ (make_func_name (func_name))\n{\n  ACE_TRACE (\"ACE_Function_Node::ACE_Function_Node\");\n  this-\u003epathname (ACE::strnew (path));\n  this-\u003emust_delete_ = 1;\n}\n\nACE_TCHAR *\nACE_Function_Node::make_func_name (ACE_TCHAR const * func_name)\n{\n  // Preprocessor symbols will not be expanded if they are\n  // stringified.  Force the preprocessor to expand them during the\n  // argument prescan by calling a macro that itself calls another\n  // that performs the actual stringification.\n#if defined (ACE_HAS_VERSIONED_NAMESPACE) \u0026\u0026 ACE_HAS_VERSIONED_NAMESPACE == 1\n# define ACE_MAKE_VERSIONED_NAMESPACE_NAME_STRING_IMPL(NAME) #NAME\n# define ACE_MAKE_VERSIONED_NAMESPACE_NAME_STRING(NAME) ACE_MAKE_VERSIONED_NAMESPACE_NAME_STRING_IMPL(NAME)\n# define ACE_VERSIONED_NAMESPACE_NAME_STRING ACE_MAKE_VERSIONED_NAMESPACE_NAME_STRING(ACE_VERSIONED_NAMESPACE_NAME)\n\n  // Check if function is using the ACE naming convention.  If so,\n  // it is likely that the ACE factory function macros\n  // (e.g. ACE_FACTORY_DECLARE) were used to declare and define it, so\n  // mangle the function name to include the ACE versioned namespace\n  // name as is done in the ACE macros.  Otherwise, leave the function\n  // name as is.\n\n  static ACE_TCHAR const make_prefix[] = ACE_TEXT (\"_make_\");\n  static size_t const make_prefix_len =\n    sizeof (make_prefix) / sizeof (make_prefix[0]) - 1;\n\n  if (ACE_OS::strncmp (make_prefix, func_name, make_prefix_len) == 0)\n    {\n      static ACE_TCHAR const versioned_namespace_name[] =\n        ACE_TEXT (ACE_VERSIONED_NAMESPACE_NAME_STRING) ACE_TEXT(\"_\") ;\n\n      // Null terminator included in versioned_namespace_name_len since\n      // it is static constant.\n      static size_t const versioned_namespace_name_len =\n        sizeof (versioned_namespace_name)\n        / sizeof (versioned_namespace_name[0]); // - 1;\n\n      size_t const len =\n        ACE_OS::strlen (func_name)\n        + versioned_namespace_name_len;\n      // + 1;  // Null terminator.\n\n      ACE_TCHAR * mangled_func_name;\n      ACE_NEW_RETURN (mangled_func_name,\n                      ACE_TCHAR[len],\n                      0);\n\n      ACE_Auto_Basic_Array_Ptr\u003cACE_TCHAR\u003e safe (mangled_func_name);\n\n      ACE_OS::snprintf (mangled_func_name,\n                        len,\n                        ACE_TEXT (\"%s%s%s\"),\n                        make_prefix,\n                        versioned_namespace_name,\n                        func_name + make_prefix_len);\n\n      return safe.release ();\n    }\n#endif  /* ACE_HAS_VERSIONED_NAMESPACE == 1 */\n\n  return ACE::strnew (func_name);\n}\n\nvoid *\nACE_Function_Node::symbol (ACE_Service_Gestalt *,\n                           int \u0026yyerrno,\n                           ACE_Service_Object_Exterminator *gobbler)\n{\n  typedef ACE_Service_Object *(*ACE_Service_Factory_Ptr)\n    (ACE_Service_Object_Exterminator *);\n\n  ACE_TRACE (\"ACE_Function_Node::symbol\");\n  if (this-\u003eopen_dll (yyerrno) == 0)\n    {\n      this-\u003esymbol_ = 0;\n\n      // Locate the factory function \u003cfunction_name\u003e in the shared\n      // object.\n      ACE_TCHAR * const function_name =\n        const_cast\u003cACE_TCHAR *\u003e (this-\u003efunction_name_);\n\n      void * const func_p = this-\u003edll_.symbol (function_name);\n      if (func_p == 0)\n        {\n          ++yyerrno;\n\n#ifndef ACE_NLOGGING\n          if (ACE::debug ())\n            {\n              ACE_TCHAR * const errmsg = this-\u003edll_.error ();\n              ACE_ERROR ((LM_ERROR,\n                          ACE_TEXT (\"DLL::symbol failed for function %s: \")\n                          ACE_TEXT (\"%s\\n\"),\n                          function_name,\n                          errmsg ? errmsg : ACE_TEXT (\"no error reported\")));\n            }\n#endif /* ACE_NLOGGING */\n\n          return 0;\n        }\n\n#if defined (ACE_OPENVMS) \u0026\u0026 (!defined (__INITIAL_POINTER_SIZE) || (__INITIAL_POINTER_SIZE \u003c 64))\n      int const temp_p = reinterpret_cast\u003cint\u003e (func_p);\n#else\n      intptr_t const temp_p = reinterpret_cast\u003cintptr_t\u003e (func_p);\n#endif\n\n      ACE_Service_Factory_Ptr func =\n        reinterpret_cast\u003cACE_Service_Factory_Ptr\u003e (temp_p);\n\n      // Invoke the factory function and record it's return value.\n      this-\u003esymbol_ = (*func) (gobbler);\n\n      if (this-\u003esymbol_ == 0)\n        {\n          ++yyerrno;\n          if (ACE::debug ())\n            {\n              ACE_ERROR ((LM_ERROR,\n                         ACE_TEXT (\"%p\\n\"),\n                         this-\u003efunction_name_));\n            }\n          return 0;\n        }\n    }\n  return this-\u003esymbol_;\n}\n\nACE_Function_Node::~ACE_Function_Node (void)\n{\n  ACE_TRACE (\"ACE_Function_Node::~ACE_Function_Node\");\n  delete[] const_cast\u003cACE_TCHAR *\u003e (function_name_);\n  delete[] const_cast\u003cACE_TCHAR *\u003e (pathname_);\n}\n\nACE_ALLOC_HOOK_DEFINE (ACE_Dummy_Node)\n\n  void\nACE_Dummy_Node::dump (void) const\n{\n#if defined (ACE_HAS_DUMP)\n  ACE_TRACE (\"ACE_Dummy_Node::dump\");\n#endif /* ACE_HAS_DUMP */\n}\n\nACE_Dummy_Node::ACE_Dummy_Node (const ACE_Static_Node *static_node,\n                                const ACE_Parse_Node *str_mods)\n  : ACE_Parse_Node (static_node-\u003ename ()),\n    node_ (static_node),\n    mods_ (str_mods)\n{\n  ACE_TRACE (\"ACE_Dummy_Node::ACE_Dummy_Node\");\n}\n\nvoid\nACE_Dummy_Node::apply (ACE_Service_Gestalt *, int \u0026yyerrno)\n{\n  ACE_TRACE (\"ACE_Dummy_Node::apply\");\n\n#ifndef ACE_NLOGGING\n  if (ACE::debug ())\n    ACE_DEBUG ((LM_DEBUG,\n                ACE_TEXT (\"did operations on stream %s, error = %d\\n\"),\n                this-\u003ename (),\n                yyerrno));\n#else\n  ACE_UNUSED_ARG (yyerrno);\n#endif /* ACE_NLOGGING */\n}\n\nACE_Dummy_Node::~ACE_Dummy_Node (void)\n{\n  ACE_TRACE (\"ACE_Dummy_Node::~ACE_Dummy_Node\");\n  ACE_Static_Node *n = const_cast\u003cACE_Static_Node *\u003e (this-\u003enode_);\n  delete n;\n  ACE_Parse_Node *m = const_cast\u003cACE_Parse_Node *\u003e (this-\u003emods_);\n  delete m;\n}\n\nACE_ALLOC_HOOK_DEFINE (ACE_Static_Function_Node)\n\n  void\nACE_Static_Function_Node::dump (void) const\n{\n#if defined (ACE_HAS_DUMP)\n  ACE_TRACE (\"ACE_Static_Function_Node::dump\");\n#endif /* ACE_HAS_DUMP */\n}\n\nACE_Static_Function_Node::ACE_Static_Function_Node (const ACE_TCHAR *func_name)\n  : function_name_ (ACE::strnew (func_name))\n{\n  ACE_TRACE (\"ACE_Static_Function_Node::ACE_Static_Function_Node\");\n  this-\u003emust_delete_ = 1;\n}\n\nvoid *\nACE_Static_Function_Node::symbol (ACE_Service_Gestalt *config,\n                                  int \u0026yyerrno,\n                                  ACE_Service_Object_Exterminator *gobbler)\n{\n  ACE_TRACE (\"ACE_Static_Function_Node::symbol\");\n\n  this-\u003esymbol_ = 0;\n\n  // Locate the factory function \u003cfunction_name\u003e in the statically\n  // linked svcs.\n\n  ACE_Static_Svc_Descriptor *ssd = 0;\n  if (config-\u003efind_static_svc_descriptor (this-\u003efunction_name_, \u0026ssd) == -1)\n    {\n      ++yyerrno;\n      if (ACE::debug ())\n        {\n          ACE_ERROR ((LM_ERROR,\n                     ACE_TEXT (\"(%P|%t) No static service \")\n                     ACE_TEXT (\"registered for function %s\\n\"),\n                     this-\u003efunction_name_));\n        }\n      return 0;\n    }\n\n  if (ssd-\u003ealloc_ == 0)\n    {\n      ++yyerrno;\n\n      if (this-\u003esymbol_ == 0)\n        {\n          ++yyerrno;\n\n          if (ACE::debug ())\n            {\n              ACE_ERROR ((LM_ERROR,\n                          ACE_TEXT (\"(%P|%t) No static service factory \")\n                          ACE_TEXT (\"function registered for function %s\\n\"),\n                          this-\u003efunction_name_));\n            }\n          return 0;\n        }\n    }\n\n  // Invoke the factory function and record it's return value.\n  this-\u003esymbol_ = (*ssd-\u003ealloc_) (gobbler);\n\n  if (this-\u003esymbol_ == 0)\n    {\n      ++yyerrno;\n      if (ACE::debug ())\n        {\n          ACE_ERROR ((LM_ERROR,\n                      ACE_TEXT (\"%p\\n\"),\n                      this-\u003efunction_name_));\n        }\n      return 0;\n    }\n\n  return this-\u003esymbol_;\n}\n\nACE_Static_Function_Node::~ACE_Static_Function_Node (void)\n{\n  ACE_TRACE (\"ACE_Static_Function_Node::~ACE_Static_Function_Node\");\n  delete[] const_cast\u003cACE_TCHAR *\u003e (this-\u003efunction_name_);\n}\n\nACE_ALLOC_HOOK_DEFINE (ACE_Service_Type_Factory)\n\nACE_Service_Type_Factory::ACE_Service_Type_Factory (ACE_TCHAR const *name,\n                                                    int type,\n                                                    ACE_Location_Node *location,\n                                                    int active)\n  : name_ (name)\n  , type_ (type)\n  , location_ (location)\n  , is_active_ (active)\n{\n}\n\n\nACE_Service_Type_Factory::~ACE_Service_Type_Factory (void)\n{\n}\n\n\nACE_Service_Type *\nACE_Service_Type_Factory::make_service_type (ACE_Service_Gestalt *cfg) const\n{\n  ACE_TRACE (\"ACE_Service_Type_Factory::make_service_type\");\n\n  u_int const flags = ACE_Service_Type::DELETE_THIS\n    | (this-\u003elocation_-\u003edispose () == 0 ? 0 : ACE_Service_Type::DELETE_OBJ);\n\n  int yyerrno = 0;\n  ACE_Service_Object_Exterminator gobbler = 0;\n\n  void *sym = this-\u003elocation_-\u003esymbol (cfg, yyerrno, \u0026gobbler);\n\n  if (sym != 0)\n    {\n      ACE_Service_Type_Impl *stp =\n        ACE_Service_Config::create_service_type_impl (this-\u003ename (),\n                                                      this-\u003etype_,\n                                                      sym,\n                                                      flags,\n                                                      gobbler);\n      if (stp == 0)\n        ++yyerrno;\n\n      ACE_Service_Type *tmp = 0;\n      ACE_NEW_RETURN (tmp,\n                      ACE_Service_Type (this-\u003ename (),\n                                        stp,\n                                        this-\u003elocation_-\u003edll (),\n                                        this-\u003eis_active_),\n                      0);\n      return tmp;\n    }\n\n#ifndef ACE_NLOGGING\n  if (ACE::debug ())\n    {\n      ACE_ERROR ((LM_ERROR,\n                  ACE_TEXT (\"ACE (%P|%t) Unable to create \")\n                  ACE_TEXT (\"service object for %s\\n\"),\n                  this-\u003ename ()));\n    }\n#endif\n  ++yyerrno;\n  return 0;\n}\n\nACE_TCHAR const*\nACE_Service_Type_Factory::name (void) const\n{\n  return name_.c_str ();\n}\n\n\nACE_END_VERSIONED_NAMESPACE_DECL\n\n#endif /* ACE_USES_CLASSIC_SVC_CONF == 1 */\n"}
{"repo_name":"llvm-mirror/clang","ref":"refs/heads/master","path":"unittests/Frontend/CodeGenActionTest.cpp","copies":"10","language":"C++","content":"//===- unittests/Frontend/CodeGenActionTest.cpp --- FrontendAction tests --===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// Unit tests for CodeGenAction.\n//\n//===----------------------------------------------------------------------===//\n\n#include \"clang/CodeGen/CodeGenAction.h\"\n#include \"clang/Basic/LangStandard.h\"\n#include \"clang/CodeGen/BackendUtil.h\"\n#include \"clang/Frontend/CompilerInstance.h\"\n#include \"clang/Lex/PreprocessorOptions.h\"\n#include \"gtest/gtest.h\"\n\nusing namespace llvm;\nusing namespace clang;\nusing namespace clang::frontend;\n\nnamespace {\n\n\nclass NullCodeGenAction : public CodeGenAction {\npublic:\n  NullCodeGenAction(llvm::LLVMContext *_VMContext = nullptr)\n    : CodeGenAction(Backend_EmitMCNull, _VMContext) {}\n\n  // The action does not call methods of ATContext.\n  void ExecuteAction() override {\n    CompilerInstance \u0026CI = getCompilerInstance();\n    if (!CI.hasPreprocessor())\n      return;\n    if (!CI.hasSema())\n      CI.createSema(getTranslationUnitKind(), nullptr);\n  }\n};\n\n\nTEST(CodeGenTest, TestNullCodeGen) {\n  auto Invocation = std::make_shared\u003cCompilerInvocation\u003e();\n  Invocation-\u003egetPreprocessorOpts().addRemappedFile(\n      \"test.cc\",\n      MemoryBuffer::getMemBuffer(\"\").release());\n  Invocation-\u003egetFrontendOpts().Inputs.push_back(\n      FrontendInputFile(\"test.cc\", Language::CXX));\n  Invocation-\u003egetFrontendOpts().ProgramAction = EmitLLVM;\n  Invocation-\u003egetTargetOpts().Triple = \"i386-unknown-linux-gnu\";\n  CompilerInstance Compiler;\n  Compiler.setInvocation(std::move(Invocation));\n  Compiler.createDiagnostics();\n  EXPECT_TRUE(Compiler.hasDiagnostics());\n\n  std::unique_ptr\u003cFrontendAction\u003e Act(new NullCodeGenAction);\n  bool Success = Compiler.ExecuteAction(*Act);\n  EXPECT_TRUE(Success);\n}\n\n}\n"}
{"repo_name":"dev-ily/ILoveYouCoins","ref":"refs/heads/master","path":"src/rpcwallet.cpp","copies":"2","language":"C++","content":"// Copyright (c) 2010 Satoshi Nakamoto\n// Copyright (c) 2009-2014 The Bitcoin developers\n// Distributed under the MIT/X11 software license, see the accompanying\n// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n\n#include \u003cboost/assign/list_of.hpp\u003e\n\n#include \"wallet.h\"\n#include \"walletdb.h\"\n#include \"bitcoinrpc.h\"\n#include \"init.h\"\n#include \"base58.h\"\n\nusing namespace std;\nusing namespace boost;\nusing namespace boost::assign;\nusing namespace json_spirit;\n\nint64 nWalletUnlockTime;\nstatic CCriticalSection cs_nWalletUnlockTime;\n\nstd::string HelpRequiringPassphrase()\n{\n    return pwalletMain \u0026\u0026 pwalletMain-\u003eIsCrypted()\n        ? \"\\nrequires wallet passphrase to be set with walletpassphrase first\"\n        : \"\";\n}\n\nvoid EnsureWalletIsUnlocked()\n{\n    if (pwalletMain-\u003eIsLocked())\n        throw JSONRPCError(RPC_WALLET_UNLOCK_NEEDED, \"Error: Please enter the wallet passphrase with walletpassphrase first.\");\n    if (fWalletUnlockStakingOnly)\n        throw JSONRPCError(RPC_WALLET_ALREADY_UNLOCKED_STAKING_ONLY, \"Error: Wallet is unlocked for staking only.\");\n}\n\nvoid WalletTxToJSON(const CWalletTx\u0026 wtx, Object\u0026 entry)\n{\n    int confirms = wtx.GetDepthInMainChain();\n    entry.push_back(Pair(\"confirmations\", confirms));\n    if (wtx.IsCoinBase() || wtx.IsCoinStake())\n        entry.push_back(Pair(\"generated\", true));\n    if (confirms \u003e 0)\n    {\n        entry.push_back(Pair(\"blockhash\", wtx.hashBlock.GetHex()));\n        entry.push_back(Pair(\"blockindex\", wtx.nIndex));\n        entry.push_back(Pair(\"blocktime\", (boost::int64_t)(mapBlockIndex[wtx.hashBlock]-\u003enTime)));\n    }\n    entry.push_back(Pair(\"txid\", wtx.GetHash().GetHex()));\n    entry.push_back(Pair(\"normtxid\", wtx.GetNormalizedHash().GetHex()));\n    entry.push_back(Pair(\"time\", (boost::int64_t)wtx.GetTxTime()));\n    entry.push_back(Pair(\"timereceived\", (boost::int64_t)wtx.nTimeReceived));\n    BOOST_FOREACH(const PAIRTYPE(string,string)\u0026 item, wtx.mapValue)\n        entry.push_back(Pair(item.first, item.second));\n}\n\nstring AccountFromValue(const Value\u0026 value)\n{\n    string strAccount = value.get_str();\n    if (strAccount == \"*\")\n        throw JSONRPCError(RPC_WALLET_INVALID_ACCOUNT_NAME, \"Invalid account name\");\n    return strAccount;\n}\n\nValue getinfo(const Array\u0026 params, bool fHelp)\n{\n    if (fHelp || params.size() != 0)\n        throw runtime_error(\n            \"getinfo\\n\"\n            \"Returns an object containing various state info.\");\n\n    proxyType proxy;\n    GetProxy(NET_IPV4, proxy);\n\n    Object obj;\n    obj.push_back(Pair(\"version\",       (int)CLIENT_VERSION));\n    obj.push_back(Pair(\"protocolversion\",(int)PROTOCOL_VERSION));\n    if (pwalletMain) {\n        obj.push_back(Pair(\"walletversion\",      pwalletMain-\u003eGetVersion()));\n        obj.push_back(Pair(\"balance\",            ValueFromAmount(pwalletMain-\u003eGetBalance())));\n        obj.push_back(Pair(\"unconfirmedbalance\", ValueFromAmount(pwalletMain-\u003eGetUnconfirmedBalance())));\n        obj.push_back(Pair(\"stake\",              ValueFromAmount(pwalletMain-\u003eGetStake())));\n        obj.push_back(Pair(\"locked\",             pwalletMain-\u003eIsLocked()));\n        obj.push_back(Pair(\"encrypted\",          pwalletMain-\u003eIsCrypted()));\n    }\n    obj.push_back(Pair(\"blocks\",        (int)nBestHeight));\n    obj.push_back(Pair(\"timeoffset\",    (boost::int64_t)GetTimeOffset()));\n    obj.push_back(Pair(\"moneysupply\",   ValueFromAmount(pindexBest-\u003enMoneySupply)));\n    obj.push_back(Pair(\"connections\",   (int)vNodes.size()));\n    obj.push_back(Pair(\"proxy\",         (proxy.first.IsValid() ? proxy.first.ToStringIPPort() : string())));\n    obj.push_back(Pair(\"difficulty\",    (double)GetDifficulty()));\n    obj.push_back(Pair(\"testnet\",       fTestNet));\n    if (pwalletMain) {\n        obj.push_back(Pair(\"keypoololdest\", (boost::int64_t)pwalletMain-\u003eGetOldestKeyPoolTime()));\n        obj.push_back(Pair(\"keypoolsize\",   (int)pwalletMain-\u003eGetKeyPoolSize()));\n    }\n    obj.push_back(Pair(\"paytxfee\",      ValueFromAmount(nTransactionFee)));\n    obj.push_back(Pair(\"mininput\",      ValueFromAmount(nMinimumInputValue)));\n    if (pwalletMain \u0026\u0026 pwalletMain-\u003eIsCrypted())\n        obj.push_back(Pair(\"unlocked_until\", (boost::int64_t)nWalletUnlockTime));\n    obj.push_back(Pair(\"errors\",        GetWarnings(\"statusbar\")));\n    return obj;\n}\n\n\n\nValue getnewaddress(const Array\u0026 params, bool fHelp)\n{\n    if (fHelp || params.size() \u003e 1)\n        throw runtime_error(\n            \"getnewaddress [account]\\n\"\n            \"Returns a new ILoveYouCoins address for receiving payments.  \"\n            \"If [account] is specified (recommended), it is added to the address book \"\n            \"so payments received with the address will be credited to [account].\");\n\n    // Parse the account first so we don't generate a key if there's an error\n    string strAccount;\n    if (params.size() \u003e 0)\n        strAccount = AccountFromValue(params[0]);\n\n    if (!pwalletMain-\u003eIsLocked())\n        pwalletMain-\u003eTopUpKeyPool();\n\n    // Generate a new key that is added to wallet\n    CPubKey newKey;\n    if (!pwalletMain-\u003eGetKeyFromPool(newKey, false))\n        throw JSONRPCError(RPC_WALLET_KEYPOOL_RAN_OUT, \"Error: Keypool ran out, please call keypoolrefill first\");\n    CKeyID keyID = newKey.GetID();\n\n    pwalletMain-\u003eSetAddressBookName(keyID, strAccount);\n\n    return CBitcoinAddress(keyID).ToString();\n}\n\n\nCBitcoinAddress GetAccountAddress(string strAccount, bool bForceNew=false)\n{\n    CWalletDB walletdb(pwalletMain-\u003estrWalletFile);\n\n    CAccount account;\n    walletdb.ReadAccount(strAccount, account);\n\n    bool bKeyUsed = false;\n\n    // Check if the current key has been used\n    if (account.vchPubKey.IsValid())\n    {\n        CScript scriptPubKey;\n        scriptPubKey.SetDestination(account.vchPubKey.GetID());\n        for (map\u003cuint256, CWalletTx\u003e::iterator it = pwalletMain-\u003emapWallet.begin();\n             it != pwalletMain-\u003emapWallet.end() \u0026\u0026 account.vchPubKey.IsValid();\n             ++it)\n        {\n            const CWalletTx\u0026 wtx = (*it).second;\n            BOOST_FOREACH(const CTxOut\u0026 txout, wtx.vout)\n                if (txout.scriptPubKey == scriptPubKey)\n                    bKeyUsed = true;\n        }\n    }\n\n    // Generate a new key\n    if (!account.vchPubKey.IsValid() || bForceNew || bKeyUsed)\n    {\n        if (!pwalletMain-\u003eGetKeyFromPool(account.vchPubKey, false))\n            throw JSONRPCError(RPC_WALLET_KEYPOOL_RAN_OUT, \"Error: Keypool ran out, please call keypoolrefill first\");\n\n        pwalletMain-\u003eSetAddressBookName(account.vchPubKey.GetID(), strAccount);\n        walletdb.WriteAccount(strAccount, account);\n    }\n\n    return CBitcoinAddress(account.vchPubKey.GetID());\n}\n\nValue getaccountaddress(const Array\u0026 params, bool fHelp)\n{\n    if (fHelp || params.size() != 1)\n        throw runtime_error(\n            \"getaccountaddress \u003caccount\u003e\\n\"\n            \"Returns the current ILoveYouCoins address for receiving payments to this account.\");\n\n    // Parse the account first so we don't generate a key if there's an error\n    string strAccount = AccountFromValue(params[0]);\n\n    Value ret;\n\n    ret = GetAccountAddress(strAccount).ToString();\n\n    return ret;\n}\n\n\n\nValue setaccount(const Array\u0026 params, bool fHelp)\n{\n    if (fHelp || params.size() \u003c 1 || params.size() \u003e 2)\n        throw runtime_error(\n            \"setaccount \u003ciloveyoucoinsaddress\u003e \u003caccount\u003e\\n\"\n            \"Sets the account associated with the given address.\");\n\n    CBitcoinAddress address(params[0].get_str());\n    if (!address.IsValid())\n        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid ILoveYouCoins address\");\n\n\n    string strAccount;\n    if (params.size() \u003e 1)\n        strAccount = AccountFromValue(params[1]);\n\n    // Detect when changing the account of an address that is the 'unused current key' of another account:\n    if (pwalletMain-\u003emapAddressBook.count(address.Get()))\n    {\n        string strOldAccount = pwalletMain-\u003emapAddressBook[address.Get()];\n        if (address == GetAccountAddress(strOldAccount))\n            GetAccountAddress(strOldAccount, true);\n    }\n\n    pwalletMain-\u003eSetAddressBookName(address.Get(), strAccount);\n\n    return Value::null;\n}\n\n\nValue getaccount(const Array\u0026 params, bool fHelp)\n{\n    if (fHelp || params.size() != 1)\n        throw runtime_error(\n            \"getaccount \u003ciloveyoucoinsaddress\u003e\\n\"\n            \"Returns the account associated with the given address.\");\n\n    CBitcoinAddress address(params[0].get_str());\n    if (!address.IsValid())\n        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid ILoveYouCoins address\");\n\n    string strAccount;\n    map\u003cCTxDestination, string\u003e::iterator mi = pwalletMain-\u003emapAddressBook.find(address.Get());\n    if (mi != pwalletMain-\u003emapAddressBook.end() \u0026\u0026 !(*mi).second.empty())\n        strAccount = (*mi).second;\n    return strAccount;\n}\n\n\nValue getaddressesbyaccount(const Array\u0026 params, bool fHelp)\n{\n    if (fHelp || params.size() != 1)\n        throw runtime_error(\n            \"getaddressesbyaccount \u003caccount\u003e\\n\"\n            \"Returns the list of addresses for the given account.\");\n\n    string strAccount = AccountFromValue(params[0]);\n\n    // Find all addresses that have the given account\n    Array ret;\n    BOOST_FOREACH(const PAIRTYPE(CBitcoinAddress, string)\u0026 item, pwalletMain-\u003emapAddressBook)\n    {\n        const CBitcoinAddress\u0026 address = item.first;\n        const string\u0026 strName = item.second;\n        if (strName == strAccount)\n            ret.push_back(address.ToString());\n    }\n    return ret;\n}\n\n\nValue setmininput(const Array\u0026 params, bool fHelp)\n{\n    if (fHelp || params.size() \u003c 1 || params.size() \u003e 1)\n        throw runtime_error(\n            \"setmininput \u003camount\u003e\\n\"\n            \"\u003camount\u003e is a real and is rounded to the nearest 0.00000001\");\n\n    // Amount\n    int64 nAmount = 0;\n    if (params[0].get_real() != 0.0)\n        nAmount = AmountFromValue(params[0]);        // rejects 0.0 amounts\n\n    nMinimumInputValue = nAmount;\n    return true;\n}\n\n\nValue sendtoaddress(const Array\u0026 params, bool fHelp)\n{\n    if (fHelp || params.size() \u003c 2 || params.size() \u003e 4)\n        throw runtime_error(\n            \"sendtoaddress \u003ciloveyoucoinsaddress\u003e \u003camount\u003e [comment] [comment-to]\\n\"\n            \"\u003camount\u003e is a real and is rounded to the nearest 0.00000001\"\n            + HelpRequiringPassphrase());\n\n    CBitcoinAddress address(params[0].get_str());\n    if (!address.IsValid())\n        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid ILoveYouCoins address\");\n\n    // Amount\n    int64 nAmount = AmountFromValue(params[1]);\n\n    // Wallet comments\n    CWalletTx wtx;\n    if (params.size() \u003e 2 \u0026\u0026 params[2].type() != null_type \u0026\u0026 !params[2].get_str().empty())\n        wtx.mapValue[\"comment\"] = params[2].get_str();\n    if (params.size() \u003e 3 \u0026\u0026 params[3].type() != null_type \u0026\u0026 !params[3].get_str().empty())\n        wtx.mapValue[\"to\"]      = params[3].get_str();\n\n    EnsureWalletIsUnlocked();\n\n    string strError = pwalletMain-\u003eSendMoneyToDestination(address.Get(), nAmount, wtx);\n    if (strError != \"\")\n        throw JSONRPCError(RPC_WALLET_ERROR, strError);\n\n    return wtx.GetHash().GetHex();\n}\n\nValue listaddressgroupings(const Array\u0026 params, bool fHelp)\n{\n    if (fHelp)\n        throw runtime_error(\n            \"listaddressgroupings\\n\"\n            \"Lists groups of addresses which have had their common ownership\\n\"\n            \"made public by common use as inputs or as the resulting change\\n\"\n            \"in past transactions\");\n\n    Array jsonGroupings;\n    map\u003cCTxDestination, int64\u003e balances = pwalletMain-\u003eGetAddressBalances();\n    BOOST_FOREACH(set\u003cCTxDestination\u003e grouping, pwalletMain-\u003eGetAddressGroupings())\n    {\n        Array jsonGrouping;\n        BOOST_FOREACH(CTxDestination address, grouping)\n        {\n            Array addressInfo;\n            addressInfo.push_back(CBitcoinAddress(address).ToString());\n            addressInfo.push_back(ValueFromAmount(balances[address]));\n            {\n                LOCK(pwalletMain-\u003ecs_wallet);\n                if (pwalletMain-\u003emapAddressBook.find(CBitcoinAddress(address).Get()) != pwalletMain-\u003emapAddressBook.end())\n                    addressInfo.push_back(pwalletMain-\u003emapAddressBook.find(CBitcoinAddress(address).Get())-\u003esecond);\n            }\n            jsonGrouping.push_back(addressInfo);\n        }\n        jsonGroupings.push_back(jsonGrouping);\n    }\n    return jsonGroupings;\n}\n\nValue signmessage(const Array\u0026 params, bool fHelp)\n{\n    if (fHelp || params.size() != 2)\n        throw runtime_error(\n            \"signmessage \u003ciloveyoucoinsaddress\u003e \u003cmessage\u003e\\n\"\n            \"Sign a message with the private key of an address\");\n\n    EnsureWalletIsUnlocked();\n\n    string strAddress = params[0].get_str();\n    string strMessage = params[1].get_str();\n\n    CBitcoinAddress addr(strAddress);\n    if (!addr.IsValid())\n        throw JSONRPCError(RPC_TYPE_ERROR, \"Invalid address\");\n\n    CKeyID keyID;\n    if (!addr.GetKeyID(keyID))\n        throw JSONRPCError(RPC_TYPE_ERROR, \"Address does not refer to key\");\n\n    CKey key;\n    if (!pwalletMain-\u003eGetKey(keyID, key))\n        throw JSONRPCError(RPC_WALLET_ERROR, \"Private key not available\");\n\n    CHashWriter ss(SER_GETHASH, 0);\n    ss \u003c\u003c strMessageMagic;\n    ss \u003c\u003c strMessage;\n\n    vector\u003cunsigned char\u003e vchSig;\n    if (!key.SignCompact(ss.GetHash(), vchSig))\n        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Sign failed\");\n\n    return EncodeBase64(\u0026vchSig[0], vchSig.size());\n}\n\nValue verifymessage(const Array\u0026 params, bool fHelp)\n{\n    if (fHelp || params.size() != 3)\n        throw runtime_error(\n            \"verifymessage \u003ciloveyoucoinsaddress\u003e \u003csignature\u003e \u003cmessage\u003e\\n\"\n            \"Verify a signed message\");\n\n    string strAddress  = params[0].get_str();\n    string strSign     = params[1].get_str();\n    string strMessage  = params[2].get_str();\n\n    CBitcoinAddress addr(strAddress);\n    if (!addr.IsValid())\n        throw JSONRPCError(RPC_TYPE_ERROR, \"Invalid address\");\n\n    CKeyID keyID;\n    if (!addr.GetKeyID(keyID))\n        throw JSONRPCError(RPC_TYPE_ERROR, \"Address does not refer to key\");\n\n    bool fInvalid = false;\n    vector\u003cunsigned char\u003e vchSig = DecodeBase64(strSign.c_str(), \u0026fInvalid);\n\n    if (fInvalid)\n        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Malformed base64 encoding\");\n\n    CHashWriter ss(SER_GETHASH, 0);\n    ss \u003c\u003c strMessageMagic;\n    ss \u003c\u003c strMessage;\n\n    CPubKey pubkey;\n    if (!pubkey.RecoverCompact(ss.GetHash(), vchSig))\n        return false;\n\n    return (pubkey.GetID() == keyID);\n}\n\n\nValue getreceivedbyaddress(const Array\u0026 params, bool fHelp)\n{\n    if (fHelp || params.size() \u003c 1 || params.size() \u003e 2)\n        throw runtime_error(\n            \"getreceivedbyaddress \u003ciloveyoucoinsaddress\u003e [minconf=1]\\n\"\n            \"Returns the total amount received by \u003ciloveyoucoinsaddress\u003e in transactions with at least [minconf] confirmations.\");\n\n    // Bitcoin address\n    CBitcoinAddress address = CBitcoinAddress(params[0].get_str());\n    CScript scriptPubKey;\n    if (!address.IsValid())\n        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid ILoveYouCoins address\");\n    scriptPubKey.SetDestination(address.Get());\n    if (!IsMine(*pwalletMain,scriptPubKey))\n        return (double)0.0;\n\n    // Minimum confirmations\n    int nMinDepth = 1;\n    if (params.size() \u003e 1)\n        nMinDepth = params[1].get_int();\n\n    // Tally\n    int64 nAmount = 0;\n    for (map\u003cuint256, CWalletTx\u003e::iterator it = pwalletMain-\u003emapWallet.begin(); it != pwalletMain-\u003emapWallet.end(); ++it)\n    {\n        const CWalletTx\u0026 wtx = (*it).second;\n        if (wtx.IsCoinBase() || wtx.IsCoinStake() || !wtx.IsFinal())\n            continue;\n\n        BOOST_FOREACH(const CTxOut\u0026 txout, wtx.vout)\n            if (txout.scriptPubKey == scriptPubKey)\n                if (wtx.GetDepthInMainChain() \u003e= nMinDepth)\n                    nAmount += txout.nValue;\n    }\n\n    return  ValueFromAmount(nAmount);\n}\n\n\nvoid GetAccountAddresses(string strAccount, set\u003cCTxDestination\u003e\u0026 setAddress)\n{\n    BOOST_FOREACH(const PAIRTYPE(CTxDestination, string)\u0026 item, pwalletMain-\u003emapAddressBook)\n    {\n        const CTxDestination\u0026 address = item.first;\n        const string\u0026 strName = item.second;\n        if (strName == strAccount)\n            setAddress.insert(address);\n    }\n}\n\nValue getreceivedbyaccount(const Array\u0026 params, bool fHelp)\n{\n    if (fHelp || params.size() \u003c 1 || params.size() \u003e 2)\n        throw runtime_error(\n            \"getreceivedbyaccount \u003caccount\u003e [minconf=1]\\n\"\n            \"Returns the total amount received by addresses with \u003caccount\u003e in transactions with at least [minconf] confirmations.\");\n\n    // Minimum confirmations\n    int nMinDepth = 1;\n    if (params.size() \u003e 1)\n        nMinDepth = params[1].get_int();\n\n    // Get the set of pub keys assigned to account\n    string strAccount = AccountFromValue(params[0]);\n    set\u003cCTxDestination\u003e setAddress;\n    GetAccountAddresses(strAccount, setAddress);\n\n    // Tally\n    int64 nAmount = 0;\n    for (map\u003cuint256, CWalletTx\u003e::iterator it = pwalletMain-\u003emapWallet.begin(); it != pwalletMain-\u003emapWallet.end(); ++it)\n    {\n        const CWalletTx\u0026 wtx = (*it).second;\n        if (wtx.IsCoinBase() || wtx.IsCoinStake() || !wtx.IsFinal())\n            continue;\n\n        BOOST_FOREACH(const CTxOut\u0026 txout, wtx.vout)\n        {\n            CTxDestination address;\n            if (ExtractDestination(txout.scriptPubKey, address) \u0026\u0026 IsMine(*pwalletMain, address) \u0026\u0026 setAddress.count(address))\n                if (wtx.GetDepthInMainChain() \u003e= nMinDepth)\n                    nAmount += txout.nValue;\n        }\n    }\n\n    return (double)nAmount / (double)COIN;\n}\n\n\nint64 GetAccountBalance(CWalletDB\u0026 walletdb, const string\u0026 strAccount, int nMinDepth)\n{\n    int64 nBalance = 0;\n\n    // Tally wallet transactions\n    for (map\u003cuint256, CWalletTx\u003e::iterator it = pwalletMain-\u003emapWallet.begin(); it != pwalletMain-\u003emapWallet.end(); ++it)\n    {\n        const CWalletTx\u0026 wtx = (*it).second;\n        if (!wtx.IsFinal())\n            continue;\n\n        int64 nReceived, nSent, nFee;\n        wtx.GetAccountAmounts(strAccount, nReceived, nSent, nFee);\n\n        if (nReceived != 0 \u0026\u0026 wtx.GetDepthInMainChain() \u003e= nMinDepth)\n            nBalance += nReceived;\n        nBalance -= nSent + nFee;\n    }\n\n    // Tally internal accounting entries\n    nBalance += walletdb.GetAccountCreditDebit(strAccount);\n\n    return nBalance;\n}\n\nint64 GetAccountBalance(const string\u0026 strAccount, int nMinDepth)\n{\n    CWalletDB walletdb(pwalletMain-\u003estrWalletFile);\n    return GetAccountBalance(walletdb, strAccount, nMinDepth);\n}\n\n\nValue getbalance(const Array\u0026 params, bool fHelp)\n{\n    if (fHelp || params.size() \u003e 2)\n        throw runtime_error(\n            \"getbalance [account] [minconf=1]\\n\"\n            \"If [account] is not specified, returns the server's total available balance.\\n\"\n            \"If [account] is specified, returns the balance in the account.\");\n\n    if (params.size() == 0)\n        return  ValueFromAmount(pwalletMain-\u003eGetBalance());\n\n    int nMinDepth = 1;\n    if (params.size() \u003e 1)\n        nMinDepth = params[1].get_int();\n\n    if (params[0].get_str() == \"*\") {\n        // Calculate total balance a different way from GetBalance()\n        // (GetBalance() sums up all unspent TxOuts)\n        // getbalance and getbalance '*' 0 should return the same number\n        int64 nBalance = 0;\n        for (map\u003cuint256, CWalletTx\u003e::iterator it = pwalletMain-\u003emapWallet.begin(); it != pwalletMain-\u003emapWallet.end(); ++it)\n        {\n            const CWalletTx\u0026 wtx = (*it).second;\n            if (!wtx.IsConfirmed())\n                continue;\n\n            int64 allFee;\n            string strSentAccount;\n            list\u003cpair\u003cCTxDestination, int64\u003e \u003e listReceived;\n            list\u003cpair\u003cCTxDestination, int64\u003e \u003e listSent;\n            wtx.GetAmounts(listReceived, listSent, allFee, strSentAccount);\n            if (wtx.GetDepthInMainChain() \u003e= nMinDepth)\n            {\n                BOOST_FOREACH(const PAIRTYPE(CTxDestination,int64)\u0026 r, listReceived)\n                    nBalance += r.second;\n            }\n            BOOST_FOREACH(const PAIRTYPE(CTxDestination,int64)\u0026 r, listSent)\n                nBalance -= r.second;\n            nBalance -= allFee;\n        }\n        return  ValueFromAmount(nBalance);\n    }\n\n    string strAccount = AccountFromValue(params[0]);\n\n    int64 nBalance = GetAccountBalance(strAccount, nMinDepth);\n\n    return ValueFromAmount(nBalance);\n}\n\nValue getunconfirmedbalance(const Array \u0026params, bool fHelp)\n{\n    if (fHelp || params.size() \u003e 0)\n        throw runtime_error(\n                \"getunconfirmedbalance\\n\"\n                \"Returns the server's total unconfirmed balance\\n\");\n    return ValueFromAmount(pwalletMain-\u003eGetUnconfirmedBalance());\n}\n\n\nValue movecmd(const Array\u0026 params, bool fHelp)\n{\n    if (fHelp || params.size() \u003c 3 || params.size() \u003e 5)\n        throw runtime_error(\n            \"move \u003cfromaccount\u003e \u003ctoaccount\u003e \u003camount\u003e [minconf=1] [comment]\\n\"\n            \"Move from one account in your wallet to another.\");\n\n    string strFrom = AccountFromValue(params[0]);\n    string strTo = AccountFromValue(params[1]);\n    int64 nAmount = AmountFromValue(params[2]);\n    if (params.size() \u003e 3)\n        // unused parameter, used to be nMinDepth, keep type-checking it though\n        (void)params[3].get_int();\n    string strComment;\n    if (params.size() \u003e 4)\n        strComment = params[4].get_str();\n\n    CWalletDB walletdb(pwalletMain-\u003estrWalletFile);\n    if (!walletdb.TxnBegin())\n        throw JSONRPCError(RPC_DATABASE_ERROR, \"database error\");\n\n    int64 nNow = GetAdjustedTime();\n\n    // Debit\n    CAccountingEntry debit;\n    debit.nOrderPos = pwalletMain-\u003eIncOrderPosNext(\u0026walletdb);\n    debit.strAccount = strFrom;\n    debit.nCreditDebit = -nAmount;\n    debit.nTime = nNow;\n    debit.strOtherAccount = strTo;\n    debit.strComment = strComment;\n    walletdb.WriteAccountingEntry(debit);\n\n    // Credit\n    CAccountingEntry credit;\n    credit.nOrderPos = pwalletMain-\u003eIncOrderPosNext(\u0026walletdb);\n    credit.strAccount = strTo;\n    credit.nCreditDebit = nAmount;\n    credit.nTime = nNow;\n    credit.strOtherAccount = strFrom;\n    credit.strComment = strComment;\n    walletdb.WriteAccountingEntry(credit);\n\n    if (!walletdb.TxnCommit())\n        throw JSONRPCError(RPC_DATABASE_ERROR, \"database error\");\n\n    return true;\n}\n\n\nValue sendfrom(const Array\u0026 params, bool fHelp)\n{\n    if (fHelp || params.size() \u003c 3 || params.size() \u003e 6)\n        throw runtime_error(\n            \"sendfrom \u003cfromaccount\u003e \u003ctoiloveyoucoinsaddress\u003e \u003camount\u003e [minconf=1] [comment] [comment-to]\\n\"\n            \"\u003camount\u003e is a real and is rounded to the nearest 0.00000001\"\n            + HelpRequiringPassphrase());\n\n    string strAccount = AccountFromValue(params[0]);\n    CBitcoinAddress address(params[1].get_str());\n    if (!address.IsValid())\n        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid ILoveYouCoins address\");\n    int64 nAmount = AmountFromValue(params[2]);\n    int nMinDepth = 1;\n    if (params.size() \u003e 3)\n        nMinDepth = params[3].get_int();\n\n    CWalletTx wtx;\n    wtx.strFromAccount = strAccount;\n    if (params.size() \u003e 4 \u0026\u0026 params[4].type() != null_type \u0026\u0026 !params[4].get_str().empty())\n        wtx.mapValue[\"comment\"] = params[4].get_str();\n    if (params.size() \u003e 5 \u0026\u0026 params[5].type() != null_type \u0026\u0026 !params[5].get_str().empty())\n        wtx.mapValue[\"to\"]      = params[5].get_str();\n\n    EnsureWalletIsUnlocked();\n\n    // Check funds\n    int64 nBalance = GetAccountBalance(strAccount, nMinDepth);\n    if (nAmount \u003e nBalance)\n        throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Account has insufficient funds\");\n\n    // Send\n    string strError = pwalletMain-\u003eSendMoneyToDestination(address.Get(), nAmount, wtx);\n    if (strError != \"\")\n        throw JSONRPCError(RPC_WALLET_ERROR, strError);\n\n    return wtx.GetHash().GetHex();\n}\n\n\nValue sendmany(const Array\u0026 params, bool fHelp)\n{\n    if (fHelp || params.size() \u003c 2 || params.size() \u003e 4)\n        throw runtime_error(\n            \"sendmany \u003cfromaccount\u003e {address:amount,...} [minconf=1] [comment]\\n\"\n            \"amounts are double-precision floating point numbers\"\n            + HelpRequiringPassphrase());\n\n    string strAccount = AccountFromValue(params[0]);\n    Object sendTo = params[1].get_obj();\n    int nMinDepth = 1;\n    if (params.size() \u003e 2)\n        nMinDepth = params[2].get_int();\n\n    CWalletTx wtx;\n    wtx.strFromAccount = strAccount;\n    if (params.size() \u003e 3 \u0026\u0026 params[3].type() != null_type \u0026\u0026 !params[3].get_str().empty())\n        wtx.mapValue[\"comment\"] = params[3].get_str();\n\n    set\u003cCBitcoinAddress\u003e setAddress;\n    vector\u003cpair\u003cCScript, int64\u003e \u003e vecSend;\n\n    int64 totalAmount = 0;\n    BOOST_FOREACH(const Pair\u0026 s, sendTo)\n    {\n        CBitcoinAddress address(s.name_);\n        if (!address.IsValid())\n            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, string(\"Invalid ILoveYouCoins address: \")+s.name_);\n\n        if (setAddress.count(address))\n            throw JSONRPCError(RPC_INVALID_PARAMETER, string(\"Invalid parameter, duplicated address: \")+s.name_);\n        setAddress.insert(address);\n\n        CScript scriptPubKey;\n        scriptPubKey.SetDestination(address.Get());\n        int64 nAmount = AmountFromValue(s.value_);\n        totalAmount += nAmount;\n\n        vecSend.push_back(make_pair(scriptPubKey, nAmount));\n    }\n\n    EnsureWalletIsUnlocked();\n\n    // Check funds\n    int64 nBalance = GetAccountBalance(strAccount, nMinDepth);\n    if (totalAmount \u003e nBalance)\n        throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Account has insufficient funds\");\n\n    // Send\n    CReserveKey keyChange(pwalletMain);\n    int64 nFeeRequired = 0;\n    string strFailReason;\n    bool fCreated = pwalletMain-\u003eCreateTransaction(vecSend, wtx, keyChange, nFeeRequired, strFailReason);\n    if (!fCreated)\n        throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, strFailReason);\n    if (!pwalletMain-\u003eCommitTransaction(wtx, keyChange))\n        throw JSONRPCError(RPC_WALLET_ERROR, \"Transaction commit failed\");\n\n    return wtx.GetHash().GetHex();\n}\n\n//\n// Used by addmultisigaddress / createmultisig:\n//\nstatic CScript _createmultisig(const Array\u0026 params)\n{\n    int nRequired = params[0].get_int();\n    const Array\u0026 keys = params[1].get_array();\n\n    // Gather public keys\n    if (nRequired \u003c 1)\n        throw runtime_error(\"a multisignature address must require at least one key to redeem\");\n    if ((int)keys.size() \u003c nRequired)\n        throw runtime_error(\n            strprintf(\"not enough keys supplied \"\n                      \"(got %\"PRIszu\" keys, but need at least %d to redeem)\", keys.size(), nRequired));\n    std::vector\u003cCPubKey\u003e pubkeys;\n    pubkeys.resize(keys.size());\n    for (unsigned int i = 0; i \u003c keys.size(); i++)\n    {\n        const std::string\u0026 ks = keys[i].get_str();\n\n        // Case 1: ILoveYouCoins address and we have full public key:\n        CBitcoinAddress address(ks);\n        if (pwalletMain \u0026\u0026 address.IsValid())\n        {\n            CKeyID keyID;\n            if (!address.GetKeyID(keyID))\n                throw runtime_error(\n                    strprintf(\"%s does not refer to a key\",ks.c_str()));\n            CPubKey vchPubKey;\n            if (!pwalletMain-\u003eGetPubKey(keyID, vchPubKey))\n                throw runtime_error(\n                    strprintf(\"no full public key for address %s\",ks.c_str()));\n            if (!vchPubKey.IsFullyValid())\n                throw runtime_error(\" Invalid public key: \"+ks);\n            pubkeys[i] = vchPubKey;\n        }\n\n        // Case 2: hex public key\n        else if (IsHex(ks))\n        {\n            CPubKey vchPubKey(ParseHex(ks));\n            if (!vchPubKey.IsFullyValid())\n                throw runtime_error(\" Invalid public key: \"+ks);\n            pubkeys[i] = vchPubKey;\n        }\n        else\n        {\n            throw runtime_error(\" Invalid public key: \"+ks);\n        }\n    }\n    CScript result;\n    result.SetMultisig(nRequired, pubkeys);\n    return result;\n}\n\nValue addmultisigaddress(const Array\u0026 params, bool fHelp)\n{\n    if (fHelp || params.size() \u003c 2 || params.size() \u003e 3)\n    {\n        string msg = \"addmultisigaddress \u003cnrequired\u003e \u003c'[\\\"key\\\",\\\"key\\\"]'\u003e [account]\\n\"\n            \"Add a nrequired-to-sign multisignature address to the wallet\\\"\\n\"\n            \"each key is a ILoveYouCoins address or hex-encoded public key\\n\"\n            \"If [account] is specified, assign address to [account].\";\n        throw runtime_error(msg);\n    }\n\n    string strAccount;\n    if (params.size() \u003e 2)\n        strAccount = AccountFromValue(params[2]);\n\n    // Construct using pay-to-script-hash:\n    CScript inner = _createmultisig(params);\n    CScriptID innerID = inner.GetID();\n    pwalletMain-\u003eAddCScript(inner);\n\n    pwalletMain-\u003eSetAddressBookName(innerID, strAccount);\n    return CBitcoinAddress(innerID).ToString();\n}\n\nValue createmultisig(const Array\u0026 params, bool fHelp)\n{\n    if (fHelp || params.size() \u003c 2 || params.size() \u003e 2)\n    {\n        string msg = \"createmultisig \u003cnrequired\u003e \u003c'[\\\"key\\\",\\\"key\\\"]'\u003e\\n\"\n            \"Creates a multi-signature address and returns a json object\\n\"\n            \"with keys:\\n\"\n            \"address : iloveyoucoins address\\n\"\n            \"redeemScript : hex-encoded redemption script\";\n        throw runtime_error(msg);\n    }\n\n    // Construct using pay-to-script-hash:\n    CScript inner = _createmultisig(params);\n    CScriptID innerID = inner.GetID();\n    CBitcoinAddress address(innerID);\n\n    Object result;\n    result.push_back(Pair(\"address\", address.ToString()));\n    result.push_back(Pair(\"redeemScript\", HexStr(inner.begin(), inner.end())));\n\n    return result;\n}\n\n\nstruct tallyitem\n{\n    int64 nAmount;\n    int nConf;\n    vector\u003cuint256\u003e txids;\n    tallyitem()\n    {\n        nAmount = 0;\n        nConf = std::numeric_limits\u003cint\u003e::max();\n    }\n};\n\nValue ListReceived(const Array\u0026 params, bool fByAccounts)\n{\n    // Minimum confirmations\n    int nMinDepth = 1;\n    if (params.size() \u003e 0)\n        nMinDepth = params[0].get_int();\n\n    // Whether to include empty accounts\n    bool fIncludeEmpty = false;\n    if (params.size() \u003e 1)\n        fIncludeEmpty = params[1].get_bool();\n\n    // Tally\n    map\u003cCBitcoinAddress, tallyitem\u003e mapTally;\n    for (map\u003cuint256, CWalletTx\u003e::iterator it = pwalletMain-\u003emapWallet.begin(); it != pwalletMain-\u003emapWallet.end(); ++it)\n    {\n        const CWalletTx\u0026 wtx = (*it).second;\n\n        if (wtx.IsCoinBase() || wtx.IsCoinStake() || !wtx.IsFinal())\n            continue;\n\n        int nDepth = wtx.GetDepthInMainChain();\n        if (nDepth \u003c nMinDepth)\n            continue;\n\n        BOOST_FOREACH(const CTxOut\u0026 txout, wtx.vout)\n        {\n            CTxDestination address;\n            if (!ExtractDestination(txout.scriptPubKey, address) || !IsMine(*pwalletMain, address))\n                continue;\n\n            tallyitem\u0026 item = mapTally[address];\n            item.nAmount += txout.nValue;\n            item.nConf = min(item.nConf, nDepth);\n            item.txids.push_back(wtx.GetHash());\n        }\n    }\n\n    // Reply\n    Array ret;\n    map\u003cstring, tallyitem\u003e mapAccountTally;\n    BOOST_FOREACH(const PAIRTYPE(CBitcoinAddress, string)\u0026 item, pwalletMain-\u003emapAddressBook)\n    {\n        const CBitcoinAddress\u0026 address = item.first;\n        const string\u0026 strAccount = item.second;\n        map\u003cCBitcoinAddress, tallyitem\u003e::iterator it = mapTally.find(address);\n        if (it == mapTally.end() \u0026\u0026 !fIncludeEmpty)\n            continue;\n\n        int64 nAmount = 0;\n        int nConf = std::numeric_limits\u003cint\u003e::max();\n        if (it != mapTally.end())\n        {\n            nAmount = (*it).second.nAmount;\n            nConf = (*it).second.nConf;\n        }\n\n        if (fByAccounts)\n        {\n            tallyitem\u0026 item = mapAccountTally[strAccount];\n            item.nAmount += nAmount;\n            item.nConf = min(item.nConf, nConf);\n        }\n        else\n        {\n            Object obj;\n            obj.push_back(Pair(\"address\",       address.ToString()));\n            obj.push_back(Pair(\"account\",       strAccount));\n            obj.push_back(Pair(\"amount\",        ValueFromAmount(nAmount)));\n            obj.push_back(Pair(\"confirmations\", (nConf == std::numeric_limits\u003cint\u003e::max() ? 0 : nConf)));\n            Array transactions;\n            if (it != mapTally.end())\n            {\n                BOOST_FOREACH(const uint256\u0026 item, (*it).second.txids)\n                {\n                    transactions.push_back(item.GetHex());\n                }\n            }\n            obj.push_back(Pair(\"txids\", transactions));\n            ret.push_back(obj);\n        }\n    }\n\n    if (fByAccounts)\n    {\n        for (map\u003cstring, tallyitem\u003e::iterator it = mapAccountTally.begin(); it != mapAccountTally.end(); ++it)\n        {\n            int64 nAmount = (*it).second.nAmount;\n            int nConf = (*it).second.nConf;\n            Object obj;\n            obj.push_back(Pair(\"account\",       (*it).first));\n            obj.push_back(Pair(\"amount\",        ValueFromAmount(nAmount)));\n            obj.push_back(Pair(\"confirmations\", (nConf == std::numeric_limits\u003cint\u003e::max() ? 0 : nConf)));\n            ret.push_back(obj);\n        }\n    }\n\n    return ret;\n}\n\nValue listreceivedbyaddress(const Array\u0026 params, bool fHelp)\n{\n    if (fHelp || params.size() \u003e 2)\n        throw runtime_error(\n            \"listreceivedbyaddress [minconf=1] [includeempty=false]\\n\"\n            \"[minconf] is the minimum number of confirmations before payments are included.\\n\"\n            \"[includeempty] whether to include addresses that haven't received any payments.\\n\"\n            \"Returns an array of objects containing:\\n\"\n            \"  \\\"address\\\" : receiving address\\n\"\n            \"  \\\"account\\\" : the account of the receiving address\\n\"\n            \"  \\\"amount\\\" : total amount received by the address\\n\"\n            \"  \\\"confirmations\\\" : number of confirmations of the most recent transaction included\\n\"\n            \"  \\\"txids\\\" : list of transactions with outputs to the address\\n\");\n\n    return ListReceived(params, false);\n}\n\nValue listreceivedbyaccount(const Array\u0026 params, bool fHelp)\n{\n    if (fHelp || params.size() \u003e 2)\n        throw runtime_error(\n            \"listreceivedbyaccount [minconf=1] [includeempty=false]\\n\"\n            \"[minconf] is the minimum number of confirmations before payments are included.\\n\"\n            \"[includeempty] whether to include accounts that haven't received any payments.\\n\"\n            \"Returns an array of objects containing:\\n\"\n            \"  \\\"account\\\" : the account of the receiving addresses\\n\"\n            \"  \\\"amount\\\" : total amount received by addresses with this account\\n\"\n            \"  \\\"confirmations\\\" : number of confirmations of the most recent transaction included\");\n\n    return ListReceived(params, true);\n}\n\nstatic void MaybePushAddress(Object \u0026 entry, const CTxDestination \u0026dest)\n{\n    CBitcoinAddress addr;\n    if (addr.Set(dest))\n        entry.push_back(Pair(\"address\", addr.ToString()));\n}\n\nvoid ListTransactions(const CWalletTx\u0026 wtx, const string\u0026 strAccount, int nMinDepth, bool fLong, Array\u0026 ret)\n{\n    int64 nFee;\n    string strSentAccount;\n    list\u003cpair\u003cCTxDestination, int64\u003e \u003e listReceived;\n    list\u003cpair\u003cCTxDestination, int64\u003e \u003e listSent;\n\n    wtx.GetAmounts(listReceived, listSent, nFee, strSentAccount);\n\n    bool fAllAccounts = (strAccount == string(\"*\"));\n\n    // Sent\n    if (!wtx.IsCoinStake() \u0026\u0026 (!listSent.empty() || nFee != 0) \u0026\u0026 (fAllAccounts || strAccount == strSentAccount))\n    {\n        BOOST_FOREACH(const PAIRTYPE(CTxDestination, int64)\u0026 s, listSent)\n        {\n            Object entry;\n            entry.push_back(Pair(\"account\", strSentAccount));\n            MaybePushAddress(entry, s.first);\n            entry.push_back(Pair(\"category\", \"send\"));\n            entry.push_back(Pair(\"amount\", ValueFromAmount(-s.second)));\n            entry.push_back(Pair(\"fee\", ValueFromAmount(-nFee)));\n            if (fLong)\n                WalletTxToJSON(wtx, entry);\n            ret.push_back(entry);\n        }\n    }\n\n    // Received\n    if (listReceived.size() \u003e 0 \u0026\u0026 wtx.GetDepthInMainChain() \u003e= nMinDepth)\n    {\n        bool stop = false;\n        BOOST_FOREACH(const PAIRTYPE(CTxDestination, int64)\u0026 r, listReceived)\n        {\n            string account;\n            if (pwalletMain-\u003emapAddressBook.count(r.first))\n                account = pwalletMain-\u003emapAddressBook[r.first];\n            if (fAllAccounts || (account == strAccount))\n            {\n                Object entry;\n                entry.push_back(Pair(\"account\", account));\n                MaybePushAddress(entry, r.first);\n                if (wtx.IsCoinBase() || wtx.IsCoinStake())\n                {\n                    if (wtx.GetDepthInMainChain() \u003c 1)\n                        entry.push_back(Pair(\"category\", \"orphan\"));\n                    else if (wtx.GetBlocksToMaturity() \u003e 0)\n                        entry.push_back(Pair(\"category\", \"immature\"));\n                    else if (wtx.IsCoinStake())\n                        entry.push_back(Pair(\"category\", \"stake\"));\n                    else\n                        entry.push_back(Pair(\"category\", \"generate\"));\n                }\n                else\n                {\n                    entry.push_back(Pair(\"category\", \"receive\"));\n                }\n                if (!wtx.IsCoinStake())\n                    entry.push_back(Pair(\"amount\", ValueFromAmount(r.second)));\n                else\n                {\n                    entry.push_back(Pair(\"amount\", ValueFromAmount(-nFee)));\n                    stop = true; // only one coinstake output\n                }\n                if (fLong)\n                    WalletTxToJSON(wtx, entry);\n                ret.push_back(entry);\n            }\n            if (stop)\n                break;\n        }\n    }\n}\n\nvoid AcentryToJSON(const CAccountingEntry\u0026 acentry, const string\u0026 strAccount, Array\u0026 ret)\n{\n    bool fAllAccounts = (strAccount == string(\"*\"));\n\n    if (fAllAccounts || acentry.strAccount == strAccount)\n    {\n        Object entry;\n        entry.push_back(Pair(\"account\", acentry.strAccount));\n        entry.push_back(Pair(\"category\", \"move\"));\n        entry.push_back(Pair(\"time\", (boost::int64_t)acentry.nTime));\n        entry.push_back(Pair(\"amount\", ValueFromAmount(acentry.nCreditDebit)));\n        entry.push_back(Pair(\"otheraccount\", acentry.strOtherAccount));\n        entry.push_back(Pair(\"comment\", acentry.strComment));\n        ret.push_back(entry);\n    }\n}\n\nValue listtransactions(const Array\u0026 params, bool fHelp)\n{\n    if (fHelp || params.size() \u003e 3)\n        throw runtime_error(\n            \"listtransactions [account] [count=10] [from=0]\\n\"\n            \"Returns up to [count] most recent transactions skipping the first [from] transactions for account [account].\");\n\n    string strAccount = \"*\";\n    if (params.size() \u003e 0)\n        strAccount = params[0].get_str();\n    int nCount = 10;\n    if (params.size() \u003e 1)\n        nCount = params[1].get_int();\n    int nFrom = 0;\n    if (params.size() \u003e 2)\n        nFrom = params[2].get_int();\n\n    if (nCount \u003c 0)\n        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Negative count\");\n    if (nFrom \u003c 0)\n        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Negative from\");\n\n    Array ret;\n\n    std::list\u003cCAccountingEntry\u003e acentries;\n    CWallet::TxItems txOrdered = pwalletMain-\u003eOrderedTxItems(acentries, strAccount);\n\n    // iterate backwards until we have nCount items to return:\n    for (CWallet::TxItems::reverse_iterator it = txOrdered.rbegin(); it != txOrdered.rend(); ++it)\n    {\n        CWalletTx *const pwtx = (*it).second.first;\n        if (pwtx != 0)\n            ListTransactions(*pwtx, strAccount, 0, true, ret);\n        CAccountingEntry *const pacentry = (*it).second.second;\n        if (pacentry != 0)\n            AcentryToJSON(*pacentry, strAccount, ret);\n\n        if ((int)ret.size() \u003e= (nCount+nFrom)) break;\n    }\n    // ret is newest to oldest\n\n    if (nFrom \u003e (int)ret.size())\n        nFrom = ret.size();\n    if ((nFrom + nCount) \u003e (int)ret.size())\n        nCount = ret.size() - nFrom;\n    Array::iterator first = ret.begin();\n    std::advance(first, nFrom);\n    Array::iterator last = ret.begin();\n    std::advance(last, nFrom+nCount);\n\n    if (last != ret.end()) ret.erase(last, ret.end());\n    if (first != ret.begin()) ret.erase(ret.begin(), first);\n\n    std::reverse(ret.begin(), ret.end()); // Return oldest to newest\n\n    return ret;\n}\n\nValue listaccounts(const Array\u0026 params, bool fHelp)\n{\n    if (fHelp || params.size() \u003e 1)\n        throw runtime_error(\n            \"listaccounts [minconf=1]\\n\"\n            \"Returns Object that has account names as keys, account balances as values.\");\n\n    int nMinDepth = 1;\n    if (params.size() \u003e 0)\n        nMinDepth = params[0].get_int();\n\n    map\u003cstring, int64\u003e mapAccountBalances;\n    BOOST_FOREACH(const PAIRTYPE(CTxDestination, string)\u0026 entry, pwalletMain-\u003emapAddressBook) {\n        if (IsMine(*pwalletMain, entry.first)) // This address belongs to me\n            mapAccountBalances[entry.second] = 0;\n    }\n\n    for (map\u003cuint256, CWalletTx\u003e::iterator it = pwalletMain-\u003emapWallet.begin(); it != pwalletMain-\u003emapWallet.end(); ++it)\n    {\n        const CWalletTx\u0026 wtx = (*it).second;\n        int64 nFee;\n        string strSentAccount;\n        list\u003cpair\u003cCTxDestination, int64\u003e \u003e listReceived;\n        list\u003cpair\u003cCTxDestination, int64\u003e \u003e listSent;\n        wtx.GetAmounts(listReceived, listSent, nFee, strSentAccount);\n        mapAccountBalances[strSentAccount] -= nFee;\n        BOOST_FOREACH(const PAIRTYPE(CTxDestination, int64)\u0026 s, listSent)\n            mapAccountBalances[strSentAccount] -= s.second;\n        if (wtx.GetDepthInMainChain() \u003e= nMinDepth)\n        {\n            BOOST_FOREACH(const PAIRTYPE(CTxDestination, int64)\u0026 r, listReceived)\n                if (pwalletMain-\u003emapAddressBook.count(r.first))\n                    mapAccountBalances[pwalletMain-\u003emapAddressBook[r.first]] += r.second;\n                else\n                    mapAccountBalances[\"\"] += r.second;\n        }\n    }\n\n    list\u003cCAccountingEntry\u003e acentries;\n    CWalletDB(pwalletMain-\u003estrWalletFile).ListAccountCreditDebit(\"*\", acentries);\n    BOOST_FOREACH(const CAccountingEntry\u0026 entry, acentries)\n        mapAccountBalances[entry.strAccount] += entry.nCreditDebit;\n\n    Object ret;\n    BOOST_FOREACH(const PAIRTYPE(string, int64)\u0026 accountBalance, mapAccountBalances) {\n        ret.push_back(Pair(accountBalance.first, ValueFromAmount(accountBalance.second)));\n    }\n    return ret;\n}\n\nValue listsinceblock(const Array\u0026 params, bool fHelp)\n{\n    if (fHelp)\n        throw runtime_error(\n            \"listsinceblock [blockhash] [target-confirmations]\\n\"\n            \"Get all transactions in blocks since block [blockhash], or all transactions if omitted\");\n\n    CBlockIndex *pindex = NULL;\n    int target_confirms = 1;\n\n    if (params.size() \u003e 0)\n    {\n        uint256 blockId = 0;\n\n        blockId.SetHex(params[0].get_str());\n        pindex = CBlockLocator(blockId).GetBlockIndex();\n    }\n\n    if (params.size() \u003e 1)\n    {\n        target_confirms = params[1].get_int();\n\n        if (target_confirms \u003c 1)\n            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid parameter\");\n    }\n\n    int depth = pindex ? (1 + nBestHeight - pindex-\u003enHeight) : -1;\n\n    Array transactions;\n\n    for (map\u003cuint256, CWalletTx\u003e::iterator it = pwalletMain-\u003emapWallet.begin(); it != pwalletMain-\u003emapWallet.end(); it++)\n    {\n        CWalletTx tx = (*it).second;\n\n        if (depth == -1 || tx.GetDepthInMainChain() \u003c depth)\n            ListTransactions(tx, \"*\", 0, true, transactions);\n    }\n\n    uint256 lastblock;\n\n    if (target_confirms == 1)\n    {\n        lastblock = hashBestChain;\n    }\n    else\n    {\n        int target_height = pindexBest-\u003enHeight + 1 - target_confirms;\n\n        CBlockIndex *block;\n        for (block = pindexBest;\n             block \u0026\u0026 block-\u003enHeight \u003e target_height;\n             block = block-\u003epprev)  { }\n\n        lastblock = block ? block-\u003eGetBlockHash() : 0;\n    }\n\n    Object ret;\n    ret.push_back(Pair(\"transactions\", transactions));\n    ret.push_back(Pair(\"lastblock\", lastblock.GetHex()));\n\n    return ret;\n}\n\nValue gettransaction(const Array\u0026 params, bool fHelp)\n{\n    if (fHelp || params.size() != 1)\n        throw runtime_error(\n            \"gettransaction \u003ctxid\u003e\\n\"\n            \"Get detailed information about in-wallet transaction \u003ctxid\u003e\");\n\n    uint256 hash;\n    hash.SetHex(params[0].get_str());\n\n    Object entry;\n    if (!pwalletMain-\u003emapWallet.count(hash))\n        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n    const CWalletTx\u0026 wtx = pwalletMain-\u003emapWallet[hash];\n\n    int64 nCredit = wtx.GetCredit();\n    int64 nDebit = wtx.GetDebit();\n    int64 nNet = nCredit - nDebit;\n    int64 nFee = (wtx.IsFromMe() ? wtx.GetValueOut() - nDebit : 0);\n\n    entry.push_back(Pair(\"amount\", ValueFromAmount(nNet - nFee)));\n    if (wtx.IsFromMe())\n        entry.push_back(Pair(\"fee\", ValueFromAmount(nFee)));\n\n    WalletTxToJSON(wtx, entry);\n\n    Array details;\n    ListTransactions(wtx, \"*\", 0, false, details);\n    entry.push_back(Pair(\"details\", details));\n\n    return entry;\n}\n\n\nValue backupwallet(const Array\u0026 params, bool fHelp)\n{\n    if (fHelp || params.size() != 1)\n        throw runtime_error(\n            \"backupwallet \u003cdestination\u003e\\n\"\n            \"Safely copies wallet.dat to destination, which can be a directory or a path with filename.\");\n\n    string strDest = params[0].get_str();\n    if (!BackupWallet(*pwalletMain, strDest))\n        throw JSONRPCError(RPC_WALLET_ERROR, \"Error: Wallet backup failed!\");\n\n    return Value::null;\n}\n\n\nValue keypoolrefill(const Array\u0026 params, bool fHelp)\n{\n    if (fHelp || params.size() \u003e 0)\n        throw runtime_error(\n            \"keypoolrefill\\n\"\n            \"Fills the keypool.\"\n            + HelpRequiringPassphrase());\n\n    EnsureWalletIsUnlocked();\n\n    pwalletMain-\u003eTopUpKeyPool();\n\n    if (pwalletMain-\u003eGetKeyPoolSize() \u003c GetArg(\"-keypool\", 100))\n        throw JSONRPCError(RPC_WALLET_ERROR, \"Error refreshing keypool.\");\n\n    return Value::null;\n}\n\n\nvoid ThreadTopUpKeyPool(void* parg)\n{\n    // Make this thread recognisable as the key-topping-up thread\n    RenameThread(\"iloveyoucoins-key-top\");\n\n    pwalletMain-\u003eTopUpKeyPool();\n}\n\nvoid ThreadCleanWalletPassphrase(void* parg)\n{\n    // Make this thread recognisable as the wallet relocking thread\n    RenameThread(\"iloveyoucoins-lock-wa\");\n\n    int64 nMyWakeTime = GetTimeMillis() + *((int64*)parg) * 1000;\n\n    ENTER_CRITICAL_SECTION(cs_nWalletUnlockTime);\n\n    if (nWalletUnlockTime == 0)\n    {\n        nWalletUnlockTime = nMyWakeTime;\n\n        do\n        {\n            if (nWalletUnlockTime==0)\n                break;\n            int64 nToSleep = nWalletUnlockTime - GetTimeMillis();\n            if (nToSleep \u003c= 0)\n                break;\n\n            LEAVE_CRITICAL_SECTION(cs_nWalletUnlockTime);\n            MilliSleep(nToSleep);\n            ENTER_CRITICAL_SECTION(cs_nWalletUnlockTime);\n\n        } while(1);\n\n        if (nWalletUnlockTime)\n        {\n            nWalletUnlockTime = 0;\n            pwalletMain-\u003eLock();\n        }\n    }\n    else\n    {\n        if (nWalletUnlockTime \u003c nMyWakeTime)\n            nWalletUnlockTime = nMyWakeTime;\n    }\n\n    LEAVE_CRITICAL_SECTION(cs_nWalletUnlockTime);\n\n    delete (int64*)parg;\n}\n\nValue walletpassphrase(const Array\u0026 params, bool fHelp)\n{\n    if (pwalletMain-\u003eIsCrypted() \u0026\u0026 (fHelp || params.size() \u003c 2 || params.size() \u003e 3))\n        throw runtime_error(\n            \"walletpassphrase \u003cpassphrase\u003e \u003ctimeout\u003e [stakingonly]\\n\"\n            \"Stores the wallet decryption key in memory for \u003ctimeout\u003e seconds.\\n\"\n            \"if [stakingonly] is true sending functions are disabled.\");\n    if (fHelp)\n        return true;\n    if (!pwalletMain-\u003eIsCrypted())\n        throw JSONRPCError(RPC_WALLET_WRONG_ENC_STATE, \"Error: running with an unencrypted wallet, but walletpassphrase was called.\");\n\n    if (!pwalletMain-\u003eIsLocked())\n        throw JSONRPCError(RPC_WALLET_ALREADY_UNLOCKED, \"Error: Wallet is already unlocked.\");\n\n    // Note that the walletpassphrase is stored in params[0] which is not mlock()ed\n    SecureString strWalletPass;\n    strWalletPass.reserve(100);\n    // TODO: get rid of this .c_str() by implementing SecureString::operator=(std::string)\n    // Alternately, find a way to make params[0] mlock()'d to begin with.\n    strWalletPass = params[0].get_str().c_str();\n\n    if (strWalletPass.length() \u003e 0)\n    {\n        if (!pwalletMain-\u003eUnlock(strWalletPass))\n            throw JSONRPCError(RPC_WALLET_PASSPHRASE_INCORRECT, \"Error: The wallet passphrase entered was incorrect.\");\n    }\n    else\n        throw runtime_error(\n            \"walletpassphrase \u003cpassphrase\u003e \u003ctimeout\u003e\\n\"\n            \"Stores the wallet decryption key in memory for \u003ctimeout\u003e seconds.\");\n\n    NewThread(ThreadTopUpKeyPool, NULL);\n    int64* pnSleepTime = new int64(params[1].get_int64());\n    NewThread(ThreadCleanWalletPassphrase, pnSleepTime);\n\n    // ppcoin: if user OS account compromised prevent trivial sendmoney commands\n    if (params.size() \u003e 2)\n        fWalletUnlockStakingOnly = params[2].get_bool();\n    else\n        fWalletUnlockStakingOnly = false;\n\n    return Value::null;\n}\n\n\nValue walletpassphrasechange(const Array\u0026 params, bool fHelp)\n{\n    if (pwalletMain-\u003eIsCrypted() \u0026\u0026 (fHelp || params.size() != 2))\n        throw runtime_error(\n            \"walletpassphrasechange \u003coldpassphrase\u003e \u003cnewpassphrase\u003e\\n\"\n            \"Changes the wallet passphrase from \u003coldpassphrase\u003e to \u003cnewpassphrase\u003e.\");\n    if (fHelp)\n        return true;\n    if (!pwalletMain-\u003eIsCrypted())\n        throw JSONRPCError(RPC_WALLET_WRONG_ENC_STATE, \"Error: running with an unencrypted wallet, but walletpassphrasechange was called.\");\n\n    // TODO: get rid of these .c_str() calls by implementing SecureString::operator=(std::string)\n    // Alternately, find a way to make params[0] mlock()'d to begin with.\n    SecureString strOldWalletPass;\n    strOldWalletPass.reserve(100);\n    strOldWalletPass = params[0].get_str().c_str();\n\n    SecureString strNewWalletPass;\n    strNewWalletPass.reserve(100);\n    strNewWalletPass = params[1].get_str().c_str();\n\n    if (strOldWalletPass.length() \u003c 1 || strNewWalletPass.length() \u003c 1)\n        throw runtime_error(\n            \"walletpassphrasechange \u003coldpassphrase\u003e \u003cnewpassphrase\u003e\\n\"\n            \"Changes the wallet passphrase from \u003coldpassphrase\u003e to \u003cnewpassphrase\u003e.\");\n\n    if (!pwalletMain-\u003eChangeWalletPassphrase(strOldWalletPass, strNewWalletPass))\n        throw JSONRPCError(RPC_WALLET_PASSPHRASE_INCORRECT, \"Error: The wallet passphrase entered was incorrect.\");\n\n    return Value::null;\n}\n\n\nValue walletlock(const Array\u0026 params, bool fHelp)\n{\n    if (pwalletMain-\u003eIsCrypted() \u0026\u0026 (fHelp || params.size() != 0))\n        throw runtime_error(\n            \"walletlock\\n\"\n            \"Removes the wallet encryption key from memory, locking the wallet.\\n\"\n            \"After calling this method, you will need to call walletpassphrase again\\n\"\n            \"before being able to call any methods which require the wallet to be unlocked.\");\n    if (fHelp)\n        return true;\n    if (!pwalletMain-\u003eIsCrypted())\n        throw JSONRPCError(RPC_WALLET_WRONG_ENC_STATE, \"Error: running with an unencrypted wallet, but walletlock was called.\");\n\n    {\n        LOCK(cs_nWalletUnlockTime);\n        pwalletMain-\u003eLock();\n        nWalletUnlockTime = 0;\n    }\n\n    return Value::null;\n}\n\n\nValue encryptwallet(const Array\u0026 params, bool fHelp)\n{\n    if (!pwalletMain-\u003eIsCrypted() \u0026\u0026 (fHelp || params.size() != 1))\n        throw runtime_error(\n            \"encryptwallet \u003cpassphrase\u003e\\n\"\n            \"Encrypts the wallet with \u003cpassphrase\u003e.\");\n    if (fHelp)\n        return true;\n    if (pwalletMain-\u003eIsCrypted())\n        throw JSONRPCError(RPC_WALLET_WRONG_ENC_STATE, \"Error: running with an encrypted wallet, but encryptwallet was called.\");\n\n    // TODO: get rid of this .c_str() by implementing SecureString::operator=(std::string)\n    // Alternately, find a way to make params[0] mlock()'d to begin with.\n    SecureString strWalletPass;\n    strWalletPass.reserve(100);\n    strWalletPass = params[0].get_str().c_str();\n\n    if (strWalletPass.length() \u003c 1)\n        throw runtime_error(\n            \"encryptwallet \u003cpassphrase\u003e\\n\"\n            \"Encrypts the wallet with \u003cpassphrase\u003e.\");\n\n    if (!pwalletMain-\u003eEncryptWallet(strWalletPass))\n        throw JSONRPCError(RPC_WALLET_ENCRYPTION_FAILED, \"Error: Failed to encrypt the wallet.\");\n\n    // BDB seems to have a bad habit of writing old data into\n    // slack space in .dat files; that is bad if the old data is\n    // unencrypted private keys. So:\n    StartShutdown();\n    return \"wallet encrypted; ILoveYouCoins server stopping, restart to run with encrypted wallet. The keypool has been flushed, you need to make a new backup.\";\n}\n\nclass DescribeAddressVisitor : public boost::static_visitor\u003cObject\u003e\n{\npublic:\n    Object operator()(const CNoDestination \u0026dest) const { return Object(); }\n\n    Object operator()(const CKeyID \u0026keyID) const {\n        Object obj;\n        CPubKey vchPubKey;\n        pwalletMain-\u003eGetPubKey(keyID, vchPubKey);\n        obj.push_back(Pair(\"isscript\", false));\n        obj.push_back(Pair(\"pubkey\", HexStr(vchPubKey)));\n        obj.push_back(Pair(\"iscompressed\", vchPubKey.IsCompressed()));\n        return obj;\n    }\n\n    Object operator()(const CScriptID \u0026scriptID) const {\n        Object obj;\n        obj.push_back(Pair(\"isscript\", true));\n        CScript subscript;\n        pwalletMain-\u003eGetCScript(scriptID, subscript);\n        std::vector\u003cCTxDestination\u003e addresses;\n        txnouttype whichType;\n        int nRequired;\n        ExtractDestinations(subscript, whichType, addresses, nRequired);\n        obj.push_back(Pair(\"script\", GetTxnOutputType(whichType)));\n        Array a;\n        BOOST_FOREACH(const CTxDestination\u0026 addr, addresses)\n            a.push_back(CBitcoinAddress(addr).ToString());\n        obj.push_back(Pair(\"addresses\", a));\n        if (whichType == TX_MULTISIG)\n            obj.push_back(Pair(\"sigsrequired\", nRequired));\n        return obj;\n    }\n};\n\nValue validateaddress(const Array\u0026 params, bool fHelp)\n{\n    if (fHelp || params.size() != 1)\n        throw runtime_error(\n            \"validateaddress \u003ciloveyoucoinsaddress\u003e\\n\"\n            \"Return information about \u003ciloveyoucoinsaddress\u003e.\");\n\n    CBitcoinAddress address(params[0].get_str());\n    bool isValid = address.IsValid();\n\n    Object ret;\n    ret.push_back(Pair(\"isvalid\", isValid));\n    if (isValid)\n    {\n        CTxDestination dest = address.Get();\n        string currentAddress = address.ToString();\n        ret.push_back(Pair(\"address\", currentAddress));\n        bool fMine = pwalletMain ? IsMine(*pwalletMain, dest) : false;\n        ret.push_back(Pair(\"ismine\", fMine));\n        if (fMine) {\n            Object detail = boost::apply_visitor(DescribeAddressVisitor(), dest);\n            ret.insert(ret.end(), detail.begin(), detail.end());\n        }\n        if (pwalletMain \u0026\u0026 pwalletMain-\u003emapAddressBook.count(dest))\n            ret.push_back(Pair(\"account\", pwalletMain-\u003emapAddressBook[dest]));\n    }\n    return ret;\n}\n\n// ppcoin: reserve balance from being staked for network protection\nValue reservebalance(const Array\u0026 params, bool fHelp)\n{\n    if (fHelp || params.size() \u003e 2)\n        throw runtime_error(\n            \"reservebalance [\u003creserve\u003e [amount]]\\n\"\n            \"\u003creserve\u003e is true or false to turn balance reserve on or off.\\n\"\n            \"\u003camount\u003e is a real and rounded to cent.\\n\"\n            \"Set reserve amount not participating in network protection.\\n\"\n            \"If no parameters provided current setting is printed.\\n\");\n\n    if (params.size() \u003e 0)\n    {\n        bool fReserve = params[0].get_bool();\n        if (fReserve)\n        {\n            if (params.size() == 1)\n                throw runtime_error(\"must provide amount to reserve balance.\\n\");\n            int64 nAmount = AmountFromValue(params[1]);\n            nAmount = (nAmount / CENT) * CENT;  // round to cent\n            if (nAmount \u003c 0)\n                throw runtime_error(\"amount cannot be negative.\\n\");\n            nReserveBalance = nAmount;\n        }\n        else\n        {\n            if (params.size() \u003e 1)\n                throw runtime_error(\"cannot specify amount to turn off reserve.\\n\");\n            nReserveBalance = 0;\n        }\n    }\n\n    Object result;\n    result.push_back(Pair(\"reserve\", (nReserveBalance \u003e 0)));\n    result.push_back(Pair(\"amount\", ValueFromAmount(nReserveBalance)));\n    return result;\n}\n\n// posv: interest received\nValue getinterest(const Array\u0026 params, bool fHelp)\n{\n    if (fHelp || params.size() \u003e 2)\n        throw runtime_error(\n            \"getinterest [start] [end]\\n\"\n            \"Both [start] and [end] are inclusive and in the form of UNIX timestamps.\");\n\n    unsigned int nTimeStart = 0;\n    unsigned int nTimeEnd = -1;\n    if (params.size() \u003e= 1)\n        nTimeStart = (unsigned int)(params[0].get_int());\n    if (params.size() == 2)\n        nTimeEnd = (unsigned int)(params[1].get_int());\n\n    int64 nInterest = 0;\n    for (map\u003cuint256, CWalletTx\u003e::iterator it = pwalletMain-\u003emapWallet.begin(); it != pwalletMain-\u003emapWallet.end(); ++it)\n    {\n        const CWalletTx\u0026 wtx = (*it).second;\n        if (!wtx.IsCoinStake() || wtx.nTime \u003c nTimeStart || wtx.nTime \u003e nTimeEnd)\n            continue;\n\n        int64 nDebit = wtx.GetDebit();\n        int64 nCredit = wtx.GetCredit();\n\n        if (nDebit \u003c= 0 || nCredit \u003c= 0 || nDebit \u003e= nCredit)\n            continue;\n        else\n            nInterest += nCredit - nDebit;\n    }\n\n    return  ValueFromAmount(nInterest);\n}\n\nValue lockunspent(const Array\u0026 params, bool fHelp)\n{\n    if (fHelp || params.size() \u003c 1 || params.size() \u003e 2)\n        throw runtime_error(\n            \"lockunspent unlock? [array-of-Objects]\\n\"\n            \"Updates list of temporarily unspendable outputs.\");\n\n    if (params.size() == 1)\n        RPCTypeCheck(params, list_of(bool_type));\n    else\n        RPCTypeCheck(params, list_of(bool_type)(array_type));\n\n    bool fUnlock = params[0].get_bool();\n\n    if (params.size() == 1) {\n        if (fUnlock)\n            pwalletMain-\u003eUnlockAllCoins();\n        return true;\n    }\n\n    Array outputs = params[1].get_array();\n    BOOST_FOREACH(Value\u0026 output, outputs)\n    {\n        if (output.type() != obj_type)\n            throw JSONRPCError(-8, \"Invalid parameter, expected object\");\n        const Object\u0026 o = output.get_obj();\n\n        RPCTypeCheck(o, map_list_of(\"txid\", str_type)(\"vout\", int_type));\n\n        string txid = find_value(o, \"txid\").get_str();\n        if (!IsHex(txid))\n            throw JSONRPCError(-8, \"Invalid parameter, expected hex txid\");\n\n        int nOutput = find_value(o, \"vout\").get_int();\n        if (nOutput \u003c 0)\n            throw JSONRPCError(-8, \"Invalid parameter, vout must be positive\");\n\n        COutPoint outpt(uint256(txid), nOutput);\n\n        if (fUnlock)\n            pwalletMain-\u003eUnlockCoin(outpt);\n        else\n            pwalletMain-\u003eLockCoin(outpt);\n    }\n\n    return true;\n}\n\nValue listlockunspent(const Array\u0026 params, bool fHelp)\n{\n    if (fHelp || params.size() \u003e 0)\n        throw runtime_error(\n            \"listlockunspent\\n\"\n            \"Returns list of temporarily unspendable outputs.\");\n\n    vector\u003cCOutPoint\u003e vOutpts;\n    pwalletMain-\u003eListLockedCoins(vOutpts);\n\n    Array ret;\n\n    BOOST_FOREACH(COutPoint \u0026outpt, vOutpts) {\n        Object o;\n\n        o.push_back(Pair(\"txid\", outpt.hash.GetHex()));\n        o.push_back(Pair(\"vout\", (int)outpt.n));\n        ret.push_back(o);\n    }\n\n    return ret;\n}\n"}
{"repo_name":"shadowofreality/ShadowCore","ref":"refs/heads/master","path":"src/server/game/Handlers/MiscHandler.cpp","copies":"1","language":"C++","content":"/*\n * Copyright (C) 2008-2017 TrinityCore \u003chttp://www.trinitycore.org/\u003e\n * Copyright (C) 2005-2009 MaNGOS \u003chttp://getmangos.com/\u003e\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the\n * Free Software Foundation; either version 2 of the License, or (at your\n * option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n * more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program. If not, see \u003chttp://www.gnu.org/licenses/\u003e.\n */\n\n#include \"Common.h\"\n#include \"Language.h\"\n#include \"DatabaseEnv.h\"\n#include \"WorldPacket.h\"\n#include \"Opcodes.h\"\n#include \"Log.h\"\n#include \"Player.h\"\n#include \"GameTime.h\"\n#include \"GossipDef.h\"\n#include \"World.h\"\n#include \"ObjectMgr.h\"\n#include \"GuildMgr.h\"\n#include \"WorldSession.h\"\n#include \"Chat.h\"\n#include \"zlib.h\"\n#include \"ObjectAccessor.h\"\n#include \"Object.h\"\n#include \"Battleground.h\"\n#include \"OutdoorPvP.h\"\n#include \"AccountMgr.h\"\n#include \"DBCEnums.h\"\n#include \"ScriptMgr.h\"\n#include \"MapManager.h\"\n#include \"GameObjectAI.h\"\n#include \"Group.h\"\n#include \"Spell.h\"\n#include \"BattlegroundMgr.h\"\n#include \"Battlefield.h\"\n#include \"BattlefieldMgr.h\"\n#include \"WhoListStorage.h\"\n\nvoid WorldSession::HandleRepopRequestOpcode(WorldPacket\u0026 recvData)\n{\n    TC_LOG_DEBUG(\"network\", \"WORLD: Recvd CMSG_REPOP_REQUEST Message\");\n\n    recvData.read_skip\u003cuint8\u003e();\n\n    if (GetPlayer()-\u003eIsAlive() || GetPlayer()-\u003eHasFlag(PLAYER_FLAGS, PLAYER_FLAGS_GHOST))\n        return;\n\n    if (GetPlayer()-\u003eHasAuraType(SPELL_AURA_PREVENT_RESURRECTION))\n        return; // silently return, client should display the error by itself\n\n    // the world update order is sessions, players, creatures\n    // the netcode runs in parallel with all of these\n    // creatures can kill players\n    // so if the server is lagging enough the player can\n    // release spirit after he's killed but before he is updated\n    if (GetPlayer()-\u003egetDeathState() == JUST_DIED)\n    {\n        TC_LOG_DEBUG(\"network\", \"HandleRepopRequestOpcode: got request after player %s(%d) was killed and before he was updated\",\n            GetPlayer()-\u003eGetName().c_str(), GetPlayer()-\u003eGetGUID().GetCounter());\n        GetPlayer()-\u003eKillPlayer();\n    }\n\n    //this is spirit release confirm?\n    GetPlayer()-\u003eRemoveGhoul();\n    GetPlayer()-\u003eRemovePet(NULL, PET_SAVE_NOT_IN_SLOT, true);\n    GetPlayer()-\u003eBuildPlayerRepop();\n    GetPlayer()-\u003eRepopAtGraveyard();\n}\n\nvoid WorldSession::HandleGossipSelectOptionOpcode(WorldPacket\u0026 recvData)\n{\n    TC_LOG_DEBUG(\"network\", \"WORLD: CMSG_GOSSIP_SELECT_OPTION\");\n\n    uint32 gossipListId;\n    uint32 menuId;\n    ObjectGuid guid;\n    std::string code = \"\";\n\n    recvData \u003e\u003e guid \u003e\u003e menuId \u003e\u003e gossipListId;\n\n    if (!_player-\u003ePlayerTalkClass-\u003eGetGossipMenu().GetItem(gossipListId))\n    {\n        recvData.rfinish();\n        return;\n    }\n\n    if (_player-\u003ePlayerTalkClass-\u003eIsGossipOptionCoded(gossipListId))\n        recvData \u003e\u003e code;\n\n    // Prevent cheating on C++ scripted menus\n    if (_player-\u003ePlayerTalkClass-\u003eGetGossipMenu().GetSenderGUID() != guid)\n        return;\n\n    Creature* unit = NULL;\n    GameObject* go = NULL;\n    if (guid.IsCreatureOrVehicle())\n    {\n        unit = GetPlayer()-\u003eGetNPCIfCanInteractWith(guid, UNIT_NPC_FLAG_GOSSIP);\n        if (!unit)\n        {\n            TC_LOG_DEBUG(\"network\", \"WORLD: HandleGossipSelectOptionOpcode - %s not found or you can't interact with him.\", guid.ToString().c_str());\n            return;\n        }\n    }\n    else if (guid.IsGameObject())\n    {\n        go = _player-\u003eGetGameObjectIfCanInteractWith(guid);\n        if (!go)\n        {\n            TC_LOG_DEBUG(\"network\", \"WORLD: HandleGossipSelectOptionOpcode - %s not found or you can't interact with it.\", guid.ToString().c_str());\n            return;\n        }\n    }\n    else\n    {\n        TC_LOG_DEBUG(\"network\", \"WORLD: HandleGossipSelectOptionOpcode - unsupported %s.\", guid.ToString().c_str());\n        return;\n    }\n\n    // remove fake death\n    if (GetPlayer()-\u003eHasUnitState(UNIT_STATE_DIED))\n        GetPlayer()-\u003eRemoveAurasByType(SPELL_AURA_FEIGN_DEATH);\n\n    if ((unit \u0026\u0026 unit-\u003eGetScriptId() != unit-\u003eLastUsedScriptID) || (go \u0026\u0026 go-\u003eGetScriptId() != go-\u003eLastUsedScriptID))\n    {\n        TC_LOG_DEBUG(\"network\", \"WORLD: HandleGossipSelectOptionOpcode - Script reloaded while in use, ignoring and set new scipt id\");\n        if (unit)\n            unit-\u003eLastUsedScriptID = unit-\u003eGetScriptId();\n        if (go)\n            go-\u003eLastUsedScriptID = go-\u003eGetScriptId();\n        _player-\u003ePlayerTalkClass-\u003eSendCloseGossip();\n        return;\n    }\n    if (!code.empty())\n    {\n        if (unit)\n        {\n            unit-\u003eAI()-\u003esGossipSelectCode(_player, menuId, gossipListId, code.c_str());\n            if (!sScriptMgr-\u003eOnGossipSelectCode(_player, unit, _player-\u003ePlayerTalkClass-\u003eGetGossipOptionSender(gossipListId), _player-\u003ePlayerTalkClass-\u003eGetGossipOptionAction(gossipListId), code.c_str()))\n                _player-\u003eOnGossipSelect(unit, gossipListId, menuId);\n        }\n        else\n        {\n            go-\u003eAI()-\u003eGossipSelectCode(_player, menuId, gossipListId, code.c_str());\n            if (!sScriptMgr-\u003eOnGossipSelectCode(_player, go, _player-\u003ePlayerTalkClass-\u003eGetGossipOptionSender(gossipListId), _player-\u003ePlayerTalkClass-\u003eGetGossipOptionAction(gossipListId), code.c_str()))\n                _player-\u003eOnGossipSelect(go, gossipListId, menuId);\n        }\n    }\n    else\n    {\n        if (unit)\n        {\n            unit-\u003eAI()-\u003esGossipSelect(_player, menuId, gossipListId);\n            if (!sScriptMgr-\u003eOnGossipSelect(_player, unit, _player-\u003ePlayerTalkClass-\u003eGetGossipOptionSender(gossipListId), _player-\u003ePlayerTalkClass-\u003eGetGossipOptionAction(gossipListId)))\n                _player-\u003eOnGossipSelect(unit, gossipListId, menuId);\n        }\n        else\n        {\n            go-\u003eAI()-\u003eGossipSelect(_player, menuId, gossipListId);\n            if (!sScriptMgr-\u003eOnGossipSelect(_player, go, _player-\u003ePlayerTalkClass-\u003eGetGossipOptionSender(gossipListId), _player-\u003ePlayerTalkClass-\u003eGetGossipOptionAction(gossipListId)))\n                _player-\u003eOnGossipSelect(go, gossipListId, menuId);\n        }\n    }\n}\n\nvoid WorldSession::HandleWhoOpcode(WorldPacket\u0026 recvData)\n{\n    TC_LOG_DEBUG(\"network\", \"WORLD: Recvd CMSG_WHO Message\");\n\n    uint32 matchCount = 0;\n\n    uint32 levelMin, levelMax, racemask, classmask, zonesCount, strCount;\n    uint32 zoneids[10];                                     // 10 is client limit\n    std::string packetPlayerName, packetGuildName;\n\n    recvData \u003e\u003e levelMin;                                   // maximal player level, default 0\n    recvData \u003e\u003e levelMax;                                   // minimal player level, default 100 (MAX_LEVEL)\n    recvData \u003e\u003e packetPlayerName;                           // player name, case sensitive...\n\n    recvData \u003e\u003e packetGuildName;                            // guild name, case sensitive...\n\n    recvData \u003e\u003e racemask;                                   // race mask\n    recvData \u003e\u003e classmask;                                  // class mask\n    recvData \u003e\u003e zonesCount;                                 // zones count, client limit = 10 (2.0.10)\n\n    if (zonesCount \u003e 10)\n        return;                                             // can't be received from real client or broken packet\n\n    for (uint32 i = 0; i \u003c zonesCount; ++i)\n    {\n        uint32 temp;\n        recvData \u003e\u003e temp;                                   // zone id, 0 if zone is unknown...\n        zoneids[i] = temp;\n        TC_LOG_DEBUG(\"network\", \"Zone %u: %u\", i, zoneids[i]);\n    }\n\n    recvData \u003e\u003e strCount;                                   // user entered strings count, client limit=4 (checked on 2.0.10)\n\n    if (strCount \u003e 4)\n        return;                                             // can't be received from real client or broken packet\n\n    TC_LOG_DEBUG(\"network\", \"Minlvl %u, maxlvl %u, name %s, guild %s, racemask %u, classmask %u, zones %u, strings %u\", levelMin, levelMax, packetPlayerName.c_str(), packetGuildName.c_str(), racemask, classmask, zonesCount, strCount);\n\n    std::wstring str[4];                                    // 4 is client limit\n    for (uint32 i = 0; i \u003c strCount; ++i)\n    {\n        std::string temp;\n        recvData \u003e\u003e temp;                                   // user entered string, it used as universal search pattern(guild+player name)?\n\n        if (!Utf8toWStr(temp, str[i]))\n            continue;\n\n        wstrToLower(str[i]);\n\n\t\tTC_LOG_DEBUG(\"network\", \"String %u: %s\", i, temp.c_str());\n    }\n\n    std::wstring wpacketPlayerName;\n    std::wstring wpacketGuildName;\n    if (!(Utf8toWStr(packetPlayerName, wpacketPlayerName) \u0026\u0026 Utf8toWStr(packetGuildName, wpacketGuildName)))\n        return;\n\n    wstrToLower(wpacketPlayerName);\n    wstrToLower(wpacketGuildName);\n\n    // client send in case not set max level value 100 but Trinity supports 255 max level,\n    // update it to show GMs with characters after 100 level\n    if (levelMax \u003e= MAX_LEVEL)\n        levelMax = STRONG_MAX_LEVEL;\n\n    uint32 team = _player-\u003eGetTeam();\n\n    uint32 gmLevelInWhoList  = sWorld-\u003egetIntConfig(CONFIG_GM_LEVEL_IN_WHO_LIST);\n    uint32 displayCount = 0;\n\n    WorldPacket data(SMSG_WHO, 500);                      // guess size\n    data \u003c\u003c uint32(matchCount);                           // placeholder, count of players matching criteria\n    data \u003c\u003c uint32(displayCount);                         // placeholder, count of players displayed\n\n    WhoListInfoVector const\u0026 whoList = sWhoListStorageMgr-\u003eGetWhoList();\n    for (WhoListPlayerInfo const\u0026 target : whoList)\n    {\n        // player can see member of other team only if CONFIG_ALLOW_TWO_SIDE_WHO_LIST\n        if (target.GetTeam() != team \u0026\u0026 !HasPermission(rbac::RBAC_PERM_TWO_SIDE_WHO_LIST))\n            continue;\n\n        // player can see MODERATOR, GAME MASTER, ADMINISTRATOR only if CONFIG_GM_IN_WHO_LIST\n        if (!HasPermission(rbac::RBAC_PERM_WHO_SEE_ALL_SEC_LEVELS) \u0026\u0026 target.GetSecurity() \u003e AccountTypes(gmLevelInWhoList))\n            continue;\n\n        // check if target is globally visible for player\n        if (_player-\u003eGetGUID() != target.GetGuid() \u0026\u0026 !target.IsVisible())\n            if (AccountMgr::IsPlayerAccount(_player-\u003eGetSession()-\u003eGetSecurity()) || target.GetSecurity() \u003e _player-\u003eGetSession()-\u003eGetSecurity())\n                continue;\n\n        // check if target's level is in level range\n        uint8 lvl = target.GetLevel();\n        if (lvl \u003c levelMin || lvl \u003e levelMax)\n            continue;\n\n        // check if class matches classmask\n        uint8 class_ = target.GetClass();\n        if (!(classmask \u0026 (1 \u003c\u003c class_)))\n            continue;\n\n        // check if race matches racemask\n        uint32 race = target.GetRace();\n        if (!(racemask \u0026 (1 \u003c\u003c race)))\n            continue;\n\n        uint32 playerZoneId = target.GetZoneId();\n        uint8 gender = target.GetGender();\n\n        bool showZones = true;\n        for (uint32 i = 0; i \u003c zonesCount; ++i)\n        {\n            if (zoneids[i] == playerZoneId)\n            {\n                showZones = true;\n                break;\n            }\n\n            showZones = false;\n        }\n        if (!showZones)\n            continue;\n\n        std::wstring const\u0026 wideplayername = target.GetWidePlayerName();\n        if (!(wpacketPlayerName.empty() || wideplayername.find(wpacketPlayerName) != std::wstring::npos))\n            continue;\n\n        std::wstring const\u0026 wideguildname = target.GetWideGuildName();\n        if (!(wpacketGuildName.empty() || wideguildname.find(wpacketGuildName) != std::wstring::npos))\n            continue;\n\n        std::string aname;\n        if (AreaTableEntry const* areaEntry = sAreaTableStore.LookupEntry(playerZoneId))\n            aname = areaEntry-\u003earea_name[GetSessionDbcLocale()];\n\n        bool s_show = true;\n        for (uint32 i = 0; i \u003c strCount; ++i)\n        {\n            if (!str[i].empty())\n            {\n                if (wideguildname.find(str[i]) != std::wstring::npos ||\n                    wideplayername.find(str[i]) != std::wstring::npos ||\n                    Utf8FitTo(aname, str[i]))\n                {\n                    s_show = true;\n                    break;\n                }\n                s_show = false;\n            }\n        }\n        if (!s_show)\n            continue;\n\n        // 49 is maximum player count sent to client - can be overridden\n        // through config, but is unstable\n        if ((matchCount++) \u003e= sWorld-\u003egetIntConfig(CONFIG_MAX_WHO))\n            continue;\n\n        data \u003c\u003c target.GetPlayerName();                   // player name\n        data \u003c\u003c target.GetGuildName();                    // guild name\n        data \u003c\u003c uint32(lvl);                              // player level\n        data \u003c\u003c uint32(class_);                           // player class\n        data \u003c\u003c uint32(race);                             // player race\n        data \u003c\u003c uint8(gender);                            // player gender\n        data \u003c\u003c uint32(playerZoneId);                     // player zone id\n\n        ++displayCount;\n    }\n\n\tdata.put(0, displayCount);                            // insert right count, count displayed\n    data.put(4, matchCount);                              // insert right count, count of matches\n\n    SendPacket(\u0026data);\n    TC_LOG_DEBUG(\"network\", \"WORLD: Send SMSG_WHO Message\");\n}\n\nvoid WorldSession::HandleLogoutRequestOpcode(WorldPacket\u0026 /*recvData*/)\n{\n    TC_LOG_DEBUG(\"network\", \"WORLD: Recvd CMSG_LOGOUT_REQUEST Message, security - %u\", GetSecurity());\n\n    if (ObjectGuid lguid = GetPlayer()-\u003eGetLootGUID())\n        DoLootRelease(lguid);\n\n    bool instantLogout = (GetPlayer()-\u003eHasFlag(PLAYER_FLAGS, PLAYER_FLAGS_RESTING) \u0026\u0026 !GetPlayer()-\u003eIsInCombat()) ||\n                         GetPlayer()-\u003eIsInFlight() || HasPermission(rbac::RBAC_PERM_INSTANT_LOGOUT);\n\n    /// TODO: Possibly add RBAC permission to log out in combat\n    bool canLogoutInCombat = GetPlayer()-\u003eHasFlag(PLAYER_FLAGS, PLAYER_FLAGS_RESTING);\n\n    uint32 reason = 0;\n    if (GetPlayer()-\u003eIsInCombat() \u0026\u0026 !canLogoutInCombat)\n        reason = 1;\n    else if (GetPlayer()-\u003em_movementInfo.HasMovementFlag(MOVEMENTFLAG_FALLING | MOVEMENTFLAG_FALLING_FAR))\n        reason = 3;                                         // is jumping or falling\n    else if (GetPlayer()-\u003eduel || GetPlayer()-\u003eHasAura(9454)) // is dueling or frozen by GM via freeze command\n        reason = 2;                                         // FIXME - Need the correct value\n\n    WorldPacket data(SMSG_LOGOUT_RESPONSE, 1+4);\n    data \u003c\u003c uint32(reason);\n    data \u003c\u003c uint8(instantLogout);\n    SendPacket(\u0026data);\n\n    if (reason)\n    {\n        LogoutRequest(0);\n        return;\n    }\n\n    //instant logout in taverns/cities or on taxi or for admins, gm's, mod's if its enabled in worldserver.conf\n    if (instantLogout)\n    {\n        LogoutPlayer(true);\n        return;\n    }\n\n    // not set flags if player can't free move to prevent lost state at logout cancel\n    if (GetPlayer()-\u003eCanFreeMove())\n    {\n        if (GetPlayer()-\u003eGetStandState() == UNIT_STAND_STATE_STAND)\n            GetPlayer()-\u003eSetStandState(UNIT_STAND_STATE_SIT);\n\n        WorldPacket data(SMSG_FORCE_MOVE_ROOT, (8+4));    // guess size\n        data \u003c\u003c GetPlayer()-\u003eGetPackGUID();\n        data \u003c\u003c (uint32)2;\n        SendPacket(\u0026data);\n        GetPlayer()-\u003eSetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_STUNNED);\n    }\n\n    LogoutRequest(time(NULL));\n}\n\nvoid WorldSession::HandlePlayerLogoutOpcode(WorldPacket\u0026 /*recvData*/)\n{\n    TC_LOG_DEBUG(\"network\", \"WORLD: Recvd CMSG_PLAYER_LOGOUT Message\");\n}\n\nvoid WorldSession::HandleLogoutCancelOpcode(WorldPacket\u0026 /*recvData*/)\n{\n    TC_LOG_DEBUG(\"network\", \"WORLD: Recvd CMSG_LOGOUT_CANCEL Message\");\n\n    // Player have already logged out serverside, too late to cancel\n    if (!GetPlayer())\n        return;\n\n    LogoutRequest(0);\n\n    WorldPacket data(SMSG_LOGOUT_CANCEL_ACK, 0);\n    SendPacket(\u0026data);\n\n    // not remove flags if can't free move - its not set in Logout request code.\n    if (GetPlayer()-\u003eCanFreeMove())\n    {\n        //!we can move again\n        data.Initialize(SMSG_FORCE_MOVE_UNROOT, 8);       // guess size\n        data \u003c\u003c GetPlayer()-\u003eGetPackGUID();\n        data \u003c\u003c uint32(0);\n        SendPacket(\u0026data);\n\n        //! Stand Up\n        GetPlayer()-\u003eSetStandState(UNIT_STAND_STATE_STAND);\n\n        //! DISABLE_ROTATE\n        GetPlayer()-\u003eRemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_STUNNED);\n    }\n}\n\nvoid WorldSession::HandleTogglePvP(WorldPacket\u0026 recvData)\n{\n    // this opcode can be used in two ways: Either set explicit new status or toggle old status\n    if (recvData.size() == 1)\n    {\n        bool newPvPStatus;\n        recvData \u003e\u003e newPvPStatus;\n        GetPlayer()-\u003eApplyModFlag(PLAYER_FLAGS, PLAYER_FLAGS_IN_PVP, newPvPStatus);\n        GetPlayer()-\u003eApplyModFlag(PLAYER_FLAGS, PLAYER_FLAGS_PVP_TIMER, !newPvPStatus);\n    }\n    else\n    {\n        GetPlayer()-\u003eToggleFlag(PLAYER_FLAGS, PLAYER_FLAGS_IN_PVP);\n        GetPlayer()-\u003eToggleFlag(PLAYER_FLAGS, PLAYER_FLAGS_PVP_TIMER);\n    }\n\n    if (GetPlayer()-\u003eHasFlag(PLAYER_FLAGS, PLAYER_FLAGS_IN_PVP))\n    {\n        if (!GetPlayer()-\u003eIsPvP() || GetPlayer()-\u003epvpInfo.EndTimer)\n            GetPlayer()-\u003eUpdatePvP(true, true);\n    }\n    else\n    {\n        if (!GetPlayer()-\u003epvpInfo.IsHostile \u0026\u0026 GetPlayer()-\u003eIsPvP())\n            GetPlayer()-\u003epvpInfo.EndTimer = time(NULL);     // start toggle-off\n    }\n\n    //if (OutdoorPvP* pvp = _player-\u003eGetOutdoorPvP())\n    //    pvp-\u003eHandlePlayerActivityChanged(_player);\n}\n\nvoid WorldSession::HandleZoneUpdateOpcode(WorldPacket\u0026 recvData)\n{\n    uint32 newZone;\n    recvData \u003e\u003e newZone;\n\n    TC_LOG_DEBUG(\"network\", \"WORLD: Recvd ZONE_UPDATE: %u\", newZone);\n\n    // use server side data, but only after update the player position. See Player::UpdatePosition().\n    GetPlayer()-\u003eSetNeedsZoneUpdate(true);\n\n    //GetPlayer()-\u003eSendInitWorldStates(true, newZone);\n}\n\nvoid WorldSession::HandleSetSelectionOpcode(WorldPacket\u0026 recvData)\n{\n    ObjectGuid guid;\n    recvData \u003e\u003e guid;\n\n    _player-\u003eSetSelection(guid);\n}\n\nvoid WorldSession::HandleStandStateChangeOpcode(WorldPacket\u0026 recvData)\n{\n    // TC_LOG_DEBUG(\"network\", \"WORLD: Received CMSG_STANDSTATECHANGE\"); -- too many spam in log at lags/debug stop\n    uint32 animstate;\n    recvData \u003e\u003e animstate;\n\n    _player-\u003eSetStandState(animstate);\n}\n\nvoid WorldSession::HandleBugOpcode(WorldPacket\u0026 recvData)\n{\n    uint32 suggestion, contentlen, typelen;\n    std::string content, type;\n\n    recvData \u003e\u003e suggestion \u003e\u003e contentlen \u003e\u003e content;\n\n    recvData \u003e\u003e typelen \u003e\u003e type;\n\n    if (suggestion == 0)\n        TC_LOG_DEBUG(\"network\", \"WORLD: Received CMSG_BUG [Bug Report]\");\n    else\n        TC_LOG_DEBUG(\"network\", \"WORLD: Received CMSG_BUG [Suggestion]\");\n\n    TC_LOG_DEBUG(\"network\", \"%s\", type.c_str());\n    TC_LOG_DEBUG(\"network\", \"%s\", content.c_str());\n\n    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_BUG_REPORT);\n\n    stmt-\u003esetString(0, type);\n    stmt-\u003esetString(1, content);\n\n    CharacterDatabase.Execute(stmt);\n}\n\nvoid WorldSession::HandleReclaimCorpseOpcode(WorldPacket\u0026 recvData)\n{\n    TC_LOG_DEBUG(\"network\", \"WORLD: Received CMSG_RECLAIM_CORPSE\");\n\n    ObjectGuid guid;\n    recvData \u003e\u003e guid;\n\n    if (_player-\u003eIsAlive())\n        return;\n\n    // do not allow corpse reclaim in arena\n    if (_player-\u003eInArena())\n        return;\n\n    // body not released yet\n    if (!_player-\u003eHasFlag(PLAYER_FLAGS, PLAYER_FLAGS_GHOST))\n        return;\n\n    Corpse* corpse = _player-\u003eGetCorpse();\n    if (!corpse)\n        return;\n\n    // prevent resurrect before 30-sec delay after body release not finished\n    if (time_t(corpse-\u003eGetGhostTime() + _player-\u003eGetCorpseReclaimDelay(corpse-\u003eGetType() == CORPSE_RESURRECTABLE_PVP)) \u003e time_t(time(NULL)))\n        return;\n\n    if (!corpse-\u003eIsWithinDistInMap(_player, CORPSE_RECLAIM_RADIUS, true))\n        return;\n\n    // resurrect\n    _player-\u003eResurrectPlayer(_player-\u003eInBattleground() ? 1.0f : 0.5f);\n\n    // spawn bones\n    _player-\u003eSpawnCorpseBones();\n}\n\nvoid WorldSession::HandleResurrectResponseOpcode(WorldPacket\u0026 recvData)\n{\n    TC_LOG_DEBUG(\"network\", \"WORLD: Received CMSG_RESURRECT_RESPONSE\");\n\n    ObjectGuid guid;\n    uint8 status;\n    recvData \u003e\u003e guid;\n    recvData \u003e\u003e status;\n\n    if (GetPlayer()-\u003eIsAlive())\n        return;\n\n    if (status == 0)\n    {\n        GetPlayer()-\u003eClearResurrectRequestData();           // reject\n        return;\n    }\n\n    if (!GetPlayer()-\u003eIsResurrectRequestedBy(guid))\n        return;\n\n    GetPlayer()-\u003eResurrectUsingRequestData();\n}\n\nvoid WorldSession::SendAreaTriggerMessage(const char* Text, ...)\n{\n    va_list ap;\n    char szStr [1024];\n    szStr[0] = '\\0';\n\n    va_start(ap, Text);\n    vsnprintf(szStr, 1024, Text, ap);\n    va_end(ap);\n\n    uint32 length = strlen(szStr)+1;\n    WorldPacket data(SMSG_AREA_TRIGGER_MESSAGE, 4+length);\n    data \u003c\u003c length;\n    data \u003c\u003c szStr;\n    SendPacket(\u0026data);\n}\n\nvoid WorldSession::HandleAreaTriggerOpcode(WorldPacket\u0026 recvData)\n{\n    uint32 triggerId;\n    recvData \u003e\u003e triggerId;\n\n    TC_LOG_DEBUG(\"network\", \"CMSG_AREATRIGGER. Trigger ID: %u\", triggerId);\n\n    Player* player = GetPlayer();\n    if (player-\u003eIsInFlight())\n    {\n        TC_LOG_DEBUG(\"network\", \"HandleAreaTriggerOpcode: Player '%s' (GUID: %u) in flight, ignore Area Trigger ID:%u\",\n            player-\u003eGetName().c_str(), player-\u003eGetGUID().GetCounter(), triggerId);\n        return;\n    }\n\n    AreaTriggerEntry const* atEntry = sAreaTriggerStore.LookupEntry(triggerId);\n    if (!atEntry)\n    {\n        TC_LOG_DEBUG(\"network\", \"HandleAreaTriggerOpcode: Player '%s' (GUID: %u) send unknown (by DBC) Area Trigger ID:%u\",\n            player-\u003eGetName().c_str(), player-\u003eGetGUID().GetCounter(), triggerId);\n        return;\n    }\n\n    if (!player-\u003eIsInAreaTriggerRadius(atEntry))\n    {\n        TC_LOG_DEBUG(\"network\", \"HandleAreaTriggerOpcode: Player '%s' (GUID: %u) too far, ignore Area Trigger ID: %u\",\n            player-\u003eGetName().c_str(), player-\u003eGetGUID().GetCounter(), triggerId);\n        return;\n    }\n\n    if (player-\u003eisDebugAreaTriggers)\n        ChatHandler(player-\u003eGetSession()).PSendSysMessage(LANG_DEBUG_AREATRIGGER_REACHED, triggerId);\n\n    if (sScriptMgr-\u003eOnAreaTrigger(player, atEntry))\n        return;\n\n    if (player-\u003eIsAlive())\n        if (uint32 questId = sObjectMgr-\u003eGetQuestForAreaTrigger(triggerId))\n            if (player-\u003eGetQuestStatus(questId) == QUEST_STATUS_INCOMPLETE)\n                player-\u003eAreaExploredOrEventHappens(questId);\n\n    if (sObjectMgr-\u003eIsTavernAreaTrigger(triggerId))\n    {\n        // set resting flag we are in the inn\n        player-\u003eSetRestFlag(REST_FLAG_IN_TAVERN, atEntry-\u003eid);\n\n        if (sWorld-\u003eIsFFAPvPRealm())\n            player-\u003eRemoveByteFlag(UNIT_FIELD_BYTES_2, UNIT_BYTES_2_OFFSET_PVP_FLAG, UNIT_BYTE2_FLAG_FFA_PVP);\n\n        return;\n    }\n\n    if (Battleground* bg = player-\u003eGetBattleground())\n        if (bg-\u003eGetStatus() == STATUS_IN_PROGRESS)\n            bg-\u003eHandleAreaTrigger(player, triggerId);\n\n    if (OutdoorPvP* pvp = player-\u003eGetOutdoorPvP())\n        if (pvp-\u003eHandleAreaTrigger(_player, triggerId))\n            return;\n\n    AreaTrigger const* at = sObjectMgr-\u003eGetAreaTrigger(triggerId);\n    if (!at)\n        return;\n\n    bool teleported = false;\n    if (player-\u003eGetMapId() != at-\u003etarget_mapId)\n    {\n        if (Map::EnterState denyReason = sMapMgr-\u003ePlayerCannotEnter(at-\u003etarget_mapId, player, false))\n        {\n            bool reviveAtTrigger = false; // should we revive the player if he is trying to enter the correct instance?\n            switch (denyReason)\n            {\n                case Map::CANNOT_ENTER_NO_ENTRY:\n                    TC_LOG_DEBUG(\"maps\", \"MAP: Player '%s' attempted to enter map with id %d which has no entry\", player-\u003eGetName().c_str(), at-\u003etarget_mapId);\n                    break;\n                case Map::CANNOT_ENTER_UNINSTANCED_DUNGEON:\n                    TC_LOG_DEBUG(\"maps\", \"MAP: Player '%s' attempted to enter dungeon map %d but no instance template was found\", player-\u003eGetName().c_str(), at-\u003etarget_mapId);\n                    break;\n                case Map::CANNOT_ENTER_DIFFICULTY_UNAVAILABLE:\n                    TC_LOG_DEBUG(\"maps\", \"MAP: Player '%s' attempted to enter instance map %d but the requested difficulty was not found\", player-\u003eGetName().c_str(), at-\u003etarget_mapId);\n                    if (MapEntry const* entry = sMapStore.LookupEntry(at-\u003etarget_mapId))\n                        player-\u003eSendTransferAborted(entry-\u003eMapID, TRANSFER_ABORT_DIFFICULTY, player-\u003eGetDifficulty(entry-\u003eIsRaid()));\n                    break;\n                case Map::CANNOT_ENTER_NOT_IN_RAID:\n                {\n                    WorldPacket data(SMSG_RAID_GROUP_ONLY, 4 + 4);\n                    data \u003c\u003c uint32(0);\n                    data \u003c\u003c uint32(2); // You must be in a raid group to enter this instance.\n                    player-\u003eGetSession()-\u003eSendPacket(\u0026data);\n                    TC_LOG_DEBUG(\"maps\", \"MAP: Player '%s' must be in a raid group to enter instance map %d\", player-\u003eGetName().c_str(), at-\u003etarget_mapId);\n                    reviveAtTrigger = true;\n                    break;\n                }\n                case Map::CANNOT_ENTER_CORPSE_IN_DIFFERENT_INSTANCE:\n                {\n                    WorldPacket data(SMSG_CORPSE_NOT_IN_INSTANCE);\n                    player-\u003eGetSession()-\u003eSendPacket(\u0026data);\n                    TC_LOG_DEBUG(\"maps\", \"MAP: Player '%s' does not have a corpse in instance map %d and cannot enter\", player-\u003eGetName().c_str(), at-\u003etarget_mapId);\n                    break;\n                }\n                case Map::CANNOT_ENTER_INSTANCE_BIND_MISMATCH:\n                    if (MapEntry const* entry = sMapStore.LookupEntry(at-\u003etarget_mapId))\n                    {\n                        char const* mapName = entry-\u003ename[player-\u003eGetSession()-\u003eGetSessionDbcLocale()];\n                        TC_LOG_DEBUG(\"maps\", \"MAP: Player '%s' cannot enter instance map '%s' because their permanent bind is incompatible with their group's\", player-\u003eGetName().c_str(), mapName);\n                        // is there a special opcode for this?\n                        // @todo figure out how to get player localized difficulty string (e.g. \"10 player\", \"Heroic\" etc)\n                        ChatHandler(player-\u003eGetSession()).PSendSysMessage(player-\u003eGetSession()-\u003eGetTrinityString(LANG_INSTANCE_BIND_MISMATCH), mapName);\n                    }\n                    reviveAtTrigger = true;\n                    break;\n                case Map::CANNOT_ENTER_TOO_MANY_INSTANCES:\n                    player-\u003eSendTransferAborted(at-\u003etarget_mapId, TRANSFER_ABORT_TOO_MANY_INSTANCES);\n                    TC_LOG_DEBUG(\"maps\", \"MAP: Player '%s' cannot enter instance map %d because he has exceeded the maximum number of instances per hour.\", player-\u003eGetName().c_str(), at-\u003etarget_mapId);\n                    reviveAtTrigger = true;\n                    break;\n                case Map::CANNOT_ENTER_MAX_PLAYERS:\n                    player-\u003eSendTransferAborted(at-\u003etarget_mapId, TRANSFER_ABORT_MAX_PLAYERS);\n                    reviveAtTrigger = true;\n                    break;\n                case Map::CANNOT_ENTER_ZONE_IN_COMBAT:\n                    player-\u003eSendTransferAborted(at-\u003etarget_mapId, TRANSFER_ABORT_ZONE_IN_COMBAT);\n                    reviveAtTrigger = true;\n                    break;\n                default:\n                    break;\n            }\n\n            if (reviveAtTrigger) // check if the player is touching the areatrigger leading to the map his corpse is on\n                if (!player-\u003eIsAlive() \u0026\u0026 player-\u003eHasCorpse())\n                    if (player-\u003eGetCorpseLocation().GetMapId() == at-\u003etarget_mapId)\n                    {\n                        player-\u003eResurrectPlayer(0.5f);\n                        player-\u003eSpawnCorpseBones();\n                    }\n\n            return;\n        }\n\n        if (Group* group = player-\u003eGetGroup())\n            if (group-\u003eisLFGGroup() \u0026\u0026 player-\u003eGetMap()-\u003eIsDungeon())\n                teleported = player-\u003eTeleportToBGEntryPoint();\n    }\n\n    if (!teleported)\n        player-\u003eTeleportTo(at-\u003etarget_mapId, at-\u003etarget_X, at-\u003etarget_Y, at-\u003etarget_Z, at-\u003etarget_Orientation, TELE_TO_NOT_LEAVE_TRANSPORT);\n}\n\nvoid WorldSession::HandleUpdateAccountData(WorldPacket\u0026 recvData)\n{\n    TC_LOG_DEBUG(\"network\", \"WORLD: Received CMSG_UPDATE_ACCOUNT_DATA\");\n\n    uint32 type, timestamp, decompressedSize;\n    recvData \u003e\u003e type \u003e\u003e timestamp \u003e\u003e decompressedSize;\n\n    TC_LOG_DEBUG(\"network\", \"UAD: type %u, time %u, decompressedSize %u\", type, timestamp, decompressedSize);\n\n    if (type \u003e NUM_ACCOUNT_DATA_TYPES)\n        return;\n\n    if (decompressedSize == 0)                               // erase\n    {\n        SetAccountData(AccountDataType(type), 0, \"\");\n\n        WorldPacket data(SMSG_UPDATE_ACCOUNT_DATA_COMPLETE, 4+4);\n        data \u003c\u003c uint32(type);\n        data \u003c\u003c uint32(0);\n        SendPacket(\u0026data);\n\n        return;\n    }\n\n    if (decompressedSize \u003e 0xFFFF)\n    {\n        recvData.rfinish();                   // unnneded warning spam in this case\n        TC_LOG_ERROR(\"network\", \"UAD: Account data packet too big, size %u\", decompressedSize);\n        return;\n    }\n\n    ByteBuffer dest;\n    dest.resize(decompressedSize);\n\n    uLongf realSize = decompressedSize;\n    if (uncompress(dest.contents(), \u0026realSize, recvData.contents() + recvData.rpos(), recvData.size() - recvData.rpos()) != Z_OK)\n    {\n        recvData.rfinish();                   // unnneded warning spam in this case\n        TC_LOG_ERROR(\"network\", \"UAD: Failed to decompress account data\");\n        return;\n    }\n\n    recvData.rfinish();                       // uncompress read (recvData.size() - recvData.rpos())\n\n    std::string adata;\n    dest \u003e\u003e adata;\n\n    SetAccountData(AccountDataType(type), timestamp, adata);\n\n    WorldPacket data(SMSG_UPDATE_ACCOUNT_DATA_COMPLETE, 4+4);\n    data \u003c\u003c uint32(type);\n    data \u003c\u003c uint32(0);\n    SendPacket(\u0026data);\n}\n\nvoid WorldSession::HandleRequestAccountData(WorldPacket\u0026 recvData)\n{\n    TC_LOG_DEBUG(\"network\", \"WORLD: Received CMSG_REQUEST_ACCOUNT_DATA\");\n\n    uint32 type;\n    recvData \u003e\u003e type;\n\n    TC_LOG_DEBUG(\"network\", \"RAD: type %u\", type);\n\n    if (type \u003e= NUM_ACCOUNT_DATA_TYPES)\n        return;\n\n    AccountData* adata = GetAccountData(AccountDataType(type));\n\n    uint32 size = adata-\u003eData.size();\n\n    uLongf destSize = compressBound(size);\n\n    ByteBuffer dest;\n    dest.resize(destSize);\n\n    if (size \u0026\u0026 compress(dest.contents(), \u0026destSize, (uint8 const*)adata-\u003eData.c_str(), size) != Z_OK)\n    {\n        TC_LOG_DEBUG(\"network\", \"RAD: Failed to compress account data\");\n        return;\n    }\n\n    dest.resize(destSize);\n\n    WorldPacket data(SMSG_UPDATE_ACCOUNT_DATA, 8+4+4+4+destSize);\n    data \u003c\u003c uint64(_player ? _player-\u003eGetGUID() : ObjectGuid::Empty);\n    data \u003c\u003c uint32(type);                                   // type (0-7)\n    data \u003c\u003c uint32(adata-\u003eTime);                            // unix time\n    data \u003c\u003c uint32(size);                                   // decompressed length\n    data.append(dest);                                      // compressed data\n    SendPacket(\u0026data);\n}\n\nvoid WorldSession::HandleSetActionButtonOpcode(WorldPacket\u0026 recvData)\n{\n    uint8 button;\n    uint32 packetData;\n    recvData \u003e\u003e button \u003e\u003e packetData;\n    TC_LOG_DEBUG(\"network\", \"CMSG_SET_ACTION_BUTTON Button: %u Data: %u\", button, packetData);\n\n    if (!packetData)\n        GetPlayer()-\u003eremoveActionButton(button);\n    else\n        GetPlayer()-\u003eaddActionButton(button, ACTION_BUTTON_ACTION(packetData), ACTION_BUTTON_TYPE(packetData));\n}\n\nvoid WorldSession::HandleCompleteCinematic(WorldPacket\u0026 /*recvData*/)\n{\n    // If player has sight bound to visual waypoint NPC we should remove it\n    GetPlayer()-\u003eGetCinematicMgr()-\u003eEndCinematic();\n}\n\nvoid WorldSession::HandleNextCinematicCamera(WorldPacket\u0026 /*recvData*/)\n{\n    // Sent by client when cinematic actually begun. So we begin the server side process\n    GetPlayer()-\u003eGetCinematicMgr()-\u003eBeginCinematic();\n}\n\nvoid WorldSession::HandleMoveTimeSkippedOpcode(WorldPacket\u0026 recvData)\n{\n    /*  WorldSession::Update(getMSTime());*/\n    TC_LOG_DEBUG(\"network\", \"WORLD: Received CMSG_MOVE_TIME_SKIPPED\");\n\n    ObjectGuid guid;\n    recvData \u003e\u003e guid.ReadAsPacked();\n    recvData.read_skip\u003cuint32\u003e();\n    /*\n        uint64 guid;\n        uint32 time_skipped;\n        recvData \u003e\u003e guid;\n        recvData \u003e\u003e time_skipped;\n        TC_LOG_DEBUG(\"network\", \"WORLD: CMSG_MOVE_TIME_SKIPPED\");\n\n        //// @todo\n        must be need use in Trinity\n        We substract server Lags to move time (AntiLags)\n        for exmaple\n        GetPlayer()-\u003eModifyLastMoveTime(-int32(time_skipped));\n    */\n}\n\nvoid WorldSession::HandleFeatherFallAck(WorldPacket\u0026 recvData)\n{\n    TC_LOG_DEBUG(\"network\", \"WORLD: CMSG_MOVE_FEATHER_FALL_ACK\");\n\n    // no used\n    recvData.rfinish();                       // prevent warnings spam\n}\n\nvoid WorldSession::HandleMoveUnRootAck(WorldPacket\u0026 recvData)\n{\n    // no used\n    recvData.rfinish();                       // prevent warnings spam\n/*\n    uint64 guid;\n    recvData \u003e\u003e guid;\n\n    // now can skip not our packet\n    if (_player-\u003eGetGUID() != guid)\n    {\n        recvData.rfinish();                   // prevent warnings spam\n        return;\n    }\n\n    TC_LOG_DEBUG(\"network\", \"WORLD: CMSG_FORCE_MOVE_UNROOT_ACK\");\n\n    recvData.read_skip\u003cuint32\u003e();                          // unk\n\n    MovementInfo movementInfo;\n    movementInfo.guid = guid;\n    ReadMovementInfo(recvData, \u0026movementInfo);\n    recvData.read_skip\u003cfloat\u003e();                           // unk2\n*/\n}\n\nvoid WorldSession::HandleMoveRootAck(WorldPacket\u0026 recvData)\n{\n    // no used\n    recvData.rfinish();                       // prevent warnings spam\n/*\n    uint64 guid;\n    recvData \u003e\u003e guid;\n\n    // now can skip not our packet\n    if (_player-\u003eGetGUID() != guid)\n    {\n        recvData.rfinish();                   // prevent warnings spam\n        return;\n    }\n\n    TC_LOG_DEBUG(\"network\", \"WORLD: CMSG_FORCE_MOVE_ROOT_ACK\");\n\n    recvData.read_skip\u003cuint32\u003e();                          // unk\n\n    MovementInfo movementInfo;\n    ReadMovementInfo(recvData, \u0026movementInfo);\n*/\n}\n\nvoid WorldSession::HandleSetActionBarToggles(WorldPacket\u0026 recvData)\n{\n    uint8 actionBar;\n    recvData \u003e\u003e actionBar;\n\n    if (!GetPlayer())                                        // ignore until not logged (check needed because STATUS_AUTHED)\n    {\n        if (actionBar != 0)\n            TC_LOG_ERROR(\"network\", \"WorldSession::HandleSetActionBarToggles in not logged state with value: %u, ignored\", uint32(actionBar));\n        return;\n    }\n\n    GetPlayer()-\u003eSetByteValue(PLAYER_FIELD_BYTES, PLAYER_FIELD_BYTES_OFFSET_ACTION_BAR_TOGGLES, actionBar);\n}\n\nvoid WorldSession::HandlePlayedTime(WorldPacket\u0026 recvData)\n{\n    uint8 unk1;\n    recvData \u003e\u003e unk1;                                      // 0 or 1 expected\n\n    WorldPacket data(SMSG_PLAYED_TIME, 4 + 4 + 1);\n    data \u003c\u003c uint32(_player-\u003eGetTotalPlayedTime());\n    data \u003c\u003c uint32(_player-\u003eGetLevelPlayedTime());\n    data \u003c\u003c uint8(unk1);                                    // 0 - will not show in chat frame\n    SendPacket(\u0026data);\n}\n\nvoid WorldSession::HandleInspectOpcode(WorldPacket\u0026 recvData)\n{\n    ObjectGuid guid;\n    recvData \u003e\u003e guid;\n\n    TC_LOG_DEBUG(\"network\", \"WORLD: Received CMSG_INSPECT\");\n\n    Player* player = ObjectAccessor::GetPlayer(*_player, guid);\n    if (!player)\n    {\n        TC_LOG_DEBUG(\"network\", \"CMSG_INSPECT: No player found from %s\", guid.ToString().c_str());\n        return;\n    }\n\n    if (!GetPlayer()-\u003eIsWithinDistInMap(player, INSPECT_DISTANCE, false))\n        return;\n\n    if (GetPlayer()-\u003eIsValidAttackTarget(player))\n        return;\n\n    uint32 talent_points = 0x47;\n    uint32 guid_size = player-\u003eGetPackGUID().size();\n    WorldPacket data(SMSG_INSPECT_TALENT, guid_size+4+talent_points);\n    data \u003c\u003c player-\u003eGetPackGUID();\n\n    if (GetPlayer()-\u003eCanBeGameMaster() || sWorld-\u003egetIntConfig(CONFIG_TALENTS_INSPECTING) + (GetPlayer()-\u003eGetTeamId() == player-\u003eGetTeamId()) \u003e 1)\n        player-\u003eBuildPlayerTalentsInfoData(\u0026data);\n    else\n    {\n        data \u003c\u003c uint32(0);                                  // unspentTalentPoints\n        data \u003c\u003c uint8(0);                                   // talentGroupCount\n        data \u003c\u003c uint8(0);                                   // talentGroupIndex\n    }\n\n    player-\u003eBuildEnchantmentsInfoData(\u0026data);\n    SendPacket(\u0026data);\n}\n\nvoid WorldSession::HandleInspectHonorStatsOpcode(WorldPacket\u0026 recvData)\n{\n    ObjectGuid guid;\n    recvData \u003e\u003e guid;\n\n    Player* player = ObjectAccessor::GetPlayer(*_player, guid);\n\n    if (!player)\n    {\n        TC_LOG_DEBUG(\"network\", \"MSG_INSPECT_HONOR_STATS: No player found from %s\", guid.ToString().c_str());\n        return;\n    }\n\n    if (!GetPlayer()-\u003eIsWithinDistInMap(player, INSPECT_DISTANCE, false))\n        return;\n\n    if (GetPlayer()-\u003eIsValidAttackTarget(player))\n        return;\n\n    WorldPacket data(MSG_INSPECT_HONOR_STATS, 8+1+4*4);\n    data \u003c\u003c uint64(player-\u003eGetGUID());\n    data \u003c\u003c uint8(player-\u003eGetHonorPoints());\n    data \u003c\u003c uint32(player-\u003eGetUInt32Value(PLAYER_FIELD_KILLS));\n    data \u003c\u003c uint32(player-\u003eGetUInt32Value(PLAYER_FIELD_TODAY_CONTRIBUTION));\n    data \u003c\u003c uint32(player-\u003eGetUInt32Value(PLAYER_FIELD_YESTERDAY_CONTRIBUTION));\n    data \u003c\u003c uint32(player-\u003eGetUInt32Value(PLAYER_FIELD_LIFETIME_HONORABLE_KILLS));\n    SendPacket(\u0026data);\n}\n\nvoid WorldSession::HandleWorldTeleportOpcode(WorldPacket\u0026 recvData)\n{\n    uint32 time;\n    uint32 mapid;\n    float PositionX;\n    float PositionY;\n    float PositionZ;\n    float Orientation;\n\n    recvData \u003e\u003e time;                                      // time in m.sec.\n    recvData \u003e\u003e mapid;\n    recvData \u003e\u003e PositionX;\n    recvData \u003e\u003e PositionY;\n    recvData \u003e\u003e PositionZ;\n    recvData \u003e\u003e Orientation;                               // o (3.141593 = 180 degrees)\n\n    TC_LOG_DEBUG(\"network\", \"WORLD: Received CMSG_WORLD_TELEPORT\");\n\n    if (GetPlayer()-\u003eIsInFlight())\n    {\n        TC_LOG_DEBUG(\"network\", \"Player '%s' (GUID: %u) in flight, ignore worldport command.\",\n            GetPlayer()-\u003eGetName().c_str(), GetPlayer()-\u003eGetGUID().GetCounter());\n        return;\n    }\n\n    TC_LOG_DEBUG(\"network\", \"CMSG_WORLD_TELEPORT: Player = %s, Time = %u, map = %u, x = %f, y = %f, z = %f, o = %f\",\n        GetPlayer()-\u003eGetName().c_str(), time, mapid, PositionX, PositionY, PositionZ, Orientation);\n\n    if (HasPermission(rbac::RBAC_PERM_OPCODE_WORLD_TELEPORT))\n        GetPlayer()-\u003eTeleportTo(mapid, PositionX, PositionY, PositionZ, Orientation);\n    else\n        SendNotification(LANG_YOU_NOT_HAVE_PERMISSION);\n}\n\nvoid WorldSession::HandleWhoisOpcode(WorldPacket\u0026 recvData)\n{\n    TC_LOG_DEBUG(\"network\", \"Received opcode CMSG_WHOIS\");\n    std::string charname;\n    recvData \u003e\u003e charname;\n\n    if (!HasPermission(rbac::RBAC_PERM_OPCODE_WHOIS))\n    {\n        SendNotification(LANG_YOU_NOT_HAVE_PERMISSION);\n        return;\n    }\n\n    if (charname.empty() || !normalizePlayerName (charname))\n    {\n        SendNotification(LANG_NEED_CHARACTER_NAME);\n        return;\n    }\n\n    Player* player = ObjectAccessor::FindConnectedPlayerByName(charname);\n\n    if (!player)\n    {\n        SendNotification(LANG_PLAYER_NOT_EXIST_OR_OFFLINE, charname.c_str());\n        return;\n    }\n\n    uint32 accid = player-\u003eGetSession()-\u003eGetAccountId();\n\n    PreparedStatement* stmt = LoginDatabase.GetPreparedStatement(LOGIN_SEL_ACCOUNT_WHOIS);\n\n    stmt-\u003esetUInt32(0, accid);\n\n    PreparedQueryResult result = LoginDatabase.Query(stmt);\n\n    if (!result)\n    {\n        SendNotification(LANG_ACCOUNT_FOR_PLAYER_NOT_FOUND, charname.c_str());\n        return;\n    }\n\n    Field* fields = result-\u003eFetch();\n    std::string acc = fields[0].GetString();\n    if (acc.empty())\n        acc = \"Unknown\";\n    std::string email = fields[1].GetString();\n    if (email.empty())\n        email = \"Unknown\";\n    std::string lastip = fields[2].GetString();\n    if (lastip.empty())\n        lastip = \"Unknown\";\n\n    std::string msg = charname + \"'s \" + \"account is \" + acc + \", e-mail: \" + email + \", last ip: \" + lastip;\n\n    WorldPacket data(SMSG_WHOIS, msg.size()+1);\n    data \u003c\u003c msg;\n    SendPacket(\u0026data);\n\n    TC_LOG_DEBUG(\"network\", \"Received whois command from player %s for character %s\",\n        GetPlayer()-\u003eGetName().c_str(), charname.c_str());\n}\n\nvoid WorldSession::HandleComplainOpcode(WorldPacket\u0026 recvData)\n{\n    TC_LOG_DEBUG(\"network\", \"WORLD: CMSG_COMPLAIN\");\n\n    uint8 spam_type;                                        // 0 - mail, 1 - chat\n    ObjectGuid spammer_guid;\n    uint32 unk1 = 0;\n    uint32 unk2 = 0;\n    uint32 unk3 = 0;\n    uint32 unk4 = 0;\n    std::string description = \"\";\n    recvData \u003e\u003e spam_type;                                 // unk 0x01 const, may be spam type (mail/chat)\n    recvData \u003e\u003e spammer_guid;                              // player guid\n    switch (spam_type)\n    {\n        case 0:\n            recvData \u003e\u003e unk1;                              // const 0\n            recvData \u003e\u003e unk2;                              // probably mail id\n            recvData \u003e\u003e unk3;                              // const 0\n            break;\n        case 1:\n            recvData \u003e\u003e unk1;                              // probably language\n            recvData \u003e\u003e unk2;                              // message type?\n            recvData \u003e\u003e unk3;                              // probably channel id\n            recvData \u003e\u003e unk4;                              // time\n            recvData \u003e\u003e description;                       // spam description string (messagetype, channel name, player name, message)\n            break;\n    }\n\n    // NOTE: all chat messages from this spammer automatically ignored by spam reporter until logout in case chat spam.\n    // if it's mail spam - ALL mails from this spammer automatically removed by client\n\n    // Complaint Received message\n    WorldPacket data(SMSG_COMPLAIN_RESULT, 1);\n    data \u003c\u003c uint8(0);\n    SendPacket(\u0026data);\n\n    TC_LOG_DEBUG(\"network\", \"REPORT SPAM: type %u, %s, unk1 %u, unk2 %u, unk3 %u, unk4 %u, message %s\",\n        spam_type, spammer_guid.ToString().c_str(), unk1, unk2, unk3, unk4, description.c_str());\n}\n\nvoid WorldSession::HandleRealmSplitOpcode(WorldPacket\u0026 recvData)\n{\n    TC_LOG_DEBUG(\"network\", \"CMSG_REALM_SPLIT\");\n\n    uint32 unk;\n    std::string split_date = \"01/01/01\";\n    recvData \u003e\u003e unk;\n\n    WorldPacket data(SMSG_REALM_SPLIT, 4+4+split_date.size()+1);\n    data \u003c\u003c unk;\n    data \u003c\u003c uint32(0x00000000);                             // realm split state\n    // split states:\n    // 0x0 realm normal\n    // 0x1 realm split\n    // 0x2 realm split pending\n    data \u003c\u003c split_date;\n    SendPacket(\u0026data);\n    //TC_LOG_DEBUG(\"response sent %u\", unk);\n}\n\nvoid WorldSession::HandleFarSightOpcode(WorldPacket\u0026 recvData)\n{\n    TC_LOG_DEBUG(\"network\", \"WORLD: CMSG_FAR_SIGHT\");\n\n    bool apply;\n    recvData \u003e\u003e apply;\n\n    if (apply)\n    {\n        TC_LOG_DEBUG(\"network\", \"Added FarSight %s to player %u\", _player-\u003eGetGuidValue(PLAYER_FARSIGHT).ToString().c_str(), _player-\u003eGetGUID().GetCounter());\n        if (WorldObject* target = _player-\u003eGetViewpoint())\n            _player-\u003eSetSeer(target);\n        else\n            TC_LOG_DEBUG(\"network\", \"Player %s (%s) requests non-existing seer %s\", _player-\u003eGetName().c_str(), _player-\u003eGetGUID().ToString().c_str(), _player-\u003eGetGuidValue(PLAYER_FARSIGHT).ToString().c_str());\n    }\n    else\n    {\n        TC_LOG_DEBUG(\"network\", \"Player %u set vision to self\", _player-\u003eGetGUID().GetCounter());\n        _player-\u003eSetSeer(_player);\n    }\n\n    GetPlayer()-\u003eUpdateVisibilityForPlayer();\n}\n\nvoid WorldSession::HandleSetTitleOpcode(WorldPacket\u0026 recvData)\n{\n    TC_LOG_DEBUG(\"network\", \"CMSG_SET_TITLE\");\n\n    int32 title;\n    recvData \u003e\u003e title;\n\n    // -1 at none\n    if (title \u003e 0 \u0026\u0026 title \u003c MAX_TITLE_INDEX)\n    {\n       if (!GetPlayer()-\u003eHasTitle(title))\n            return;\n    }\n    else\n        title = 0;\n\n    GetPlayer()-\u003eSetUInt32Value(PLAYER_CHOSEN_TITLE, title);\n}\n\nvoid WorldSession::HandleTimeSyncResp(WorldPacket\u0026 recvData)\n{\n    TC_LOG_DEBUG(\"network\", \"CMSG_TIME_SYNC_RESP\");\n\n    uint32 counter, clientTicks;\n    recvData \u003e\u003e counter \u003e\u003e clientTicks;\n\n    if (counter != _player-\u003em_timeSyncCounter - 1)\n        TC_LOG_DEBUG(\"network\", \"Wrong time sync counter from player %s (cheater?)\", _player-\u003eGetName().c_str());\n\n    TC_LOG_DEBUG(\"network\", \"Time sync received: counter %u, client ticks %u, time since last sync %u\", counter, clientTicks, clientTicks - _player-\u003em_timeSyncClient);\n\n    uint32 ourTicks = clientTicks + (GameTime::GetGameTimeMS() - _player-\u003em_timeSyncServer);\n\n    // diff should be small\n    TC_LOG_DEBUG(\"network\", \"Our ticks: %u, diff %u, latency %u\", ourTicks, ourTicks - clientTicks, GetLatency());\n\n    _player-\u003em_timeSyncClient = clientTicks;\n}\n\nvoid WorldSession::HandleResetInstancesOpcode(WorldPacket\u0026 /*recvData*/)\n{\n    TC_LOG_DEBUG(\"network\", \"WORLD: CMSG_RESET_INSTANCES\");\n\n    if (Group* group = _player-\u003eGetGroup())\n    {\n        if (group-\u003eIsLeader(_player-\u003eGetGUID()))\n            group-\u003eResetInstances(INSTANCE_RESET_ALL, false, _player);\n    }\n    else\n        _player-\u003eResetInstances(INSTANCE_RESET_ALL, false);\n}\n\nvoid WorldSession::HandleSetDungeonDifficultyOpcode(WorldPacket\u0026 recvData)\n{\n    TC_LOG_DEBUG(\"network\", \"MSG_SET_DUNGEON_DIFFICULTY\");\n\n    uint32 mode;\n    recvData \u003e\u003e mode;\n\n    if (mode \u003e= MAX_DUNGEON_DIFFICULTY)\n    {\n        TC_LOG_DEBUG(\"network\", \"WorldSession::HandleSetDungeonDifficultyOpcode: player %d sent an invalid instance mode %d!\", _player-\u003eGetGUID().GetCounter(), mode);\n        return;\n    }\n\n    if (Difficulty(mode) == _player-\u003eGetDungeonDifficulty())\n        return;\n\n    // cannot reset while in an instance\n    Map* map = _player-\u003eFindMap();\n    if (map \u0026\u0026 map-\u003eIsDungeon())\n    {\n        TC_LOG_DEBUG(\"network\", \"WorldSession::HandleSetDungeonDifficultyOpcode: player (Name: %s, GUID: %u) tried to reset the instance while player is inside!\",\n            _player-\u003eGetName().c_str(), _player-\u003eGetGUID().GetCounter());\n        return;\n    }\n\n    Group* group = _player-\u003eGetGroup();\n    if (group)\n    {\n        if (group-\u003eIsLeader(_player-\u003eGetGUID()))\n        {\n            for (GroupReference* itr = group-\u003eGetFirstMember(); itr != NULL; itr = itr-\u003enext())\n            {\n                Player* groupGuy = itr-\u003eGetSource();\n                if (!groupGuy)\n                    continue;\n\n                if (!groupGuy-\u003eIsInMap(groupGuy))\n                    return;\n\n                if (groupGuy-\u003eGetMap()-\u003eIsNonRaidDungeon())\n                {\n                    TC_LOG_DEBUG(\"network\", \"WorldSession::HandleSetDungeonDifficultyOpcode: player %d tried to reset the instance while group member (Name: %s, GUID: %u) is inside!\",\n                        _player-\u003eGetGUID().GetCounter(), groupGuy-\u003eGetName().c_str(), groupGuy-\u003eGetGUID().GetCounter());\n                    return;\n                }\n            }\n            // the difficulty is set even if the instances can't be reset\n            //_player-\u003eSendDungeonDifficulty(true);\n            group-\u003eResetInstances(INSTANCE_RESET_CHANGE_DIFFICULTY, false, _player);\n            group-\u003eSetDungeonDifficulty(Difficulty(mode));\n        }\n    }\n    else\n    {\n        _player-\u003eResetInstances(INSTANCE_RESET_CHANGE_DIFFICULTY, false);\n        _player-\u003eSetDungeonDifficulty(Difficulty(mode));\n    }\n}\n\nvoid WorldSession::HandleSetRaidDifficultyOpcode(WorldPacket\u0026 recvData)\n{\n    TC_LOG_DEBUG(\"network\", \"MSG_SET_RAID_DIFFICULTY\");\n\n    uint32 mode;\n    recvData \u003e\u003e mode;\n\n    if (mode \u003e= MAX_RAID_DIFFICULTY)\n    {\n        TC_LOG_ERROR(\"network\", \"WorldSession::HandleSetRaidDifficultyOpcode: player %d sent an invalid instance mode %d!\", _player-\u003eGetGUID().GetCounter(), mode);\n        return;\n    }\n\n    // cannot reset while in an instance\n    Map* map = _player-\u003eFindMap();\n    if (map \u0026\u0026 map-\u003eIsDungeon())\n    {\n        TC_LOG_DEBUG(\"network\", \"WorldSession::HandleSetRaidDifficultyOpcode: player %d tried to reset the instance while inside!\", _player-\u003eGetGUID().GetCounter());\n        return;\n    }\n\n    if (Difficulty(mode) == _player-\u003eGetRaidDifficulty())\n        return;\n\n    Group* group = _player-\u003eGetGroup();\n    if (group)\n    {\n        if (group-\u003eIsLeader(_player-\u003eGetGUID()))\n        {\n            for (GroupReference* itr = group-\u003eGetFirstMember(); itr != NULL; itr = itr-\u003enext())\n            {\n                Player* groupGuy = itr-\u003eGetSource();\n                if (!groupGuy)\n                    continue;\n\n                if (!groupGuy-\u003eIsInMap(groupGuy))\n                    return;\n\n                if (groupGuy-\u003eGetMap()-\u003eIsRaid())\n                {\n                    TC_LOG_DEBUG(\"network\", \"WorldSession::HandleSetRaidDifficultyOpcode: player %d tried to reset the instance while inside!\", _player-\u003eGetGUID().GetCounter());\n                    return;\n                }\n            }\n            // the difficulty is set even if the instances can't be reset\n            //_player-\u003eSendDungeonDifficulty(true);\n            group-\u003eResetInstances(INSTANCE_RESET_CHANGE_DIFFICULTY, true, _player);\n            group-\u003eSetRaidDifficulty(Difficulty(mode));\n        }\n    }\n    else\n    {\n        _player-\u003eResetInstances(INSTANCE_RESET_CHANGE_DIFFICULTY, true);\n        _player-\u003eSetRaidDifficulty(Difficulty(mode));\n    }\n}\n\nvoid WorldSession::HandleCancelMountAuraOpcode(WorldPacket\u0026 /*recvData*/)\n{\n    TC_LOG_DEBUG(\"network\", \"WORLD: CMSG_CANCEL_MOUNT_AURA\");\n\n    //If player is not mounted, so go out :)\n    if (!_player-\u003eIsMounted())                              // not blizz like; no any messages on blizz\n    {\n        ChatHandler(this).SendSysMessage(LANG_CHAR_NON_MOUNTED);\n        return;\n    }\n\n    if (_player-\u003eIsInFlight())                               // not blizz like; no any messages on blizz\n    {\n        ChatHandler(this).SendSysMessage(LANG_YOU_IN_FLIGHT);\n        return;\n    }\n\n    _player-\u003eRemoveAurasByType(SPELL_AURA_MOUNTED); // Calls Dismount()\n}\n\nvoid WorldSession::HandleMoveSetCanFlyAckOpcode(WorldPacket\u0026 recvData)\n{\n    // fly mode on/off\n    TC_LOG_DEBUG(\"network\", \"WORLD: CMSG_MOVE_SET_CAN_FLY_ACK\");\n\n    ObjectGuid guid;                                            // guid - unused\n    recvData \u003e\u003e guid.ReadAsPacked();\n\n    recvData.read_skip\u003cuint32\u003e();                          // unk\n\n    MovementInfo movementInfo;\n    movementInfo.guid = guid;\n    ReadMovementInfo(recvData, \u0026movementInfo);\n\n    recvData.read_skip\u003cfloat\u003e();                           // unk2\n\n    _player-\u003em_unitMovedByMe-\u003em_movementInfo.flags = movementInfo.GetMovementFlags();\n}\n\nvoid WorldSession::HandleRequestPetInfoOpcode(WorldPacket\u0026 /*recvData */)\n{\n    /*\n        TC_LOG_DEBUG(\"network\", \"WORLD: CMSG_REQUEST_PET_INFO\");\n        recvData.hexlike();\n    */\n}\n\nvoid WorldSession::HandleSetTaxiBenchmarkOpcode(WorldPacket\u0026 recvData)\n{\n    TC_LOG_DEBUG(\"network\", \"WORLD: CMSG_SET_TAXI_BENCHMARK_MODE\");\n\n    uint8 mode;\n    recvData \u003e\u003e mode;\n\n    mode ? _player-\u003eSetFlag(PLAYER_FLAGS, PLAYER_FLAGS_TAXI_BENCHMARK) : _player-\u003eRemoveFlag(PLAYER_FLAGS, PLAYER_FLAGS_TAXI_BENCHMARK);\n\n    TC_LOG_DEBUG(\"network\", \"Client used \\\"/timetest %d\\\" command\", mode);\n}\n\nvoid WorldSession::HandleQueryInspectAchievements(WorldPacket\u0026 recvData)\n{\n    ObjectGuid guid;\n    recvData \u003e\u003e guid.ReadAsPacked();\n\n    TC_LOG_DEBUG(\"network\", \"CMSG_QUERY_INSPECT_ACHIEVEMENTS [%s] Inspected Player [%s]\", _player-\u003eGetGUID().ToString().c_str(), guid.ToString().c_str());\n    Player* player = ObjectAccessor::GetPlayer(*_player, guid);\n    if (!player)\n        return;\n\n    if (!GetPlayer()-\u003eIsWithinDistInMap(player, INSPECT_DISTANCE, false))\n        return;\n\n    if (GetPlayer()-\u003eIsValidAttackTarget(player))\n        return;\n\n    player-\u003eSendRespondInspectAchievements(_player);\n}\n\nvoid WorldSession::HandleWorldStateUITimerUpdate(WorldPacket\u0026 /*recvData*/)\n{\n    // empty opcode\n    TC_LOG_DEBUG(\"network\", \"WORLD: CMSG_WORLD_STATE_UI_TIMER_UPDATE\");\n\n    WorldPacket data(SMSG_WORLD_STATE_UI_TIMER_UPDATE, 4);\n    data \u003c\u003c uint32(time(NULL));\n    SendPacket(\u0026data);\n}\n\nvoid WorldSession::HandleReadyForAccountDataTimes(WorldPacket\u0026 /*recvData*/)\n{\n    // empty opcode\n    TC_LOG_DEBUG(\"network\", \"WORLD: CMSG_READY_FOR_ACCOUNT_DATA_TIMES\");\n\n    SendAccountDataTimes(GLOBAL_CACHE_MASK);\n}\n\nvoid WorldSession::SendSetPhaseShift(uint32 PhaseShift)\n{\n    WorldPacket data(SMSG_SET_PHASE_SHIFT, 4);\n    data \u003c\u003c uint32(PhaseShift);\n    SendPacket(\u0026data);\n}\n// Battlefield and Battleground\nvoid WorldSession::HandleAreaSpiritHealerQueryOpcode(WorldPacket\u0026 recvData)\n{\n    TC_LOG_DEBUG(\"network\", \"WORLD: CMSG_AREA_SPIRIT_HEALER_QUERY\");\n\n    Battleground* bg = _player-\u003eGetBattleground();\n\n    ObjectGuid guid;\n    recvData \u003e\u003e guid;\n\n    Creature* unit = GetPlayer()-\u003eGetMap()-\u003eGetCreature(guid);\n    if (!unit)\n        return;\n\n    if (!unit-\u003eIsSpiritService())                            // it's not spirit service\n        return;\n\n    if (bg)\n        sBattlegroundMgr-\u003eSendAreaSpiritHealerQueryOpcode(_player, bg, guid);\n\n    if (Battlefield* bf = sBattlefieldMgr-\u003eGetBattlefieldToZoneId(_player-\u003eGetZoneId()))\n        bf-\u003eSendAreaSpiritHealerQueryOpcode(_player, guid);\n}\n\nvoid WorldSession::HandleAreaSpiritHealerQueueOpcode(WorldPacket\u0026 recvData)\n{\n    TC_LOG_DEBUG(\"network\", \"WORLD: CMSG_AREA_SPIRIT_HEALER_QUEUE\");\n\n    Battleground* bg = _player-\u003eGetBattleground();\n\n    ObjectGuid guid;\n    recvData \u003e\u003e guid;\n\n    Creature* unit = GetPlayer()-\u003eGetMap()-\u003eGetCreature(guid);\n    if (!unit)\n        return;\n\n    if (!unit-\u003eIsSpiritService())                            // it's not spirit service\n        return;\n\n    if (bg)\n        bg-\u003eAddPlayerToResurrectQueue(guid, _player-\u003eGetGUID());\n\n    if (Battlefield* bf = sBattlefieldMgr-\u003eGetBattlefieldToZoneId(_player-\u003eGetZoneId()))\n        bf-\u003eAddPlayerToResurrectQueue(guid, _player-\u003eGetGUID());\n}\n\nvoid WorldSession::HandleHearthAndResurrect(WorldPacket\u0026 /*recvData*/)\n{\n    if (_player-\u003eIsInFlight())\n        return;\n\n    if (Battlefield* bf = sBattlefieldMgr-\u003eGetBattlefieldToZoneId(_player-\u003eGetZoneId()))\n    {\n        bf-\u003ePlayerAskToLeave(_player);\n        return;\n    }\n\n    AreaTableEntry const* atEntry = sAreaTableStore.LookupEntry(_player-\u003eGetAreaId());\n    if (!atEntry || !(atEntry-\u003eflags \u0026 AREA_FLAG_WINTERGRASP_2))\n        return;\n\n    _player-\u003eBuildPlayerRepop();\n    _player-\u003eResurrectPlayer(1.0f);\n    _player-\u003eTeleportTo(_player-\u003em_homebindMapId, _player-\u003em_homebindX, _player-\u003em_homebindY, _player-\u003em_homebindZ, _player-\u003eGetOrientation());\n}\n\nvoid WorldSession::HandleInstanceLockResponse(WorldPacket\u0026 recvPacket)\n{\n    uint8 accept;\n    recvPacket \u003e\u003e accept;\n\n    if (!_player-\u003eHasPendingBind())\n    {\n        TC_LOG_INFO(\"network\", \"InstanceLockResponse: Player %s (guid %u) tried to bind himself/teleport to graveyard without a pending bind!\",\n            _player-\u003eGetName().c_str(), _player-\u003eGetGUID().GetCounter());\n        return;\n    }\n\n    if (accept)\n        _player-\u003eBindToInstance();\n    else\n        _player-\u003eRepopAtGraveyard();\n\n    _player-\u003eSetPendingBind(0, 0);\n}\n\nvoid WorldSession::HandleUpdateMissileTrajectory(WorldPacket\u0026 recvPacket)\n{\n    TC_LOG_DEBUG(\"network\", \"WORLD: CMSG_UPDATE_MISSILE_TRAJECTORY\");\n\n    ObjectGuid guid;\n    uint32 spellId;\n    float elevation, speed;\n    float curX, curY, curZ;\n    float targetX, targetY, targetZ;\n    uint8 moveStop;\n\n    recvPacket \u003e\u003e guid \u003e\u003e spellId \u003e\u003e elevation \u003e\u003e speed;\n    recvPacket \u003e\u003e curX \u003e\u003e curY \u003e\u003e curZ;\n    recvPacket \u003e\u003e targetX \u003e\u003e targetY \u003e\u003e targetZ;\n    recvPacket \u003e\u003e moveStop;\n\n    Unit* caster = ObjectAccessor::GetUnit(*_player, guid);\n    Spell* spell = caster ? caster-\u003eGetCurrentSpell(CURRENT_GENERIC_SPELL) : NULL;\n    if (!spell || spell-\u003em_spellInfo-\u003eId != spellId || !spell-\u003em_targets.HasDst() || !spell-\u003em_targets.HasSrc())\n    {\n        recvPacket.rfinish();\n        return;\n    }\n\n    Position pos = *spell-\u003em_targets.GetSrcPos();\n    pos.Relocate(curX, curY, curZ);\n    spell-\u003em_targets.ModSrc(pos);\n\n    pos = *spell-\u003em_targets.GetDstPos();\n    pos.Relocate(targetX, targetY, targetZ);\n    spell-\u003em_targets.ModDst(pos);\n\n    spell-\u003em_targets.SetElevation(elevation);\n    spell-\u003em_targets.SetSpeed(speed);\n\n    if (moveStop)\n    {\n        uint32 opcode;\n        recvPacket \u003e\u003e opcode;\n        recvPacket.SetOpcode(opcode);\n        HandleMovementOpcodes(recvPacket);\n    }\n}\n"}
{"repo_name":"babymannen/theforgottenserver-7.4","ref":"refs/heads/master","path":"src/items.cpp","copies":"1","language":"C++","content":"/**\n * The Forgotten Server - a free and open-source MMORPG server emulator\n * Copyright (C) 2016  Mark Samman \u003cmark.samman@gmail.com\u003e\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n\n#include \"otpch.h\"\n\n#include \"items.h\"\n#include \"spells.h\"\n#include \"movement.h\"\n#include \"weapons.h\"\n\n#include \"pugicast.h\"\n\nuint32_t Items::dwMajorVersion = 0;\nuint32_t Items::dwMinorVersion = 0;\nuint32_t Items::dwBuildNumber = 0;\n\nextern MoveEvents* g_moveEvents;\nextern Weapons* g_weapons;\n\nItemType::ItemType() :\n\tgroup(ITEM_GROUP_NONE), type(ITEM_TYPE_NONE), id(0), clientId(0),\n\tstackable(false), isAnimation(false), weight(0), levelDoor(0), decayTime(0),\n\twieldInfo(0), minReqLevel(0), minReqMagicLevel(0), charges(0), maxHitChance(-1),\n\tdecayTo(-1), attack(0), defense(0), extraDefense(0), armor(0), rotateTo(0),\n\truneMagLevel(0), runeLevel(0), combatType(COMBAT_NONE), transformToOnUse(0),\n\ttransformToFree(0), destroyTo(0), maxTextLen(0), writeOnceItemId(0),\n\ttransformEquipTo(0), transformDeEquipTo(0), maxItems(8), slotPosition(SLOTP_HAND),\n\tspeed(0), wareId(0), magicEffect(CONST_ME_NONE), bedPartnerDir(DIRECTION_NONE),\n\tweaponType(WEAPON_NONE), ammoType(AMMO_NONE), shootType(CONST_ANI_NONE),\n\tcorpseType(RACE_NONE), fluidSource(FLUID_NONE), floorChange(0),\n\talwaysOnTopOrder(0), lightLevel(0), lightColor(0), shootRange(1), hitChance(0),\n\tforceUse(false), hasHeight(false), walkStack(true), blockSolid(false),\n\tblockPickupable(false), blockProjectile(false), blockPathFind(false),\n\tallowPickupable(false), showDuration(false), showCharges(false),\n\tshowAttributes(false), replaceable(true), pickupable(false), rotatable(false),\n\tuseable(false), moveable(false), alwaysOnTop(false), canReadText(false),\n\tcanWriteText(false), isVertical(false), isHorizontal(false), isHangable(false),\n\tallowDistRead(false), lookThrough(false), stopTime(false), showCount(true)\n{\n}\n\nItems::Items()\n{\n\titems.reserve(20000);\n}\n\nItems::~Items()\n{\n\tclear();\n}\n\nvoid Items::clear()\n{\n\titems.clear();\n}\n\nbool Items::reload()\n{\n\tclear();\n\tloadFromOtb(\"data/items/items.otb\");\n\n\tif (!loadFromXml()) {\n\t\treturn false;\n\t}\n\n\tg_moveEvents-\u003ereload();\n\tg_weapons-\u003ereload();\n\tg_weapons-\u003eloadDefaults();\n\treturn true;\n}\n\nFILELOADER_ERRORS Items::loadFromOtb(const std::string\u0026 file)\n{\n\tFileLoader f;\n\tif (!f.openFile(file.c_str(), \"OTBI\")) {\n\t\treturn f.getError();\n\t}\n\n\tuint32_t type;\n\tNODE node = f.getChildNode(NO_NODE, type);\n\n\tPropStream props;\n\tif (f.getProps(node, props)) {\n\t\t//4 byte flags\n\t\t//attributes\n\t\t//0x01 = version data\n\t\tuint32_t flags;\n\t\tif (!props.read\u003cuint32_t\u003e(flags)) {\n\t\t\treturn ERROR_INVALID_FORMAT;\n\t\t}\n\n\t\tuint8_t attr;\n\t\tif (!props.read\u003cuint8_t\u003e(attr)) {\n\t\t\treturn ERROR_INVALID_FORMAT;\n\t\t}\n\n\t\tif (attr == ROOT_ATTR_VERSION) {\n\t\t\tuint16_t datalen;\n\t\t\tif (!props.read\u003cuint16_t\u003e(datalen)) {\n\t\t\t\treturn ERROR_INVALID_FORMAT;\n\t\t\t}\n\n\t\t\tif (datalen != sizeof(VERSIONINFO)) {\n\t\t\t\treturn ERROR_INVALID_FORMAT;\n\t\t\t}\n\n\t\t\tVERSIONINFO vi;\n\t\t\tif (!props.read(vi)) {\n\t\t\t\treturn ERROR_INVALID_FORMAT;\n\t\t\t}\n\n\t\t\tItems::dwMajorVersion = vi.dwMajorVersion; //items otb format file version\n\t\t\tItems::dwMinorVersion = vi.dwMinorVersion; //client version\n\t\t\tItems::dwBuildNumber = vi.dwBuildNumber; //revision\n\t\t}\n\t}\n\n\tif (Items::dwMajorVersion == 0xFFFFFFFF) {\n\t\tstd::cout \u003c\u003c \"[Warning - Items::loadFromOtb] items.otb using generic client version.\" \u003c\u003c std::endl;\n\t} else if (Items::dwMajorVersion \u003e 2) {\n\t\tstd::cout \u003c\u003c \"New version detected, an older version of items.otb is required.\" \u003c\u003c std::endl;\n\t\treturn ERROR_INVALID_FORMAT;\n\t} else if (Items::dwMinorVersion \u003c CLIENT_VERSION_740) {\n\t\tstd::cout \u003c\u003c \"A newer version of items.otb is required.\" \u003c\u003c std::endl;\n\t\treturn ERROR_INVALID_FORMAT;\n\t}\n\n\tnode = f.getChildNode(node, type);\n\twhile (node != NO_NODE) {\n\t\tPropStream stream;\n\t\tif (!f.getProps(node, stream)) {\n\t\t\treturn f.getError();\n\t\t}\n\n\t\tuint32_t flags;\n\t\tif (!stream.read\u003cuint32_t\u003e(flags)) {\n\t\t\treturn ERROR_INVALID_FORMAT;\n\t\t}\n\n\t\tuint16_t serverId = 0;\n\t\tuint16_t clientId = 0;\n\t\tuint16_t speed = 0;\n\t\tuint16_t wareId = 0;\n\t\tuint8_t lightLevel = 0;\n\t\tuint8_t lightColor = 0;\n\t\tuint8_t alwaysOnTopOrder = 0;\n\n\t\tuint8_t attrib;\n\t\twhile (stream.read\u003cuint8_t\u003e(attrib)) {\n\t\t\tuint16_t datalen;\n\t\t\tif (!stream.read\u003cuint16_t\u003e(datalen)) {\n\t\t\t\treturn ERROR_INVALID_FORMAT;\n\t\t\t}\n\n\t\t\tswitch (attrib) {\n\t\t\t\tcase ITEM_ATTR_SERVERID: {\n\t\t\t\t\tif (datalen != sizeof(uint16_t)) {\n\t\t\t\t\t\treturn ERROR_INVALID_FORMAT;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!stream.read\u003cuint16_t\u003e(serverId)) {\n\t\t\t\t\t\treturn ERROR_INVALID_FORMAT;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (serverId \u003e 20000 \u0026\u0026 serverId \u003c 20100) {\n\t\t\t\t\t\tserverId -= 20000;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tcase ITEM_ATTR_CLIENTID: {\n\t\t\t\t\tif (datalen != sizeof(uint16_t)) {\n\t\t\t\t\t\treturn ERROR_INVALID_FORMAT;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!stream.read\u003cuint16_t\u003e(clientId)) {\n\t\t\t\t\t\treturn ERROR_INVALID_FORMAT;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tcase ITEM_ATTR_SPEED: {\n\t\t\t\t\tif (datalen != sizeof(uint16_t)) {\n\t\t\t\t\t\treturn ERROR_INVALID_FORMAT;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!stream.read\u003cuint16_t\u003e(speed)) {\n\t\t\t\t\t\treturn ERROR_INVALID_FORMAT;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tcase ITEM_ATTR_LIGHT2: {\n\t\t\t\t\tif (datalen != sizeof(lightBlock2)) {\n\t\t\t\t\t\treturn ERROR_INVALID_FORMAT;\n\t\t\t\t\t}\n\n\t\t\t\t\tlightBlock2 lb2;\n\t\t\t\t\tif (!stream.read(lb2)) {\n\t\t\t\t\t\treturn ERROR_INVALID_FORMAT;\n\t\t\t\t\t}\n\n\t\t\t\t\tlightLevel = static_cast\u003cuint8_t\u003e(lb2.lightLevel);\n\t\t\t\t\tlightColor = static_cast\u003cuint8_t\u003e(lb2.lightColor);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tcase ITEM_ATTR_TOPORDER: {\n\t\t\t\t\tif (datalen != sizeof(uint8_t)) {\n\t\t\t\t\t\treturn ERROR_INVALID_FORMAT;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!stream.read\u003cuint8_t\u003e(alwaysOnTopOrder)) {\n\t\t\t\t\t\treturn ERROR_INVALID_FORMAT;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tcase ITEM_ATTR_WAREID: {\n\t\t\t\t\tif (datalen != sizeof(uint16_t)) {\n\t\t\t\t\t\treturn ERROR_INVALID_FORMAT;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!stream.read\u003cuint16_t\u003e(wareId)) {\n\t\t\t\t\t\treturn ERROR_INVALID_FORMAT;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tdefault: {\n\t\t\t\t\t//skip unknown attributes\n\t\t\t\t\tif (!stream.skip(datalen)) {\n\t\t\t\t\t\treturn ERROR_INVALID_FORMAT;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treverseItemMap.emplace(clientId, serverId);\n\n\t\t// store the found item\n\t\tif (serverId \u003e= items.size()) {\n\t\t\titems.resize(serverId + 1);\n\t\t}\n\t\tItemType\u0026 iType = items[serverId];\n\n\t\tiType.group = static_cast\u003citemgroup_t\u003e(type);\n\t\tswitch (type) {\n\t\t\tcase ITEM_GROUP_CONTAINER:\n\t\t\t\tiType.type = ITEM_TYPE_CONTAINER;\n\t\t\t\tbreak;\n\t\t\tcase ITEM_GROUP_DOOR:\n\t\t\t\t//not used\n\t\t\t\tiType.type = ITEM_TYPE_DOOR;\n\t\t\t\tbreak;\n\t\t\tcase ITEM_GROUP_MAGICFIELD:\n\t\t\t\t//not used\n\t\t\t\tiType.type = ITEM_TYPE_MAGICFIELD;\n\t\t\t\tbreak;\n\t\t\tcase ITEM_GROUP_TELEPORT:\n\t\t\t\t//not used\n\t\t\t\tiType.type = ITEM_TYPE_TELEPORT;\n\t\t\t\tbreak;\n\t\t\tcase ITEM_GROUP_NONE:\n\t\t\tcase ITEM_GROUP_GROUND:\n\t\t\tcase ITEM_GROUP_SPLASH:\n\t\t\tcase ITEM_GROUP_FLUID:\n\t\t\tcase ITEM_GROUP_CHARGES:\n\t\t\tcase ITEM_GROUP_DEPRECATED:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn ERROR_INVALID_FORMAT;\n\t\t}\n\n\t\tiType.blockSolid = hasBitSet(FLAG_BLOCK_SOLID, flags);\n\t\tiType.blockProjectile = hasBitSet(FLAG_BLOCK_PROJECTILE, flags);\n\t\tiType.blockPathFind = hasBitSet(FLAG_BLOCK_PATHFIND, flags);\n\t\tiType.hasHeight = hasBitSet(FLAG_HAS_HEIGHT, flags);\n\t\tiType.useable = hasBitSet(FLAG_USEABLE, flags);\n\t\tiType.pickupable = hasBitSet(FLAG_PICKUPABLE, flags);\n\t\tiType.moveable = hasBitSet(FLAG_MOVEABLE, flags);\n\t\tiType.stackable = hasBitSet(FLAG_STACKABLE, flags);\n\n\t\tiType.alwaysOnTop = hasBitSet(FLAG_ALWAYSONTOP, flags);\n\t\tiType.isVertical = hasBitSet(FLAG_VERTICAL, flags);\n\t\tiType.isHorizontal = hasBitSet(FLAG_HORIZONTAL, flags);\n\t\tiType.isHangable = hasBitSet(FLAG_HANGABLE, flags);\n\t\tiType.allowDistRead = hasBitSet(FLAG_ALLOWDISTREAD, flags);\n\t\tiType.rotatable = hasBitSet(FLAG_ROTATABLE, flags);\n\t\tiType.canReadText = hasBitSet(FLAG_READABLE, flags);\n\t\tiType.lookThrough = hasBitSet(FLAG_LOOKTHROUGH, flags);\n\t\t// iType.walkStack = !hasBitSet(FLAG_FULLTILE, flags);\n\t\tiType.forceUse = hasBitSet(FLAG_FORCEUSE, flags);\n\n\t\tiType.id = serverId;\n\t\tiType.clientId = clientId;\n\t\tiType.speed = speed;\n\t\tiType.lightLevel = lightLevel;\n\t\tiType.lightColor = lightColor;\n\t\tiType.wareId = wareId;\n\t\tiType.alwaysOnTopOrder = alwaysOnTopOrder;\n\n\t\tnode = f.getNextNode(node, type);\n\t}\n\n\titems.shrink_to_fit();\n\treturn ERROR_NONE;\n}\n\nbool Items::loadFromXml()\n{\n\tpugi::xml_document doc;\n\tpugi::xml_parse_result result = doc.load_file(\"data/items/items.xml\");\n\tif (!result) {\n\t\tprintXMLError(\"Error - Items::loadFromXml\", \"data/items/items.xml\", result);\n\t\treturn false;\n\t}\n\n\tfor (auto itemNode : doc.child(\"items\").children()) {\n\t\tpugi::xml_attribute idAttribute = itemNode.attribute(\"id\");\n\t\tif (idAttribute) {\n\t\t\tparseItemNode(itemNode, pugi::cast\u003cuint16_t\u003e(idAttribute.value()));\n\t\t\tcontinue;\n\t\t}\n\n\t\tpugi::xml_attribute fromIdAttribute = itemNode.attribute(\"fromid\");\n\t\tif (!fromIdAttribute) {\n\t\t\tstd::cout \u003c\u003c \"[Warning - Items::loadFromXml] No item id found\" \u003c\u003c std::endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tpugi::xml_attribute toIdAttribute = itemNode.attribute(\"toid\");\n\t\tif (!toIdAttribute) {\n\t\t\tstd::cout \u003c\u003c \"[Warning - Items::loadFromXml] fromid (\" \u003c\u003c fromIdAttribute.value() \u003c\u003c \") without toid\" \u003c\u003c std::endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tuint16_t id = pugi::cast\u003cuint16_t\u003e(fromIdAttribute.value());\n\t\tuint16_t toId = pugi::cast\u003cuint16_t\u003e(toIdAttribute.value());\n\t\twhile (id \u003c= toId) {\n\t\t\tparseItemNode(itemNode, id++);\n\t\t}\n\t}\n\treturn true;\n}\n\nvoid Items::parseItemNode(const pugi::xml_node\u0026 itemNode, uint16_t id)\n{\n\tif (id \u003e 20000 \u0026\u0026 id \u003c 20100) {\n\t\tid -= 20000;\n\n\t\tif (id \u003e= items.size()) {\n\t\t\titems.resize(id + 1);\n\t\t}\n\t\tItemType\u0026 iType = items[id];\n\t\tiType.id = id;\n\t}\n\n\tItemType\u0026 it = getItemType(id);\n\tif (it.id == 0) {\n\t\treturn;\n\t}\n\n\tit.name = itemNode.attribute(\"name\").as_string();\n\n\tpugi::xml_attribute articleAttribute = itemNode.attribute(\"article\");\n\tif (articleAttribute) {\n\t\tit.article = articleAttribute.as_string();\n\t}\n\n\tpugi::xml_attribute pluralAttribute = itemNode.attribute(\"plural\");\n\tif (pluralAttribute) {\n\t\tit.pluralName = pluralAttribute.as_string();\n\t}\n\n\tfor (auto attributeNode : itemNode.children()) {\n\t\tpugi::xml_attribute keyAttribute = attributeNode.attribute(\"key\");\n\t\tif (!keyAttribute) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tpugi::xml_attribute valueAttribute = attributeNode.attribute(\"value\");\n\t\tif (!valueAttribute) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tstd::string tmpStrValue = asLowerCaseString(keyAttribute.as_string());\n\t\tif (tmpStrValue == \"type\") {\n\t\t\ttmpStrValue = asLowerCaseString(valueAttribute.as_string());\n\t\t\tif (tmpStrValue == \"key\") {\n\t\t\t\tit.type = ITEM_TYPE_KEY;\n\t\t\t} else if (tmpStrValue == \"magicfield\") {\n\t\t\t\tit.type = ITEM_TYPE_MAGICFIELD;\n\t\t\t} else if (tmpStrValue == \"container\") {\n\t\t\t\tit.group = ITEM_GROUP_CONTAINER;\n\t\t\t\tit.type = ITEM_TYPE_CONTAINER;\n\t\t\t} else if (tmpStrValue == \"depot\") {\n\t\t\t\tit.type = ITEM_TYPE_DEPOT;\n\t\t\t} else if (tmpStrValue == \"mailbox\") {\n\t\t\t\tit.type = ITEM_TYPE_MAILBOX;\n\t\t\t} else if (tmpStrValue == \"trashholder\") {\n\t\t\t\tit.type = ITEM_TYPE_TRASHHOLDER;\n\t\t\t} else if (tmpStrValue == \"teleport\") {\n\t\t\t\tit.type = ITEM_TYPE_TELEPORT;\n\t\t\t} else if (tmpStrValue == \"door\") {\n\t\t\t\tit.type = ITEM_TYPE_DOOR;\n\t\t\t} else if (tmpStrValue == \"bed\") {\n\t\t\t\tit.type = ITEM_TYPE_BED;\n\t\t\t} else if (tmpStrValue == \"rune\") {\n\t\t\t\tit.type = ITEM_TYPE_RUNE;\n\t\t\t} else {\n\t\t\t\tstd::cout \u003c\u003c \"[Warning - Items::parseItemNode] Unknown type: \" \u003c\u003c valueAttribute.as_string() \u003c\u003c std::endl;\n\t\t\t}\n\t\t} else if (tmpStrValue == \"description\") {\n\t\t\tit.description = valueAttribute.as_string();\n\t\t} else if (tmpStrValue == \"runespellname\") {\n\t\t\tit.runeSpellName = valueAttribute.as_string();\n\t\t} else if (tmpStrValue == \"weight\") {\n\t\t\tit.weight = pugi::cast\u003cuint32_t\u003e(valueAttribute.value());\n\t\t} else if (tmpStrValue == \"showcount\") {\n\t\t\tit.showCount = valueAttribute.as_bool();\n\t\t} else if (tmpStrValue == \"armor\") {\n\t\t\tit.armor = pugi::cast\u003cint32_t\u003e(valueAttribute.value());\n\t\t} else if (tmpStrValue == \"defense\") {\n\t\t\tit.defense = pugi::cast\u003cint32_t\u003e(valueAttribute.value());\n\t\t} else if (tmpStrValue == \"extradef\") {\n\t\t\tit.extraDefense = pugi::cast\u003cint32_t\u003e(valueAttribute.value());\n\t\t} else if (tmpStrValue == \"attack\") {\n\t\t\tit.attack = pugi::cast\u003cint32_t\u003e(valueAttribute.value());\n\t\t} else if (tmpStrValue == \"rotateto\") {\n\t\t\tit.rotateTo = pugi::cast\u003cint32_t\u003e(valueAttribute.value());\n\t\t} else if (tmpStrValue == \"moveable\" || tmpStrValue == \"movable\") {\n\t\t\tit.moveable = valueAttribute.as_bool();\n\t\t} else if (tmpStrValue == \"blockprojectile\") {\n\t\t\tit.blockProjectile = valueAttribute.as_bool();\n\t\t} else if (tmpStrValue == \"allowpickupable\" || tmpStrValue == \"pickupable\") {\n\t\t\tit.allowPickupable = valueAttribute.as_bool();\n\t\t} else if (tmpStrValue == \"floorchange\") {\n\t\t\ttmpStrValue = asLowerCaseString(valueAttribute.as_string());\n\t\t\tif (tmpStrValue == \"down\") {\n\t\t\t\tit.floorChange = TILESTATE_FLOORCHANGE_DOWN;\n\t\t\t} else if (tmpStrValue == \"north\") {\n\t\t\t\tit.floorChange = TILESTATE_FLOORCHANGE_NORTH;\n\t\t\t} else if (tmpStrValue == \"south\") {\n\t\t\t\tit.floorChange = TILESTATE_FLOORCHANGE_SOUTH;\n\t\t\t} else if (tmpStrValue == \"southalt\") {\n\t\t\t\tit.floorChange = TILESTATE_FLOORCHANGE_SOUTH_ALT;\n\t\t\t} else if (tmpStrValue == \"west\") {\n\t\t\t\tit.floorChange = TILESTATE_FLOORCHANGE_WEST;\n\t\t\t} else if (tmpStrValue == \"east\") {\n\t\t\t\tit.floorChange = TILESTATE_FLOORCHANGE_EAST;\n\t\t\t} else if (tmpStrValue == \"eastalt\") {\n\t\t\t\tit.floorChange = TILESTATE_FLOORCHANGE_EAST_ALT;\n\t\t\t} else {\n\t\t\t\tstd::cout \u003c\u003c \"[Warning - Items::parseItemNode] Unknown floorChange: \" \u003c\u003c valueAttribute.as_string() \u003c\u003c std::endl;\n\t\t\t}\n\t\t} else if (tmpStrValue == \"corpsetype\") {\n\t\t\ttmpStrValue = asLowerCaseString(valueAttribute.as_string());\n\t\t\tif (tmpStrValue == \"venom\") {\n\t\t\t\tit.corpseType = RACE_VENOM;\n\t\t\t} else if (tmpStrValue == \"blood\") {\n\t\t\t\tit.corpseType = RACE_BLOOD;\n\t\t\t} else if (tmpStrValue == \"undead\") {\n\t\t\t\tit.corpseType = RACE_UNDEAD;\n\t\t\t} else if (tmpStrValue == \"fire\") {\n\t\t\t\tit.corpseType = RACE_FIRE;\n\t\t\t} else if (tmpStrValue == \"energy\") {\n\t\t\t\tit.corpseType = RACE_ENERGY;\n\t\t\t} else {\n\t\t\t\tstd::cout \u003c\u003c \"[Warning - Items::parseItemNode] Unknown corpseType: \" \u003c\u003c valueAttribute.as_string() \u003c\u003c std::endl;\n\t\t\t}\n\t\t} else if (tmpStrValue == \"containersize\") {\n\t\t\tit.maxItems = pugi::cast\u003cuint16_t\u003e(valueAttribute.value());\n\t\t} else if (tmpStrValue == \"fluidsource\") {\n\t\t\ttmpStrValue = asLowerCaseString(valueAttribute.as_string());\n\t\t\tif (tmpStrValue == \"water\") {\n\t\t\t\tit.fluidSource = FLUID_WATER;\n\t\t\t} else if (tmpStrValue == \"blood\") {\n\t\t\t\tit.fluidSource = FLUID_BLOOD;\n\t\t\t} else if (tmpStrValue == \"beer\") {\n\t\t\t\tit.fluidSource = FLUID_BEER;\n\t\t\t} else if (tmpStrValue == \"slime\") {\n\t\t\t\tit.fluidSource = FLUID_SLIME;\n\t\t\t} else if (tmpStrValue == \"lemonade\") {\n\t\t\t\tit.fluidSource = FLUID_LEMONADE;\n\t\t\t} else if (tmpStrValue == \"milk\") {\n\t\t\t\tit.fluidSource = FLUID_MILK;\n\t\t\t} else if (tmpStrValue == \"mana\") {\n\t\t\t\tit.fluidSource = FLUID_MANA;\n\t\t\t} else if (tmpStrValue == \"life\") {\n\t\t\t\tit.fluidSource = FLUID_LIFE;\n\t\t\t} else if (tmpStrValue == \"oil\") {\n\t\t\t\tit.fluidSource = FLUID_OIL;\n\t\t\t} else if (tmpStrValue == \"urine\") {\n\t\t\t\tit.fluidSource = FLUID_URINE;\n\t\t\t} else if (tmpStrValue == \"coconut\") {\n\t\t\t\tit.fluidSource = FLUID_COCONUTMILK;\n\t\t\t} else if (tmpStrValue == \"wine\") {\n\t\t\t\tit.fluidSource = FLUID_WINE;\n\t\t\t} else if (tmpStrValue == \"mud\") {\n\t\t\t\tit.fluidSource = FLUID_MUD;\n\t\t\t} else if (tmpStrValue == \"fruitjuice\") {\n\t\t\t\tit.fluidSource = FLUID_FRUITJUICE;\n\t\t\t} else if (tmpStrValue == \"lava\") {\n\t\t\t\tit.fluidSource = FLUID_LAVA;\n\t\t\t} else if (tmpStrValue == \"rum\") {\n\t\t\t\tit.fluidSource = FLUID_RUM;\n\t\t\t} else if (tmpStrValue == \"swamp\") {\n\t\t\t\tit.fluidSource = FLUID_SWAMP;\n\t\t\t} else if (tmpStrValue == \"tea\") {\n\t\t\t\tit.fluidSource = FLUID_TEA;\n\t\t\t} else if (tmpStrValue == \"mead\") {\n\t\t\t\tit.fluidSource = FLUID_MEAD;\n\t\t\t} else {\n\t\t\t\tstd::cout \u003c\u003c \"[Warning - Items::parseItemNode] Unknown fluidSource: \" \u003c\u003c valueAttribute.as_string() \u003c\u003c std::endl;\n\t\t\t}\n\t\t} else if (tmpStrValue == \"readable\") {\n\t\t\tit.canReadText = valueAttribute.as_bool();\n\t\t} else if (tmpStrValue == \"writeable\") {\n\t\t\tit.canWriteText = valueAttribute.as_bool();\n\t\t\tit.canReadText = it.canWriteText;\n\t\t} else if (tmpStrValue == \"maxtextlen\") {\n\t\t\tit.maxTextLen = pugi::cast\u003cuint16_t\u003e(valueAttribute.value());\n\t\t} else if (tmpStrValue == \"writeonceitemid\") {\n\t\t\tit.writeOnceItemId = pugi::cast\u003cuint16_t\u003e(valueAttribute.value());\n\t\t} else if (tmpStrValue == \"weapontype\") {\n\t\t\ttmpStrValue = asLowerCaseString(valueAttribute.as_string());\n\t\t\tif (tmpStrValue == \"sword\") {\n\t\t\t\tit.weaponType = WEAPON_SWORD;\n\t\t\t} else if (tmpStrValue == \"club\") {\n\t\t\t\tit.weaponType = WEAPON_CLUB;\n\t\t\t} else if (tmpStrValue == \"axe\") {\n\t\t\t\tit.weaponType = WEAPON_AXE;\n\t\t\t} else if (tmpStrValue == \"shield\") {\n\t\t\t\tit.weaponType = WEAPON_SHIELD;\n\t\t\t} else if (tmpStrValue == \"distance\") {\n\t\t\t\tit.weaponType = WEAPON_DISTANCE;\n\t\t\t} else if (tmpStrValue == \"wand\") {\n\t\t\t\tit.weaponType = WEAPON_WAND;\n\t\t\t} else if (tmpStrValue == \"ammunition\") {\n\t\t\t\tit.weaponType = WEAPON_AMMO;\n\t\t\t} else {\n\t\t\t\tstd::cout \u003c\u003c \"[Warning - Items::parseItemNode] Unknown weaponType: \" \u003c\u003c valueAttribute.as_string() \u003c\u003c std::endl;\n\t\t\t}\n\t\t} else if (tmpStrValue == \"slottype\") {\n\t\t\ttmpStrValue = asLowerCaseString(valueAttribute.as_string());\n\t\t\tif (tmpStrValue == \"head\") {\n\t\t\t\tit.slotPosition |= SLOTP_HEAD;\n\t\t\t} else if (tmpStrValue == \"body\") {\n\t\t\t\tit.slotPosition |= SLOTP_ARMOR;\n\t\t\t} else if (tmpStrValue == \"legs\") {\n\t\t\t\tit.slotPosition |= SLOTP_LEGS;\n\t\t\t} else if (tmpStrValue == \"feet\") {\n\t\t\t\tit.slotPosition |= SLOTP_FEET;\n\t\t\t} else if (tmpStrValue == \"backpack\") {\n\t\t\t\tit.slotPosition |= SLOTP_BACKPACK;\n\t\t\t} else if (tmpStrValue == \"two-handed\") {\n\t\t\t\tit.slotPosition |= SLOTP_TWO_HAND;\n\t\t\t} else if (tmpStrValue == \"right-hand\") {\n\t\t\t\tit.slotPosition \u0026= ~SLOTP_LEFT;\n\t\t\t} else if (tmpStrValue == \"left-hand\") {\n\t\t\t\tit.slotPosition \u0026= ~SLOTP_RIGHT;\n\t\t\t} else if (tmpStrValue == \"necklace\") {\n\t\t\t\tit.slotPosition |= SLOTP_NECKLACE;\n\t\t\t} else if (tmpStrValue == \"ring\") {\n\t\t\t\tit.slotPosition |= SLOTP_RING;\n\t\t\t} else if (tmpStrValue == \"ammo\") {\n\t\t\t\tit.slotPosition |= SLOTP_AMMO;\n\t\t\t} else if (tmpStrValue == \"hand\") {\n\t\t\t\tit.slotPosition |= SLOTP_HAND;\n\t\t\t} else {\n\t\t\t\tstd::cout \u003c\u003c \"[Warning - Items::parseItemNode] Unknown slotType: \" \u003c\u003c valueAttribute.as_string() \u003c\u003c std::endl;\n\t\t\t}\n\t\t} else if (tmpStrValue == \"ammotype\") {\n\t\t\tit.ammoType = getAmmoType(valueAttribute.as_string());\n\t\t\tif (it.ammoType == AMMO_NONE) {\n\t\t\t\tstd::cout \u003c\u003c \"[Warning - Items::parseItemNode] Unknown ammoType: \" \u003c\u003c valueAttribute.as_string() \u003c\u003c std::endl;\n\t\t\t}\n\t\t} else if (tmpStrValue == \"shoottype\") {\n\t\t\tShootType_t shoot = getShootType(valueAttribute.as_string());\n\t\t\tif (shoot != CONST_ANI_NONE) {\n\t\t\t\tit.shootType = shoot;\n\t\t\t} else {\n\t\t\t\tstd::cout \u003c\u003c \"[Warning - Items::parseItemNode] Unknown shootType: \" \u003c\u003c valueAttribute.as_string() \u003c\u003c std::endl;\n\t\t\t}\n\t\t} else if (tmpStrValue == \"effect\") {\n\t\t\tMagicEffectClasses effect = getMagicEffect(valueAttribute.as_string());\n\t\t\tif (effect != CONST_ME_NONE) {\n\t\t\t\tit.magicEffect = effect;\n\t\t\t} else {\n\t\t\t\tstd::cout \u003c\u003c \"[Warning - Items::parseItemNode] Unknown effect: \" \u003c\u003c valueAttribute.as_string() \u003c\u003c std::endl;\n\t\t\t}\n\t\t} else if (tmpStrValue == \"range\") {\n\t\t\tit.shootRange = pugi::cast\u003cuint16_t\u003e(valueAttribute.value());\n\t\t} else if (tmpStrValue == \"stopduration\") {\n\t\t\tit.stopTime = valueAttribute.as_bool();\n\t\t} else if (tmpStrValue == \"decayto\") {\n\t\t\tit.decayTo = pugi::cast\u003cint32_t\u003e(valueAttribute.value());\n\t\t} else if (tmpStrValue == \"transformequipto\") {\n\t\t\tit.transformEquipTo = pugi::cast\u003cuint16_t\u003e(valueAttribute.value());\n\t\t} else if (tmpStrValue == \"transformdeequipto\") {\n\t\t\tit.transformDeEquipTo = pugi::cast\u003cuint16_t\u003e(valueAttribute.value());\n\t\t} else if (tmpStrValue == \"duration\") {\n\t\t\tit.decayTime = pugi::cast\u003cuint32_t\u003e(valueAttribute.value());\n\t\t} else if (tmpStrValue == \"showduration\") {\n\t\t\tit.showDuration = valueAttribute.as_bool();\n\t\t} else if (tmpStrValue == \"charges\") {\n\t\t\tit.charges = pugi::cast\u003cuint32_t\u003e(valueAttribute.value());\n\t\t} else if (tmpStrValue == \"showcharges\") {\n\t\t\tit.showCharges = valueAttribute.as_bool();\n\t\t} else if (tmpStrValue == \"showattributes\") {\n\t\t\tit.showAttributes = valueAttribute.as_bool();\n\t\t} else if (tmpStrValue == \"hitchance\") {\n\t\t\tit.hitChance = std::min\u003cint8_t\u003e(100, std::max\u003cint8_t\u003e(-100, pugi::cast\u003cint16_t\u003e(valueAttribute.value())));\n\t\t} else if (tmpStrValue == \"maxhitchance\") {\n\t\t\tit.maxHitChance = std::min\u003cuint32_t\u003e(100, pugi::cast\u003cuint32_t\u003e(valueAttribute.value()));\n\t\t} else if (tmpStrValue == \"invisible\") {\n\t\t\tit.getAbilities().invisible = valueAttribute.as_bool();\n\t\t} else if (tmpStrValue == \"speed\") {\n\t\t\tit.getAbilities().speed = pugi::cast\u003cint32_t\u003e(valueAttribute.value());\n\t\t} else if (tmpStrValue == \"healthgain\") {\n\t\t\tAbilities\u0026 abilities = it.getAbilities();\n\t\t\tabilities.regeneration = true;\n\t\t\tabilities.healthGain = pugi::cast\u003cuint32_t\u003e(valueAttribute.value());\n\t\t} else if (tmpStrValue == \"healthticks\") {\n\t\t\tAbilities\u0026 abilities = it.getAbilities();\n\t\t\tabilities.regeneration = true;\n\t\t\tabilities.healthTicks = pugi::cast\u003cuint32_t\u003e(valueAttribute.value());\n\t\t} else if (tmpStrValue == \"managain\") {\n\t\t\tAbilities\u0026 abilities = it.getAbilities();\n\t\t\tabilities.regeneration = true;\n\t\t\tabilities.manaGain = pugi::cast\u003cuint32_t\u003e(valueAttribute.value());\n\t\t} else if (tmpStrValue == \"manaticks\") {\n\t\t\tAbilities\u0026 abilities = it.getAbilities();\n\t\t\tabilities.regeneration = true;\n\t\t\tabilities.manaTicks = pugi::cast\u003cuint32_t\u003e(valueAttribute.value());\n\t\t} else if (tmpStrValue == \"manashield\") {\n\t\t\tit.getAbilities().manaShield = valueAttribute.as_bool();\n\t\t} else if (tmpStrValue == \"skillsword\") {\n\t\t\tit.getAbilities().skills[SKILL_SWORD] = pugi::cast\u003cint32_t\u003e(valueAttribute.value());\n\t\t} else if (tmpStrValue == \"skillaxe\") {\n\t\t\tit.getAbilities().skills[SKILL_AXE] = pugi::cast\u003cint32_t\u003e(valueAttribute.value());\n\t\t} else if (tmpStrValue == \"skillclub\") {\n\t\t\tit.getAbilities().skills[SKILL_CLUB] = pugi::cast\u003cint32_t\u003e(valueAttribute.value());\n\t\t} else if (tmpStrValue == \"skilldist\") {\n\t\t\tit.getAbilities().skills[SKILL_DISTANCE] = pugi::cast\u003cint32_t\u003e(valueAttribute.value());\n\t\t} else if (tmpStrValue == \"skillfish\") {\n\t\t\tit.getAbilities().skills[SKILL_FISHING] = pugi::cast\u003cint32_t\u003e(valueAttribute.value());\n\t\t} else if (tmpStrValue == \"skillshield\") {\n\t\t\tit.getAbilities().skills[SKILL_SHIELD] = pugi::cast\u003cint32_t\u003e(valueAttribute.value());\n\t\t} else if (tmpStrValue == \"skillfist\") {\n\t\t\tit.getAbilities().skills[SKILL_FIST] = pugi::cast\u003cint32_t\u003e(valueAttribute.value());\n\t\t} else if (tmpStrValue == \"maxhitpoints\") {\n\t\t\tit.getAbilities().stats[STAT_MAXHITPOINTS] = pugi::cast\u003cint32_t\u003e(valueAttribute.value());\n\t\t} else if (tmpStrValue == \"maxhitpointspercent\") {\n\t\t\tit.getAbilities().statsPercent[STAT_MAXHITPOINTS] = pugi::cast\u003cint32_t\u003e(valueAttribute.value());\n\t\t} else if (tmpStrValue == \"maxmanapoints\") {\n\t\t\tit.getAbilities().stats[STAT_MAXMANAPOINTS] = pugi::cast\u003cint32_t\u003e(valueAttribute.value());\n\t\t} else if (tmpStrValue == \"maxmanapointspercent\") {\n\t\t\tit.getAbilities().statsPercent[STAT_MAXMANAPOINTS] = pugi::cast\u003cint32_t\u003e(valueAttribute.value());\n\t\t} else if (tmpStrValue == \"magicpoints\" || tmpStrValue == \"magiclevelpoints\") {\n\t\t\tit.getAbilities().stats[STAT_MAGICPOINTS] = pugi::cast\u003cint32_t\u003e(valueAttribute.value());\n\t\t} else if (tmpStrValue == \"magicpointspercent\") {\n\t\t\tit.getAbilities().statsPercent[STAT_MAGICPOINTS] = pugi::cast\u003cint32_t\u003e(valueAttribute.value());\n\t\t} else if (tmpStrValue == \"fieldabsorbpercentenergy\") {\n\t\t\tit.getAbilities().fieldAbsorbPercent[combatTypeToIndex(COMBAT_ENERGYDAMAGE)] += pugi::cast\u003cint16_t\u003e(valueAttribute.value());\n\t\t} else if (tmpStrValue == \"fieldabsorbpercentfire\") {\n\t\t\tit.getAbilities().fieldAbsorbPercent[combatTypeToIndex(COMBAT_FIREDAMAGE)] += pugi::cast\u003cint16_t\u003e(valueAttribute.value());\n\t\t} else if (tmpStrValue == \"fieldabsorbpercentpoison\" || tmpStrValue == \"fieldabsorpercentearth\") {\n\t\t\tit.getAbilities().fieldAbsorbPercent[combatTypeToIndex(COMBAT_EARTHDAMAGE)] += pugi::cast\u003cint16_t\u003e(valueAttribute.value());\n\t\t} else if (tmpStrValue == \"absorbpercentall\" || tmpStrValue == \"absorbpercentallelements\") {\n\t\t\tint16_t value = pugi::cast\u003cint16_t\u003e(valueAttribute.value());\n\t\t\tAbilities\u0026 abilities = it.getAbilities();\n\t\t\tfor (size_t i = 0; i \u003c COMBAT_COUNT; ++i) {\n\t\t\t\tabilities.absorbPercent[i] += value;\n\t\t\t}\n\t\t} else if (tmpStrValue == \"absorbpercentelements\") {\n\t\t\tint16_t value = pugi::cast\u003cint16_t\u003e(valueAttribute.value());\n\t\t\tAbilities\u0026 abilities = it.getAbilities();\n\t\t\tabilities.absorbPercent[combatTypeToIndex(COMBAT_ENERGYDAMAGE)] += value;\n\t\t\tabilities.absorbPercent[combatTypeToIndex(COMBAT_FIREDAMAGE)] += value;\n\t\t\tabilities.absorbPercent[combatTypeToIndex(COMBAT_EARTHDAMAGE)] += value;\n\t\t} else if (tmpStrValue == \"absorbpercentmagic\") {\n\t\t\tint16_t value = pugi::cast\u003cint16_t\u003e(valueAttribute.value());\n\t\t\tAbilities\u0026 abilities = it.getAbilities();\n\t\t\tabilities.absorbPercent[combatTypeToIndex(COMBAT_ENERGYDAMAGE)] += value;\n\t\t\tabilities.absorbPercent[combatTypeToIndex(COMBAT_FIREDAMAGE)] += value;\n\t\t\tabilities.absorbPercent[combatTypeToIndex(COMBAT_EARTHDAMAGE)] += value;\n\t\t} else if (tmpStrValue == \"absorbpercentenergy\") {\n\t\t\tit.getAbilities().absorbPercent[combatTypeToIndex(COMBAT_ENERGYDAMAGE)] += pugi::cast\u003cint16_t\u003e(valueAttribute.value());\n\t\t} else if (tmpStrValue == \"absorbpercentfire\") {\n\t\t\tit.getAbilities().absorbPercent[combatTypeToIndex(COMBAT_FIREDAMAGE)] += pugi::cast\u003cint16_t\u003e(valueAttribute.value());\n\t\t} else if (tmpStrValue == \"absorbpercentpoison\" ||\ttmpStrValue == \"absorbpercentearth\") {\n\t\t\tit.getAbilities().absorbPercent[combatTypeToIndex(COMBAT_EARTHDAMAGE)] += pugi::cast\u003cint16_t\u003e(valueAttribute.value());\n\t\t} else if (tmpStrValue == \"absorbpercentlifedrain\") {\n\t\t\tit.getAbilities().absorbPercent[combatTypeToIndex(COMBAT_LIFEDRAIN)] += pugi::cast\u003cint16_t\u003e(valueAttribute.value());\n\t\t} else if (tmpStrValue == \"absorbpercentmanadrain\") {\n\t\t\tit.getAbilities().absorbPercent[combatTypeToIndex(COMBAT_MANADRAIN)] += pugi::cast\u003cint16_t\u003e(valueAttribute.value());\n\t\t} else if (tmpStrValue == \"absorbpercentphysical\") {\n\t\t\tit.getAbilities().absorbPercent[combatTypeToIndex(COMBAT_PHYSICALDAMAGE)] += pugi::cast\u003cint16_t\u003e(valueAttribute.value());\n\t\t} else if (tmpStrValue == \"absorbpercenthealing\") {\n\t\t\tit.getAbilities().absorbPercent[combatTypeToIndex(COMBAT_HEALING)] += pugi::cast\u003cint16_t\u003e(valueAttribute.value());\n\t\t} else if (tmpStrValue == \"absorbpercentundefined\") {\n\t\t\tit.getAbilities().absorbPercent[combatTypeToIndex(COMBAT_UNDEFINEDDAMAGE)] += pugi::cast\u003cint16_t\u003e(valueAttribute.value());\n\t\t} else if (tmpStrValue == \"suppressdrunk\") {\n\t\t\tif (valueAttribute.as_bool()) {\n\t\t\t\tit.getAbilities().conditionSuppressions |= CONDITION_DRUNK;\n\t\t\t}\n\t\t} else if (tmpStrValue == \"suppressenergy\") {\n\t\t\tif (valueAttribute.as_bool()) {\n\t\t\t\tit.getAbilities().conditionSuppressions |= CONDITION_ENERGY;\n\t\t\t}\n\t\t} else if (tmpStrValue == \"suppressfire\") {\n\t\t\tif (valueAttribute.as_bool()) {\n\t\t\t\tit.getAbilities().conditionSuppressions |= CONDITION_FIRE;\n\t\t\t}\n\t\t} else if (tmpStrValue == \"suppresspoison\") {\n\t\t\tif (valueAttribute.as_bool()) {\n\t\t\t\tit.getAbilities().conditionSuppressions |= CONDITION_POISON;\n\t\t\t}\n\t\t} else if (tmpStrValue == \"suppressphysical\") {\n\t\t\tif (valueAttribute.as_bool()) {\n\t\t\t\tit.getAbilities().conditionSuppressions |= CONDITION_BLEEDING;\n\t\t\t}\n\t\t} else if (tmpStrValue == \"field\") {\n\t\t\tit.group = ITEM_GROUP_MAGICFIELD;\n\t\t\tit.type = ITEM_TYPE_MAGICFIELD;\n\n\t\t\tCombatType_t combatType = COMBAT_NONE;\n\t\t\tConditionDamage* conditionDamage = nullptr;\n\n\t\t\ttmpStrValue = asLowerCaseString(valueAttribute.as_string());\n\t\t\tif (tmpStrValue == \"fire\") {\n\t\t\t\tconditionDamage = new ConditionDamage(CONDITIONID_COMBAT, CONDITION_FIRE);\n\t\t\t\tcombatType = COMBAT_FIREDAMAGE;\n\t\t\t} else if (tmpStrValue == \"energy\") {\n\t\t\t\tconditionDamage = new ConditionDamage(CONDITIONID_COMBAT, CONDITION_ENERGY);\n\t\t\t\tcombatType = COMBAT_ENERGYDAMAGE;\n\t\t\t} else if (tmpStrValue == \"poison\") {\n\t\t\t\tconditionDamage = new ConditionDamage(CONDITIONID_COMBAT, CONDITION_POISON);\n\t\t\t\tcombatType = COMBAT_EARTHDAMAGE;\n\t\t\t} else if (tmpStrValue == \"physical\") {\n\t\t\t\tconditionDamage = new ConditionDamage(CONDITIONID_COMBAT, CONDITION_BLEEDING);\n\t\t\t\tcombatType = COMBAT_PHYSICALDAMAGE;\n\t\t\t} else {\n\t\t\t\tstd::cout \u003c\u003c \"[Warning - Items::parseItemNode] Unknown field value: \" \u003c\u003c valueAttribute.as_string() \u003c\u003c std::endl;\n\t\t\t}\n\n\t\t\tif (combatType != COMBAT_NONE) {\n\t\t\t\tit.combatType = combatType;\n\t\t\t\tit.conditionDamage.reset(conditionDamage);\n\t\t\t\tuint32_t ticks = 0;\n\t\t\t\tint32_t damage = 0;\n\t\t\t\tint32_t start = 0;\n\t\t\t\tint32_t count = 1;\n\n\t\t\t\tfor (auto subAttributeNode : attributeNode.children()) {\n\t\t\t\t\tpugi::xml_attribute subKeyAttribute = subAttributeNode.attribute(\"key\");\n\t\t\t\t\tif (!subKeyAttribute) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tpugi::xml_attribute subValueAttribute = subAttributeNode.attribute(\"value\");\n\t\t\t\t\tif (!subValueAttribute) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\ttmpStrValue = asLowerCaseString(subKeyAttribute.as_string());\n\t\t\t\t\tif (tmpStrValue == \"ticks\") {\n\t\t\t\t\t\tticks = pugi::cast\u003cuint32_t\u003e(subValueAttribute.value());\n\t\t\t\t\t} else if (tmpStrValue == \"count\") {\n\t\t\t\t\t\tcount = std::max\u003cint32_t\u003e(1, pugi::cast\u003cint32_t\u003e(subValueAttribute.value()));\n\t\t\t\t\t} else if (tmpStrValue == \"start\") {\n\t\t\t\t\t\tstart = std::max\u003cint32_t\u003e(0, pugi::cast\u003cint32_t\u003e(subValueAttribute.value()));\n\t\t\t\t\t} else if (tmpStrValue == \"damage\") {\n\t\t\t\t\t\tdamage = -pugi::cast\u003cint32_t\u003e(subValueAttribute.value());\n\n\t\t\t\t\t\tif (start \u003e 0) {\n\t\t\t\t\t\t\tstd::list\u003cint32_t\u003e damageList;\n\t\t\t\t\t\t\tConditionDamage::generateDamageList(damage, start, damageList);\n\t\t\t\t\t\t\tfor (int32_t damageValue : damageList) {\n\t\t\t\t\t\t\t\tconditionDamage-\u003eaddDamage(1, ticks, -damageValue);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tstart = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconditionDamage-\u003eaddDamage(count, ticks, damage);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconditionDamage-\u003esetParam(CONDITION_PARAM_FIELD, 1);\n\n\t\t\t\tif (conditionDamage-\u003egetTotalDamage() \u003e 0) {\n\t\t\t\t\tconditionDamage-\u003esetParam(CONDITION_PARAM_FORCEUPDATE, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (tmpStrValue == \"replaceable\") {\n\t\t\tit.replaceable = valueAttribute.as_bool();\n\t\t} else if (tmpStrValue == \"partnerdirection\") {\n\t\t\tit.bedPartnerDir = getDirection(valueAttribute.as_string());\n\t\t} else if (tmpStrValue == \"leveldoor\") {\n\t\t\tit.levelDoor = pugi::cast\u003cuint32_t\u003e(valueAttribute.value());\n\t\t} else if (tmpStrValue == \"sleeper\") {\n\t\t\tuint16_t value = pugi::cast\u003cuint16_t\u003e(valueAttribute.value());\n\t\t\tit.transformToOnUse = value;\n\t\t\tItemType\u0026 other = getItemType(value);\n\t\t\tif (other.transformToFree == 0) {\n\t\t\t\tother.transformToFree = it.id;\n\t\t\t}\n\n\t\t\tif (it.transformToOnUse == 0) {\n\t\t\t\tit.transformToOnUse = value;\n\t\t\t}\n\t\t} else if (tmpStrValue == \"transformto\") {\n\t\t\tit.transformToFree = pugi::cast\u003cuint16_t\u003e(valueAttribute.value());\n\t\t} else if (tmpStrValue == \"destroyto\") {\n\t\t\tit.destroyTo = pugi::cast\u003cuint16_t\u003e(valueAttribute.value());\n\t\t} else if (tmpStrValue == \"elementearth\") {\n\t\t\tAbilities\u0026 abilities = it.getAbilities();\n\t\t\tabilities.elementDamage = pugi::cast\u003cuint16_t\u003e(valueAttribute.value());\n\t\t\tabilities.elementType = COMBAT_EARTHDAMAGE;\n\t\t} else if (tmpStrValue == \"elementfire\") {\n\t\t\tAbilities\u0026 abilities = it.getAbilities();\n\t\t\tabilities.elementDamage = pugi::cast\u003cuint16_t\u003e(valueAttribute.value());\n\t\t\tabilities.elementType = COMBAT_FIREDAMAGE;\n\t\t} else if (tmpStrValue == \"elementenergy\") {\n\t\t\tAbilities\u0026 abilities = it.getAbilities();\n\t\t\tabilities.elementDamage = pugi::cast\u003cuint16_t\u003e(valueAttribute.value());\n\t\t\tabilities.elementType = COMBAT_ENERGYDAMAGE;\n\t\t} else if (tmpStrValue == \"walkstack\") {\n\t\t\tit.walkStack = valueAttribute.as_bool();\n\t\t} else if (tmpStrValue == \"blocking\") {\n\t\t\tit.blockSolid = valueAttribute.as_bool();\n\t\t} else if (tmpStrValue == \"allowdistread\") {\n\t\t\tit.allowDistRead = booleanString(valueAttribute.as_string());\n\t\t} else {\n\t\t\tstd::cout \u003c\u003c \"[Warning - Items::parseItemNode] Unknown key value: \" \u003c\u003c keyAttribute.as_string() \u003c\u003c std::endl;\n\t\t}\n\t}\n\n\t//check bed items\n\tif ((it.transformToFree != 0 || it.transformToOnUse != 0 || it.transformToOnUse != 0) \u0026\u0026 it.type != ITEM_TYPE_BED) {\n\t\tstd::cout \u003c\u003c \"[Warning - Items::parseItemNode] Item \" \u003c\u003c it.id \u003c\u003c \" is not set as a bed-type\" \u003c\u003c std::endl;\n\t}\n}\n\nItemType\u0026 Items::getItemType(size_t id)\n{\n\tif (id \u003c items.size()) {\n\t\treturn items[id];\n\t}\n\treturn items.front();\n}\n\nconst ItemType\u0026 Items::getItemType(size_t id) const\n{\n\tif (id \u003c items.size()) {\n\t\treturn items[id];\n\t}\n\treturn items.front();\n}\n\nconst ItemType\u0026 Items::getItemIdByClientId(uint16_t spriteId) const\n{\n\tauto it = reverseItemMap.find(spriteId);\n\tif (it != reverseItemMap.end()) {\n\t\treturn getItemType(it-\u003esecond);\n\t}\n\treturn items.front();\n}\n\nuint16_t Items::getItemIdByName(const std::string\u0026 name)\n{\n\tif (name.empty()) {\n\t\treturn 0;\n\t}\n\n\tconst char* itemName = name.c_str();\n\tfor (size_t i = 100, size = items.size(); i \u003c size; ++i) {\n\t\tif (strcasecmp(itemName, items[i].name.c_str()) == 0) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn 0;\n}\n"}
{"repo_name":"Earlz/dobbscoin-source","ref":"refs/heads/master","path":"src/test/transaction_tests.cpp","copies":"1","language":"C++","content":"// Copyright (c) 2011-2014 The Dobbscoin Core developers\n// Distributed under the MIT/X11 software license, see the accompanying\n// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n\n#include \"data/tx_invalid.json.h\"\n#include \"data/tx_valid.json.h\"\n\n#include \"clientversion.h\"\n#include \"key.h\"\n#include \"keystore.h\"\n#include \"main.h\"\n#include \"script/script.h\"\n#include \"script/script_error.h\"\n#include \"core_io.h\"\n\n#include \u003cmap\u003e\n#include \u003cstring\u003e\n\n#include \u003cboost/algorithm/string/classification.hpp\u003e\n#include \u003cboost/algorithm/string/split.hpp\u003e\n#include \u003cboost/test/unit_test.hpp\u003e\n#include \u003cboost/assign/list_of.hpp\u003e\n#include \"json/json_spirit_writer_template.h\"\n\nusing namespace std;\nusing namespace json_spirit;\nusing namespace boost::algorithm;\n\n// In script_tests.cpp\nextern Array read_json(const std::string\u0026 jsondata);\n\nstatic std::map\u003cstring, unsigned int\u003e mapFlagNames = boost::assign::map_list_of\n    (string(\"NONE\"), (unsigned int)SCRIPT_VERIFY_NONE)\n    (string(\"P2SH\"), (unsigned int)SCRIPT_VERIFY_P2SH)\n    (string(\"STRICTENC\"), (unsigned int)SCRIPT_VERIFY_STRICTENC)\n    (string(\"DERSIG\"), (unsigned int)SCRIPT_VERIFY_DERSIG)\n    (string(\"LOW_S\"), (unsigned int)SCRIPT_VERIFY_LOW_S)\n    (string(\"SIGPUSHONLY\"), (unsigned int)SCRIPT_VERIFY_SIGPUSHONLY)\n    (string(\"MINIMALDATA\"), (unsigned int)SCRIPT_VERIFY_MINIMALDATA)\n    (string(\"NULLDUMMY\"), (unsigned int)SCRIPT_VERIFY_NULLDUMMY)\n    (string(\"DISCOURAGE_UPGRADABLE_NOPS\"), (unsigned int)SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS);\n\nunsigned int ParseScriptFlags(string strFlags)\n{\n    if (strFlags.empty()) {\n        return 0;\n    }\n    unsigned int flags = 0;\n    vector\u003cstring\u003e words;\n    split(words, strFlags, is_any_of(\",\"));\n\n    BOOST_FOREACH(string word, words)\n    {\n        if (!mapFlagNames.count(word))\n            BOOST_ERROR(\"Bad test: unknown verification flag '\" \u003c\u003c word \u003c\u003c \"'\");\n        flags |= mapFlagNames[word];\n    }\n\n    return flags;\n}\n\nstring FormatScriptFlags(unsigned int flags)\n{\n    if (flags == 0) {\n        return \"\";\n    }\n    string ret;\n    std::map\u003cstring, unsigned int\u003e::const_iterator it = mapFlagNames.begin();\n    while (it != mapFlagNames.end()) {\n        if (flags \u0026 it-\u003esecond) {\n            ret += it-\u003efirst + \",\";\n        }\n        it++;\n    }\n    return ret.substr(0, ret.size() - 1);\n}\n\nBOOST_AUTO_TEST_SUITE(transaction_tests)\n\nBOOST_AUTO_TEST_CASE(tx_valid)\n{\n    // Read tests from test/data/tx_valid.json\n    // Format is an array of arrays\n    // Inner arrays are either [ \"comment\" ]\n    // or [[[prevout hash, prevout index, prevout scriptPubKey], [input 2], ...],\"], serializedTransaction, verifyFlags\n    // ... where all scripts are stringified scripts.\n    //\n    // verifyFlags is a comma separated list of script verification flags to apply, or \"NONE\"\n    Array tests = read_json(std::string(json_tests::tx_valid, json_tests::tx_valid + sizeof(json_tests::tx_valid)));\n\n    ScriptError err;\n    BOOST_FOREACH(Value\u0026 tv, tests)\n    {\n        Array test = tv.get_array();\n        string strTest = write_string(tv, false);\n        if (test[0].type() == array_type)\n        {\n            if (test.size() != 3 || test[1].type() != str_type || test[2].type() != str_type)\n            {\n                BOOST_ERROR(\"Bad test: \" \u003c\u003c strTest);\n                continue;\n            }\n\n            map\u003cCOutPoint, CScript\u003e mapprevOutScriptPubKeys;\n            Array inputs = test[0].get_array();\n            bool fValid = true;\n            BOOST_FOREACH(Value\u0026 input, inputs)\n            {\n                if (input.type() != array_type)\n                {\n                    fValid = false;\n                    break;\n                }\n                Array vinput = input.get_array();\n                if (vinput.size() != 3)\n                {\n                    fValid = false;\n                    break;\n                }\n\n                mapprevOutScriptPubKeys[COutPoint(uint256(vinput[0].get_str()), vinput[1].get_int())] = ParseScript(vinput[2].get_str());\n            }\n            if (!fValid)\n            {\n                BOOST_ERROR(\"Bad test: \" \u003c\u003c strTest);\n                continue;\n            }\n\n            string transaction = test[1].get_str();\n            CDataStream stream(ParseHex(transaction), SER_NETWORK, PROTOCOL_VERSION);\n            CTransaction tx;\n            stream \u003e\u003e tx;\n\n            CValidationState state;\n            BOOST_CHECK_MESSAGE(CheckTransaction(tx, state), strTest);\n            BOOST_CHECK(state.IsValid());\n\n            for (unsigned int i = 0; i \u003c tx.vin.size(); i++)\n            {\n                if (!mapprevOutScriptPubKeys.count(tx.vin[i].prevout))\n                {\n                    BOOST_ERROR(\"Bad test: \" \u003c\u003c strTest);\n                    break;\n                }\n\n                unsigned int verify_flags = ParseScriptFlags(test[2].get_str());\n                BOOST_CHECK_MESSAGE(VerifyScript(tx.vin[i].scriptSig, mapprevOutScriptPubKeys[tx.vin[i].prevout],\n                                                 verify_flags, TransactionSignatureChecker(\u0026tx, i), \u0026err),\n                                    strTest);\n                BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n            }\n        }\n    }\n}\n\nBOOST_AUTO_TEST_CASE(tx_invalid)\n{\n    // Read tests from test/data/tx_invalid.json\n    // Format is an array of arrays\n    // Inner arrays are either [ \"comment\" ]\n    // or [[[prevout hash, prevout index, prevout scriptPubKey], [input 2], ...],\"], serializedTransaction, verifyFlags\n    // ... where all scripts are stringified scripts.\n    //\n    // verifyFlags is a comma separated list of script verification flags to apply, or \"NONE\"\n    Array tests = read_json(std::string(json_tests::tx_invalid, json_tests::tx_invalid + sizeof(json_tests::tx_invalid)));\n\n    ScriptError err;\n    BOOST_FOREACH(Value\u0026 tv, tests)\n    {\n        Array test = tv.get_array();\n        string strTest = write_string(tv, false);\n        if (test[0].type() == array_type)\n        {\n            if (test.size() != 3 || test[1].type() != str_type || test[2].type() != str_type)\n            {\n                BOOST_ERROR(\"Bad test: \" \u003c\u003c strTest);\n                continue;\n            }\n\n            map\u003cCOutPoint, CScript\u003e mapprevOutScriptPubKeys;\n            Array inputs = test[0].get_array();\n            bool fValid = true;\n            BOOST_FOREACH(Value\u0026 input, inputs)\n            {\n                if (input.type() != array_type)\n                {\n                    fValid = false;\n                    break;\n                }\n                Array vinput = input.get_array();\n                if (vinput.size() != 3)\n                {\n                    fValid = false;\n                    break;\n                }\n\n                mapprevOutScriptPubKeys[COutPoint(uint256(vinput[0].get_str()), vinput[1].get_int())] = ParseScript(vinput[2].get_str());\n            }\n            if (!fValid)\n            {\n                BOOST_ERROR(\"Bad test: \" \u003c\u003c strTest);\n                continue;\n            }\n\n            string transaction = test[1].get_str();\n            CDataStream stream(ParseHex(transaction), SER_NETWORK, PROTOCOL_VERSION);\n            CTransaction tx;\n            stream \u003e\u003e tx;\n\n            CValidationState state;\n            fValid = CheckTransaction(tx, state) \u0026\u0026 state.IsValid();\n\n            for (unsigned int i = 0; i \u003c tx.vin.size() \u0026\u0026 fValid; i++)\n            {\n                if (!mapprevOutScriptPubKeys.count(tx.vin[i].prevout))\n                {\n                    BOOST_ERROR(\"Bad test: \" \u003c\u003c strTest);\n                    break;\n                }\n\n                unsigned int verify_flags = ParseScriptFlags(test[2].get_str());\n                fValid = VerifyScript(tx.vin[i].scriptSig, mapprevOutScriptPubKeys[tx.vin[i].prevout],\n                                      verify_flags, TransactionSignatureChecker(\u0026tx, i), \u0026err);\n            }\n            BOOST_CHECK_MESSAGE(!fValid, strTest);\n            BOOST_CHECK_MESSAGE(err != SCRIPT_ERR_OK, ScriptErrorString(err));\n        }\n    }\n}\n\nBOOST_AUTO_TEST_CASE(basic_transaction_tests)\n{\n    // Random real transaction (e2769b09e784f32f62ef849763d4f45b98e07ba658647343b915ff832b110436)\n    unsigned char ch[] = {0x01, 0x00, 0x00, 0x00, 0x01, 0x6b, 0xff, 0x7f, 0xcd, 0x4f, 0x85, 0x65, 0xef, 0x40, 0x6d, 0xd5, 0xd6, 0x3d, 0x4f, 0xf9, 0x4f, 0x31, 0x8f, 0xe8, 0x20, 0x27, 0xfd, 0x4d, 0xc4, 0x51, 0xb0, 0x44, 0x74, 0x01, 0x9f, 0x74, 0xb4, 0x00, 0x00, 0x00, 0x00, 0x8c, 0x49, 0x30, 0x46, 0x02, 0x21, 0x00, 0xda, 0x0d, 0xc6, 0xae, 0xce, 0xfe, 0x1e, 0x06, 0xef, 0xdf, 0x05, 0x77, 0x37, 0x57, 0xde, 0xb1, 0x68, 0x82, 0x09, 0x30, 0xe3, 0xb0, 0xd0, 0x3f, 0x46, 0xf5, 0xfc, 0xf1, 0x50, 0xbf, 0x99, 0x0c, 0x02, 0x21, 0x00, 0xd2, 0x5b, 0x5c, 0x87, 0x04, 0x00, 0x76, 0xe4, 0xf2, 0x53, 0xf8, 0x26, 0x2e, 0x76, 0x3e, 0x2d, 0xd5, 0x1e, 0x7f, 0xf0, 0xbe, 0x15, 0x77, 0x27, 0xc4, 0xbc, 0x42, 0x80, 0x7f, 0x17, 0xbd, 0x39, 0x01, 0x41, 0x04, 0xe6, 0xc2, 0x6e, 0xf6, 0x7d, 0xc6, 0x10, 0xd2, 0xcd, 0x19, 0x24, 0x84, 0x78, 0x9a, 0x6c, 0xf9, 0xae, 0xa9, 0x93, 0x0b, 0x94, 0x4b, 0x7e, 0x2d, 0xb5, 0x34, 0x2b, 0x9d, 0x9e, 0x5b, 0x9f, 0xf7, 0x9a, 0xff, 0x9a, 0x2e, 0xe1, 0x97, 0x8d, 0xd7, 0xfd, 0x01, 0xdf, 0xc5, 0x22, 0xee, 0x02, 0x28, 0x3d, 0x3b, 0x06, 0xa9, 0xd0, 0x3a, 0xcf, 0x80, 0x96, 0x96, 0x8d, 0x7d, 0xbb, 0x0f, 0x91, 0x78, 0xff, 0xff, 0xff, 0xff, 0x02, 0x8b, 0xa7, 0x94, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0xba, 0xde, 0xec, 0xfd, 0xef, 0x05, 0x07, 0x24, 0x7f, 0xc8, 0xf7, 0x42, 0x41, 0xd7, 0x3b, 0xc0, 0x39, 0x97, 0x2d, 0x7b, 0x88, 0xac, 0x40, 0x94, 0xa8, 0x02, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0xc1, 0x09, 0x32, 0x48, 0x3f, 0xec, 0x93, 0xed, 0x51, 0xf5, 0xfe, 0x95, 0xe7, 0x25, 0x59, 0xf2, 0xcc, 0x70, 0x43, 0xf9, 0x88, 0xac, 0x00, 0x00, 0x00, 0x00, 0x00};\n    vector\u003cunsigned char\u003e vch(ch, ch + sizeof(ch) -1);\n    CDataStream stream(vch, SER_DISK, CLIENT_VERSION);\n    CMutableTransaction tx;\n    stream \u003e\u003e tx;\n    CValidationState state;\n    BOOST_CHECK_MESSAGE(CheckTransaction(tx, state) \u0026\u0026 state.IsValid(), \"Simple deserialized transaction should be valid.\");\n\n    // Check that duplicate txins fail\n    tx.vin.push_back(tx.vin[0]);\n    BOOST_CHECK_MESSAGE(!CheckTransaction(tx, state) || !state.IsValid(), \"Transaction with duplicate txins should be invalid.\");\n}\n\n//\n// Helper: create two dummy transactions, each with\n// two outputs.  The first has 11 and 50 CENT outputs\n// paid to a TX_PUBKEY, the second 21 and 22 CENT outputs\n// paid to a TX_PUBKEYHASH.\n//\nstatic std::vector\u003cCMutableTransaction\u003e\nSetupDummyInputs(CBasicKeyStore\u0026 keystoreRet, CCoinsViewCache\u0026 coinsRet)\n{\n    std::vector\u003cCMutableTransaction\u003e dummyTransactions;\n    dummyTransactions.resize(2);\n\n    // Add some keys to the keystore:\n    CKey key[4];\n    for (int i = 0; i \u003c 4; i++)\n    {\n        key[i].MakeNewKey(i % 2);\n        keystoreRet.AddKey(key[i]);\n    }\n\n    // Create some dummy input transactions\n    dummyTransactions[0].vout.resize(2);\n    dummyTransactions[0].vout[0].nValue = 11*CENT;\n    dummyTransactions[0].vout[0].scriptPubKey \u003c\u003c ToByteVector(key[0].GetPubKey()) \u003c\u003c OP_CHECKSIG;\n    dummyTransactions[0].vout[1].nValue = 50*CENT;\n    dummyTransactions[0].vout[1].scriptPubKey \u003c\u003c ToByteVector(key[1].GetPubKey()) \u003c\u003c OP_CHECKSIG;\n    coinsRet.ModifyCoins(dummyTransactions[0].GetHash())-\u003eFromTx(dummyTransactions[0], 0);\n\n    dummyTransactions[1].vout.resize(2);\n    dummyTransactions[1].vout[0].nValue = 21*CENT;\n    dummyTransactions[1].vout[0].scriptPubKey = GetScriptForDestination(key[2].GetPubKey().GetID());\n    dummyTransactions[1].vout[1].nValue = 22*CENT;\n    dummyTransactions[1].vout[1].scriptPubKey = GetScriptForDestination(key[3].GetPubKey().GetID());\n    coinsRet.ModifyCoins(dummyTransactions[1].GetHash())-\u003eFromTx(dummyTransactions[1], 0);\n\n    return dummyTransactions;\n}\n\nBOOST_AUTO_TEST_CASE(test_Get)\n{\n    CBasicKeyStore keystore;\n    CCoinsView coinsDummy;\n    CCoinsViewCache coins(\u0026coinsDummy);\n    std::vector\u003cCMutableTransaction\u003e dummyTransactions = SetupDummyInputs(keystore, coins);\n\n    CMutableTransaction t1;\n    t1.vin.resize(3);\n    t1.vin[0].prevout.hash = dummyTransactions[0].GetHash();\n    t1.vin[0].prevout.n = 1;\n    t1.vin[0].scriptSig \u003c\u003c std::vector\u003cunsigned char\u003e(65, 0);\n    t1.vin[1].prevout.hash = dummyTransactions[1].GetHash();\n    t1.vin[1].prevout.n = 0;\n    t1.vin[1].scriptSig \u003c\u003c std::vector\u003cunsigned char\u003e(65, 0) \u003c\u003c std::vector\u003cunsigned char\u003e(33, 4);\n    t1.vin[2].prevout.hash = dummyTransactions[1].GetHash();\n    t1.vin[2].prevout.n = 1;\n    t1.vin[2].scriptSig \u003c\u003c std::vector\u003cunsigned char\u003e(65, 0) \u003c\u003c std::vector\u003cunsigned char\u003e(33, 4);\n    t1.vout.resize(2);\n    t1.vout[0].nValue = 90*CENT;\n    t1.vout[0].scriptPubKey \u003c\u003c OP_1;\n\n    BOOST_CHECK(AreInputsStandard(t1, coins));\n    BOOST_CHECK_EQUAL(coins.GetValueIn(t1), (50+21+22)*CENT);\n\n    // Adding extra junk to the scriptSig should make it non-standard:\n    t1.vin[0].scriptSig \u003c\u003c OP_11;\n    BOOST_CHECK(!AreInputsStandard(t1, coins));\n\n    // ... as should not having enough:\n    t1.vin[0].scriptSig = CScript();\n    BOOST_CHECK(!AreInputsStandard(t1, coins));\n}\n\nBOOST_AUTO_TEST_CASE(test_IsStandard)\n{\n    LOCK(cs_main);\n    CBasicKeyStore keystore;\n    CCoinsView coinsDummy;\n    CCoinsViewCache coins(\u0026coinsDummy);\n    std::vector\u003cCMutableTransaction\u003e dummyTransactions = SetupDummyInputs(keystore, coins);\n\n    CMutableTransaction t;\n    t.vin.resize(1);\n    t.vin[0].prevout.hash = dummyTransactions[0].GetHash();\n    t.vin[0].prevout.n = 1;\n    t.vin[0].scriptSig \u003c\u003c std::vector\u003cunsigned char\u003e(65, 0);\n    t.vout.resize(1);\n    t.vout[0].nValue = 90*CENT;\n    CKey key;\n    key.MakeNewKey(true);\n    t.vout[0].scriptPubKey = GetScriptForDestination(key.GetPubKey().GetID());\n\n    string reason;\n    BOOST_CHECK(IsStandardTx(t, reason));\n\n    t.vout[0].nValue = 501; // dust\n    BOOST_CHECK(!IsStandardTx(t, reason));\n\n    t.vout[0].nValue = 601; // not dust\n    BOOST_CHECK(IsStandardTx(t, reason));\n\n    t.vout[0].scriptPubKey = CScript() \u003c\u003c OP_1;\n    BOOST_CHECK(!IsStandardTx(t, reason));\n\n    // 40-byte TX_NULL_DATA (standard)\n    t.vout[0].scriptPubKey = CScript() \u003c\u003c OP_RETURN \u003c\u003c ParseHex(\"04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38\");\n    BOOST_CHECK(IsStandardTx(t, reason));\n\n    // 41-byte TX_NULL_DATA (non-standard)\n    t.vout[0].scriptPubKey = CScript() \u003c\u003c OP_RETURN \u003c\u003c ParseHex(\"04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef3800\");\n    BOOST_CHECK(!IsStandardTx(t, reason));\n\n    // TX_NULL_DATA w/o PUSHDATA\n    t.vout.resize(1);\n    t.vout[0].scriptPubKey = CScript() \u003c\u003c OP_RETURN;\n    BOOST_CHECK(IsStandardTx(t, reason));\n\n    // Only one TX_NULL_DATA permitted in all cases\n    t.vout.resize(2);\n    t.vout[0].scriptPubKey = CScript() \u003c\u003c OP_RETURN \u003c\u003c ParseHex(\"04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38\");\n    t.vout[1].scriptPubKey = CScript() \u003c\u003c OP_RETURN \u003c\u003c ParseHex(\"04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38\");\n    BOOST_CHECK(!IsStandardTx(t, reason));\n\n    t.vout[0].scriptPubKey = CScript() \u003c\u003c OP_RETURN \u003c\u003c ParseHex(\"04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38\");\n    t.vout[1].scriptPubKey = CScript() \u003c\u003c OP_RETURN;\n    BOOST_CHECK(!IsStandardTx(t, reason));\n\n    t.vout[0].scriptPubKey = CScript() \u003c\u003c OP_RETURN;\n    t.vout[1].scriptPubKey = CScript() \u003c\u003c OP_RETURN;\n    BOOST_CHECK(!IsStandardTx(t, reason));\n}\n\nBOOST_AUTO_TEST_SUITE_END()\n"}
{"repo_name":"pcarrier-packaging/deb-phantomjs","ref":"refs/heads/master","path":"src/qt/src/3rdparty/webkit/Source/WebCore/generated/JSSVGPathSegLinetoHorizontalRel.cpp","copies":"43","language":"C++","content":"/*\n    This file is part of the WebKit open source project.\n    This file has been generated by generate-bindings.pl. DO NOT MODIFY!\n\n    This library is free software; you can redistribute it and/or\n    modify it under the terms of the GNU Library General Public\n    License as published by the Free Software Foundation; either\n    version 2 of the License, or (at your option) any later version.\n\n    This library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n    Library General Public License for more details.\n\n    You should have received a copy of the GNU Library General Public License\n    along with this library; see the file COPYING.LIB.  If not, write to\n    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n    Boston, MA 02110-1301, USA.\n*/\n\n#include \"config.h\"\n\n#if ENABLE(SVG)\n\n#include \"JSSVGPathSegLinetoHorizontalRel.h\"\n\n#include \"SVGPathSegLinetoHorizontal.h\"\n#include \u003cruntime/Error.h\u003e\n#include \u003cwtf/GetPtr.h\u003e\n\nusing namespace JSC;\n\nnamespace WebCore {\n\nASSERT_CLASS_FITS_IN_CELL(JSSVGPathSegLinetoHorizontalRel);\n\n/* Hash table */\n#if ENABLE(JIT)\n#define THUNK_GENERATOR(generator) , generator\n#else\n#define THUNK_GENERATOR(generator)\n#endif\n\nstatic const HashTableValue JSSVGPathSegLinetoHorizontalRelTableValues[3] =\n{\n    { \"x\", DontDelete, (intptr_t)static_cast\u003cPropertySlot::GetValueFunc\u003e(jsSVGPathSegLinetoHorizontalRelX), (intptr_t)setJSSVGPathSegLinetoHorizontalRelX THUNK_GENERATOR(0) },\n    { \"constructor\", DontEnum | ReadOnly, (intptr_t)static_cast\u003cPropertySlot::GetValueFunc\u003e(jsSVGPathSegLinetoHorizontalRelConstructor), (intptr_t)0 THUNK_GENERATOR(0) },\n    { 0, 0, 0, 0 THUNK_GENERATOR(0) }\n};\n\n#undef THUNK_GENERATOR\nstatic JSC_CONST_HASHTABLE HashTable JSSVGPathSegLinetoHorizontalRelTable = { 5, 3, JSSVGPathSegLinetoHorizontalRelTableValues, 0 };\n/* Hash table for constructor */\n#if ENABLE(JIT)\n#define THUNK_GENERATOR(generator) , generator\n#else\n#define THUNK_GENERATOR(generator)\n#endif\n\nstatic const HashTableValue JSSVGPathSegLinetoHorizontalRelConstructorTableValues[1] =\n{\n    { 0, 0, 0, 0 THUNK_GENERATOR(0) }\n};\n\n#undef THUNK_GENERATOR\nstatic JSC_CONST_HASHTABLE HashTable JSSVGPathSegLinetoHorizontalRelConstructorTable = { 1, 0, JSSVGPathSegLinetoHorizontalRelConstructorTableValues, 0 };\nclass JSSVGPathSegLinetoHorizontalRelConstructor : public DOMConstructorObject {\npublic:\n    JSSVGPathSegLinetoHorizontalRelConstructor(JSC::ExecState*, JSC::Structure*, JSDOMGlobalObject*);\n\n    virtual bool getOwnPropertySlot(JSC::ExecState*, const JSC::Identifier\u0026, JSC::PropertySlot\u0026);\n    virtual bool getOwnPropertyDescriptor(JSC::ExecState*, const JSC::Identifier\u0026, JSC::PropertyDescriptor\u0026);\n    static const JSC::ClassInfo s_info;\n    static JSC::Structure* createStructure(JSC::JSGlobalData\u0026 globalData, JSC::JSValue prototype)\n    {\n        return JSC::Structure::create(globalData, prototype, JSC::TypeInfo(JSC::ObjectType, StructureFlags), AnonymousSlotCount, \u0026s_info);\n    }\nprotected:\n    static const unsigned StructureFlags = JSC::OverridesGetOwnPropertySlot | JSC::ImplementsHasInstance | DOMConstructorObject::StructureFlags;\n};\n\nconst ClassInfo JSSVGPathSegLinetoHorizontalRelConstructor::s_info = { \"SVGPathSegLinetoHorizontalRelConstructor\", \u0026DOMConstructorObject::s_info, \u0026JSSVGPathSegLinetoHorizontalRelConstructorTable, 0 };\n\nJSSVGPathSegLinetoHorizontalRelConstructor::JSSVGPathSegLinetoHorizontalRelConstructor(ExecState* exec, Structure* structure, JSDOMGlobalObject* globalObject)\n    : DOMConstructorObject(structure, globalObject)\n{\n    ASSERT(inherits(\u0026s_info));\n    putDirect(exec-\u003eglobalData(), exec-\u003epropertyNames().prototype, JSSVGPathSegLinetoHorizontalRelPrototype::self(exec, globalObject), DontDelete | ReadOnly);\n}\n\nbool JSSVGPathSegLinetoHorizontalRelConstructor::getOwnPropertySlot(ExecState* exec, const Identifier\u0026 propertyName, PropertySlot\u0026 slot)\n{\n    return getStaticValueSlot\u003cJSSVGPathSegLinetoHorizontalRelConstructor, JSDOMWrapper\u003e(exec, \u0026JSSVGPathSegLinetoHorizontalRelConstructorTable, this, propertyName, slot);\n}\n\nbool JSSVGPathSegLinetoHorizontalRelConstructor::getOwnPropertyDescriptor(ExecState* exec, const Identifier\u0026 propertyName, PropertyDescriptor\u0026 descriptor)\n{\n    return getStaticValueDescriptor\u003cJSSVGPathSegLinetoHorizontalRelConstructor, JSDOMWrapper\u003e(exec, \u0026JSSVGPathSegLinetoHorizontalRelConstructorTable, this, propertyName, descriptor);\n}\n\n/* Hash table for prototype */\n#if ENABLE(JIT)\n#define THUNK_GENERATOR(generator) , generator\n#else\n#define THUNK_GENERATOR(generator)\n#endif\n\nstatic const HashTableValue JSSVGPathSegLinetoHorizontalRelPrototypeTableValues[1] =\n{\n    { 0, 0, 0, 0 THUNK_GENERATOR(0) }\n};\n\n#undef THUNK_GENERATOR\nstatic JSC_CONST_HASHTABLE HashTable JSSVGPathSegLinetoHorizontalRelPrototypeTable = { 1, 0, JSSVGPathSegLinetoHorizontalRelPrototypeTableValues, 0 };\nconst ClassInfo JSSVGPathSegLinetoHorizontalRelPrototype::s_info = { \"SVGPathSegLinetoHorizontalRelPrototype\", \u0026JSC::JSObjectWithGlobalObject::s_info, \u0026JSSVGPathSegLinetoHorizontalRelPrototypeTable, 0 };\n\nJSObject* JSSVGPathSegLinetoHorizontalRelPrototype::self(ExecState* exec, JSGlobalObject* globalObject)\n{\n    return getDOMPrototype\u003cJSSVGPathSegLinetoHorizontalRel\u003e(exec, globalObject);\n}\n\nconst ClassInfo JSSVGPathSegLinetoHorizontalRel::s_info = { \"SVGPathSegLinetoHorizontalRel\", \u0026JSSVGPathSeg::s_info, \u0026JSSVGPathSegLinetoHorizontalRelTable, 0 };\n\nJSSVGPathSegLinetoHorizontalRel::JSSVGPathSegLinetoHorizontalRel(Structure* structure, JSDOMGlobalObject* globalObject, PassRefPtr\u003cSVGPathSegLinetoHorizontalRel\u003e impl)\n    : JSSVGPathSeg(structure, globalObject, impl)\n{\n    ASSERT(inherits(\u0026s_info));\n}\n\nJSObject* JSSVGPathSegLinetoHorizontalRel::createPrototype(ExecState* exec, JSGlobalObject* globalObject)\n{\n    return new (exec) JSSVGPathSegLinetoHorizontalRelPrototype(exec-\u003eglobalData(), globalObject, JSSVGPathSegLinetoHorizontalRelPrototype::createStructure(exec-\u003eglobalData(), JSSVGPathSegPrototype::self(exec, globalObject)));\n}\n\nbool JSSVGPathSegLinetoHorizontalRel::getOwnPropertySlot(ExecState* exec, const Identifier\u0026 propertyName, PropertySlot\u0026 slot)\n{\n    return getStaticValueSlot\u003cJSSVGPathSegLinetoHorizontalRel, Base\u003e(exec, \u0026JSSVGPathSegLinetoHorizontalRelTable, this, propertyName, slot);\n}\n\nbool JSSVGPathSegLinetoHorizontalRel::getOwnPropertyDescriptor(ExecState* exec, const Identifier\u0026 propertyName, PropertyDescriptor\u0026 descriptor)\n{\n    return getStaticValueDescriptor\u003cJSSVGPathSegLinetoHorizontalRel, Base\u003e(exec, \u0026JSSVGPathSegLinetoHorizontalRelTable, this, propertyName, descriptor);\n}\n\nJSValue jsSVGPathSegLinetoHorizontalRelX(ExecState* exec, JSValue slotBase, const Identifier\u0026)\n{\n    JSSVGPathSegLinetoHorizontalRel* castedThis = static_cast\u003cJSSVGPathSegLinetoHorizontalRel*\u003e(asObject(slotBase));\n    UNUSED_PARAM(exec);\n    SVGPathSegLinetoHorizontalRel* imp = static_cast\u003cSVGPathSegLinetoHorizontalRel*\u003e(castedThis-\u003eimpl());\n    JSValue result = jsNumber(imp-\u003ex());\n    return result;\n}\n\n\nJSValue jsSVGPathSegLinetoHorizontalRelConstructor(ExecState* exec, JSValue slotBase, const Identifier\u0026)\n{\n    JSSVGPathSegLinetoHorizontalRel* domObject = static_cast\u003cJSSVGPathSegLinetoHorizontalRel*\u003e(asObject(slotBase));\n    return JSSVGPathSegLinetoHorizontalRel::getConstructor(exec, domObject-\u003eglobalObject());\n}\n\nvoid JSSVGPathSegLinetoHorizontalRel::put(ExecState* exec, const Identifier\u0026 propertyName, JSValue value, PutPropertySlot\u0026 slot)\n{\n    lookupPut\u003cJSSVGPathSegLinetoHorizontalRel, Base\u003e(exec, propertyName, value, \u0026JSSVGPathSegLinetoHorizontalRelTable, this, slot);\n}\n\nvoid setJSSVGPathSegLinetoHorizontalRelX(ExecState* exec, JSObject* thisObject, JSValue value)\n{\n    JSSVGPathSegLinetoHorizontalRel* castedThis = static_cast\u003cJSSVGPathSegLinetoHorizontalRel*\u003e(thisObject);\n    SVGPathSegLinetoHorizontalRel* imp = static_cast\u003cSVGPathSegLinetoHorizontalRel*\u003e(castedThis-\u003eimpl());\n    imp-\u003esetX(value.toFloat(exec));\n}\n\n\nJSValue JSSVGPathSegLinetoHorizontalRel::getConstructor(ExecState* exec, JSGlobalObject* globalObject)\n{\n    return getDOMConstructor\u003cJSSVGPathSegLinetoHorizontalRelConstructor\u003e(exec, static_cast\u003cJSDOMGlobalObject*\u003e(globalObject));\n}\n\n\n}\n\n#endif // ENABLE(SVG)\n"}
{"repo_name":"rlewis1988/lean","ref":"refs/heads/master","path":"src/library/tactic/smt/util.cpp","copies":"9","language":"C++","content":"/*\nCopyright (c) 2016 Microsoft Corporation. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\n\nAuthor: Leonardo de Moura\n*/\n#include \"library/annotation.h\"\n#include \"library/util.h\"\n#include \"library/replace_visitor.h\"\n#include \"library/vm/vm.h\"\n#include \"library/tactic/smt/congruence_closure.h\"\n\nnamespace lean {\nstatic name * g_cc_proof_name = nullptr;\nstatic macro_definition * g_cc_proof_macro = nullptr;\n\nclass cc_proof_macro_cell : public macro_definition_cell {\npublic:\n    virtual name get_name() const { return *g_cc_proof_name; }\n\n    virtual expr check_type(expr const \u0026 e, abstract_type_context \u0026 ctx, bool) const {\n        return mk_eq(ctx, macro_arg(e, 0), macro_arg(e, 1));\n    }\n\n    virtual optional\u003cexpr\u003e expand(expr const \u0026, abstract_type_context \u0026) const {\n        /* This is a temporary/delayed proof step. */\n        lean_unreachable();\n    }\n\n    virtual void write(serializer \u0026) const {\n        /* This is a temporary/delayed proof step. */\n        lean_unreachable();\n    }\n\n    virtual bool operator==(macro_definition_cell const \u0026 other) const {\n        cc_proof_macro_cell const * other_ptr = dynamic_cast\u003ccc_proof_macro_cell const *\u003e(\u0026other);\n        return other_ptr;\n    }\n\n    virtual unsigned hash() const { return 23; }\n};\n\n/* Delayed (congruence closure procedure) proof.\n   This proof is a placeholder for the real one that is computed only if needed. */\nexpr mk_delayed_cc_eq_proof(expr const \u0026 e1, expr const \u0026 e2) {\n    expr args[2] = {e1, e2};\n    return mk_macro(*g_cc_proof_macro, 2, args);\n}\n\nbool is_delayed_cc_eq_proof(expr const \u0026 e) {\n    return is_macro(e) \u0026\u0026 dynamic_cast\u003ccc_proof_macro_cell const *\u003e(macro_def(e).raw());\n}\n\nstatic name * g_theory_proof = nullptr;\n\nexpr mark_cc_theory_proof(expr const \u0026 pr) {\n    return mk_annotation(*g_theory_proof, pr);\n}\n\nbool is_cc_theory_proof(expr const \u0026 e) {\n    return is_annotation(e, *g_theory_proof);\n}\n\nexpr get_cc_theory_proof_arg(expr const \u0026 pr) {\n    lean_assert(is_cc_theory_proof(pr));\n    return get_annotation_arg(pr);\n}\n\nclass expand_delayed_cc_proofs_fn : public replace_visitor {\n    congruence_closure const \u0026 m_cc;\n\n    expr visit_macro(expr const \u0026 e) {\n        if (is_delayed_cc_eq_proof(e)) {\n            expr const \u0026 lhs = macro_arg(e, 0);\n            expr const \u0026 rhs = macro_arg(e, 1);\n            return *m_cc.get_eq_proof(lhs, rhs);\n        } else {\n            return replace_visitor::visit_macro(e);\n        }\n    }\n\npublic:\n    expand_delayed_cc_proofs_fn(congruence_closure const \u0026 cc):m_cc(cc) {}\n};\n\nexpr expand_delayed_cc_proofs(congruence_closure const \u0026 cc, expr const \u0026 e) {\n    return expand_delayed_cc_proofs_fn(cc)(e);\n}\n\nvoid initialize_smt_util() {\n    g_cc_proof_name   = new name(\"cc_proof\");\n    g_cc_proof_macro  = new macro_definition(new cc_proof_macro_cell());\n    g_theory_proof    = new name(\"th_proof\");\n    register_annotation(*g_theory_proof);\n}\n\nvoid finalize_smt_util() {\n    delete g_cc_proof_macro;\n    delete g_cc_proof_name;\n    delete g_theory_proof;\n}\n}\n"}
{"repo_name":"g3rg/GoldenCheetah","ref":"refs/heads/master","path":"src/HrPwPlot.cpp","copies":"1","language":"C++","content":"/*\n * Copyright (c) 2011 Damien Grauser\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 2 of the License, or (at your option)\n * any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n * more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc., 51\n * Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\n\n#include \"HrPwPlot.h\"\n#include \"MainWindow.h\"\n#include \"HrPwWindow.h\"\n#include \"RideFile.h\"\n#include \"RideItem.h\"\n#include \"Zones.h\"\n#include \"Settings.h\"\n#include \"Colors.h\"\n\n#include \u003cassert.h\u003e\n#include \u003cqwt_plot_curve.h\u003e\n#include \u003cqwt_plot_grid.h\u003e\n#include \u003cqwt_plot_canvas.h\u003e\n#include \u003cqwt_plot_marker.h\u003e\n#include \u003cqwt_text.h\u003e\n#include \u003cqwt_symbol.h\u003e\n#include \u003cqwt_legend.h\u003e\n#include \u003cqwt_series_data.h\u003e\n\n\nstatic inline double\nmax(double a, double b) { if (a \u003e b) return a; else return b; }\n\nHrPwPlot::HrPwPlot(MainWindow *mainWindow, HrPwWindow *hrPwWindow) :\n    QwtPlot(hrPwWindow),\n    hrPwWindow(hrPwWindow),\n    mainWindow(mainWindow),\n    bg(NULL), delay(-1),\n    minHr(50), minWatt(50), maxWatt(500),\n    settings(GC_SETTINGS_CO, GC_SETTINGS_APP),\n    unit(settings.value(GC_UNIT))\n{\n    setCanvasBackground(Qt::white);\n    canvas()-\u003esetFrameStyle(QFrame::NoFrame);\n    setXTitle(); // Power (Watts)\n\n    // Linear Regression Curve\n    regCurve = new QwtPlotCurve(\"reg\");\n    regCurve-\u003esetPen(QPen(GColor(CPLOTMARKER)));\n    regCurve-\u003eattach(this);\n\n    // Power distribution\n    wattsStepCurve = new QwtPlotCurve(\"Power\");\n    wattsStepCurve-\u003esetStyle(QwtPlotCurve::Steps);\n    wattsStepCurve-\u003esetRenderHint(QwtPlotItem::RenderAntialiased);\n    QColor wattsColor = QColor(200,200,255);\n    QColor wattsColor2 = QColor(100,100,255);\n    wattsStepCurve-\u003esetPen(QPen(wattsColor2));\n    wattsStepCurve-\u003esetBrush(QBrush(wattsColor));\n\n    wattsStepCurve-\u003eattach(this);\n\n    // Hr distribution\n    hrStepCurve = new QwtPlotCurve(\"Hr\");\n    hrStepCurve-\u003esetStyle(QwtPlotCurve::Steps);\n    hrStepCurve-\u003esetRenderHint(QwtPlotItem::RenderAntialiased);\n    QColor hrColor = QColor(255,200,200);\n    QColor hrColor2 = QColor(255,100,100);\n    hrStepCurve-\u003esetPen(QPen(hrColor2));\n    hrStepCurve-\u003esetBrush(QBrush(hrColor));\n    hrStepCurve-\u003eattach(this);\n\n    // Heart Rate Curve\n\n    hrCurves.resize(36);\n    for (int i = 0; i \u003c 36; ++i) {\n        hrCurves[i] = new QwtPlotCurve;\n        hrCurves[i]-\u003eattach(this);\n    }\n\n    // Grid\n    grid = new QwtPlotGrid();\n    grid-\u003eenableX(false);\n    QPen gridPen;\n    gridPen.setStyle(Qt::DotLine);\n    gridPen.setColor(GColor(CPLOTGRID));\n    grid-\u003esetPen(gridPen);\n    grid-\u003eattach(this);\n\n\n    // axis markers\n    r_mrk1 = new QwtPlotMarker;\n    r_mrk2 = new QwtPlotMarker;\n    r_mrk1-\u003eattach(this);\n    r_mrk2-\u003eattach(this);\n\n    shade_zones = true;\n}\n\nstruct DataPoint {\n    double time, hr, watts;\n    int inter;\n    DataPoint(double t, double h, double w, int i) :\n        time(t), hr(h), watts(w), inter(i) {}\n};\n\nvoid\nHrPwPlot::setAxisTitle(int axis, QString label)\n{\n    // setup the default fonts\n    QFont stGiles; // hoho - Chart Font St. Giles ... ok you have to be British to get this joke\n    stGiles.fromString(appsettings-\u003evalue(this, GC_FONT_CHARTLABELS, QFont().toString()).toString());\n    stGiles.setPointSize(appsettings-\u003evalue(NULL, GC_FONT_CHARTLABELS_SIZE, 8).toInt());\n\n    QwtText title(label);\n    title.setFont(stGiles);\n    QwtPlot::setAxisFont(axis, stGiles);\n    QwtPlot::setAxisTitle(axis, title);\n}\n\nvoid\nHrPwPlot::recalc()\n{\n    if (timeArray.count() == 0)\n        return;\n\n    int rideTimeSecs = (int) ceil(timeArray[arrayLength - 1]);\n    if (rideTimeSecs \u003e 7*24*60*60) {\n        return;\n    }\n\n\n\n\n    // Find Hr Delay\n    //int delayori = findDelay(wattsArray, hrArray, rideTimeSecs/5);\n    //int delay  = 0;\n\n\n    // ------ smoothing -----\n    // ----------------------\n    double totalWatts = 0.0;\n    double totalHr = 0.0;\n    QList\u003cDataPoint*\u003e list;\n    int i = 0;\n    QVector\u003cdouble\u003e smoothWatts(rideTimeSecs + 1);\n    QVector\u003cdouble\u003e smoothHr(rideTimeSecs + 1);\n    QVector\u003cdouble\u003e smoothTime(rideTimeSecs + 1);\n    int decal=0;\n\n    /*for (int secs = 0; ((secs \u003c smooth) \u0026\u0026 (secs \u003c rideTimeSecs)); ++secs) {\n        smoothWatts[secs] = 0.0;\n        smoothHr[secs]    = 0.0;\n    }*/\n\n    //int interval = 0;\n    int smooth = hrPwWindow-\u003esmooth;\n\n    for (int secs = smooth; secs \u003c= rideTimeSecs; ++secs) {\n        while ((i \u003c arrayLength) \u0026\u0026 (timeArray[i] \u003c= secs)) {\n            DataPoint *dp =\n                new DataPoint(timeArray[i], hrArray[i], wattsArray[i], interArray[i]);\n\t\n            totalWatts += wattsArray[i];\n                totalHr    += hrArray[i];\n\t        list.append(dp);\n\n            ++i;\n        }\n        while (!list.empty() \u0026\u0026 (list.front()-\u003etime \u003c secs - smooth)) {\n            DataPoint *dp = list.front();\n            list.removeFirst();\n            totalWatts -= dp-\u003ewatts;\n            totalHr    -= dp-\u003ehr;\n            delete dp;\n        }\n        if (list.empty()) {\n            ++decal;\n        }\n        else {\n            smoothWatts[secs-decal]    = totalWatts / list.size();\n            smoothHr[secs-decal]       = totalHr / list.size();\n            // Utiliser interval du fichier\n            //if (smooth/list.size()\u003e0)\n            //\tinterval = smooth/list.size();\n        }\n        smoothTime[secs]  = secs / 60.0;\n    }\n\n    rideTimeSecs = rideTimeSecs-decal;\n    smoothWatts.resize(rideTimeSecs);\n    smoothHr.resize(rideTimeSecs);\n\n    // Clip to max\n    QVector\u003cdouble\u003e clipWatts(rideTimeSecs);\n    QVector\u003cdouble\u003e clipHr(rideTimeSecs);\n\n    /*for (int secs = 0; secs \u003c rideTimeSecs; ++secs) {\n        clipWatts[secs] = 0.0;\n        clipHr[secs] = 0.0;\n    }*/\n\n    decal = 0;\n    for (int secs = 0; secs \u003c rideTimeSecs; ++secs) {\n                if (smoothHr[secs]\u003e= minHr \u0026\u0026 smoothWatts[secs]\u003e= minWatt \u0026\u0026 smoothWatts[secs]\u003cmaxWatt) {\n                        clipWatts[secs-decal]    = smoothWatts[secs];\n                        clipHr[secs-decal]    = smoothHr[secs];\n                }\n                else\n                        decal ++;\n        }\n    rideTimeSecs = rideTimeSecs-decal;\n    clipWatts.resize(rideTimeSecs);\n    clipHr.resize(rideTimeSecs);\n\n\n\n    // Find Hr Delay\n    if (delay == -1)\n       delay = hrPwWindow-\u003efindDelay(clipWatts, clipHr, clipWatts.size());\n\n    // Apply delay\n    QVector\u003cdouble\u003e delayWatts(rideTimeSecs-delay);\n    QVector\u003cdouble\u003e delayHr(rideTimeSecs-delay);\n\n    for (int secs = 0; secs \u003c rideTimeSecs-delay; ++secs) {\n        delayWatts[secs]    = clipWatts[secs];\n        delayHr[secs]    = clipHr[secs+delay];\n    }\n    rideTimeSecs = rideTimeSecs-delay;\n\n    double rpente = hrPwWindow-\u003epente(delayWatts, delayHr, delayWatts.size());\n    double rordonnee = hrPwWindow-\u003eordonnee(delayWatts, delayHr, delayWatts.size());\n    double maxr = hrPwWindow-\u003ecorr(delayWatts, delayHr, delayWatts.size());\n\n    // ----- limit plotted points ---\n    // ----------------------\n    int intpoints = 10; // could be ride length dependent\n    int nbpoints = (int)floor(rideTimeSecs/intpoints);\n\n    QVector\u003cdouble\u003e plotedWatts(nbpoints);\n    QVector\u003cdouble\u003e plotedHr(nbpoints);\n\n    for (int secs = 0; secs \u003c nbpoints; ++secs) {\n        plotedWatts[secs]    = clipWatts[secs*intpoints];\n        plotedHr[secs]    = clipHr[secs*intpoints];\n    }\n    int nbpoints2 = (int)floor(nbpoints/36)+2;\n\n    double *plotedWattsArray[36];\n    double *plotedHrArray[36];\n\n    for (int i = 0; i \u003c 36; ++i) {\n        plotedWattsArray[i]= new double[nbpoints2];\n        plotedHrArray[i]= new double[nbpoints2];\n    }\n\n    for (int secs = 0; secs \u003c nbpoints; ++secs) {\n        for (int i = 0; i \u003c 36; ++i) {\n            if (secs \u003e= i*nbpoints2 \u0026\u0026 secs\u003c (i+1)*nbpoints2) {\n                plotedWattsArray[i][secs-i*nbpoints2] = plotedWatts[secs-i];\n                plotedHrArray[i][secs-i*nbpoints2]    = plotedHr[secs-i];\n            }\n        }\n    }\n\n\n    for (int i = 0; i \u003c 36; ++i) {\n\n    \tif (nbpoints-i*nbpoints2\u003e0) {\n\n                hrCurves[i]-\u003esetData(plotedWattsArray[i], plotedHrArray[i], (nbpoints-i*nbpoints2\u003cnbpoints2?nbpoints-i*nbpoints2:nbpoints2));\n    \t\thrCurves[i]-\u003esetVisible(true);\n    \t} else\n    \t\thrCurves[i]-\u003esetVisible(false);\n    }\n\n\n    setAxisScale(xBottom, 0.0, maxWatt);\n\n    setYMax();\n    refreshZoneLabels();\n\n    QString labelp;\n\n    labelp.setNum(rpente, 'f', 3);\n    QString labelo;\n    labelo.setNum(rordonnee, 'f', 1);\n\n    QString labelr;\n    labelr.setNum(maxr, 'f', 3);\n    QString labeldelay;\n    labeldelay.setNum(delay);\n\n    int power150 =  (int)floor((150-rordonnee)/rpente);\n    QString labelpower150;\n    labelpower150.setNum(power150);\n\n    QwtText textr = QwtText(labelp+\"*x+\"+labelo+\" : R \"+labelr+\" (\"+labeldelay+\") \\n Power@150:\"+labelpower150+\"W\");\n    textr.setFont(QFont(\"Helvetica\", 10, QFont::Bold));\n    textr.setColor(Qt::black);\n\n    r_mrk1-\u003esetValue(0,0);\n    r_mrk1-\u003esetLineStyle(QwtPlotMarker::VLine);\n    r_mrk1-\u003esetLabelAlignment(Qt::AlignRight | Qt::AlignTop);\n    r_mrk1-\u003esetLinePen(QPen(Qt::black, 0, Qt::DashDotLine));\n    double moyennewatt = hrPwWindow-\u003emoyenne(clipWatts, clipWatts.size());\n    r_mrk1-\u003esetValue(moyennewatt, 0.0);\n    r_mrk1-\u003esetLabel(textr);\n\n    r_mrk2-\u003esetValue(0,0);\n    r_mrk2-\u003esetLineStyle(QwtPlotMarker::HLine);\n    r_mrk2-\u003esetLabelAlignment(Qt::AlignRight | Qt::AlignTop);\n    r_mrk2-\u003esetLinePen(QPen(Qt::black, 0, Qt::DashDotLine));\n    double moyennehr = hrPwWindow-\u003emoyenne(clipHr,  clipHr.size());\n    r_mrk2-\u003esetValue(0.0,moyennehr);\n\n    addWattStepCurve(clipWatts, clipWatts.size());\n    addHrStepCurve(clipHr, clipHr.size());\n\n    addRegLinCurve(rpente, rordonnee);\n\n    setJoinLine(joinLine);\n    replot();\n}\n\nvoid\nHrPwPlot::setYMax()\n{\n    double ymax = 0;\n    QString ylabel = \"\";\n    for (int i = 0; i \u003c 36; ++i) {\n\t    if (hrCurves[i]-\u003eisVisible()) {\n\t        ymax = max(ymax, hrCurves[i]-\u003emaxYValue());\n\t        //ylabel += QString((ylabel == \"\") ? \"\" : \" / \") + \"BPM\";\n\t    }\n    }\n    setAxisScale(yLeft, minHr, ymax * 1.2);\n    setAxisTitle(yLeft, tr(\"Heart Rate(BPM)\"));\n}\n\nvoid\nHrPwPlot::addWattStepCurve(QVector\u003cdouble\u003e \u0026finalWatts, int nbpoints)\n{\n    QMap\u003cdouble,double\u003e powerHist;\n\n    for (int h=0; h\u003c nbpoints; ++h) {\n        if (powerHist.contains(finalWatts[h]))\n            powerHist[finalWatts[h]] += 1;\n        else\n            powerHist[finalWatts[h]] = 1;\n    }\n    int maxPower = 500;\n    double *array = new double[maxPower];\n\n    for (int i = 0; i \u003c maxPower; ++i)\n        array[i] = 0.0;\n\n    QMapIterator\u003cdouble,double\u003e k(powerHist);\n    while (k.hasNext()) {\n        k.next();\n        array[(int) round(k.key())] += k.value();\n    }\n\n    int nbSteps = (int) ceil((maxPower - 1) / 10);\n    QVector\u003cdouble\u003e smoothWattsStep(nbSteps+1);\n    QVector\u003cdouble\u003e smoothTimeStep(nbSteps+1);\n\n    int t;\n    for (t = 1; t \u003c nbSteps; ++t) {\n    \tint low = t * 10;\n    \tint high = low + 10;\n\n        smoothWattsStep[t] = low;\n        smoothTimeStep[t]  = minHr;\n        while (low \u003c high) {\n        \tsmoothTimeStep[t] += array[low++]/ nbpoints * 300;\n        }\n    }\n    smoothTimeStep[t] = 0.0;\n    smoothWattsStep[t] = t * 10;\n\n    wattsStepCurve-\u003esetData(smoothWattsStep.data(), smoothTimeStep.data(), nbSteps+1);\n}\n\nvoid\nHrPwPlot::addHrStepCurve(QVector\u003cdouble\u003e \u0026finalHr, int nbpoints)\n{\n    QMap\u003cdouble,double\u003e hrHist;\n    for (int h=0; h\u003c nbpoints; ++h) {\n            if (hrHist.contains(finalHr[h]))\n                hrHist[finalHr[h]] += 1;\n            else\n                hrHist[finalHr[h]] = 1;\n    }\n    int maxHr = 220;\n\n    double *array = new double[maxHr];\n    for (int i = 0; i \u003c maxHr; ++i)\n        array[i] = 0.0;\n    QMapIterator\u003cdouble,double\u003e l(hrHist);\n    while (l.hasNext()) {\n        l.next();\n        array[(int) round(l.key())] += l.value();\n    }\n\n\n    int nbSteps = (int) ceil((maxHr - 1) / 2);\n    QVector\u003cdouble\u003e smoothHrStep(nbSteps+1);\n    QVector\u003cdouble\u003e smoothTimeStep2(nbSteps+1);\n\n    int t;\n    for (t = 1; t \u003c nbSteps; ++t) {\n        int low = t * 2;\n        int high = low + 2;\n\n        smoothHrStep[t] = low;\n        smoothTimeStep2[t]  = 0.0;\n        while (low \u003c high) {\n        \tsmoothTimeStep2[t] += array[low++]/ nbpoints * 500;\n        }\n    }\n    smoothTimeStep2[t] = 0.0;\n    smoothHrStep[t] = t * 2;\n\n    hrStepCurve-\u003esetData(smoothTimeStep2.data(), smoothHrStep.data(), nbSteps+1);\n}\n\nvoid\nHrPwPlot::addRegLinCurve( double rpente, double rordonnee)\n{\n    double regWatts[]     = {0, 0};\n    double regHr[]        = {0, 500};\n\n    regWatts[0] = regHr[0]*rpente+rordonnee;\n    regWatts[1] = regHr[1]*rpente+rordonnee;\n\n    regCurve-\u003esetData(regHr, regWatts, 2);\n}\n\nvoid\nHrPwPlot::setXTitle()\n{\n    setAxisTitle(xBottom, tr(\"Power (Watts)\"));\n}\n\nvoid\nHrPwPlot::setDataFromRide(RideItem *_rideItem)\n{\n    rideItem = _rideItem;\n\n    // ignore null / bad rides\n    if (!_rideItem || !_rideItem-\u003eride()) return;\n\n    RideFile *ride = rideItem-\u003eride();\n\n    const RideFileDataPresent *dataPresent = ride-\u003eareDataPresent();\n    int npoints = ride-\u003edataPoints().size();\n\n    if (dataPresent-\u003ewatts \u0026\u0026 dataPresent-\u003ehr) {\n        wattsArray.resize(npoints);\n        hrArray.resize(npoints);\n        timeArray.resize(npoints);\n        interArray.resize(npoints);\n\n        arrayLength = 0;\n        //QListIterator\u003cRideFilePoint*\u003e i(ride-\u003edataPoints());\n        //while (i.hasNext()) {\n        foreach (const RideFilePoint *point, ride-\u003edataPoints()) {\n            //RideFilePoint *point = i.next();\n            if (!timeArray.empty())\n                timeArray[arrayLength]  = point-\u003esecs;\n            if (!wattsArray.empty())\n                wattsArray[arrayLength] = max(0, point-\u003ewatts);\n            if (!hrArray.empty())\n                hrArray[arrayLength]    = max(0, point-\u003ehr);\n            if (!interArray.empty())\n                interArray[arrayLength] = point-\u003einterval;\n            ++arrayLength;\n        }\n\n        delay = -1;\n        recalc();\n    }\n}\n\nvoid\nHrPwPlot::setJoinLine(bool value)\n{\n\n    joinLine = value;\n\n    for (int i = 0; i \u003c 36; ++i) {\n        QColor color = QColor(255,255,255);\n        color.setHsv(60+i*(360/36), 255,255,255);\n        if (value) {\n            QwtSymbol sym;\n            sym.setStyle(QwtSymbol::NoSymbol);\n\n            QPen pen = QPen(color);\n            pen.setWidth(1);\n            hrCurves[i]-\u003esetPen(pen);\n            hrCurves[i]-\u003esetStyle(QwtPlotCurve::Lines);\n            hrCurves[i]-\u003esetSymbol(new QwtSymbol(sym));\n        } else {\n            QwtSymbol sym;\n            sym.setStyle(QwtSymbol::Ellipse);\n            sym.setSize(5);\n            sym.setPen(QPen(color));\n            sym.setBrush(QBrush(color));\n            hrCurves[i]-\u003esetPen(Qt::NoPen);\n            hrCurves[i]-\u003esetStyle(QwtPlotCurve::Dots);\n            hrCurves[i]-\u003esetSymbol(new QwtSymbol(sym));\n        }\n        //hrCurves[i].setRenderHint(QwtPlotItem::RenderAntialiased);\n    }\n\n}\n\nvoid\nHrPwPlot::pointHover(QwtPlotCurve *curve, int index)\n{\n    if (index \u003e= 0) {\n\n        double yvalue = curve-\u003esample(index).y();\n        double xvalue = curve-\u003esample(index).x();\n\n        // output the tooltip\n        QString text = QString(\"%1 %2\\n%3 %4\")\n                        .arg(yvalue, 0, 'f', 0)\n                        .arg(this-\u003eaxisTitle(curve-\u003eyAxis()).text())\n                        .arg(xvalue, 0, 'f', 2)\n                        .arg(this-\u003eaxisTitle(curve-\u003exAxis()).text());\n\n        // set that text up\n        tooltip-\u003esetText(text);\n    } else {\n        tooltip-\u003esetText(\"\");\n    }\n}\n\n/*----------------------------------------------------------------------\n * Draw Power Zone Shading on Background (here to end of source file)\n *--------------------------------------------------------------------*/\nclass HrPwPlotBackground: public QwtPlotItem\n{\n    private:\n        HrPwPlot *parent;\n\n    public:\n        HrPwPlotBackground(HrPwPlot *_parent) {\n            setZ(0.0);\n            parent = _parent;\n        }\n\n        virtual int rtti() const {\n            return QwtPlotItem::Rtti_PlotUserItem;\n        }\n\n        virtual void draw(QPainter *painter,\n              const QwtScaleMap \u0026xMap, const QwtScaleMap \u0026,\n              const QRectF \u0026rect) const {\n\n            RideItem *rideItem = parent-\u003erideItem;\n\n            if (! rideItem)\n                return;\n\n            const Zones *zones = rideItem-\u003ezones;\n            int zone_range     = rideItem-\u003ezoneRange();\n\n            if (parent-\u003eisShadeZones() \u0026\u0026 zones \u0026\u0026 (zone_range \u003e= 0)) {\n                QList \u003cint\u003e zone_lows = zones-\u003egetZoneLows(zone_range);\n                int num_zones = zone_lows.size();\n                if (num_zones \u003e 0) {\n                    for (int z = 0; z \u003c num_zones; z ++) {\n                        QRectF r = rect;\n\n                        QColor shading_color = zoneColor(z, num_zones);\n                        shading_color.setHsv(\n                            shading_color.hue(),\n                            shading_color.saturation() / 4,\n                            shading_color.value()\n                        );\n                        r.setLeft(xMap.transform(zone_lows[z]));\n                        if (z + 1 \u003c num_zones)\n                            r.setRight(xMap.transform(zone_lows[z + 1]));\n                        if (r.left() \u003c= r.right())\n                            painter-\u003efillRect(r, shading_color);\n                    }\n                }\n            }\n    }\n};\n\n// Zone labels are drawn if power zone bands are enabled, automatically\n// at the center of the plot\nclass HrPwPlotZoneLabel: public QwtPlotItem\n{\n    private:\n        HrPwPlot *parent;\n        int zone_number;\n        double watts;\n        QwtText text;\n\n    public:\n        HrPwPlotZoneLabel(HrPwPlot *_parent, int _zone_number) {\n            parent = _parent;\n            zone_number = _zone_number;\n\n            RideItem *rideItem = parent-\u003erideItem;\n\n\n            if (! rideItem)\n                return;\n\n            const Zones *zones = rideItem-\u003ezones;\n            int zone_range     = rideItem-\u003ezoneRange();\n\n            // create new zone labels if we're shading\n            if (parent-\u003eisShadeZones() \u0026\u0026 zones \u0026\u0026 (zone_range \u003e= 0)) {\n                QList \u003cint\u003e zone_lows = zones-\u003egetZoneLows(zone_range);\n                QList \u003cQString\u003e zone_names = zones-\u003egetZoneNames(zone_range);\n                int num_zones = zone_lows.size();\n                assert(zone_names.size() == num_zones);\n                if (zone_number \u003c num_zones) {\n                    watts =\n                        (\n                        (zone_number + 1 \u003c num_zones) ?\n                         0.5 * (zone_lows[zone_number] + zone_lows[zone_number + 1]) :\n                        (\n                        (zone_number \u003e 0) ?\n                        (1.5 * zone_lows[zone_number] - 0.5 * zone_lows[zone_number - 1]) :\n                        2.0 * zone_lows[zone_number]\n                        )\n                        );\n\n                    text = QwtText(zone_names[zone_number]);\n                    text.setFont(QFont(\"Helvetica\",24, QFont::Bold));\n                    QColor text_color = zoneColor(zone_number, num_zones);\n                    text_color.setAlpha(64);\n                    text.setColor(text_color);\n                }\n            }\n\n            setZ(1.0 + zone_number / 100.0);\n        }\n\n        virtual int rtti() const {\n            return QwtPlotItem::Rtti_PlotUserItem;\n        }\n\n        void draw(QPainter *painter,\n                const QwtScaleMap \u0026xMap, const QwtScaleMap \u0026,\n                const QRectF \u0026rect) const {\n            if (parent-\u003eisShadeZones()) {\n                int y = (rect.bottom() + rect.top()) / 2;\n                int x = xMap.transform(watts);\n\n                // the following code based on source for QwtPlotMarker::draw()\n                QRect tr(QPoint(0, 0), text.textSize(painter-\u003efont()).toSize());\n                tr.moveCenter(QPoint(x, y));\n                text.draw(painter, tr);\n            }\n        }\n};\n\nint\nHrPwPlot::isShadeZones() const {\n    return (shadeZones \u0026\u0026 !wattsArray.empty());\n}\n\nvoid\nHrPwPlot::setShadeZones(int x)\n{\n    shadeZones = x;\n}\n\nvoid\nHrPwPlot::refreshZoneLabels() {\n    foreach(HrPwPlotZoneLabel *label, zoneLabels) {\n        label-\u003edetach();\n        delete label;\n    }\n    zoneLabels.clear();\n\n    if (bg) {\n        bg-\u003edetach();\n        delete bg;\n        bg = NULL;\n    }\n\n    if (rideItem) {\n        int zone_range = rideItem-\u003ezoneRange();\n        const Zones *zones = rideItem-\u003ezones;\n\n        // generate labels for existing zones\n        if (zones \u0026\u0026 (zone_range \u003e= 0)) {\n            int num_zones = zones-\u003enumZones(zone_range);\n            for (int z = 0; z \u003c num_zones; z ++) {\n                HrPwPlotZoneLabel *label = new HrPwPlotZoneLabel(this, z);\n                label-\u003eattach(this);\n                zoneLabels.append(label);\n            }\n        }\n    }\n\n    // create a background object for shading\n    bg = new HrPwPlotBackground(this);\n    bg-\u003eattach(this);\n}\n"}
{"repo_name":"braska/tdesktop","ref":"refs/heads/master","path":"Telegram/SourceFiles/gui/twidget.cpp","copies":"29","language":"C++","content":"/*\nThis file is part of Telegram Desktop,\nthe official desktop version of Telegram messaging app, see https://telegram.org\n\nTelegram Desktop is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nIt is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\nGNU General Public License for more details.\n\nFull license: https://github.com/telegramdesktop/tdesktop/blob/master/LICENSE\nCopyright (c) 2014 John Preston, https://desktop.telegram.org\n*/\n#include \"stdafx.h\"\n\n#include \"application.h\"\n\nnamespace {\n\tvoid _sendResizeEvents(QWidget *target) {\n\t\tQResizeEvent e(target-\u003esize(), QSize());\n\t\tQApplication::sendEvent(target, \u0026e);\n\n\t\tconst QObjectList children = target-\u003echildren();\n\t\tfor (int i = 0; i \u003c children.size(); ++i) {\n\t\t\tQWidget *child = static_cast\u003cQWidget*\u003e(children.at(i));\n\t\t\tif (child-\u003eisWidgetType() \u0026\u0026 !child-\u003eisWindow() \u0026\u0026 child-\u003etestAttribute(Qt::WA_PendingResizeEvent)) {\n\t\t\t\t_sendResizeEvents(child);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid myEnsureResized(QWidget *target) {\n\tif (target \u0026\u0026 (target-\u003etestAttribute(Qt::WA_PendingResizeEvent) || !target-\u003etestAttribute(Qt::WA_WState_Created))) {\n\t\t_sendResizeEvents(target);\n\t}\n}\n\nQPixmap myGrab(QWidget *target, const QRect \u0026rect) {\n    if (!cRetina()) return target-\u003egrab(rect);\n    \n\tmyEnsureResized(target);\n    \n    qreal dpr = App::app()-\u003edevicePixelRatio();\n    QPixmap result(rect.size() * dpr);\n    result.setDevicePixelRatio(dpr);\n    result.fill(Qt::transparent);\n    target-\u003erender(\u0026result, QPoint(), QRegion(rect), QWidget::DrawWindowBackground | QWidget::DrawChildren | QWidget::IgnoreMask);\n    return result;\n}\n"}
{"repo_name":"thientu/drake","ref":"refs/heads/master","path":"util/drakeGeometryUtil.cpp","copies":"1","language":"C++","content":"#include \"drakeGeometryUtil.h\"\n#include \u003ciostream\u003e\n#include \u003ccmath\u003e\n#include \u003climits\u003e\n#include \u003cstdexcept\u003e\n#include \u003cEigen/Sparse\u003e\n#include \"expmap2quat.h\"\n\nusing namespace Eigen;\n\n\ndouble angleDiff(double phi1, double phi2)\n{\n  double d = phi2-phi1;\n  if(d\u003e0.0)\n  {\n    d = fmod(d+M_PI,2*M_PI)-M_PI;\n  }\n  else\n  {\n    d = fmod(d-M_PI,2*M_PI)+M_PI;\n  }\n  return d;\n}\n\n\nVector4d quatConjugate(const Eigen::Vector4d\u0026 q)\n{\n  Vector4d q_conj;\n  q_conj \u003c\u003c q(0), -q(1), -q(2), -q(3);\n  return q_conj;\n}\n\nEigen::Matrix4d dquatConjugate()\n{\n  Matrix4d dq_conj = Matrix4d::Identity();\n  dq_conj(1, 1) = -1.0;\n  dq_conj(2, 2) = -1.0;\n  dq_conj(3, 3) = -1.0;\n  return dq_conj;\n}\n\nEigen::Vector4d quatProduct(const Eigen::Vector4d\u0026 q1, const Eigen::Vector4d\u0026 q2)\n{\n  double w1 = q1(0);\n  double w2 = q2(0);\n  const auto\u0026 v1 = q1.tail\u003c3\u003e();\n  const auto\u0026 v2 = q2.tail\u003c3\u003e();\n  Vector4d r;\n  r \u003c\u003c w1 * w2 - v1.dot(v2), v1.cross(v2) + w1 * v2 + w2 * v1;\n  return r;\n}\n\nEigen::Matrix\u003cdouble, 4, 8\u003e dquatProduct(const Eigen::Vector4d\u0026 q1, const Eigen::Vector4d\u0026 q2)\n{\n  double w1 = q1(0);\n  double w2 = q2(0);\n  const auto\u0026 v1 = q1.tail\u003c3\u003e();\n  const auto\u0026 v2 = q2.tail\u003c3\u003e();\n\n  Matrix\u003cdouble, 4, 8\u003e dr;\n  dr.row(0) \u003c\u003c w2, -v2.transpose(), w1, -v1.transpose();\n  dr.row(1) \u003c\u003c q2(1), q2(0), q2(3), -q2(2), q1(1), q1(0), -q1(3), q1(2);\n  dr.row(2) \u003c\u003c q2(2), -q2(3), q2(0), q2(1), q1(2), q1(3), q1(0), -q1(1);\n  dr.row(3) \u003c\u003c q2(3), q2(2), -q2(1), q2(0), q1(3), -q1(2), q1(1), q1(0);\n  return dr;\n}\n\nEigen::Vector3d quatRotateVec(const Eigen::Vector4d\u0026 q, const Eigen::Vector3d\u0026 v)\n{\n  Vector4d v_quat;\n  v_quat \u003c\u003c 0, v;\n  Vector4d q_times_v = quatProduct(q, v_quat);\n  Vector4d q_conj = quatConjugate(q);\n  Vector4d v_rot = quatProduct(q_times_v, q_conj);\n  Vector3d r = v_rot.bottomRows\u003c3\u003e();\n  return r;\n}\n\nEigen::Matrix\u003cdouble, 3, 7\u003e dquatRotateVec(const Eigen::Vector4d\u0026 q, const Eigen::Vector3d\u0026 v)\n{\n  Matrix\u003cdouble, 4, 7\u003e dq;\n  dq \u003c\u003c Matrix4d::Identity(), MatrixXd::Zero(4, 3);\n  Matrix\u003cdouble, 4, 7\u003e dv = Matrix\u003cdouble, 4, 7\u003e::Zero();\n  dv.bottomRightCorner\u003c3, 3\u003e() = Matrix3d::Identity();\n  Matrix\u003cdouble, 8, 7\u003e dqdv;\n  dqdv \u003c\u003c dq, dv;\n\n  Vector4d v_quat;\n  v_quat \u003c\u003c 0, v;\n  Vector4d q_times_v = quatProduct(q, v_quat);\n  Matrix\u003cdouble, 4, 8\u003e dq_times_v_tmp = dquatProduct(q, v_quat);\n  Matrix\u003cdouble, 4, 7\u003e dq_times_v = dq_times_v_tmp * dqdv;\n\n  Matrix\u003cdouble, 4, 7\u003e dq_conj = dquatConjugate() * dq;\n  Matrix\u003cdouble, 8, 7\u003e dq_times_v_dq_conj;\n  dq_times_v_dq_conj \u003c\u003c dq_times_v, dq_conj;\n  Matrix\u003cdouble, 4, 8\u003e dv_rot_tmp = dquatProduct(q_times_v, quatConjugate(q));\n  Matrix\u003cdouble, 4, 7\u003e dv_rot = dv_rot_tmp * dq_times_v_dq_conj;\n  Eigen::Matrix\u003cdouble, 3, 7\u003e dr = dv_rot.bottomRows(3);\n  return dr;\n}\n\nEigen::Vector4d quatDiff(const Eigen::Vector4d\u0026 q1, const Eigen::Vector4d\u0026 q2)\n{\n  return quatProduct(quatConjugate(q1), q2);\n}\n\nEigen::Matrix\u003cdouble, 4, 8\u003e dquatDiff(const Eigen::Vector4d\u0026 q1, const Eigen::Vector4d\u0026 q2)\n{\n  auto dr = dquatProduct(quatConjugate(q1), q2);\n  dr.block\u003c4, 3\u003e(0, 1) = -dr.block\u003c4, 3\u003e(0, 1);\n  return dr;\n}\n\ndouble quatDiffAxisInvar(const Eigen::Vector4d\u0026 q1, const Eigen::Vector4d\u0026 q2, const Eigen::Vector3d\u0026 u)\n{\n  Vector4d r = quatDiff(q1, q2);\n  double e = -2.0 + 2 * r(0) * r(0) + 2 * pow(u(0) * r(1) + u(1) * r(2) + u(2) * r(3), 2);\n  return e;\n}\n\nEigen::Matrix\u003cdouble, 1, 11\u003e dquatDiffAxisInvar(const Eigen::Vector4d\u0026 q1, const Eigen::Vector4d\u0026 q2, const Eigen::Vector3d\u0026 u)\n{\n  Vector4d r = quatDiff(q1, q2);\n  Matrix\u003cdouble, 4, 8\u003e dr = dquatDiff(q1, q2);\n  Matrix\u003cdouble, 1, 11\u003e de;\n  const auto\u0026 rvec = r.tail\u003c3\u003e();\n  de \u003c\u003c 4.0 * r(0) * dr.row(0) + 4.0 * u.transpose() * rvec *u.transpose() * dr.block\u003c3, 8\u003e(1, 0), 4.0 * u.transpose() * rvec * rvec.transpose();\n  return de;\n}\n\ndouble quatNorm(const Eigen::Vector4d\u0026 q)\n{\n  return std::acos(q(0));\n}\n\nEigen::Vector4d slerp(const Eigen::Vector4d\u0026 q1, const Eigen::Vector4d\u0026 q2, double interpolation_parameter)\n{\n  /*\n   * Q = slerp(q1, q2, f) Spherical linear interpolation between two quaternions\n   *   This function uses the implementation given in Algorithm 8 of [1].\n   *\n   * @param q1   Initial quaternion (w, x, y, z)\n   * @param q2   Final quaternion (w, x, y, z)\n   * @param f    Interpolation parameter between 0 and 1 (inclusive)\n   * @retval Q   Interpolated quaternion(s). 4-by-1 vector.\n   *\n   * [1] Kuffner, J.J., \"Effective sampling and distance metrics for 3D rigid\n   * body path planning,\" Robotics and Automation, 2004. Proceedings. ICRA '04.\n   * 2004 IEEE International Conference on , vol.4, no., pp.3993,3998 Vol.4,\n   * April 26-May 1, 2004\n   * doi: 10.1109/ROBOT.2004.1308895\n   */\n\n  // Compute the quaternion inner product\n  double lambda = (q1.transpose() * q2).value();\n  int q2_sign;\n  if (lambda \u003c 0.0) {\n    // The quaternions are pointing in opposite directions, so use the equivalent alternative representation for q2\n    lambda = -lambda;\n    q2_sign = -1;\n  }\n  else {\n    q2_sign = 1;\n  }\n\n  // Calculate interpolation factors\n  // TODO: do we really want an epsilon so small?\n  double r, s;\n  if (std::abs(1.0 - lambda) \u003c std::numeric_limits\u003cdouble\u003e::epsilon()) {\n    // The quaternions are nearly parallel, so use linear interpolation\n    r = 1.0 - interpolation_parameter;\n    s = interpolation_parameter;\n  }\n  else {\n    double alpha = std::acos(lambda);\n    double gamma = 1.0 / std::sin(alpha);\n    r = std::sin((1.0 - interpolation_parameter) * alpha) * gamma;\n    s = std::sin(interpolation_parameter * alpha) * gamma;\n  }\n\n  Vector4d ret = q1 * r;\n  ret += q2_sign * q2 * s;\n  return ret;\n}\n\nVector4d uniformlyRandomAxisAngle(std::default_random_engine\u0026 generator)\n{\n  std::normal_distribution\u003cdouble\u003e normal;\n  std::uniform_real_distribution\u003cdouble\u003e uniform(-M_PI, M_PI);\n  double angle = uniform(generator);\n  Vector3d axis = Vector3d(normal(generator), normal(generator), normal(generator));\n  axis.normalize();\n  Vector4d a;\n  a \u003c\u003c axis, angle;\n  return a;\n}\n\nVector4d uniformlyRandomQuat(std::default_random_engine\u0026 generator)\n{\n  return axis2quat(uniformlyRandomAxisAngle(generator));\n}\n\nEigen::Matrix3d uniformlyRandomRotmat(std::default_random_engine\u0026 generator)\n{\n  return axis2rotmat(uniformlyRandomAxisAngle(generator));\n}\n\nEigen::Vector3d uniformlyRandomRPY(std::default_random_engine\u0026 generator)\n{\n  return axis2rpy(uniformlyRandomAxisAngle(generator));\n}\n\ntemplate \u003ctypename Derived\u003e\nEigen::Matrix\u003ctypename Derived::Scalar, 3, 1\u003e quat2rpy(const Eigen::MatrixBase\u003cDerived\u003e\u0026 q)\n{\n  EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE(Eigen::MatrixBase\u003cDerived\u003e, 4);\n  auto q_normalized = q.normalized();\n  auto w = q_normalized(0);\n  auto x = q_normalized(1);\n  auto y = q_normalized(2);\n  auto z = q_normalized(3);\n\n  Eigen::Matrix\u003ctypename Derived::Scalar, 3, 1\u003e ret;\n  ret \u003c\u003c std::atan2(2.0*(w*x + y*z), w*w + z*z -(x*x +y*y)),\n      std::asin(2.0*(w*y - z*x)),\n      std::atan2(2.0*(w*z + x*y), w*w + x*x-(y*y+z*z));\n  return ret;\n}\n\ntemplate \u003ctypename Derived\u003e\nEigen::Matrix\u003ctypename Derived::Scalar, 3, 3\u003e quat2rotmat(const Eigen::MatrixBase\u003cDerived\u003e\u0026 q)\n{\n  EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE(Eigen::MatrixBase\u003cDerived\u003e, 4);\n  auto q_normalized = q.normalized();\n  auto w = q_normalized(0);\n  auto x = q_normalized(1);\n  auto y = q_normalized(2);\n  auto z = q_normalized(3);\n\n  Eigen::Matrix\u003ctypename Derived::Scalar, 3, 3\u003e M;\n  M.row(0) \u003c\u003c w * w + x * x - y * y - z * z, 2.0 * x * y - 2.0 * w * z, 2.0 * x * z + 2.0 * w * y;\n  M.row(1) \u003c\u003c 2.0 * x * y + 2.0 * w * z, w * w + y * y - x * x - z * z, 2.0 * y * z - 2.0 * w * x;\n  M.row(2) \u003c\u003c 2.0 * x * z - 2.0 * w * y, 2.0 * y * z + 2.0 * w * x, w * w + z * z - x * x - y * y;\n\n  return M;\n}\n\ntemplate \u003ctypename Derived\u003e\nEigen::Matrix\u003ctypename Derived::Scalar, 4, 1\u003e quat2axis(const Eigen::MatrixBase\u003cDerived\u003e\u0026 q)\n{\n  EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE(Eigen::MatrixBase\u003cDerived\u003e, 4);\n  auto q_normalized = q.normalized();\n  auto s = std::sqrt(1.0 - q_normalized(0) * q_normalized(0)) + std::numeric_limits\u003ctypename Derived::Scalar\u003e::epsilon();\n  Eigen::Matrix\u003ctypename Derived::Scalar, 4, 1\u003e a;\n\n  a \u003c\u003c q_normalized.template tail\u003c3\u003e() / s, 2.0 * std::acos(q_normalized(0));\n  return a;\n}\n\ntemplate \u003ctypename Derived\u003e\nEigen::Vector4d axis2quat(const Eigen::MatrixBase\u003cDerived\u003e\u0026 a)\n{\n  EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE(Eigen::MatrixBase\u003cDerived\u003e, 4);\n  auto axis = a.template head\u003c3\u003e();\n  auto angle = a(3);\n  auto arg = 0.5 * angle;\n  auto c = std::cos(arg);\n  auto s = std::sin(arg);\n  Eigen::Vector4d ret;\n  ret \u003c\u003c c, s * axis;\n  return ret;\n}\n\ntemplate \u003ctypename Derived\u003e\nEigen::Matrix\u003ctypename Derived::Scalar, 3, 3\u003e axis2rotmat(const Eigen::MatrixBase\u003cDerived\u003e\u0026 a)\n{\n  EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE(Eigen::MatrixBase\u003cDerived\u003e, 4);\n  const auto\u0026 axis = (a.template head\u003c3\u003e())/(a.template head\u003c3\u003e()).norm();\n  const auto\u0026 theta = a(3);\n  auto x = axis(0);\n  auto y = axis(1);\n  auto z = axis(2);\n  auto ctheta = std::cos(theta);\n  auto stheta = std::sin(theta);\n  auto c = 1 - ctheta;\n  Eigen::Matrix\u003ctypename Derived::Scalar, 3, 3\u003e R;\n  R \u003c\u003c\n      ctheta + x * x * c , x * y * c - z * stheta, x * z * c + y * stheta,\n      y * x * c + z * stheta, ctheta + y * y * c, y * z * c - x * stheta,\n      z * x * c - y * stheta, z * y * c + x * stheta, ctheta + z * z * c;\n\n  return R;\n}\n\ntemplate \u003ctypename Derived\u003e\nEigen::Matrix\u003ctypename Derived::Scalar, 3, 1\u003e axis2rpy(const Eigen::MatrixBase\u003cDerived\u003e\u0026 a)\n{\n  EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE(Eigen::MatrixBase\u003cDerived\u003e, 4);\n  return quat2rpy(axis2quat(a));\n}\n\ntemplate \u003ctypename Derived\u003e\nEigen::Matrix\u003ctypename Derived::Scalar, 4, 1\u003e rotmat2axis(const Eigen::MatrixBase\u003cDerived\u003e\u0026 R)\n{\n  EIGEN_STATIC_ASSERT_MATRIX_SPECIFIC_SIZE(Eigen::MatrixBase\u003cDerived\u003e, 3, 3);\n\n  typename Derived::Scalar theta = std::acos((R.trace() - 1.0) / 2.0);\n  Vector4d a;\n  if (theta \u003e std::numeric_limits\u003ctypename Derived::Scalar\u003e::epsilon()) {\n    a \u003c\u003c R(2, 1) - R(1, 2), R(0, 2) - R(2, 0), R(1, 0) - R(0, 1), theta;\n    a.head\u003c3\u003e() *= 1.0 / (2.0 * std::sin(theta));\n  }\n  else {\n    a \u003c\u003c 1.0, 0.0, 0.0, 0.0;\n  }\n  return a;\n}\n\ntemplate \u003ctypename Derived\u003e\nEigen::Matrix\u003ctypename Derived::Scalar, 4, 1\u003e rotmat2quat(const Eigen::MatrixBase\u003cDerived\u003e\u0026 M)\n{\n  EIGEN_STATIC_ASSERT_MATRIX_SPECIFIC_SIZE(Eigen::MatrixBase\u003cDerived\u003e, 3, 3);\n  using namespace std;\n\n  Matrix\u003ctypename Derived::Scalar, 4, 3\u003e A;\n  A.row(0) \u003c\u003c 1.0, 1.0, 1.0;\n  A.row(1) \u003c\u003c 1.0, -1.0, -1.0;\n  A.row(2) \u003c\u003c -1.0, 1.0, -1.0;\n  A.row(3) \u003c\u003c -1.0, -1.0, 1.0;\n  Matrix\u003ctypename Derived::Scalar, 4, 1\u003e B = A * M.diagonal();\n  typename Matrix\u003ctypename Derived::Scalar, 4, 1\u003e::Index ind, max_col;\n  typename Derived::Scalar val = B.maxCoeff(\u0026ind, \u0026max_col);\n\n  typename Derived::Scalar w, x, y, z;\n  switch (ind) {\n  case 0: {\n    // val = trace(M)\n    w = sqrt(1.0 + val) / 2.0;\n    typename Derived::Scalar w4 = w * 4.0;\n    x = (M(2, 1) - M(1, 2)) / w4;\n    y = (M(0, 2) - M(2, 0)) / w4;\n    z = (M(1, 0) - M(0, 1)) / w4;\n    break;\n  }\n  case 1: {\n    // val = M(1,1) - M(2,2) - M(3,3)\n    double s = 2.0 * sqrt(1.0 + val);\n    w = (M(2, 1) - M(1, 2)) / s;\n    x = 0.25 * s;\n    y = (M(0, 1) + M(1, 0)) / s;\n    z = (M(0, 2) + M(2, 0)) / s;\n    break;\n  }\n  case 2: {\n    //  % val = M(2,2) - M(1,1) - M(3,3)\n    double s = 2.0 * (sqrt(1.0 + val));\n    w = (M(0, 2) - M(2, 0)) / s;\n    x = (M(0, 1) + M(1, 0)) / s;\n    y = 0.25 * s;\n    z = (M(1, 2) + M(2, 1)) / s;\n    break;\n  }\n  default: {\n    // val = M(3,3) - M(2,2) - M(1,1)\n    double s = 2.0 * (sqrt(1.0 + val));\n    w = (M(1, 0) - M(0, 1)) / s;\n    x = (M(0, 2) + M(2, 0)) / s;\n    y = (M(1, 2) + M(2, 1)) / s;\n    z = 0.25 * s;\n    break;\n  }\n  }\n\n  Eigen::Matrix\u003ctypename Derived::Scalar, 4, 1\u003e q;\n  q \u003c\u003c w, x, y, z;\n  return q;\n}\n\ntemplate\u003ctypename Derived\u003e\nEigen::Matrix\u003ctypename Derived::Scalar, 3, 1\u003e rotmat2rpy(const Eigen::MatrixBase\u003cDerived\u003e\u0026 R)\n{\n  EIGEN_STATIC_ASSERT_MATRIX_SPECIFIC_SIZE(Eigen::MatrixBase\u003cDerived\u003e, 3, 3);\n  using namespace std;\n\n  Eigen::Matrix\u003ctypename Derived::Scalar, 3, 1\u003e rpy;\n  rpy \u003c\u003c atan2(R(2, 1), R(2, 2)), atan2(-R(2, 0), sqrt(pow(R(2, 1), 2.0) + pow(R(2, 2), 2.0))), atan2(R(1, 0), R(0, 0));\n  return rpy;\n}\n\ntemplate\u003ctypename Derived\u003e\nDLLEXPORT Eigen::Matrix\u003ctypename Derived::Scalar, Eigen::Dynamic, 1\u003e rotmat2Representation(const Eigen::MatrixBase\u003cDerived\u003e\u0026 R, int rotation_type)\n{\n  typedef typename Derived::Scalar Scalar;\n  Eigen::Matrix\u003cScalar, Eigen::Dynamic, 1\u003e ret;\n  switch (rotation_type) {\n  case 0:\n    return Eigen::Matrix\u003cScalar, Eigen::Dynamic, 1\u003e(0, 1);\n  case 1:\n    return rotmat2rpy(R);\n  case 2:\n    return rotmat2quat(R);\n  default:\n    throw std::runtime_error(\"rotation representation type not recognized\");\n  }\n}\n\ntemplate\u003ctypename Scalar\u003e\nDLLEXPORT GradientVar\u003cScalar, Eigen::Dynamic, 1\u003e rotmat2Representation(const GradientVar\u003cScalar, SPACE_DIMENSION, SPACE_DIMENSION\u003e\u0026 R, int rotation_type)\n{\n  GradientVar\u003cScalar, Eigen::Dynamic, 1\u003e ret(rotationRepresentationSize(rotation_type), 1, R.getNumVariables(), R.maxOrder());\n  switch (rotation_type) {\n  case 0:\n    // empty matrix, already done\n    break;\n  case 1:\n    ret.value() = rotmat2rpy(R.value());\n    if (R.hasGradient()) {\n      ret.gradient().value() = drotmat2rpy(R.value(), R.gradient().value());\n    }\n    break;\n  case 2:\n    ret.value() = rotmat2quat(R.value());\n    if (R.hasGradient()) {\n      ret.gradient().value() = drotmat2quat(R.value(), R.gradient().value());\n    }\n    break;\n  default:\n    throw std::runtime_error(\"rotation representation type not recognized\");\n  }\n  return ret;\n}\n\ntemplate \u003ctypename Derived\u003e\nGradientVar\u003ctypename Derived::Scalar, QUAT_SIZE, 1\u003e expmap2quat(const Eigen::MatrixBase\u003cDerived\u003e\u0026 v, const int gradient_order)\n{\n  EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE(Eigen::MatrixBase\u003cDerived\u003e, 3);\n  GradientVar\u003ctypename Derived::Scalar, QUAT_SIZE, 1\u003e ret(QUAT_SIZE, 1, EXPMAP_SIZE,gradient_order);\n  auto theta = v.norm();\n  if (theta \u003c pow(std::numeric_limits\u003ctypename Derived::Scalar\u003e::epsilon(),0.25)) {\n    ret.value() = expmap2quatDegenerate(v, theta);\n    if(gradient_order\u003e0)\n    {\n      ret.gradient().value() = dexpmap2quatDegenerate(v, theta);\n      if(gradient_order\u003e1)\n      {\n        ret.gradient().gradient().value() = ddexpmap2quatDegenerate(v, theta);\n        if(gradient_order\u003e2)\n        {\n          throw std::runtime_error(\"expmap2quat does not support gradient order larger than 2\");\n        }\n      }\n    }\n  } else {\n    ret.value() = expmap2quatNonDegenerate(v, theta);\n    if(gradient_order\u003e0)\n    {\n      ret.gradient().value() = dexpmap2quatNonDegenerate(v, theta);\n      if(gradient_order\u003e1)\n      {\n        ret.gradient().gradient().value() = ddexpmap2quatNonDegenerate(v, theta);\n        if(gradient_order\u003e2)\n        {\n          throw std::runtime_error(\"expmap2quat does not support gradient order larger than 2\");\n        }\n      }\n    }\n  }\n  return ret;\n}\n\nDLLEXPORT int rotationRepresentationSize(int rotation_type)\n{\n  switch (rotation_type) {\n  case 0:\n    return 0;\n    break;\n  case 1:\n    return 3;\n    break;\n  case 2:\n    return 4;\n    break;\n  default:\n    throw std::runtime_error(\"rotation representation type not recognized\");\n  }\n}\n\ntemplate\u003ctypename Derived\u003e\nEigen::Matrix\u003ctypename Derived::Scalar, 4, 1\u003e rpy2axis(const Eigen::MatrixBase\u003cDerived\u003e\u0026 rpy)\n{\n  return quat2axis(rpy2quat(rpy));\n}\n\ntemplate\u003ctypename Derived\u003e\nEigen::Matrix\u003ctypename Derived::Scalar, 4, 1\u003e rpy2quat(const Eigen::MatrixBase\u003cDerived\u003e\u0026 rpy)\n{\n  EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE(Eigen::MatrixBase\u003cDerived\u003e, 3);\n  auto rpy_2 = (rpy / 2.0).array();\n  auto s = rpy_2.sin();\n  auto c = rpy_2.cos();\n\n  Vector4d q;\n  q \u003c\u003c c(0)*c(1)*c(2) + s(0)*s(1)*s(2),\n        s(0)*c(1)*c(2) - c(0)*s(1)*s(2),\n        c(0)*s(1)*c(2) + s(0)*c(1)*s(2),\n        c(0)*c(1)*s(2) - s(0)*s(1)*c(2);\n\n  q /= q.norm() + std::numeric_limits\u003ctypename Derived::Scalar\u003e::epsilon();\n  return q;\n}\n\ntemplate\u003ctypename Derived\u003e\nEigen::Matrix\u003ctypename Derived::Scalar, 3, 3\u003e rpy2rotmat(const Eigen::MatrixBase\u003cDerived\u003e\u0026 rpy)\n{\n  EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE(Eigen::MatrixBase\u003cDerived\u003e, 3);\n  auto rpy_array = rpy.array();\n  auto s = rpy_array.sin();\n  auto c = rpy_array.cos();\n\n  Eigen::Matrix\u003ctypename Derived::Scalar, 3, 3\u003e R;\n  R.row(0) \u003c\u003c c(2) * c(1), c(2) * s(1) * s(0) - s(2) * c(0), c(2) * s(1) * c(0) + s(2) * s(0);\n  R.row(1) \u003c\u003c s(2) * c(1), s(2) * s(1) * s(0) + c(2) * c(0), s(2) * s(1) * c(0) - c(2) * s(0);\n  R.row(2) \u003c\u003c -s(1), c(1) * s(0), c(1) * c(0);\n\n  return R;\n}\n\nMatrix3d rotz(double theta) {\n  // returns 3D rotation matrix (about the z axis)\n  Matrix3d M;\n  double c=cos(theta);\n  double s=sin(theta);\n  M \u003c\u003c c,-s, 0,\n     s, c, 0,\n     0, 0, 1;\n  return M;\n}\n\n\nvoid rotz(double theta, Matrix3d \u0026M, Matrix3d \u0026dM, Matrix3d \u0026ddM)\n{\n  double c=cos(theta), s=sin(theta);\n  M \u003c\u003c c,-s,0, s,c,0, 0,0,1;\n  dM \u003c\u003c -s,-c,0, c,-s,0, 0,0,0;\n  ddM \u003c\u003c -c,s,0, -s,-c,0, 0,0,0;\n}\n\ntemplate\u003ctypename Derived\u003e\nEigen::Matrix\u003ctypename Derived::Scalar,9,3\u003e drpy2rotmat(const Eigen::MatrixBase\u003cDerived\u003e\u0026 rpy)\n{\n  EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE(Eigen::MatrixBase\u003cDerived\u003e, 3);\n  auto rpy_array = rpy.array();\n  auto s = rpy_array.sin();\n  auto c = rpy_array.cos();\n\n\tEigen::Matrix\u003ctypename Derived::Scalar, 9, 3\u003e dR;\n\tdR.row(0) \u003c\u003c 0, c(2)*-s(1), c(1)*-s(2);\n\tdR.row(1) \u003c\u003c 0, -s(1)*s(2), c(2)*c(1);\n\tdR.row(2) \u003c\u003c 0, -c(1), 0;\n\tdR.row(3) \u003c\u003c c(2)*s(1)*c(0)-s(2)*-s(0), c(2)*c(1)*s(0), -s(2)*s(1)*s(0)-c(2)*c(0);\n\tdR.row(4) \u003c\u003c s(2)*s(1)*c(0)+c(2)*-s(0), s(2)*c(1)*s(0), c(2)*s(1)*s(0)-s(2)*c(0);\n\tdR.row(5) \u003c\u003c c(1)*c(0), -s(1)*s(0),0;\n\tdR.row(6) \u003c\u003c c(2)*s(1)*-s(0)+s(2)*c(0), c(2)*c(1)*c(0), -s(2)*s(1)*c(0)+c(2)*s(0);\n\tdR.row(7) \u003c\u003c s(2)*s(1)*-s(0)-c(2)*c(0), s(2)*c(1)*c(0), c(2)*s(1)*c(0)+s(2)*s(0);\n\tdR.row(8) \u003c\u003c c(1)*-s(0), -s(1)*c(0), 0; \n\n\treturn dR;\n}\n\n// NOTE: not reshaping second derivative to Matlab geval output format!\ntemplate \u003ctypename Derived\u003e\nvoid normalizeVec(\n    const Eigen::MatrixBase\u003cDerived\u003e\u0026 x,\n    typename Derived::PlainObject\u0026 x_norm,\n    typename Gradient\u003cDerived, Derived::RowsAtCompileTime, 1\u003e::type* dx_norm,\n    typename Gradient\u003cDerived, Derived::RowsAtCompileTime, 2\u003e::type* ddx_norm) {\n\n  typename Derived::Scalar xdotx = x.squaredNorm();\n  typename Derived::Scalar norm_x = std::sqrt(xdotx);\n  x_norm = x / norm_x;\n\n  if (dx_norm) {\n    dx_norm-\u003esetIdentity(x.rows(), x.rows());\n    (*dx_norm) -= x * x.transpose() / xdotx;\n    (*dx_norm) /= norm_x;\n\n    if (ddx_norm) {\n      auto dx_norm_transpose = transposeGrad(*dx_norm, x.rows());\n      auto ddx_norm_times_norm = -matGradMultMat(x_norm, x_norm.transpose(), (*dx_norm), dx_norm_transpose);\n      auto dnorm_inv = -x.transpose() / (xdotx * norm_x);\n      (*ddx_norm) = ddx_norm_times_norm / norm_x;\n      auto temp = (*dx_norm) * norm_x;\n      typename Derived::Index n = x.rows();\n      for (int col = 0; col \u003c n; col++) {\n        auto column_as_matrix = (dnorm_inv(0, col) * temp);\n        for (int row_block = 0; row_block \u003c n; row_block++) {\n          ddx_norm-\u003eblock(row_block * n, col, n, 1) += column_as_matrix.col(row_block);\n        }\n      }\n    }\n  }\n}\n\n\n\ntemplate \u003ctypename Derived\u003e\ntypename Gradient\u003cMatrix\u003ctypename Derived::Scalar, 3, 3\u003e, QUAT_SIZE\u003e::type dquat2rotmat(const Eigen::MatrixBase\u003cDerived\u003e\u0026 q)\n{\n  EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE(Eigen::MatrixBase\u003cDerived\u003e, QUAT_SIZE);\n\n  typename Gradient\u003cMatrix\u003ctypename Derived::Scalar, 3, 3\u003e, QUAT_SIZE\u003e::type ret;\n  typename Eigen::MatrixBase\u003cDerived\u003e::PlainObject qtilde;\n  typename Gradient\u003cDerived, QUAT_SIZE\u003e::type dqtilde;\n  normalizeVec(q, qtilde, \u0026dqtilde);\n\n  typedef typename Derived::Scalar Scalar;\n  Scalar w=qtilde(0);\n  Scalar x=qtilde(1);\n  Scalar y=qtilde(2);\n  Scalar z=qtilde(3);\n\n  ret \u003c\u003c w, x, -y, -z, z, y, x, w, -y, z, -w, x, -z, y, x, -w, w, -x, y, -z, x, w, z, y, y, z, w, x, -x, -w, z, y, w, -x, -y, z;\n  ret *= 2.0;\n  ret *= dqtilde;\n  return ret;\n}\n\ntemplate \u003ctypename DerivedR, typename DerivedDR\u003e\ntypename Gradient\u003cEigen::Matrix\u003ctypename DerivedR::Scalar, RPY_SIZE, 1\u003e, DerivedDR::ColsAtCompileTime\u003e::type drotmat2rpy(\n    const Eigen::MatrixBase\u003cDerivedR\u003e\u0026 R,\n    const Eigen::MatrixBase\u003cDerivedDR\u003e\u0026 dR)\n{\n  EIGEN_STATIC_ASSERT_MATRIX_SPECIFIC_SIZE(Eigen::MatrixBase\u003cDerivedR\u003e, SPACE_DIMENSION, SPACE_DIMENSION);\n  EIGEN_STATIC_ASSERT(Eigen::MatrixBase\u003cDerivedDR\u003e::RowsAtCompileTime == RotmatSize, THIS_METHOD_IS_ONLY_FOR_MATRICES_OF_A_SPECIFIC_SIZE);\n\n  typename DerivedDR::Index nq = dR.cols();\n  typedef typename DerivedR::Scalar Scalar;\n  typedef typename Gradient\u003cEigen::Matrix\u003cScalar, RPY_SIZE, 1\u003e, DerivedDR::ColsAtCompileTime\u003e::type ReturnType;\n  ReturnType drpy(RPY_SIZE, nq);\n\n  auto dR11_dq = getSubMatrixGradient\u003cDerivedDR::ColsAtCompileTime\u003e(dR, 0, 0, R.rows());\n  auto dR21_dq = getSubMatrixGradient\u003cDerivedDR::ColsAtCompileTime\u003e(dR, 1, 0, R.rows());\n  auto dR31_dq = getSubMatrixGradient\u003cDerivedDR::ColsAtCompileTime\u003e(dR, 2, 0, R.rows());\n  auto dR32_dq = getSubMatrixGradient\u003cDerivedDR::ColsAtCompileTime\u003e(dR, 2, 1, R.rows());\n  auto dR33_dq = getSubMatrixGradient\u003cDerivedDR::ColsAtCompileTime\u003e(dR, 2, 2, R.rows());\n\n  Scalar sqterm = R(2,1) * R(2,1) + R(2,2) * R(2,2);\n\n  using namespace std;\n  // droll_dq\n  drpy.row(0) = (R(2, 2) * dR32_dq - R(2, 1) * dR33_dq) / sqterm;\n\n  // dpitch_dq\n  Scalar sqrt_sqterm = sqrt(sqterm);\n  drpy.row(1) = (-sqrt_sqterm * dR31_dq + R(2, 0) / sqrt_sqterm * (R(2, 1) * dR32_dq + R(2, 2) * dR33_dq)) / (R(2, 0) * R(2, 0) + R(2, 1) * R(2, 1) + R(2, 2) * R(2, 2));\n\n  // dyaw_dq\n  sqterm = R(0, 0) * R(0, 0) + R(1, 0) * R(1, 0);\n  drpy.row(2) = (R(0, 0) * dR21_dq - R(1, 0) * dR11_dq) / sqterm;\n  return drpy;\n}\n\ntemplate \u003ctypename DerivedR, typename DerivedDR\u003e\ntypename Gradient\u003cEigen::Matrix\u003ctypename DerivedR::Scalar, QUAT_SIZE, 1\u003e, DerivedDR::ColsAtCompileTime\u003e::type drotmat2quat(\n    const Eigen::MatrixBase\u003cDerivedR\u003e\u0026 R,\n    const Eigen::MatrixBase\u003cDerivedDR\u003e\u0026 dR)\n{\n  EIGEN_STATIC_ASSERT_MATRIX_SPECIFIC_SIZE(Eigen::MatrixBase\u003cDerivedR\u003e, SPACE_DIMENSION, SPACE_DIMENSION);\n  EIGEN_STATIC_ASSERT(Eigen::MatrixBase\u003cDerivedDR\u003e::RowsAtCompileTime == RotmatSize, THIS_METHOD_IS_ONLY_FOR_MATRICES_OF_A_SPECIFIC_SIZE);\n\n  typedef typename DerivedR::Scalar Scalar;\n  typedef typename Gradient\u003cEigen::Matrix\u003cScalar, QUAT_SIZE, 1\u003e, DerivedDR::ColsAtCompileTime\u003e::type ReturnType;\n  typename DerivedDR::Index nq = dR.cols();\n\n  auto dR11_dq = getSubMatrixGradient\u003cDerivedDR::ColsAtCompileTime\u003e(dR, 0, 0, R.rows());\n  auto dR12_dq = getSubMatrixGradient\u003cDerivedDR::ColsAtCompileTime\u003e(dR, 0, 1, R.rows());\n  auto dR13_dq = getSubMatrixGradient\u003cDerivedDR::ColsAtCompileTime\u003e(dR, 0, 2, R.rows());\n  auto dR21_dq = getSubMatrixGradient\u003cDerivedDR::ColsAtCompileTime\u003e(dR, 1, 0, R.rows());\n  auto dR22_dq = getSubMatrixGradient\u003cDerivedDR::ColsAtCompileTime\u003e(dR, 1, 1, R.rows());\n  auto dR23_dq = getSubMatrixGradient\u003cDerivedDR::ColsAtCompileTime\u003e(dR, 1, 2, R.rows());\n  auto dR31_dq = getSubMatrixGradient\u003cDerivedDR::ColsAtCompileTime\u003e(dR, 2, 0, R.rows());\n  auto dR32_dq = getSubMatrixGradient\u003cDerivedDR::ColsAtCompileTime\u003e(dR, 2, 1, R.rows());\n  auto dR33_dq = getSubMatrixGradient\u003cDerivedDR::ColsAtCompileTime\u003e(dR, 2, 2, R.rows());\n\n  Matrix\u003cScalar, 4, 3\u003e A;\n  A.row(0) \u003c\u003c 1.0, 1.0, 1.0;\n  A.row(1) \u003c\u003c 1.0, -1.0, -1.0;\n  A.row(2) \u003c\u003c -1.0, 1.0, -1.0;\n  A.row(3) \u003c\u003c -1.0, -1.0, 1.0;\n  Matrix\u003cScalar, 4, 1\u003e B = A * R.diagonal();\n  typename Matrix\u003cScalar, 4, 1\u003e::Index ind, max_col;\n  Scalar val = B.maxCoeff(\u0026ind, \u0026max_col);\n\n  ReturnType dq(QUAT_SIZE, nq);\n  using namespace std;\n  switch (ind) {\n  case 0: {\n    // val = trace(M)\n    auto dvaldq = dR11_dq + dR22_dq + dR33_dq;\n    auto dwdq = dvaldq / (4.0 * sqrt(1.0 + val));\n    auto w = sqrt(1.0 + val) / 2.0;\n    auto wsquare4 = 4.0 * w * w;\n    dq.row(0) = dwdq;\n    dq.row(1) = ((dR32_dq - dR23_dq) * w - (R(2, 1) - R(1, 2)) * dwdq) / wsquare4;\n    dq.row(2) = ((dR13_dq - dR31_dq) * w - (R(0, 2) - R(2, 0)) * dwdq) / wsquare4;\n    dq.row(3) = ((dR21_dq - dR12_dq) * w - (R(1, 0) - R(0, 1)) * dwdq) / wsquare4;\n    break;\n  }\n  case 1: {\n    // val = M(1,1) - M(2,2) - M(3,3)\n    auto dvaldq = dR11_dq - dR22_dq - dR33_dq;\n    auto s = 2.0 * sqrt(1.0 + val);\n    auto ssquare = s * s;\n    auto dsdq = dvaldq / sqrt(1.0 + val);\n    dq.row(0) = ((dR32_dq - dR23_dq) * s - (R(2, 1) - R(1, 2)) * dsdq) / ssquare;\n    dq.row(1) = .25 * dsdq;\n    dq.row(2) = ((dR12_dq + dR21_dq) * s - (R(0, 1) + R(1, 0)) * dsdq) / ssquare;\n    dq.row(3) = ((dR13_dq + dR31_dq) * s - (R(0, 2) + R(2, 0)) * dsdq) / ssquare;\n    break;\n  }\n  case 2: {\n    // val = M(2,2) - M(1,1) - M(3,3)\n    auto dvaldq = -dR11_dq + dR22_dq - dR33_dq;\n    auto s = 2.0 * (sqrt(1.0 + val));\n    auto ssquare = s * s;\n    auto dsdq = dvaldq / sqrt(1.0 + val);\n    dq.row(0) = ((dR13_dq - dR31_dq) * s - (R(0, 2) - R(2, 0)) * dsdq) / ssquare;\n    dq.row(1) = ((dR12_dq + dR21_dq) * s - (R(0, 1) + R(1, 0)) * dsdq) / ssquare;\n    dq.row(2) = .25 * dsdq;\n    dq.row(3) = ((dR23_dq + dR32_dq) * s - (R(1, 2) + R(2, 1)) * dsdq) / ssquare;\n    break;\n  }\n  default: {\n    // val = M(3,3) - M(2,2) - M(1,1)\n    auto dvaldq = -dR11_dq - dR22_dq + dR33_dq;\n    auto s = 2.0 * (sqrt(1.0 + val));\n    auto ssquare = s * s;\n    auto dsdq = dvaldq / sqrt(1.0 + val);\n    dq.row(0) = ((dR21_dq - dR12_dq) * s - (R(1, 0) - R(0, 1)) * dsdq) / ssquare;\n    dq.row(1) = ((dR13_dq + dR31_dq) * s - (R(0, 2) + R(2, 0)) * dsdq) / ssquare;\n    dq.row(2) = ((dR23_dq + dR32_dq) * s - (R(1, 2) + R(2, 1)) * dsdq) / ssquare;\n    dq.row(3) = .25 * dsdq;\n    break;\n  }\n  }\n  return dq;\n}\n\ntemplate\u003ctypename Derived\u003e\nEigen::Matrix\u003ctypename Derived::Scalar, 3, 3\u003e vectorToSkewSymmetric(const Eigen::MatrixBase\u003cDerived\u003e\u0026 p)\n{\n  EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE(Eigen::MatrixBase\u003cDerived\u003e, SPACE_DIMENSION);\n  Eigen::Matrix\u003ctypename Derived::Scalar, 3, 3\u003e ret;\n  ret \u003c\u003c 0.0, -p(2), p(1), p(2), 0.0, -p(0), -p(1), p(0), 0.0;\n  return ret;\n}\n\ntemplate \u003ctypename DerivedA, typename DerivedB\u003e\nEigen::Matrix\u003ctypename DerivedA::Scalar, 3, Eigen::Dynamic\u003e dcrossProduct(\n    const Eigen::MatrixBase\u003cDerivedA\u003e\u0026 a,\n    const Eigen::MatrixBase\u003cDerivedB\u003e\u0026 b,\n    const typename Gradient\u003cDerivedA, Eigen::Dynamic\u003e::type\u0026 da,\n    const typename Gradient\u003cDerivedB, Eigen::Dynamic\u003e::type\u0026 db)\n{\n  Eigen::Matrix\u003ctypename DerivedA::Scalar, 3, Eigen::Dynamic\u003e ret(3, da.cols());\n  ret.noalias() = da.colwise().cross(b);\n  ret.noalias() -= db.colwise().cross(a);\n  return ret;\n}\n\ntemplate \u003ctypename DerivedQ, typename DerivedM, typename DerivedDM\u003e\nvoid angularvel2quatdotMatrix(const Eigen::MatrixBase\u003cDerivedQ\u003e\u0026 q,\n    Eigen::MatrixBase\u003cDerivedM\u003e\u0026 M,\n    Eigen::MatrixBase\u003cDerivedDM\u003e* dM)\n{\n  // note: not normalizing to match MATLAB implementation\n  M.resize(QUAT_SIZE, SPACE_DIMENSION);\n  M.row(0) \u003c\u003c -q(1), -q(2), -q(3);\n  M.row(1) \u003c\u003c q(0), q(3), -q(2);\n  M.row(2) \u003c\u003c -q(3), q(0), q(1);\n  M.row(3) \u003c\u003c q(2), -q(1), q(0);\n  M *= 0.5;\n\n  if (dM) {\n    (*dM) \u003c\u003c 0.0, -0.5, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.5, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, -0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 0.0, -0.5, 0.0, 0.0, 0.0, 0.0, 0.0, -0.5, 0.0, 0.0, -0.5, 0.0, 0.0, 0.5, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0;\n  }\n}\n\ntemplate\u003ctypename DerivedQ, typename DerivedM\u003e\nvoid quatdot2angularvelMatrix(const Eigen::MatrixBase\u003cDerivedQ\u003e\u0026 q, Eigen::MatrixBase\u003cDerivedM\u003e\u0026 M, typename Gradient\u003cDerivedM, QUAT_SIZE, 1\u003e::type* dM)\n{\n  EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE(Eigen::MatrixBase\u003cDerivedQ\u003e, QUAT_SIZE);\n  EIGEN_STATIC_ASSERT_MATRIX_SPECIFIC_SIZE(Eigen::MatrixBase\u003cDerivedM\u003e, SPACE_DIMENSION, QUAT_SIZE);\n\n  typename DerivedQ::PlainObject qtilde;\n  if (dM) {\n    typename Gradient\u003cDerivedQ, QUAT_SIZE\u003e::type dqtilde;\n    normalizeVec(q, qtilde, \u0026dqtilde);\n    (*dM) \u003c\u003c 0.0, -2.0, 0.0, 0.0, 0.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0, -2.0, 2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 2.0, 0.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0, -2.0, 2.0, 0.0, 0.0, 0.0, 0.0, 2.0, 0.0, 0.0, 0.0, 0.0, 2.0, 0.0, 0.0, -2.0, 0.0, 0.0, 2.0, 0.0, 0.0, 0.0;\n    (*dM) *= dqtilde;\n  } else {\n    normalizeVec(q, qtilde);\n  }\n  M \u003c\u003c -qtilde(1), qtilde(0), -qtilde(3), qtilde(2), -qtilde(2), qtilde(3), qtilde(0), -qtilde(1), -qtilde(3), -qtilde(2), qtilde(1), qtilde(0);\n  M *= 2.0;\n}\n\ntemplate\u003ctypename DerivedRPY, typename DerivedPhi, typename DerivedDPhi, typename DerivedDDPhi\u003e\nvoid angularvel2rpydotMatrix(const Eigen::MatrixBase\u003cDerivedRPY\u003e\u0026 rpy,\n    typename Eigen::MatrixBase\u003cDerivedPhi\u003e\u0026 phi,\n    typename Eigen::MatrixBase\u003cDerivedDPhi\u003e* dphi,\n    typename Eigen::MatrixBase\u003cDerivedDDPhi\u003e* ddphi)\n{\n  phi.resize(RPY_SIZE, SPACE_DIMENSION);\n\n  typedef typename DerivedRPY::Scalar Scalar;\n  Scalar p = rpy(1);\n  Scalar y = rpy(2);\n\n  using namespace std;\n  Scalar sy = sin(y);\n  Scalar cy = cos(y);\n  Scalar sp = sin(p);\n  Scalar cp = cos(p);\n  Scalar tp = sp / cp;\n\n  phi \u003c\u003c cy / cp, sy / cp, 0.0, -sy, cy, 0.0, cy * tp, tp * sy, 1.0;\n  if (dphi) {\n    dphi-\u003eresize(phi.size(), RPY_SIZE);\n    Scalar sp2 = sp * sp;\n    Scalar cp2 = cp * cp;\n    (*dphi) \u003c\u003c 0.0, (cy * sp) / cp2, -sy / cp, 0.0, 0.0, -cy, 0.0, cy + (cy * sp2) / cp2, -(sp * sy) / cp, 0.0, (sp * sy) / cp2, cy / cp, 0.0, 0.0, -sy, 0.0, sy + (sp2 * sy) / cp2, (cy * sp) / cp, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0;\n\n    if (ddphi) {\n      ddphi-\u003eresize(dphi-\u003esize(), RPY_SIZE);\n      Scalar cp3 = cp2 * cp;\n      (*ddphi) \u003c\u003c 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -(cy * (cp2 - 2.0)) / cp3, (sp * sy) / (sp2 - 1.0), 0.0, 0.0, 0.0, 0.0, (2.0 * cy * sp) / cp3, sy / (sp2 - 1.0), 0.0, (2.0 * sy - cp2 * sy)\n          / cp3, (cy * sp) / cp2, 0.0, 0.0, 0.0, 0.0, (2.0 * sp * sy) / cp3, cy / cp2, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, (sp * sy) / (sp2 - 1.0), -cy / cp, 0.0, 0.0, sy, 0.0, sy / (sp2 - 1.0), -(cy * sp) / cp, 0.0, (cy * sp) / cp2, -sy / cp, 0.0, 0.0, -cy, 0.0, cy / cp2, -(sp * sy)\n          / cp, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0;\n    }\n  }\n}\n\ntemplate\u003ctypename Derived\u003e\nDLLEXPORT GradientVar\u003ctypename Derived::Scalar, Eigen::Dynamic, SPACE_DIMENSION\u003e angularvel2RepresentationDotMatrix(\n    int rotation_type, const Eigen::MatrixBase\u003cDerived\u003e\u0026 qrot, int gradient_order)\n{\n  // note: gradients w.r.t. qrot\n  GradientVar\u003ctypename Derived::Scalar, Eigen::Dynamic, SPACE_DIMENSION\u003e ret(qrot.rows(), SPACE_DIMENSION, qrot.rows(), gradient_order);\n  switch (rotation_type) {\n  case 0:\n    // done\n    break;\n  case 1: {\n    if (gradient_order \u003e 1) {\n      angularvel2rpydotMatrix(qrot, ret.value(), \u0026ret.gradient().value(), \u0026ret.gradient().gradient().value());\n    }\n    else if (gradient_order \u003e 0) {\n      angularvel2rpydotMatrix(qrot, ret.value(), \u0026ret.gradient().value(), (MatrixXd*) nullptr);\n    }\n    else {\n      angularvel2rpydotMatrix(qrot, ret.value(), (MatrixXd*) nullptr, (MatrixXd*) nullptr);\n    }\n    break;\n  }\n  case 2: {\n    if (gradient_order \u003e 1) {\n      ret.gradient().gradient().value().setZero();\n    }\n    if (gradient_order \u003e 0) {\n      angularvel2quatdotMatrix(qrot, ret.value(), \u0026ret.gradient().value());\n    }\n    else {\n      angularvel2quatdotMatrix(qrot, ret.value(), (MatrixXd*) nullptr);\n    }\n    break;\n  }\n  default:\n    throw std::runtime_error(\"rotation representation type not recognized\");\n  }\n  return ret;\n}\n\ntemplate\u003ctypename DerivedRPY, typename DerivedE\u003e\nvoid rpydot2angularvelMatrix(const Eigen::MatrixBase\u003cDerivedRPY\u003e\u0026 rpy,\n\t\tEigen::MatrixBase\u003cDerivedE\u003e\u0026 E,\n\t\ttypename Gradient\u003cDerivedE,RPY_SIZE,1\u003e::type* dE)\n{\n  EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE(Eigen::MatrixBase\u003cDerivedRPY\u003e, RPY_SIZE);\n  EIGEN_STATIC_ASSERT_MATRIX_SPECIFIC_SIZE(Eigen::MatrixBase\u003cDerivedE\u003e, SPACE_DIMENSION,RPY_SIZE);\n  typedef typename DerivedRPY::Scalar Scalar;\n  Scalar p = rpy(1);\n  Scalar y = rpy(2);\n  Scalar sp = sin(p);\n  Scalar cp = cos(p);\n  Scalar sy = sin(y);\n  Scalar cy = cos(y);\n\n  using namespace std;\n  E \u003c\u003c cp*cy, -sy, 0.0, cp*sy, cy, 0.0, -sp, 0.0, 1.0;\n  if(dE)\n  {\n    (*dE)\u003c\u003c 0.0, -sp*cy, -cp*sy, 0.0, -sp*sy, cp*cy, 0.0, -cp, 0.0, 0.0, 0.0, -cy, 0.0, 0.0, -sy, 0.0, 0.0, 0.0,  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0;\n  }\n}\n\ntemplate\u003ctypename DerivedM\u003e\ntypename TransformSpatial\u003cDerivedM\u003e::type transformSpatialMotion(\n    const Eigen::Transform\u003ctypename DerivedM::Scalar, 3, Eigen::Isometry\u003e\u0026 T,\n    const Eigen::MatrixBase\u003cDerivedM\u003e\u0026 M) {\n  Eigen::Matrix\u003ctypename DerivedM::Scalar, TWIST_SIZE, DerivedM::ColsAtCompileTime\u003e ret(TWIST_SIZE, M.cols());\n  ret.template topRows\u003c3\u003e().noalias() = T.linear() * M.template topRows\u003c3\u003e();\n  ret.template bottomRows\u003c3\u003e().noalias() = -ret.template topRows\u003c3\u003e().colwise().cross(T.translation());\n  ret.template bottomRows\u003c3\u003e().noalias() += T.linear() * M.template bottomRows\u003c3\u003e();\n  return ret;\n}\n\ntemplate\u003ctypename DerivedF\u003e\ntypename TransformSpatial\u003cDerivedF\u003e::type transformSpatialForce(\n    const Eigen::Transform\u003ctypename DerivedF::Scalar, 3, Eigen::Isometry\u003e\u0026 T,\n    const Eigen::MatrixBase\u003cDerivedF\u003e\u0026 F) {\n  Eigen::Matrix\u003ctypename DerivedF::Scalar, TWIST_SIZE, DerivedF::ColsAtCompileTime\u003e ret(TWIST_SIZE, F.cols());\n  ret.template bottomRows\u003c3\u003e().noalias() = T.linear() * F.template bottomRows\u003c3\u003e().eval();\n  ret.template topRows\u003c3\u003e() = -ret.template bottomRows\u003c3\u003e().colwise().cross(T.translation());\n  ret.template topRows\u003c3\u003e().noalias() += T.linear() * F.template topRows\u003c3\u003e();\n  return ret;\n}\n\ntemplate\u003ctypename DerivedI\u003e\nGradientVar\u003ctypename DerivedI::Scalar, TWIST_SIZE, TWIST_SIZE\u003e transformSpatialInertia(\n    const Eigen::Transform\u003ctypename DerivedI::Scalar, SPACE_DIMENSION, Eigen::Isometry\u003e\u0026 T_current_to_new,\n    const typename Gradient\u003ctypename Eigen::Transform\u003ctypename DerivedI::Scalar, SPACE_DIMENSION, Eigen::Isometry\u003e::MatrixType, Eigen::Dynamic\u003e::type* dT_current_to_new,\n    const Eigen::MatrixBase\u003cDerivedI\u003e\u0026 I)\n{\n  int gradient_order;\n  typename DerivedI::Index nq;\n  if (dT_current_to_new) {\n    gradient_order = 1;\n    nq = dT_current_to_new-\u003ecols();\n  }\n  else {\n    nq = 0;\n    gradient_order = 0;\n  }\n\n  GradientVar\u003ctypename DerivedI::Scalar, TWIST_SIZE, TWIST_SIZE\u003e ret(TWIST_SIZE, TWIST_SIZE, nq, gradient_order);\n  auto I_half_transformed = transformSpatialForce(T_current_to_new, I);\n\n  ret.value() = transformSpatialForce(T_current_to_new, I_half_transformed.transpose());\n\n  if (gradient_order \u003e 0) {\n    auto dI = Eigen::Matrix\u003ctypename DerivedI::Scalar, DerivedI::SizeAtCompileTime, Eigen::Dynamic\u003e::Zero(I.size(), nq).eval(); // TODO: would be better not to evaluate and make another explicit instantiation\n    auto dI_half_transformed = dTransformSpatialForce(T_current_to_new, I, *dT_current_to_new, dI);\n    auto dI_half_transformed_transpose = transposeGrad(dI_half_transformed, I_half_transformed.rows());\n    ret.gradient().value() = dTransformSpatialForce(T_current_to_new, I_half_transformed.transpose(), *dT_current_to_new, dI_half_transformed_transpose);\n  }\n  return ret;\n}\n\ntemplate\u003ctypename DerivedA, typename DerivedB\u003e\ntypename TransformSpatial\u003cDerivedB\u003e::type crossSpatialMotion(\n  const Eigen::MatrixBase\u003cDerivedA\u003e\u0026 a,\n  const Eigen::MatrixBase\u003cDerivedB\u003e\u0026 b) {\n  typename TransformSpatial\u003cDerivedB\u003e::type ret(TWIST_SIZE, b.cols());\n  ret.template topRows\u003c3\u003e() = -b.template topRows\u003c3\u003e().colwise().cross(a.template topRows\u003c3\u003e());\n  ret.template bottomRows\u003c3\u003e() = -b.template topRows\u003c3\u003e().colwise().cross(a.template bottomRows\u003c3\u003e());\n  ret.template bottomRows\u003c3\u003e() -= b.template bottomRows\u003c3\u003e().colwise().cross(a.template topRows\u003c3\u003e());\n  return ret;\n}\n\ntemplate\u003ctypename DerivedA, typename DerivedB\u003e\ntypename TransformSpatial\u003cDerivedB\u003e::type crossSpatialForce(\n  const Eigen::MatrixBase\u003cDerivedA\u003e\u0026 a,\n  const Eigen::MatrixBase\u003cDerivedB\u003e\u0026 b) {\n  typename TransformSpatial\u003cDerivedB\u003e::type ret(TWIST_SIZE, b.cols());\n  ret.template topRows\u003c3\u003e() = -b.template topRows\u003c3\u003e().colwise().cross(a.template topRows\u003c3\u003e());\n  ret.template topRows\u003c3\u003e() -= b.template bottomRows\u003c3\u003e().colwise().cross(a.template bottomRows\u003c3\u003e());\n  ret.template bottomRows\u003c3\u003e() = -b.template bottomRows\u003c3\u003e().colwise().cross(a.template topRows\u003c3\u003e());\n  return ret;\n}\n\ntemplate\u003ctypename DerivedA, typename DerivedB\u003e\nEigen::Matrix\u003ctypename DerivedA::Scalar, TWIST_SIZE, Eigen::Dynamic\u003e dCrossSpatialMotion(\n  const Eigen::MatrixBase\u003cDerivedA\u003e\u0026 a,\n  const Eigen::MatrixBase\u003cDerivedB\u003e\u0026 b,\n  const typename Gradient\u003cDerivedA, Eigen::Dynamic\u003e::type\u0026 da,\n  const typename Gradient\u003cDerivedB, Eigen::Dynamic\u003e::type\u0026 db) {\n  Eigen::Matrix\u003ctypename DerivedA::Scalar, TWIST_SIZE, Eigen::Dynamic\u003e ret(TWIST_SIZE, da.cols());\n  ret.row(0) = -da.row(2)*b[1] + da.row(1)*b[2] - a[2]*db.row(1) + a[1]*db.row(2);\n  ret.row(1) =  da.row(2)*b[0] - da.row(0)*b[2] + a[2]*db.row(0) - a[0]*db.row(2);\n  ret.row(2) = -da.row(1)*b[0] + da.row(0)*b[1] - a[1]*db.row(0) + a[0]*db.row(1);\n  ret.row(3) = -da.row(5)*b[1] + da.row(4)*b[2] - da.row(2)*b[4] + da.row(1)*b[5] - a[5]*db.row(1) + a[4]*db.row(2) - a[2]*db.row(4) + a[1]*db.row(5);\n  ret.row(4) =  da.row(5)*b[0] - da.row(3)*b[2] + da.row(2)*b[3] - da.row(0)*b[5] + a[5]*db.row(0) - a[3]*db.row(2) + a[2]*db.row(3) - a[0]*db.row(5);\n  ret.row(5) = -da.row(4)*b[0] + da.row(3)*b[1] - da.row(1)*b[3] + da.row(0)*b[4] - a[4]*db.row(0) + a[3]*db.row(1) - a[1]*db.row(3) + a[0]*db.row(4);\n  return ret;\n}\n\ntemplate\u003ctypename DerivedA, typename DerivedB\u003e\nEigen::Matrix\u003ctypename DerivedA::Scalar, TWIST_SIZE, Eigen::Dynamic\u003e dCrossSpatialForce(\n  const Eigen::MatrixBase\u003cDerivedA\u003e\u0026 a,\n  const Eigen::MatrixBase\u003cDerivedB\u003e\u0026 b,\n  const typename Gradient\u003cDerivedA, Eigen::Dynamic\u003e::type\u0026 da,\n  const typename Gradient\u003cDerivedB, Eigen::Dynamic\u003e::type\u0026 db) {\n  Eigen::Matrix\u003ctypename DerivedA::Scalar, TWIST_SIZE, Eigen::Dynamic\u003e ret(TWIST_SIZE, da.cols());\n  ret.row(0) =  da.row(2)*b[1] - da.row(1)*b[2] + da.row(5)*b[4] - da.row(4)*b[5] + a[2]*db.row(1) - a[1]*db.row(2) + a[5]*db.row(4) - a[4]*db.row(5);\n  ret.row(1) = -da.row(2)*b[0] + da.row(0)*b[2] - da.row(5)*b[3] + da.row(3)*b[5] - a[2]*db.row(0) + a[0]*db.row(2) - a[5]*db.row(3) + a[3]*db.row(5);\n  ret.row(2) =  da.row(1)*b[0] - da.row(0)*b[1] + da.row(4)*b[3] - da.row(3)*b[4] + a[1]*db.row(0) - a[0]*db.row(1) + a[4]*db.row(3) - a[3]*db.row(4);\n  ret.row(3) =  da.row(2)*b[4] - da.row(1)*b[5] + a[2]*db.row(4) - a[1]*db.row(5);\n  ret.row(4) = -da.row(2)*b[3] + da.row(0)*b[5] - a[2]*db.row(3) + a[0]*db.row(5);\n  ret.row(5) =  da.row(1)*b[3] - da.row(0)*b[4] + a[1]*db.row(3) - a[0]*db.row(4);\n  ret = -ret;\n  return ret;\n}\n\ntemplate\u003ctypename DerivedS, typename DerivedQdotToV\u003e\ntypename DHomogTrans\u003cDerivedQdotToV\u003e::type dHomogTrans(\n    const Eigen::Transform\u003ctypename DerivedQdotToV::Scalar, 3, Eigen::Isometry\u003e\u0026 T,\n    const Eigen::MatrixBase\u003cDerivedS\u003e\u0026 S,\n    const Eigen::MatrixBase\u003cDerivedQdotToV\u003e\u0026 qdot_to_v) {\n  const int nq_at_compile_time = DerivedQdotToV::ColsAtCompileTime;\n  typename DerivedQdotToV::Index nq = qdot_to_v.cols();\n  auto qdot_to_twist = (S * qdot_to_v).eval();\n\n  const int numel = HOMOGENEOUS_TRANSFORM_SIZE;\n  Eigen::Matrix\u003ctypename DerivedQdotToV::Scalar, numel, nq_at_compile_time\u003e ret(numel, nq);\n\n  const auto\u0026 Rx = T.linear().col(0);\n  const auto\u0026 Ry = T.linear().col(1);\n  const auto\u0026 Rz = T.linear().col(2);\n\n  const auto\u0026 qdot_to_omega_x = qdot_to_twist.row(0);\n  const auto\u0026 qdot_to_omega_y = qdot_to_twist.row(1);\n  const auto\u0026 qdot_to_omega_z = qdot_to_twist.row(2);\n\n  ret.template middleRows\u003c3\u003e(0) = -Rz * qdot_to_omega_y + Ry * qdot_to_omega_z;\n  ret.row(3).setZero();\n\n  ret.template middleRows\u003c3\u003e(4) = Rz * qdot_to_omega_x - Rx * qdot_to_omega_z;\n  ret.row(7).setZero();\n\n  ret.template middleRows\u003c3\u003e(8) = -Ry * qdot_to_omega_x + Rx * qdot_to_omega_y;\n  ret.row(11).setZero();\n\n  ret.template middleRows\u003c3\u003e(12) = T.linear() * qdot_to_twist.bottomRows(3);\n  ret.row(15).setZero();\n\n  return ret;\n}\n\ntemplate\u003ctypename DerivedDT\u003e\ntypename DHomogTrans\u003cDerivedDT\u003e::type dHomogTransInv(\n    const Eigen::Transform\u003ctypename DerivedDT::Scalar, 3, Eigen::Isometry\u003e\u0026 T,\n    const Eigen::MatrixBase\u003cDerivedDT\u003e\u0026 dT) {\n  typename DerivedDT::Index nq = dT.cols();\n\n  const auto\u0026 R = T.linear();\n  const auto\u0026 p = T.translation();\n\n  std::array\u003cint, 3\u003e rows = {0, 1, 2};\n  std::array\u003cint, 3\u003e R_cols = {0, 1, 2};\n  std::array\u003cint, 1\u003e p_cols = {3};\n\n  auto dR = getSubMatrixGradient\u003cEigen::Dynamic\u003e(dT, rows, R_cols, T.Rows);\n  auto dp = getSubMatrixGradient\u003cEigen::Dynamic\u003e(dT, rows, p_cols, T.Rows);\n\n  auto dinvT_R = transposeGrad(dR, R.rows());\n  auto dinvT_p = (-R.transpose() * dp - matGradMult(dinvT_R, p)).eval();\n\n  const int numel = HOMOGENEOUS_TRANSFORM_SIZE;\n  Eigen::Matrix\u003ctypename DerivedDT::Scalar, numel, DerivedDT::ColsAtCompileTime\u003e ret(numel, nq);\n  setSubMatrixGradient\u003cEigen::Dynamic\u003e(ret, dinvT_R, rows, R_cols, T.Rows);\n  setSubMatrixGradient\u003cEigen::Dynamic\u003e(ret, dinvT_p, rows, p_cols, T.Rows);\n\n  // zero out gradient of elements in last row:\n  const int last_row = 3;\n  for (int col = 0; col \u003c T.HDim; col++) {\n    ret.row(last_row + col * T.Rows).setZero();\n  }\n\n  return ret;\n}\n\ntemplate \u003ctypename Scalar, typename DerivedX, typename DerivedDT, typename DerivedDX\u003e\ntypename Gradient\u003cDerivedX, DerivedDX::ColsAtCompileTime, 1\u003e::type dTransformSpatialMotion(\n    const Eigen::Transform\u003cScalar, 3, Eigen::Isometry\u003e\u0026 T,\n    const Eigen::MatrixBase\u003cDerivedX\u003e\u0026 X,\n    const Eigen::MatrixBase\u003cDerivedDT\u003e\u0026 dT,\n    const Eigen::MatrixBase\u003cDerivedDX\u003e\u0026 dX) {\n  assert(dT.cols() == dX.cols());\n  typename DerivedDT::Index nq = dT.cols();\n\n  const auto\u0026 R = T.linear();\n  const auto\u0026 p = T.translation();\n\n  std::array\u003cint, 3\u003e rows = {0, 1, 2};\n  std::array\u003cint, 3\u003e R_cols = {0, 1, 2};\n  std::array\u003cint, 1\u003e p_cols = {3};\n\n  auto dR = getSubMatrixGradient\u003cEigen::Dynamic\u003e(dT, rows, R_cols, T.Rows);\n  auto dp = getSubMatrixGradient\u003cEigen::Dynamic\u003e(dT, rows, p_cols, T.Rows);\n\n  typename Gradient\u003cDerivedX, DerivedDX::ColsAtCompileTime, 1\u003e::type ret(X.size(), nq);\n  std::array\u003cint, 3\u003e Xomega_rows = {0, 1, 2};\n  std::array\u003cint, 3\u003e Xv_rows = {3, 4, 5};\n  for (int col = 0; col \u003c X.cols(); col++) {\n    auto Xomega_col = X.template block\u003c3, 1\u003e(0, col);\n    auto Xv_col = X.template block\u003c3, 1\u003e(3, col);\n\n    auto RXomega_col = (R * Xomega_col).eval();\n\n    std::array\u003cint, 1\u003e col_array = {col};\n    auto dXomega_col = getSubMatrixGradient\u003cEigen::Dynamic\u003e(dX, Xomega_rows, col_array, X.rows());\n    auto dXv_col = getSubMatrixGradient\u003cEigen::Dynamic\u003e(dX, Xv_rows, col_array, X.rows());\n\n    auto domega_part_col = (R * dXomega_col + matGradMult(dR, Xomega_col)).eval();\n    auto dv_part_col = (R * dXv_col + matGradMult(dR, Xv_col)).eval();\n    dv_part_col += dp.colwise().cross(RXomega_col);\n    dv_part_col -= domega_part_col.colwise().cross(p);\n\n    setSubMatrixGradient\u003cEigen::Dynamic\u003e(ret, domega_part_col, Xomega_rows, col_array, X.rows());\n    setSubMatrixGradient\u003cEigen::Dynamic\u003e(ret, dv_part_col, Xv_rows, col_array, X.rows());\n  }\n  return ret;\n}\n\ntemplate \u003ctypename Scalar, typename DerivedX, typename DerivedDT, typename DerivedDX\u003e\ntypename Gradient\u003cDerivedX, DerivedDX::ColsAtCompileTime\u003e::type dTransformSpatialForce(\n    const Eigen::Transform\u003cScalar, 3, Eigen::Isometry\u003e\u0026 T,\n    const Eigen::MatrixBase\u003cDerivedX\u003e\u0026 X,\n    const Eigen::MatrixBase\u003cDerivedDT\u003e\u0026 dT,\n    const Eigen::MatrixBase\u003cDerivedDX\u003e\u0026 dX) {\n  assert(dT.cols() == dX.cols());\n  typename DerivedDT::Index nq = dT.cols();\n\n  const auto\u0026 R = T.linear();\n  const auto\u0026 p = T.translation();\n\n  std::array\u003cint, 3\u003e rows = {0, 1, 2};\n  std::array\u003cint, 3\u003e R_cols = {0, 1, 2};\n  std::array\u003cint, 1\u003e p_cols = {3};\n\n  auto dR = getSubMatrixGradient\u003cEigen::Dynamic\u003e(dT, rows, R_cols, T.Rows);\n  auto dp = getSubMatrixGradient\u003cEigen::Dynamic\u003e(dT, rows, p_cols, T.Rows);\n\n  typename Gradient\u003cDerivedX, DerivedDX::ColsAtCompileTime\u003e::type ret(X.size(), nq);\n  std::array\u003cint, 3\u003e Xomega_rows = {0, 1, 2};\n  std::array\u003cint, 3\u003e Xv_rows = {3, 4, 5};\n  for (int col = 0; col \u003c X.cols(); col++) {\n    auto Xomega_col = X.template block\u003c3, 1\u003e(0, col);\n    auto Xv_col = X.template block\u003c3, 1\u003e(3, col);\n\n    auto RXv_col = (R * Xv_col).eval();\n\n    std::array\u003cint, 1\u003e col_array = {col};\n    auto dXomega_col = getSubMatrixGradient\u003cEigen::Dynamic\u003e(dX, Xomega_rows, col_array, X.rows());\n    auto dXv_col = getSubMatrixGradient\u003cEigen::Dynamic\u003e(dX, Xv_rows, col_array, X.rows());\n\n    auto domega_part_col = (R * dXomega_col).eval();\n    domega_part_col += matGradMult(dR, Xomega_col);\n    auto dv_part_col = (R * dXv_col).eval();\n    dv_part_col += matGradMult(dR, Xv_col);\n    domega_part_col += dp.colwise().cross(RXv_col);\n    domega_part_col -= dv_part_col.colwise().cross(p);\n\n    setSubMatrixGradient\u003cEigen::Dynamic\u003e(ret, domega_part_col, Xomega_rows, col_array, X.rows());\n    setSubMatrixGradient\u003cEigen::Dynamic\u003e(ret, dv_part_col, Xv_rows, col_array, X.rows());\n  }\n  return ret;\n}\n\ntemplate\u003ctypename Scalar \u003e\nDLLEXPORT void cylindrical2cartesian(const Matrix\u003cScalar,3,1\u003e \u0026m_cylinder_axis, const Matrix\u003cScalar,3,1\u003e \u0026m_cylinder_x_dir, const Matrix\u003cScalar,3,1\u003e \u0026cylinder_origin, const Matrix\u003cScalar,6,1\u003e \u0026x_cylinder, const Matrix\u003cScalar,6,1\u003e \u0026v_cylinder, Matrix\u003cScalar,6,1\u003e \u0026x_cartesian, Matrix\u003cScalar,6,1\u003e \u0026v_cartesian, Matrix\u003cScalar,6,6\u003e \u0026J, Matrix\u003cScalar,6,1\u003e \u0026Jdotv)\n{\n  Matrix\u003cScalar,3,1\u003e cylinder_axis = m_cylinder_axis/m_cylinder_axis.norm();\n  Matrix\u003cScalar,3,1\u003e cylinder_x_dir = m_cylinder_x_dir/m_cylinder_x_dir.norm();\n  Matrix\u003cScalar,3,3\u003e R_cylinder2cartesian;\n  R_cylinder2cartesian.col(0) = cylinder_x_dir;\n  R_cylinder2cartesian.col(1) = cylinder_axis.cross(cylinder_x_dir);\n  R_cylinder2cartesian.col(2) = cylinder_axis;\n  double radius = x_cylinder(0);\n  double theta = x_cylinder(1);\n  double c_theta = cos(theta);\n  double s_theta = sin(theta);\n  double height = x_cylinder(2);\n  double radius_dot = v_cylinder(0);\n  double theta_dot = v_cylinder(1);\n  double height_dot = v_cylinder(2);\n  Matrix\u003cScalar,3,1\u003e x_pos_cartesian;\n  x_pos_cartesian \u003c\u003c radius*c_theta, radius*s_theta, height;\n  x_pos_cartesian = R_cylinder2cartesian*x_pos_cartesian+cylinder_origin;\n  Matrix\u003cScalar,3,1\u003e v_pos_cartesian;\n  v_pos_cartesian \u003c\u003c radius*-s_theta*theta_dot+radius_dot*c_theta, radius*c_theta*theta_dot+radius_dot*s_theta, height_dot;\n  v_pos_cartesian = R_cylinder2cartesian*v_pos_cartesian;\n  Vector3d x_rpy_cylinder = x_cylinder.block(3,0,3,1);\n  Matrix\u003cScalar,3,3\u003e R_tangent = rpy2rotmat(x_rpy_cylinder);\nMatrix\u003cScalar,3,3\u003e R_tangent2cylinder;\n  Matrix\u003cScalar,3,3\u003e dR_tangent2cylinder;\n  Matrix\u003cScalar,3,3\u003e ddR_tangent2cylinder;\n  rotz(theta-M_PI/2,R_tangent2cylinder,dR_tangent2cylinder, ddR_tangent2cylinder);\n  Matrix\u003cScalar,3,3\u003e dR_tangent2cylinder_dtheta = dR_tangent2cylinder;\n  Matrix\u003cScalar,3,3\u003e R_cylinder = R_tangent2cylinder*R_tangent;\n  Matrix\u003cScalar,3,3\u003e R_cartesian = R_cylinder2cartesian*R_cylinder;\n  Matrix\u003cScalar,3,1\u003e x_rpy_cartesian = rotmat2rpy(R_cartesian);\n  x_cartesian.block(0,0,3,1) = x_pos_cartesian;\n  x_cartesian.block(3,0,3,1) = x_rpy_cartesian;\n  v_cartesian.block(0,0,3,1) = v_pos_cartesian;\n  v_cartesian.block(3,0,3,1) = theta_dot*R_cylinder2cartesian.col(2)+R_cylinder2cartesian*R_tangent2cylinder*v_cylinder.block(3,0,3,1);\n  J = Matrix\u003cScalar,6,6\u003e::Zero();\n  J.block(0,0,3,1) \u003c\u003c c_theta,s_theta,0;\n  J.block(0,1,3,1) \u003c\u003c radius*-s_theta,radius*c_theta,0;\n  J.block(0,2,3,1) \u003c\u003c 0,0,1;\n  J.block(0,0,3,3) = R_cylinder2cartesian*J.block(0,0,3,3);\n  J.block(3,1,3,1) = R_cylinder2cartesian.col(2);\n  J.block(3,3,3,3) = R_cylinder2cartesian*R_tangent2cylinder;\n  Matrix\u003cScalar,3,3\u003e dJ1_dradius = Matrix\u003cScalar,3,3\u003e::Zero();\n  dJ1_dradius(0,1) = -s_theta;\n  dJ1_dradius(1,1) = c_theta;\n  Matrix\u003cScalar,3,3\u003e dJ1_dtheta = Matrix\u003cScalar,3,3\u003e::Zero();\n  dJ1_dtheta(0,0) = -s_theta;\n  dJ1_dtheta(0,1) = -radius*c_theta;\n  dJ1_dtheta(1,0) = c_theta;\n  dJ1_dtheta(1,1) = -radius*s_theta;\n  Jdotv.block(0,0,3,1) = R_cylinder2cartesian*(dJ1_dradius*radius_dot+dJ1_dtheta*theta_dot)*v_cylinder.block(0,0,3,1);\n  Jdotv.block(3,0,3,1) = R_cylinder2cartesian*dR_tangent2cylinder_dtheta*theta_dot*v_cylinder.block(3,0,3,1);\n}\n\ntemplate \u003ctypename Scalar\u003e\nDLLEXPORT  void cartesian2cylindrical(const Eigen::Matrix\u003cScalar,3,1\u003e \u0026m_cylinder_axis, const Eigen::Matrix\u003cScalar,3,1\u003e \u0026m_cylinder_x_dir, const Eigen::Matrix\u003cScalar,3,1\u003e \u0026 cylinder_origin, const Eigen::Matrix\u003cScalar,6,1\u003e \u0026x_cartesian, const Eigen::Matrix\u003cScalar,6,1\u003e \u0026v_cartesian, Eigen::Matrix\u003cScalar,6,1\u003e \u0026x_cylinder, Eigen::Matrix\u003cScalar,6,1\u003e \u0026v_cylinder, Eigen::Matrix\u003cScalar,6,6\u003e \u0026J, Eigen::Matrix\u003cScalar,6,1\u003e \u0026Jdotv )\n{\n  Matrix\u003cScalar,3,1\u003e cylinder_axis = m_cylinder_axis/m_cylinder_axis.norm();\n  Matrix\u003cScalar,3,1\u003e cylinder_x_dir = m_cylinder_x_dir/m_cylinder_x_dir.norm();\n  Matrix\u003cScalar,3,3\u003e R_cylinder2cartesian;\n  R_cylinder2cartesian.col(0) = cylinder_x_dir;\n  R_cylinder2cartesian.col(1) = cylinder_axis.cross(cylinder_x_dir);\n  R_cylinder2cartesian.col(2) = cylinder_axis;\n  Matrix\u003cScalar,3,3\u003e R_cartesian2cylinder = R_cylinder2cartesian.transpose();\n  Matrix\u003cScalar,3,1\u003e x_pos_cylinder = R_cartesian2cylinder*(x_cartesian.block(0,0,3,1)-cylinder_origin);\n  Matrix\u003cScalar,3,1\u003e v_pos_cylinder = R_cartesian2cylinder*v_cartesian.block(0,0,3,1);\n  double radius = sqrt(pow(x_pos_cylinder(0),2)+pow(x_pos_cylinder(1),2));\n  double radius_dot = (x_pos_cylinder(0)*v_pos_cylinder(0)+x_pos_cylinder(1)*v_pos_cylinder(1))/radius;\n  double theta = atan2(x_pos_cylinder(1),x_pos_cylinder(0));\n  double radius_square = pow(radius,2);\n  double radius_cubic = pow(radius,3);\n  double radius_quad = pow(radius,4);\n  double theta_dot = (-x_pos_cylinder(1)*v_pos_cylinder(0)+x_pos_cylinder(0)*v_pos_cylinder(1))/radius_square;\n  double height = x_pos_cylinder(2);\n  double height_dot = v_pos_cylinder(2);\n  x_cylinder(0) = radius;\n  x_cylinder(1) = theta;\n  x_cylinder(2) = height;\n  v_cylinder(0) = radius_dot;\n  v_cylinder(1) = theta_dot;\n  v_cylinder(2) = height_dot;\n  Matrix\u003cScalar,3,3\u003e R_tangent2cylinder;\n  Matrix\u003cScalar,3,3\u003e dR_tangent2cylinder;\n  Matrix\u003cScalar,3,3\u003e ddR_tangent2cylinder;\n  rotz(theta-M_PI/2,R_tangent2cylinder,dR_tangent2cylinder, ddR_tangent2cylinder);\n  Matrix\u003cScalar,3,3\u003e R_cylinder2tangent = R_tangent2cylinder.transpose();\n  Vector3d x_rpy_cartesian = x_cartesian.block(3,0,3,1);\n  Matrix\u003cScalar,3,3\u003e R_cartesian = rpy2rotmat(x_rpy_cartesian);\n  x_cylinder.block(3,0,3,1) = rotmat2rpy(R_cylinder2tangent*R_cartesian2cylinder*R_cartesian);\n  J = Matrix\u003cScalar,6,6\u003e::Zero();\n  Matrix\u003cScalar,6,6\u003e Jdot = Matrix\u003cScalar,6,6\u003e::Zero();\n  J(0,0) = x_pos_cylinder(0)/radius;\n  J(0,1) = x_pos_cylinder(1)/radius;\n  J(1,0) = -x_pos_cylinder(1)/radius_square;\n  J(1,1) = x_pos_cylinder(0)/radius_square;\n  J(2,2) = 1.0;\n  J.block(0,0,3,3) = J.block(0,0,3,3)*R_cartesian2cylinder;\n  Jdot(0,0) = pow(x_pos_cylinder(1),2)/radius_cubic*v_pos_cylinder(0)-x_pos_cylinder(0)*x_pos_cylinder(1)/radius_cubic*v_pos_cylinder(1);\n  Jdot(0,1) = -x_pos_cylinder(0)*x_pos_cylinder(1)/radius_cubic*v_pos_cylinder(0)+pow(x_pos_cylinder(0),2)/radius_cubic*v_pos_cylinder(1);\n  Jdot(1,0) = 2*x_pos_cylinder(0)*x_pos_cylinder(1)/radius_quad*v_pos_cylinder(0)+(pow(x_pos_cylinder(1),2)-pow(x_pos_cylinder(0),2))/radius_quad*v_pos_cylinder(1);\n  Jdot(1,1) = (pow(x_pos_cylinder(1),2)-pow(x_pos_cylinder(0),2))/radius_quad*v_pos_cylinder(0)-2*x_pos_cylinder(0)*x_pos_cylinder(1)/radius_quad*v_pos_cylinder(1);\n  Jdot.block(0,0,3,3) = Jdot.block(0,0,3,3)*R_cartesian2cylinder;\n  v_cylinder.block(3,0,3,1) = R_cylinder2tangent*R_cartesian2cylinder*v_cartesian.block(3,0,3,1)-theta_dot*R_cylinder2tangent.col(2);\n  J.block(3,0,3,3) = R_cylinder2tangent.col(2)*-J.block(1,0,1,3);\n  J.block(3,3,3,3) = R_cylinder2tangent*R_cartesian2cylinder;\n  Jdot.block(3,0,3,3) = dR_tangent2cylinder.row(2).transpose()*-J.block(1,0,1,3)*theta_dot+R_cylinder2tangent.col(2)*-Jdot.block(1,0,1,3);\n  Jdot.block(3,3,3,3) = dR_tangent2cylinder.transpose()*theta_dot*R_cartesian2cylinder;\n  Jdotv = Jdot*v_cartesian;\n}\n\nDLLEXPORT GradientVar\u003cdouble,3,1\u003e quat2expmap(const Ref\u003cconst Vector4d\u003e \u0026q, int gradient_order)\n{\n  double t = sqrt(1-q(0)*q(0));\n  bool is_degenerate=(t*t\u003cstd::numeric_limits\u003cdouble\u003e::epsilon());\n  double s = is_degenerate?2.0:2.0*acos(q(0))/t;\n  GradientVar\u003cdouble,3,1\u003e ret(3,1,4,gradient_order);\n  ret.value() = s*q.tail(3);\n  if(gradient_order\u003e0)\n  {\n    ret.gradient().value() = Matrix\u003cdouble,3,4\u003e::Zero();\n    double dsdq1 = is_degenerate?0.0: (-2*t+2*acos(q(0))*q(0))/pow(t,3);\n    ret.gradient().value().col(0) = q.tail(3)*dsdq1;\n    ret.gradient().value().block(0,1,3,3) = Matrix3d::Identity()*s;\n  }\n  else if(gradient_order\u003e1)\n  {\n    throw std::runtime_error(\"gradient_order\u003e1 is not supported in quat2expmap\");\n  }\n  return ret;\n}\n\nDLLEXPORT GradientVar\u003cdouble,3,1\u003e flipExpmap(const Ref\u003cconst Vector3d\u003e \u0026expmap, int gradient_order)\n{\n  if(gradient_order\u003e1)\n  {\n    throw std::runtime_error(\"gradient_order\u003e1 is not supported in flipExpmap\");\n  }\n  double expmap_norm = expmap.norm();\n  bool is_degenerate=(expmap_norm\u003cstd::numeric_limits\u003cdouble\u003e::epsilon());\n  GradientVar\u003cdouble,3,1\u003e ret(3,1,3,gradient_order);\n  Matrix3d eye3 = Matrix3d::Identity();\n  if(is_degenerate)\n  {\n    ret.value() = expmap;\n    if(gradient_order\u003e0)\n    {\n      ret.gradient().value() = eye3;\n    }\n  }\n  else\n  {\n    ret.value() = expmap-expmap/expmap_norm*2*M_PI;\n    if(gradient_order\u003e0)\n    {\n      ret.gradient().value() = eye3-(expmap_norm*expmap_norm*eye3-expmap*expmap.transpose())/pow(expmap_norm,3)*2*M_PI;\n    }\n  }\n  return ret;\n}\n\nDLLEXPORT GradientVar\u003cdouble, 3,1\u003e unwrapExpmap(const Ref\u003cconst Vector3d\u003e \u0026 expmap1, const Ref\u003cconst Vector3d\u003e \u0026expmap2, int gradient_order)\n{\n  auto expmap2_flip = flipExpmap(expmap2,gradient_order);\n  double distance1 = (expmap1-expmap2).squaredNorm();\n  double distance2 = (expmap1-expmap2_flip.value()).squaredNorm();\n  if(distance1\u003edistance2)\n  {\n    return expmap2_flip;\n  }\n  else\n  {\n    GradientVar\u003cdouble,3,1\u003e ret(3,1,3,gradient_order);\n    ret.value() = expmap2;\n    if(gradient_order\u003e0)\n    {\n      ret.gradient().value() = Matrix3d::Identity();\n    }\n    return ret;\n  }\n}\n\n\nvoid quat2expmapSequence(const Ref\u003cconst Matrix\u003cdouble,4,Dynamic\u003e\u003e \u0026quat, const Ref\u003cconst Matrix\u003cdouble,4,Dynamic\u003e\u003e \u0026quat_dot, Ref\u003cMatrix\u003cdouble,3,Dynamic\u003e\u003e expmap, Ref\u003cMatrix\u003cdouble,3,Dynamic\u003e\u003e expmap_dot)\n{\n  DenseIndex N = quat.cols();\n  if(quat_dot.cols() != N)\n  {\n    throw std::runtime_error(\"quat_dot must have the same number of columns as quat in quat2expmapSequence\");\n  }\n  expmap.resize(3,N);\n  expmap_dot.resize(3,N);\n  for(int i = 0;i\u003cN;i++)\n  {\n    auto expmap_grad = quat2expmap(quat.col(i),1);\n    expmap.col(i) = expmap_grad.value();\n    expmap_dot.col(i) = expmap_grad.gradient().value()*quat_dot.col(i);\n    if(i\u003e=1)\n    {\n      auto closest_grad = closestExpmap(expmap.col(i-1),expmap.col(i),1);\n      expmap.col(i) = closest_grad.value();\n      expmap_dot.col(i) = closest_grad.gradient().value()*expmap_dot.col(i);\n    }\n  }\n}\n\nDLLEXPORT GradientVar\u003cdouble, 3,1\u003e closestExpmap(const Ref\u003cconst Vector3d\u003e \u0026 expmap1, const Ref\u003cconst Vector3d\u003e \u0026expmap2, int gradient_order)\n{\n  if (gradient_order\u003e1) {\n    throw std::runtime_error(\"closestExpmap only supports first order gradient\");\n  }\n  double expmap1_norm = expmap1.norm();\n  double expmap2_norm = expmap2.norm();\n  GradientVar\u003cdouble, 3, 1\u003e ret(3,1,3,gradient_order);\n  if (expmap2_norm \u003c std::numeric_limits\u003cdouble\u003e::epsilon()) {\n    if (expmap1_norm \u003e std::numeric_limits\u003cdouble\u003e::epsilon()) {\n      Vector3d expmap1_axis = expmap1/expmap1_norm;\n      int expmap1_round = static_cast\u003cint\u003e(expmap1_norm/(2*M_PI) + 0.5);\n      ret.value() = expmap1_axis*expmap1_round*2*M_PI;\n      if(ret.hasGradient()) {\n        ret.gradient().value() = Matrix3d::Zero();\n      }\n      return ret;\n    }\n    else {\n      ret.value() = expmap2;\n      if (ret.hasGradient()) {\n        ret.gradient().value() = Matrix3d::Identity();\n      }\n    }\n  }\n  else {\n    Vector3d expmap2_axis = expmap2/expmap2_norm;\n    Matrix3d dexpmap2_axis_dexpmap2 = (expmap2_norm*Matrix3d::Identity() - expmap2*expmap2.transpose()/expmap2_norm)/pow(expmap2_norm,2);\n    double expmap2_closest_k = (expmap2_axis.transpose()*expmap1 - expmap2_norm)/(2*M_PI);\n    int expmap2_closest_k1;\n    int expmap2_closest_k2;\n    if (expmap2_closest_k\u003e0) {\n      expmap2_closest_k1 = (int) expmap2_closest_k;\n    }\n    else {\n      expmap2_closest_k1 = (int) expmap2_closest_k - 1;\n    }\n    expmap2_closest_k2 = expmap2_closest_k1 + 1;\n    Vector3d expmap2_closest1 = expmap2 + 2*expmap2_closest_k1*M_PI*expmap2_axis;\n    Vector3d expmap2_closest2 = expmap2 + 2*expmap2_closest_k2*M_PI*expmap2_axis;\n    if ((expmap2_closest1 - expmap1).norm() \u003c (expmap2_closest2 - expmap1).norm()) {\n      ret.value() = expmap2_closest1;\n      if (ret.hasGradient()) {\n        ret.gradient().value() = Matrix3d::Identity() + 2*dexpmap2_axis_dexpmap2*(double)expmap2_closest_k1*M_PI;\n      }\n      return ret;\n    }\n    else {\n      ret.value() = expmap2_closest2;\n      if (ret.hasGradient()) {\n        ret.gradient().value() = Matrix3d::Identity() + 2*dexpmap2_axis_dexpmap2*(double)expmap2_closest_k2*M_PI;\n      }\n      return ret;\n    }\n  }\n  return ret;\n}\n// explicit instantiations\ntemplate DLLEXPORT void normalizeVec(\n    const MatrixBase\u003c Vector3d \u003e\u0026 x,\n    Vector3d\u0026 x_norm,\n    Gradient\u003cVector3d, 3, 1\u003e::type*,\n    Gradient\u003cVector3d, 3, 2\u003e::type*);\n\ntemplate DLLEXPORT void normalizeVec(\n    const MatrixBase\u003c Vector4d \u003e\u0026 x,\n    Vector4d\u0026 x_norm,\n    Gradient\u003cVector4d, 4, 1\u003e::type*,\n    Gradient\u003cVector4d, 4, 2\u003e::type*);\n\ntemplate DLLEXPORT void normalizeVec(\n    const MatrixBase\u003c Map\u003cVector4d\u003e \u003e\u0026 x,\n    Vector4d\u0026 x_norm,\n    Gradient\u003cVector4d, 4, 1\u003e::type*,\n    Gradient\u003cVector4d, 4, 2\u003e::type*);\n\ntemplate DLLEXPORT void normalizeVec(\n    const MatrixBase\u003c Eigen::Block\u003cEigen::Ref\u003cEigen::Matrix\u003cdouble, -1, 1, 0, -1, 1\u003e const, 0, Eigen::InnerStride\u003c1\u003e \u003e const, 4, 1, false\u003e \u003e\u0026 x,\n    Vector4d\u0026 x_norm,\n    Gradient\u003cVector4d, 4, 1\u003e::type*,\n    Gradient\u003cVector4d, 4, 2\u003e::type*);\n\ntemplate DLLEXPORT Vector4d quat2axis(const MatrixBase\u003cVector4d\u003e\u0026);\ntemplate DLLEXPORT Matrix3d quat2rotmat(const MatrixBase\u003cVector4d\u003e\u0026 q);\ntemplate DLLEXPORT Matrix3d quat2rotmat(const MatrixBase\u003cEigen::Block\u003cEigen::Ref\u003cEigen::Matrix\u003cdouble, -1, 1, 0, -1, 1\u003e const, 0, Eigen::InnerStride\u003c1\u003e \u003e const, 4, 1, false\u003e \u003e\u0026 q);\ntemplate DLLEXPORT Matrix\u003cMap\u003cMatrix\u003cdouble, 4, 1, 0, 4, 1\u003e const, 0, Stride\u003c0, 0\u003e \u003e::Scalar, 3, 3, 0, 3, 3\u003e quat2rotmat\u003cMap\u003cMatrix\u003cdouble, 4, 1, 0, 4, 1\u003e const, 0, Stride\u003c0, 0\u003e \u003e \u003e(MatrixBase\u003cMap\u003cMatrix\u003cdouble, 4, 1, 0, 4, 1\u003e const, 0, Stride\u003c0, 0\u003e \u003e \u003e const\u0026);\ntemplate DLLEXPORT Vector3d quat2rpy(const MatrixBase\u003cVector4d\u003e\u0026);\n\ntemplate DLLEXPORT Vector4d axis2quat(const MatrixBase\u003cVector4d\u003e\u0026);\ntemplate DLLEXPORT Matrix3d axis2rotmat(const MatrixBase\u003cVector4d\u003e\u0026);\ntemplate DLLEXPORT Vector3d axis2rpy(const MatrixBase\u003cVector4d\u003e\u0026);\n\ntemplate DLLEXPORT Vector4d rotmat2axis(const MatrixBase\u003cMatrix3d\u003e\u0026);\ntemplate DLLEXPORT Vector4d rotmat2quat(const MatrixBase\u003cMatrix3d\u003e\u0026);\ntemplate DLLEXPORT Vector3d rotmat2rpy(const MatrixBase\u003cMatrix3d\u003e\u0026);\n\ntemplate DLLEXPORT Eigen::Matrix\u003cEigen::Block\u003cEigen::Matrix\u003cdouble, 4, 4, 0, 4, 4\u003e, 3, 3, false\u003e::Scalar, -1, 1, 0, -1, 1\u003e rotmat2Representation\u003cEigen::Block\u003cEigen::Matrix\u003cdouble, 4, 4, 0, 4, 4\u003e, 3, 3, false\u003e \u003e(Eigen::MatrixBase\u003cEigen::Block\u003cEigen::Matrix\u003cdouble, 4, 4, 0, 4, 4\u003e, 3, 3, false\u003e \u003e const\u0026, int);\n\ntemplate DLLEXPORT GradientVar\u003cdouble, Eigen::Dynamic, 1\u003e rotmat2Representation(\n    const GradientVar\u003cdouble, SPACE_DIMENSION, SPACE_DIMENSION\u003e\u0026 R,\n    int rotation_type);\n\ntemplate DLLEXPORT GradientVar\u003cdouble, QUAT_SIZE, 1\u003e expmap2quat(const MatrixBase\u003cVector3d\u003e\u0026 v, const int gradient_order);\ntemplate DLLEXPORT GradientVar\u003cdouble, QUAT_SIZE, 1\u003e expmap2quat(const MatrixBase\u003cMap\u003cVector3d\u003e\u003e\u0026 v, const int gradient_order);\ntemplate DLLEXPORT GradientVar\u003cEigen::Block\u003cEigen::Matrix\u003cdouble, -1, 1, 0, -1, 1\u003e, 3, 1, false\u003e::Scalar, 4, 1\u003e expmap2quat\u003cEigen::Block\u003cEigen::Matrix\u003cdouble, -1, 1, 0, -1, 1\u003e, 3, 1, false\u003e \u003e(Eigen::MatrixBase\u003cEigen::Block\u003cEigen::Matrix\u003cdouble, -1, 1, 0, -1, 1\u003e, 3, 1, false\u003e \u003e const\u0026, int);\n\ntemplate DLLEXPORT Vector4d rpy2axis(const Eigen::MatrixBase\u003cVector3d\u003e\u0026);\ntemplate DLLEXPORT Vector4d rpy2quat(const Eigen::MatrixBase\u003cVector3d\u003e\u0026);\ntemplate DLLEXPORT Matrix3d rpy2rotmat(const Eigen::MatrixBase\u003cVector3d\u003e\u0026);\ntemplate DLLEXPORT Matrix3d rpy2rotmat(const Eigen::MatrixBase\u003cEigen::Block\u003cEigen::Ref\u003cEigen::Matrix\u003cdouble, -1, 1, 0, -1, 1\u003e const, 0, Eigen::InnerStride\u003c1\u003e \u003e const, 3, 1, false\u003e\u003e\u0026);\n\ntemplate DLLEXPORT Matrix\u003cdouble,9,3\u003e drpy2rotmat(const Eigen::MatrixBase\u003cVector3d\u003e\u0026);\ntemplate DLLEXPORT Matrix\u003cdouble,9,3\u003e drpy2rotmat(const Eigen::MatrixBase\u003cEigen::Block\u003cEigen::Ref\u003cEigen::Matrix\u003cdouble, -1, 1, 0, -1, 1\u003e const, 0, Eigen::InnerStride\u003c1\u003e \u003e const, 3, 1, false\u003e\u003e\u0026);\n\ntemplate DLLEXPORT Vector4d quat2axis(const MatrixBase\u003c Map\u003cVector4d\u003e \u003e\u0026);\ntemplate DLLEXPORT Matrix3d quat2rotmat(const MatrixBase\u003c Map\u003cVector4d\u003e \u003e\u0026 q);\ntemplate DLLEXPORT Vector3d quat2rpy(const MatrixBase\u003c Map\u003cVector4d\u003e \u003e\u0026);\n\ntemplate DLLEXPORT Vector4d axis2quat(const MatrixBase\u003c Map\u003cVector4d\u003e \u003e\u0026);\ntemplate DLLEXPORT Matrix3d axis2rotmat(const MatrixBase\u003c Map\u003cVector4d\u003e \u003e\u0026);\ntemplate DLLEXPORT Vector3d axis2rpy(const MatrixBase\u003c Map\u003cVector4d\u003e \u003e\u0026);\n\ntemplate DLLEXPORT Vector4d rotmat2axis(const MatrixBase\u003c Map\u003cMatrix3d\u003e \u003e\u0026);\ntemplate DLLEXPORT Vector4d rotmat2quat(const MatrixBase\u003c Map\u003cMatrix3d\u003e \u003e\u0026);\ntemplate DLLEXPORT Vector3d rotmat2rpy(const MatrixBase\u003c Map\u003cMatrix3d\u003e \u003e\u0026);\n\ntemplate DLLEXPORT Vector4d rpy2axis(const Eigen::MatrixBase\u003c Map\u003cVector3d\u003e \u003e\u0026);\ntemplate DLLEXPORT Vector4d rpy2quat(const Eigen::MatrixBase\u003c Map\u003cVector3d\u003e \u003e\u0026);\ntemplate DLLEXPORT Matrix3d rpy2rotmat(const Eigen::MatrixBase\u003c Map\u003cVector3d\u003e \u003e\u0026);\ntemplate DLLEXPORT Matrix\u003cdouble,9,3\u003e drpy2rotmat(const Eigen::MatrixBase\u003c Map\u003cVector3d\u003e \u003e\u0026);\n\ntemplate DLLEXPORT Matrix\u003cBlock\u003cMatrix4d const, 3, 3, false\u003e::Scalar, 4, 1, 0, 4, 1\u003e rotmat2quat\u003cBlock\u003cMatrix4d const, 3, 3, false\u003e \u003e(MatrixBase\u003cBlock\u003cMatrix4d const, 3, 3, false\u003e \u003e const\u0026);\n\n\ntemplate DLLEXPORT Eigen::Matrix\u003cdouble, TWIST_SIZE, Eigen::Dynamic\u003e transformSpatialMotion(\n    const Eigen::Isometry3d\u0026,\n    const Eigen::MatrixBase\u003c Eigen::Matrix\u003cdouble, TWIST_SIZE, Eigen::Dynamic\u003e \u003e\u0026);\n\ntemplate DLLEXPORT Eigen::Matrix\u003cdouble, TWIST_SIZE, 1\u003e transformSpatialMotion(\n    const Eigen::Isometry3d\u0026,\n    const Eigen::MatrixBase\u003c Eigen::Matrix\u003cdouble, TWIST_SIZE, 1\u003e \u003e\u0026);\n\ntemplate DLLEXPORT TransformSpatial\u003c MatrixXd \u003e::type transformSpatialMotion\u003cMatrixXd\u003e(\n    const Eigen::Isometry3d\u0026,\n    const Eigen::MatrixBase\u003c MatrixXd \u003e\u0026);\n\ntemplate DLLEXPORT TransformSpatial\u003cEigen::Block\u003cEigen::Matrix\u003cdouble, -1, -1, 0, -1, -1\u003e, 6, -1, false\u003e \u003e::type transformSpatialMotion(\n    const Eigen::Isometry3d\u0026 T,\n    const Eigen::MatrixBase\u003cEigen::Block\u003cEigen::Matrix\u003cdouble, -1, -1, 0, -1, -1\u003e, 6, -1, false\u003e \u003e\u0026 M);\n\ntemplate DLLEXPORT TransformSpatial\u003c Matrix\u003cdouble, TWIST_SIZE, Eigen::Dynamic\u003e \u003e::type transformSpatialForce\u003cMatrix\u003cdouble, TWIST_SIZE, Eigen::Dynamic\u003e\u003e(\n    const Eigen::Isometry3d\u0026,\n    const Eigen::MatrixBase\u003c Matrix\u003cdouble, TWIST_SIZE, Eigen::Dynamic\u003e \u003e\u0026);\n\ntemplate DLLEXPORT TransformSpatial\u003c MatrixXd \u003e::type transformSpatialForce\u003cMatrixXd\u003e(\n    const Eigen::Isometry3d\u0026,\n    const Eigen::MatrixBase\u003c MatrixXd \u003e\u0026);\n\ntemplate DLLEXPORT TransformSpatial\u003cEigen::Block\u003cEigen::Matrix\u003cdouble, 6, -1, 0, 6, -1\u003e, 6, -1, true\u003e\u003e::type transformSpatialForce(\n    const Eigen::Isometry3d\u0026,\n    const Eigen::MatrixBase\u003cEigen::Block\u003cEigen::Matrix\u003cdouble, 6, -1, 0, 6, -1\u003e, 6, -1, true\u003e \u003e\u0026);\n\ntemplate DLLEXPORT TransformSpatial\u003cEigen::Matrix\u003cdouble, 6, 1, 0, 6, 1\u003e \u003e::type transformSpatialForce(\n    const Eigen::Isometry3d\u0026,\n    const Eigen::MatrixBase\u003cEigen::Matrix\u003cdouble, 6, 1, 0, 6, 1\u003e \u003e\u0026);\n\ntemplate DLLEXPORT TransformSpatial\u003cEigen::Block\u003cEigen::Matrix\u003cdouble, 6, -1, 0, 6, -1\u003e const, 6, 1, true\u003e \u003e::type transformSpatialForce(\n    const Eigen::Transform\u003cEigen::Block\u003cEigen::Matrix\u003cdouble, 6, -1, 0, 6, -1\u003e const, 6, 1, true\u003e::Scalar, 3, 1, 0\u003e \u0026,\n    const Eigen::MatrixBase\u003cEigen::Block\u003cEigen::Matrix\u003cdouble, 6, -1, 0, 6, -1\u003e const, 6, 1, true\u003e \u003e \u0026);\n\ntemplate DLLEXPORT TransformSpatial\u003cMap\u003cMatrix\u003cdouble, 6, 1, 0, 6, 1\u003e const, 0, Stride\u003c0, 0\u003e \u003e \u003e::type transformSpatialForce\u003cMap\u003cMatrix\u003cdouble, 6, 1, 0, 6, 1\u003e const, 0, Stride\u003c0, 0\u003e \u003e\u003e(\n    const Eigen::Isometry3d\u0026,\n    const Eigen::MatrixBase\u003cMap\u003cMatrix\u003cdouble, 6, 1, 0, 6, 1\u003e const, 0, Stride\u003c0, 0\u003e \u003e \u003e\u0026);\n\ntemplate DLLEXPORT GradientVar\u003cdouble, TWIST_SIZE, TWIST_SIZE\u003e transformSpatialInertia(\n    const Eigen::Transform\u003cdouble, SPACE_DIMENSION, Eigen::Isometry\u003e\u0026 T_current_to_new,\n    const Gradient\u003cEigen::Transform\u003cdouble, SPACE_DIMENSION, Eigen::Isometry\u003e::MatrixType, Eigen::Dynamic\u003e::type* dT_current_to_new,\n    const Eigen::MatrixBase\u003c Eigen::Matrix\u003cdouble, TWIST_SIZE, TWIST_SIZE\u003e \u003e\u0026 I);\n\ntemplate DLLEXPORT GradientVar\u003cdouble, TWIST_SIZE, TWIST_SIZE\u003e transformSpatialInertia(\n    const Eigen::Transform\u003cdouble, SPACE_DIMENSION, Eigen::Isometry\u003e\u0026 T_current_to_new,\n    const Gradient\u003cEigen::Transform\u003cdouble, SPACE_DIMENSION, Eigen::Isometry\u003e::MatrixType, Eigen::Dynamic\u003e::type* dT_current_to_new,\n    const Eigen::MatrixBase\u003c Eigen::MatrixXd \u003e\u0026 I);\n\ntemplate DLLEXPORT Eigen::Matrix\u003cdouble, TWIST_SIZE, Eigen::Dynamic\u003e dCrossSpatialMotion(\n  const Eigen::MatrixBase\u003cEigen::Matrix\u003cdouble, 6, 1, 0, 6, 1\u003e \u003e\u0026 a,\n  const Eigen::MatrixBase\u003cEigen::Matrix\u003cdouble, 6, 1, 0, 6, 1\u003e \u003e\u0026 b,\n  const Gradient\u003cEigen::Matrix\u003cdouble, 6, 1, 0, 6, 1\u003e, Eigen::Dynamic\u003e::type\u0026 da,\n  const Gradient\u003cEigen::Matrix\u003cdouble, 6, 1, 0, 6, 1\u003e, Eigen::Dynamic\u003e::type\u0026 db);\n\ntemplate DLLEXPORT Eigen::Matrix\u003cdouble, TWIST_SIZE, Eigen::Dynamic\u003e dCrossSpatialForce(\n  const Eigen::MatrixBase\u003cEigen::Matrix\u003cdouble, 6, 1, 0, 6, 1\u003e \u003e\u0026 a,\n  const Eigen::MatrixBase\u003cEigen::Matrix\u003cdouble, 6, 1, 0, 6, 1\u003e \u003e\u0026 b,\n  const Gradient\u003cEigen::Matrix\u003cdouble, 6, 1, 0, 6, 1\u003e, Eigen::Dynamic\u003e::type\u0026 da,\n  const Gradient\u003cEigen::Matrix\u003cdouble, 6, 1, 0, 6, 1\u003e, Eigen::Dynamic\u003e::type\u0026 db);\n\ntemplate DLLEXPORT Gradient\u003cMatrix3d, QUAT_SIZE\u003e::type dquat2rotmat(const Eigen::MatrixBase\u003cVector4d\u003e\u0026);\ntemplate DLLEXPORT Gradient\u003cMatrix3d, QUAT_SIZE\u003e::type dquat2rotmat(const Eigen::MatrixBase\u003c Map\u003cVector4d\u003e \u003e\u0026);\ntemplate DLLEXPORT Gradient\u003cMatrix3d, QUAT_SIZE\u003e::type dquat2rotmat(const Eigen::MatrixBase\u003cEigen::Block\u003cEigen::Ref\u003cEigen::Matrix\u003cdouble, -1, 1, 0, -1, 1\u003e const, 0, Eigen::InnerStride\u003c1\u003e \u003e const, 4, 1, false\u003e \u003e\u0026);\n\ntemplate DLLEXPORT Gradient\u003cVector3d, Dynamic\u003e::type drotmat2rpy(\n    const Eigen::MatrixBase\u003cMatrix3d\u003e\u0026,\n    const Eigen::MatrixBase\u003c Matrix\u003cdouble, RotmatSize, Dynamic\u003e \u003e\u0026);\n\ntemplate DLLEXPORT Gradient\u003cVector3d, 6\u003e::type drotmat2rpy(\n    const Eigen::MatrixBase\u003cMatrix3d\u003e\u0026,\n    const Eigen::MatrixBase\u003c Matrix\u003cdouble, RotmatSize, 6\u003e \u003e\u0026);\n\ntemplate DLLEXPORT Gradient\u003cVector4d, Dynamic\u003e::type drotmat2quat(\n    const Eigen::MatrixBase\u003cMatrix3d\u003e\u0026,\n    const Eigen::MatrixBase\u003c Matrix\u003cdouble, RotmatSize, Dynamic\u003e \u003e\u0026);\n\ntemplate DLLEXPORT\nEigen::Matrix\u003cdouble, 3, 3\u003e vectorToSkewSymmetric(const Eigen::MatrixBase\u003cEigen::Vector3d\u003e\u0026);\n\ntemplate DLLEXPORT Eigen::Matrix\u003cdouble, 3, Eigen::Dynamic\u003e dcrossProduct(\n    const Eigen::MatrixBase\u003cVector3d\u003e\u0026 a,\n    const Eigen::MatrixBase\u003cVector3d\u003e\u0026 b,\n    const Gradient\u003cVector3d, Eigen::Dynamic\u003e::type\u0026 da,\n    const Gradient\u003cVector3d, Eigen::Dynamic\u003e::type\u0026 db);\n\ntemplate DLLEXPORT Eigen::Matrix\u003cdouble, 3, Eigen::Dynamic\u003e dcrossProduct(\n    const Eigen::MatrixBase\u003cEigen::Block\u003cEigen::Matrix\u003cdouble, 3, -1, 0, 3, -1\u003e, 3, 1, true\u003e\u003e\u0026 a,\n    const Eigen::MatrixBase\u003cEigen::Block\u003cEigen::Matrix\u003cdouble, -1, 1, 0, -1, 1\u003e const, 3, 1, false\u003e\u003e\u0026 b,\n    const Gradient\u003cEigen::Block\u003cEigen::Matrix\u003cdouble, 3, -1, 0, 3, -1\u003e, 3, 1, true\u003e, Eigen::Dynamic\u003e::type\u0026 da,\n    const Gradient\u003cEigen::Block\u003cEigen::Matrix\u003cdouble, -1, 1, 0, -1, 1\u003e const, 3, 1, false\u003e, Eigen::Dynamic\u003e::type\u0026 db);\n\ntemplate DLLEXPORT Eigen::Matrix\u003cdouble, 3, Eigen::Dynamic\u003e dcrossProduct(\n    const Eigen::MatrixBase\u003c Eigen::Block\u003cEigen::Matrix\u003cdouble, 3, -1, 0, 3, -1\u003e, 3, 1, true\u003e \u003e\u0026 a,\n    const Eigen::MatrixBase\u003c Eigen::Block\u003cEigen::Matrix\u003cdouble, -1, -1, 0, -1, -1\u003e const, 3, 1, false\u003e \u003e\u0026 b,\n    const Gradient\u003c Eigen::Block\u003cEigen::Matrix\u003cdouble, 3, -1, 0, 3, -1\u003e, 3, 1, true\u003e, Eigen::Dynamic\u003e::type\u0026 da,\n    const Gradient\u003c Eigen::Block\u003cEigen::Matrix\u003cdouble, -1, -1, 0, -1, -1\u003e const, 3, 1, false\u003e, Eigen::Dynamic\u003e::type\u0026 db);\n\ntemplate DLLEXPORT Eigen::Matrix\u003cdouble, 3, Eigen::Dynamic\u003e dcrossProduct(\n    const Eigen::MatrixBase\u003cEigen::Block\u003cEigen::Matrix\u003cdouble, 6, 1, 0, 6, 1\u003e const, 3, 1, false\u003e\u003e\u0026 a,\n    const Eigen::MatrixBase\u003cEigen::Block\u003cEigen::Block\u003cEigen::Matrix\u003cdouble, -1, -1, 0, -1, -1\u003e, 3, -1, false\u003e, 3, 1, true\u003e\u003e\u0026 b,\n    const Gradient\u003cEigen::Block\u003cEigen::Matrix\u003cdouble, 6, 1, 0, 6, 1\u003e const, 3, 1, false\u003e, Eigen::Dynamic\u003e::type\u0026 da,\n    const Gradient\u003cEigen::Block\u003cEigen::Block\u003cEigen::Matrix\u003cdouble, -1, -1, 0, -1, -1\u003e, 3, -1, false\u003e, 3, 1, true\u003e, Eigen::Dynamic\u003e::type\u0026 db);\n\ntemplate DLLEXPORT Eigen::Matrix\u003cdouble, 3, Eigen::Dynamic\u003e dcrossProduct(\n    const Eigen::MatrixBase\u003cEigen::Block\u003cEigen::Matrix\u003cdouble, 6, 1, 0, 6, 1\u003e const, 3, 1, false\u003e\u003e\u0026 a,\n    const Eigen::MatrixBase\u003cEigen::Block\u003cEigen::Matrix\u003cdouble, 3, -1, 0, 3, -1\u003e, 3, 1, true\u003e\u003e\u0026 b,\n    const Gradient\u003cEigen::Block\u003cEigen::Matrix\u003cdouble, 6, 1, 0, 6, 1\u003e const, 3, 1, false\u003e, Eigen::Dynamic\u003e::type\u0026 da,\n    const Gradient\u003cEigen::Block\u003cEigen::Matrix\u003cdouble, 3, -1, 0, 3, -1\u003e, 3, 1, true\u003e, Eigen::Dynamic\u003e::type\u0026 db);\n\ntemplate DLLEXPORT Eigen::Matrix\u003cdouble, 3, Eigen::Dynamic\u003e dcrossProduct(\n    const Eigen::MatrixBase\u003cEigen::Block\u003cEigen::Block\u003cEigen::Matrix\u003cdouble, 6, -1, 0, 6, -1\u003e, 3, -1, false\u003e, 3, 1, true\u003e\u003e\u0026 a,\n    const Eigen::MatrixBase\u003cEigen::Matrix\u003cdouble, 3, 1, 0, 3, 1\u003e\u003e\u0026 b,\n    const Gradient\u003cEigen::Block\u003cEigen::Block\u003cEigen::Matrix\u003cdouble, 6, -1, 0, 6, -1\u003e, 3, -1, false\u003e, 3, 1, true\u003e, Eigen::Dynamic\u003e::type\u0026 da,\n    const Gradient\u003cEigen::Matrix\u003cdouble, 3, 1, 0, 3, 1\u003e, Eigen::Dynamic\u003e::type\u0026 db);\n\ntemplate DLLEXPORT Eigen::Matrix\u003cdouble, 3, Eigen::Dynamic\u003e dcrossProduct(\n    const Eigen::MatrixBase\u003cEigen::Block\u003cEigen::Matrix\u003cdouble, 6, 1, 0, 6, 1\u003e, 3, 1, false\u003e\u003e\u0026 a,\n    const Eigen::MatrixBase\u003cEigen::Matrix\u003cdouble, 3, 1, 0, 3, 1\u003e\u003e\u0026 b,\n    const Gradient\u003cEigen::Block\u003cEigen::Matrix\u003cdouble, 6, 1, 0, 6, 1\u003e, 3, 1, false\u003e, Eigen::Dynamic\u003e::type\u0026 da,\n    const Gradient\u003cEigen::Matrix\u003cdouble, 3, 1, 0, 3, 1\u003e, Eigen::Dynamic\u003e::type\u0026 db);\n\ntemplate DLLEXPORT Eigen::Matrix\u003cEigen::Block\u003cEigen::Block\u003cEigen::Matrix\u003cdouble, 6, -1, 0, 6, -1\u003e, 3, -1, false\u003e, 3, 1, true\u003e::Scalar, 3, -1, 0, 3, -1\u003e dcrossProduct\u003cEigen::Block\u003cEigen::Block\u003cEigen::Matrix\u003cdouble, 6, -1, 0, 6, -1\u003e, 3, -1, false\u003e, 3, 1, true\u003e,\n    Eigen::Block\u003cEigen::Matrix\u003cdouble, -1, 1, 0, -1, 1\u003e const, 3, 1, false\u003e \u003e(Eigen::MatrixBase\u003cEigen::Block\u003cEigen::Block\u003cEigen::Matrix\u003cdouble, 6, -1, 0, 6, -1\u003e, 3, -1, false\u003e, 3, 1, true\u003e \u003e const\u0026, Eigen::MatrixBase\u003cEigen::Block\u003cEigen::Matrix\u003cdouble, -1, 1, 0, -1, 1\u003e const, 3, 1, false\u003e \u003e const\u0026,\n    Gradient\u003cEigen::Block\u003cEigen::Block\u003cEigen::Matrix\u003cdouble, 6, -1, 0, 6, -1\u003e, 3, -1, false\u003e, 3, 1, true\u003e, -1, 1\u003e::type const\u0026, Gradient\u003cEigen::Block\u003cEigen::Matrix\u003cdouble, -1, 1, 0, -1, 1\u003e const, 3, 1, false\u003e, -1, 1\u003e::type const\u0026);\n\ntemplate DLLEXPORT Eigen::Matrix\u003cEigen::Block\u003cEigen::Block\u003cEigen::Matrix\u003cdouble, 6, -1, 0, 6, -1\u003e, 3, -1, false\u003e, 3, 1, true\u003e::Scalar, 3, -1, 0, 3, -1\u003e dcrossProduct\u003cEigen::Block\u003cEigen::Block\u003cEigen::Matrix\u003cdouble, 6, -1, 0, 6, -1\u003e, 3, -1, false\u003e, 3, 1, true\u003e,\n    Eigen::Block\u003cEigen::Matrix\u003cdouble, -1, -1, 0, -1, -1\u003e const, 3, 1, false\u003e \u003e(Eigen::MatrixBase\u003cEigen::Block\u003cEigen::Block\u003cEigen::Matrix\u003cdouble, 6, -1, 0, 6, -1\u003e, 3, -1, false\u003e, 3, 1, true\u003e \u003e const\u0026,\n    Eigen::MatrixBase\u003cEigen::Block\u003cEigen::Matrix\u003cdouble, -1, -1, 0, -1, -1\u003e const, 3, 1, false\u003e \u003e const\u0026, Gradient\u003cEigen::Block\u003cEigen::Block\u003cEigen::Matrix\u003cdouble, 6, -1, 0, 6, -1\u003e, 3, -1, false\u003e, 3, 1, true\u003e, -1, 1\u003e::type const\u0026,\n    Gradient\u003cEigen::Block\u003cEigen::Matrix\u003cdouble, -1, -1, 0, -1, -1\u003e const, 3, 1, false\u003e, -1, 1\u003e::type const\u0026);\n\ntemplate DLLEXPORT Eigen::Matrix\u003cdouble, 3, -1, 0, 3, -1\u003e dcrossProduct\u003cEigen::Block\u003cEigen::Matrix\u003cdouble, 6, 1, 0, 6, 1\u003e const, 3, 1, false\u003e, Eigen::Block\u003cEigen::Block\u003cEigen::Matrix\u003cdouble, -1, 1, 0, -1, 1\u003e, 3, 1, false\u003e, 3, 1, true\u003e \u003e(\n    Eigen::MatrixBase\u003cEigen::Block\u003cEigen::Matrix\u003cdouble, 6, 1, 0, 6, 1\u003e const, 3, 1, false\u003e \u003e const\u0026, Eigen::MatrixBase\u003cEigen::Block\u003cEigen::Block\u003cEigen::Matrix\u003cdouble, -1, 1, 0, -1, 1\u003e, 3, 1, false\u003e, 3, 1, true\u003e \u003e const\u0026,\n    Gradient\u003cEigen::Block\u003cEigen::Matrix\u003cdouble, 6, 1, 0, 6, 1\u003e const, 3, 1, false\u003e, -1, 1\u003e::type const\u0026, Gradient\u003cEigen::Block\u003cEigen::Block\u003cEigen::Matrix\u003cdouble, -1, 1, 0, -1, 1\u003e, 3, 1, false\u003e, 3, 1, true\u003e, -1, 1\u003e::type const\u0026);\n\ntemplate DLLEXPORT Eigen::Matrix\u003cdouble, 3, -1, 0, 3, -1\u003e dcrossProduct\u003cEigen::Block\u003cEigen::Matrix\u003cdouble, 6, 1, 0, 6, 1\u003e const, 3, 1, false\u003e, Eigen::Block\u003cEigen::Matrix\u003cdouble, 3, 1, 0, 3, 1\u003e, 3, 1, true\u003e \u003e(\n    Eigen::MatrixBase\u003cEigen::Block\u003cEigen::Matrix\u003cdouble, 6, 1, 0, 6, 1\u003e const, 3, 1, false\u003e \u003e const\u0026, Eigen::MatrixBase\u003cEigen::Block\u003cEigen::Matrix\u003cdouble, 3, 1, 0, 3, 1\u003e, 3, 1, true\u003e \u003e const\u0026, Gradient\u003cEigen::Block\u003cEigen::Matrix\u003cdouble, 6, 1, 0, 6, 1\u003e const, 3, 1, false\u003e, -1, 1\u003e::type const\u0026,\n    Gradient\u003cEigen::Block\u003cEigen::Matrix\u003cdouble, 3, 1, 0, 3, 1\u003e, 3, 1, true\u003e, -1, 1\u003e::type const\u0026);\n\ntemplate DLLEXPORT Eigen::Matrix\u003cEigen::Block\u003cEigen::Block\u003cEigen::Matrix\u003cdouble, 6, -1, 0, 6, -1\u003e, 3, -1, false\u003e, 3, 1, true\u003e::Scalar, 3, -1, 0, 3, -1\u003e dcrossProduct\u003cEigen::Block\u003cEigen::Block\u003cEigen::Matrix\u003cdouble, 6, -1, 0, 6, -1\u003e, 3, -1, false\u003e, 3, 1, true\u003e,\n    Eigen::Block\u003cEigen::Matrix\u003cdouble, -1, 1, 0, -1, 1\u003e, 3, 1, false\u003e \u003e(Eigen::MatrixBase\u003cEigen::Block\u003cEigen::Block\u003cEigen::Matrix\u003cdouble, 6, -1, 0, 6, -1\u003e, 3, -1, false\u003e, 3, 1, true\u003e \u003e const\u0026, Eigen::MatrixBase\u003cEigen::Block\u003cEigen::Matrix\u003cdouble, -1, 1, 0, -1, 1\u003e, 3, 1, false\u003e \u003e const\u0026,\n    Gradient\u003cEigen::Block\u003cEigen::Block\u003cEigen::Matrix\u003cdouble, 6, -1, 0, 6, -1\u003e, 3, -1, false\u003e, 3, 1, true\u003e, -1, 1\u003e::type const\u0026, Gradient\u003cEigen::Block\u003cEigen::Matrix\u003cdouble, -1, 1, 0, -1, 1\u003e, 3, 1, false\u003e, -1, 1\u003e::type const\u0026);\n\ntemplate DLLEXPORT Eigen::Matrix\u003cEigen::Block\u003cEigen::Block\u003cEigen::Matrix\u003cdouble, 6, -1, 0, 6, -1\u003e, 3, -1, false\u003e, 3, 1, true\u003e::Scalar, 3, -1, 0, 3, -1\u003e dcrossProduct\u003cEigen::Block\u003cEigen::Block\u003cEigen::Matrix\u003cdouble, 6, -1, 0, 6, -1\u003e, 3, -1, false\u003e, 3, 1, true\u003e,\n    Eigen::Block\u003cEigen::Matrix\u003cdouble, -1, -1, 0, -1, -1\u003e, 3, 1, false\u003e \u003e(Eigen::MatrixBase\u003cEigen::Block\u003cEigen::Block\u003cEigen::Matrix\u003cdouble, 6, -1, 0, 6, -1\u003e, 3, -1, false\u003e, 3, 1, true\u003e \u003e const\u0026, Eigen::MatrixBase\u003cEigen::Block\u003cEigen::Matrix\u003cdouble, -1, -1, 0, -1, -1\u003e, 3, 1, false\u003e \u003e const\u0026,\n    Gradient\u003cEigen::Block\u003cEigen::Block\u003cEigen::Matrix\u003cdouble, 6, -1, 0, 6, -1\u003e, 3, -1, false\u003e, 3, 1, true\u003e, -1, 1\u003e::type const\u0026, Gradient\u003cEigen::Block\u003cEigen::Matrix\u003cdouble, -1, -1, 0, -1, -1\u003e, 3, 1, false\u003e, -1, 1\u003e::type const\u0026);\n\ntemplate DLLEXPORT DHomogTrans\u003cMatrixXd\u003e::type dHomogTrans(\n    const Isometry3d\u0026,\n    const MatrixBase\u003c Matrix\u003cdouble, TWIST_SIZE, Dynamic\u003e \u003e\u0026,\n    const MatrixBase\u003c MatrixXd \u003e\u0026);\n\ntemplate DLLEXPORT DHomogTrans\u003cMatrix\u003cdouble, HOMOGENEOUS_TRANSFORM_SIZE, Dynamic\u003e\u003e::type dHomogTransInv(\n    const Isometry3d\u0026,\n    const MatrixBase\u003c Matrix\u003cdouble, HOMOGENEOUS_TRANSFORM_SIZE, Dynamic\u003e \u003e\u0026);\n\ntemplate DLLEXPORT Gradient\u003c Matrix\u003cdouble, TWIST_SIZE, Dynamic\u003e, Dynamic, 1\u003e::type dTransformSpatialMotion(\n    const Isometry3d\u0026,\n    const MatrixBase\u003c Matrix\u003cdouble, TWIST_SIZE, Dynamic\u003e \u003e\u0026,\n    const MatrixBase\u003c Matrix\u003cdouble, HOMOGENEOUS_TRANSFORM_SIZE, Dynamic\u003e \u003e\u0026,\n    const MatrixBase\u003cMatrixXd\u003e\u0026);\n\ntemplate DLLEXPORT Gradient\u003c Matrix\u003cdouble, TWIST_SIZE, 1\u003e, Dynamic, 1\u003e::type dTransformSpatialMotion(\n    const Isometry3d\u0026,\n    const MatrixBase\u003c Matrix\u003cdouble, TWIST_SIZE, 1\u003e \u003e\u0026,\n    const MatrixBase\u003c Matrix\u003cdouble, HOMOGENEOUS_TRANSFORM_SIZE, Dynamic\u003e \u003e\u0026,\n    const MatrixBase\u003c Matrix\u003cdouble, TWIST_SIZE, Eigen::Dynamic\u003e \u003e\u0026);\n\ntemplate DLLEXPORT TransformSpatial\u003cEigen::Matrix\u003cdouble, TWIST_SIZE, 1\u003e\u003e::type crossSpatialMotion(\n  const Eigen::MatrixBase\u003cEigen::Matrix\u003cdouble, TWIST_SIZE, 1\u003e \u003e\u0026 a,\n  const Eigen::MatrixBase\u003cEigen::Matrix\u003cdouble, TWIST_SIZE, 1\u003e \u003e\u0026 b);\n\ntemplate DLLEXPORT TransformSpatial\u003cEigen::Matrix\u003cdouble, TWIST_SIZE, TWIST_SIZE\u003e\u003e::type crossSpatialMotion(\n  const Eigen::MatrixBase\u003cEigen::Matrix\u003cdouble, TWIST_SIZE, 1\u003e \u003e\u0026 a,\n  const Eigen::MatrixBase\u003cEigen::Matrix\u003cdouble, TWIST_SIZE, TWIST_SIZE\u003e \u003e\u0026 b);\n\ntemplate DLLEXPORT TransformSpatial\u003cEigen::Matrix\u003cdouble, TWIST_SIZE, Eigen::Dynamic\u003e\u003e::type crossSpatialMotion(\n  const Eigen::MatrixBase\u003cEigen::Matrix\u003cdouble, TWIST_SIZE, 1\u003e \u003e\u0026 a,\n  const Eigen::MatrixBase\u003cEigen::Matrix\u003cdouble, TWIST_SIZE, Eigen::Dynamic\u003e \u003e\u0026 b);\n\ntemplate DLLEXPORT TransformSpatial\u003cEigen::Matrix\u003cdouble, TWIST_SIZE, 1\u003e\u003e::type crossSpatialForce(\n  const Eigen::MatrixBase\u003cEigen::Matrix\u003cdouble, TWIST_SIZE, 1\u003e \u003e\u0026 a,\n  const Eigen::MatrixBase\u003cEigen::Matrix\u003cdouble, TWIST_SIZE, 1\u003e \u003e\u0026 b);\n\ntemplate DLLEXPORT TransformSpatial\u003cEigen::Matrix\u003cdouble, TWIST_SIZE, TWIST_SIZE\u003e\u003e::type crossSpatialForce(\n  const Eigen::MatrixBase\u003cEigen::Matrix\u003cdouble, TWIST_SIZE, 1\u003e \u003e\u0026 a,\n  const Eigen::MatrixBase\u003cEigen::Matrix\u003cdouble, TWIST_SIZE, TWIST_SIZE\u003e \u003e\u0026 b);\n\ntemplate DLLEXPORT Gradient\u003c Matrix\u003cdouble, TWIST_SIZE, Dynamic\u003e, Dynamic, 1\u003e::type dTransformSpatialForce(\n    const Isometry3d\u0026,\n    const MatrixBase\u003c Matrix\u003cdouble, TWIST_SIZE, Dynamic\u003e \u003e\u0026,\n    const MatrixBase\u003c Matrix\u003cdouble, HOMOGENEOUS_TRANSFORM_SIZE, Dynamic\u003e \u003e\u0026,\n    const MatrixBase\u003cMatrixXd\u003e\u0026);\n\ntemplate DLLEXPORT Gradient\u003c Matrix\u003cdouble, TWIST_SIZE, Dynamic\u003e, Dynamic, 1\u003e::type dTransformSpatialForce(\n    const Isometry3d\u0026,\n    const MatrixBase\u003c Matrix\u003cdouble, TWIST_SIZE, Dynamic\u003e \u003e\u0026,\n    const MatrixBase\u003cMatrixXd\u003e\u0026,\n    const MatrixBase\u003cMatrixXd\u003e\u0026);\n\ntemplate DLLEXPORT Gradient\u003cEigen::Matrix\u003cdouble, 6, 1, 0, 6, 1\u003e, Eigen::Block\u003cEigen::Matrix\u003cdouble, 6, -1, 0, 6, -1\u003e, 6, -1, true\u003e::ColsAtCompileTime\u003e::type dTransformSpatialForce(\n    const Isometry3d\u0026 T,\n    const Eigen::MatrixBase\u003cEigen::Matrix\u003cdouble, 6, 1, 0, 6, 1\u003e \u003e\u0026 X,\n    const Eigen::MatrixBase\u003cEigen::Matrix\u003cdouble, 16, -1, 0, 16, -1\u003e \u003e\u0026 dT,\n    const Eigen::MatrixBase\u003cEigen::Block\u003cEigen::Matrix\u003cdouble, 6, -1, 0, 6, -1\u003e, 6, -1, true\u003e \u003e\u0026 dX);\n\ntemplate DLLEXPORT Gradient\u003cEigen::Matrix\u003cdouble, 6, 1, 0, 6, 1\u003e, Eigen::Matrix\u003cdouble, 6, -1, 0, 6, -1\u003e::ColsAtCompileTime\u003e::type dTransformSpatialForce(\n    const Isometry3d\u0026 T,\n    const Eigen::MatrixBase\u003cEigen::Matrix\u003cdouble, 6, 1, 0, 6, 1\u003e\u003e\u0026 X,\n    const Eigen::MatrixBase\u003cEigen::Matrix\u003cdouble, 16, -1, 0, 16, -1\u003e\u003e\u0026 dT,\n    const Eigen::MatrixBase\u003cEigen::Matrix\u003cdouble, 6, -1, 0, 6, -1\u003e\u003e\u0026 dX);\n\ntemplate DLLEXPORT  void cylindrical2cartesian(const Matrix\u003cdouble,3,1\u003e \u0026cylinder_axis, const Matrix\u003cdouble,3,1\u003e \u0026cylinder_x_dir, const Matrix\u003cdouble,3,1\u003e \u0026 cylinder_origin, const Matrix\u003cdouble,6,1\u003e \u0026x_cylinder, const Matrix\u003cdouble,6,1\u003e \u0026v_cylinder, Matrix\u003cdouble,6,1\u003e \u0026x_cartesian, Matrix\u003cdouble,6,1\u003e \u0026v_cartesian, Matrix\u003cdouble,6,6\u003e \u0026J, Matrix\u003cdouble,6,1\u003e \u0026Jdotv );\n\ntemplate DLLEXPORT  void cartesian2cylindrical(const Matrix\u003cdouble,3,1\u003e \u0026cylinder_axis, const Matrix\u003cdouble,3,1\u003e \u0026cylinder_x_dir, const Matrix\u003cdouble,3,1\u003e \u0026 cylinder_origin, const Matrix\u003cdouble,6,1\u003e \u0026x_cartesian, const Matrix\u003cdouble,6,1\u003e \u0026v_cartesian, Matrix\u003cdouble,6,1\u003e \u0026x_cylinder, Matrix\u003cdouble,6,1\u003e \u0026v_cylinder, Matrix\u003cdouble,6,6\u003e \u0026J, Matrix\u003cdouble,6,1\u003e \u0026Jdotv );\n\ntemplate DLLEXPORT void angularvel2quatdotMatrix(const Eigen::MatrixBase\u003cVector4d\u003e\u0026 q,\n    Eigen::MatrixBase\u003c Matrix\u003cdouble, QUAT_SIZE, SPACE_DIMENSION\u003e \u003e\u0026 M,\n    Eigen::MatrixBase\u003c Gradient\u003cMatrix\u003cdouble, QUAT_SIZE, SPACE_DIMENSION\u003e, QUAT_SIZE, 1\u003e::type\u003e* dM);\ntemplate DLLEXPORT void angularvel2quatdotMatrix(const Eigen::MatrixBase\u003cMap\u003cVector4d\u003e\u003e\u0026 q,\n    Eigen::MatrixBase\u003c Matrix\u003cdouble, QUAT_SIZE, SPACE_DIMENSION\u003e \u003e\u0026 M,\n    Eigen::MatrixBase\u003c Gradient\u003cMatrix\u003cdouble, QUAT_SIZE, SPACE_DIMENSION\u003e, QUAT_SIZE, 1\u003e::type\u003e* dM);\ntemplate DLLEXPORT void angularvel2quatdotMatrix(const Eigen::MatrixBase\u003c Eigen::Block\u003cEigen::Ref\u003cEigen::Matrix\u003cdouble, -1, 1, 0, -1, 1\u003e const, 0, Eigen::InnerStride\u003c1\u003e \u003e const, 4, 1, false\u003e \u003e\u0026 q,\n    Eigen::MatrixBase\u003c Matrix\u003cdouble, QUAT_SIZE, SPACE_DIMENSION\u003e \u003e\u0026 M,\n    Eigen::MatrixBase\u003c Gradient\u003cMatrix\u003cdouble, QUAT_SIZE, SPACE_DIMENSION\u003e, QUAT_SIZE, 1\u003e::type\u003e* dM);\n\ntemplate DLLEXPORT void angularvel2rpydotMatrix(const Eigen::MatrixBase\u003cVector3d\u003e\u0026 rpy,\n    Eigen::MatrixBase\u003c Matrix\u003cdouble, RPY_SIZE, SPACE_DIMENSION\u003e \u003e\u0026 phi,\n    Eigen::MatrixBase\u003c Gradient\u003cMatrix\u003cdouble, RPY_SIZE, SPACE_DIMENSION\u003e, RPY_SIZE, 1\u003e::type\u003e* dphi,\n    Eigen::MatrixBase\u003c Gradient\u003cMatrix\u003cdouble, RPY_SIZE, SPACE_DIMENSION\u003e, RPY_SIZE, 2\u003e::type\u003e* ddphi);\n\ntemplate DLLEXPORT void angularvel2rpydotMatrix(const Eigen::MatrixBase\u003cVector3d\u003e\u0026 rpy,\n    Eigen::MatrixBase\u003c Matrix\u003cdouble, RPY_SIZE, SPACE_DIMENSION\u003e \u003e\u0026 phi,\n    Eigen::MatrixBase\u003c Matrix\u003cdouble, Eigen::Dynamic, Eigen::Dynamic\u003e \u003e* dphi,\n    Eigen::MatrixBase\u003c Matrix\u003cdouble, Eigen::Dynamic, Eigen::Dynamic\u003e \u003e* ddphi);\n\ntemplate DLLEXPORT void rpydot2angularvelMatrix(const Eigen::MatrixBase\u003cVector3d\u003e\u0026 rpy,\n    Eigen::MatrixBase\u003cEigen::Matrix\u003cdouble, SPACE_DIMENSION, RPY_SIZE\u003e \u003e\u0026 E,\n    Gradient\u003cMatrix\u003cdouble,SPACE_DIMENSION,RPY_SIZE\u003e,RPY_SIZE,1\u003e::type* dE);\ntemplate DLLEXPORT void rpydot2angularvelMatrix(const Eigen::MatrixBase\u003cMap\u003cVector3d\u003e\u003e\u0026 rpy,\n    Eigen::MatrixBase\u003cEigen::Matrix\u003cdouble, SPACE_DIMENSION, RPY_SIZE\u003e \u003e\u0026 E,\n    Gradient\u003cMatrix\u003cdouble,SPACE_DIMENSION,RPY_SIZE\u003e,RPY_SIZE,1\u003e::type* dE);\ntemplate DLLEXPORT void rpydot2angularvelMatrix(const Eigen::MatrixBase\u003c Eigen::Block\u003cEigen::Ref\u003cEigen::Matrix\u003cdouble, -1, 1, 0, -1, 1\u003e const, 0, Eigen::InnerStride\u003c1\u003e \u003e const, 3, 1, false\u003e \u003e\u0026 rpy,\n    Eigen::MatrixBase\u003cEigen::Matrix\u003cdouble, SPACE_DIMENSION, RPY_SIZE\u003e \u003e\u0026 E,\n    Gradient\u003cMatrix\u003cdouble,SPACE_DIMENSION,RPY_SIZE\u003e,RPY_SIZE,1\u003e::type* dE);\n\ntemplate DLLEXPORT GradientVar\u003cdouble, Eigen::Dynamic, SPACE_DIMENSION\u003e angularvel2RepresentationDotMatrix(\n    int rotation_type, const Eigen::MatrixBase\u003cVectorXd\u003e\u0026 qrot, int gradient_order);\ntemplate DLLEXPORT GradientVar\u003cdouble, Eigen::Dynamic, SPACE_DIMENSION\u003e angularvel2RepresentationDotMatrix(\n    int rotation_type, const Eigen::MatrixBase\u003c Eigen::Block\u003cEigen::Matrix\u003cdouble, -1, -1, 0, -1, -1\u003e, -1, 1, false\u003e \u003e\u0026 qrot, int gradient_order);\ntemplate DLLEXPORT GradientVar\u003cdouble, -1, 3\u003e angularvel2RepresentationDotMatrix\u003cEigen::Block\u003cEigen::Matrix\u003cdouble, -1, 1, 0, -1, 1\u003e, -1, 1, false\u003e \u003e(int, Eigen::MatrixBase\u003cEigen::Block\u003cEigen::Matrix\u003cdouble, -1, 1, 0, -1, 1\u003e, -1, 1, false\u003e \u003e const\u0026, int);\ntemplate DLLEXPORT GradientVar\u003cEigen::Block\u003cEigen::Matrix\u003cdouble, -1, 1, 0, -1, 1\u003e const, -1, 1, false\u003e::Scalar, -1, 3\u003e angularvel2RepresentationDotMatrix\u003cEigen::Block\u003cEigen::Matrix\u003cdouble, -1, 1, 0, -1, 1\u003e const, -1, 1, false\u003e \u003e(int,\n    Eigen::MatrixBase\u003cEigen::Block\u003cEigen::Matrix\u003cdouble, -1, 1, 0, -1, 1\u003e const, -1, 1, false\u003e \u003e const\u0026, int);\ntemplate DLLEXPORT GradientVar\u003cEigen::Block\u003cEigen::Matrix\u003cdouble, -1, -1, 0, -1, -1\u003e const, -1, 1, false\u003e::Scalar, -1, 3\u003e angularvel2RepresentationDotMatrix\u003cEigen::Block\u003cEigen::Matrix\u003cdouble, -1, -1, 0, -1, -1\u003e const, -1, 1, false\u003e \u003e(int,\n    Eigen::MatrixBase\u003cEigen::Block\u003cEigen::Matrix\u003cdouble, -1, -1, 0, -1, -1\u003e const, -1, 1, false\u003e \u003e const\u0026, int);\n\n\ntemplate DLLEXPORT void quatdot2angularvelMatrix(const Eigen::MatrixBase\u003cVector4d\u003e\u0026 q,\n    Eigen::MatrixBase\u003c Matrix\u003cdouble, SPACE_DIMENSION, QUAT_SIZE\u003e \u003e\u0026 M,\n    Gradient\u003cMatrix\u003cdouble, SPACE_DIMENSION, QUAT_SIZE\u003e, QUAT_SIZE, 1\u003e::type* dM);\ntemplate DLLEXPORT void quatdot2angularvelMatrix(const Eigen::MatrixBase\u003cMap\u003cVector4d\u003e\u003e\u0026 q,\n    Eigen::MatrixBase\u003c Matrix\u003cdouble, SPACE_DIMENSION, QUAT_SIZE\u003e \u003e\u0026 M,\n    Gradient\u003cMatrix\u003cdouble, SPACE_DIMENSION, QUAT_SIZE\u003e, QUAT_SIZE, 1\u003e::type* dM);\ntemplate DLLEXPORT void quatdot2angularvelMatrix(const Eigen::MatrixBase\u003c Eigen::Block\u003cEigen::Ref\u003cEigen::Matrix\u003cdouble, -1, 1, 0, -1, 1\u003e const, 0, Eigen::InnerStride\u003c1\u003e \u003e const, 4, 1, false\u003e \u003e\u0026 q,\n    Eigen::MatrixBase\u003c Matrix\u003cdouble, SPACE_DIMENSION, QUAT_SIZE\u003e \u003e\u0026 M,\n    Gradient\u003cMatrix\u003cdouble, SPACE_DIMENSION, QUAT_SIZE\u003e, QUAT_SIZE, 1\u003e::type* dM);\n"}
{"repo_name":"lthall/Leonard_ardupilot","ref":"refs/heads/master","path":"libraries/AP_NavEKF/AP_NavEKF_core_common.cpp","copies":"13","language":"C++","content":"/*\n  NavEKF_core_common holds scratch data shared by EKF2 and EKF3\n\n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program.  If not, see \u003chttp://www.gnu.org/licenses/\u003e.\n */\n#include \"AP_NavEKF_core_common.h\"\n\nNavEKF_core_common::Matrix24 NavEKF_core_common::KH;\nNavEKF_core_common::Matrix24 NavEKF_core_common::KHP;\nNavEKF_core_common::Matrix24 NavEKF_core_common::nextP;\nNavEKF_core_common::Vector28 NavEKF_core_common::Kfusion;\n\n/*\n  fill common scratch variables, for detecting re-use of variables between loops in SITL\n */\nvoid NavEKF_core_common::fill_scratch_variables(void)\n{\n#if CONFIG_HAL_BOARD == HAL_BOARD_SITL\n    // fill the common variables with NaN, so we catch any cases in\n    // SITL where they are used without initialisation. These are all\n    // supposed to be scratch variables that are not used between\n    // iterations\n    fill_nanf(\u0026KH[0][0], sizeof(KH)/sizeof(float));\n    fill_nanf(\u0026KHP[0][0], sizeof(KHP)/sizeof(float));\n    fill_nanf(\u0026nextP[0][0], sizeof(nextP)/sizeof(float));\n    fill_nanf(\u0026Kfusion[0], sizeof(Kfusion)/sizeof(float));\n#endif\n}\n"}
{"repo_name":"samdnic/Tarantula","ref":"refs/heads/master","path":"boost/libs/coroutine/src/detail/standard_stack_allocator_posix.cpp","copies":"13","language":"C++","content":"\n//          Copyright Oliver Kowalke 2009.\n// Distributed under the Boost Software License, Version 1.0.\n//    (See accompanying file LICENSE_1_0.txt or copy at\n//          http://www.boost.org/LICENSE_1_0.txt)\n\n#define BOOST_COROUTINES_SOURCE\n\n#include \"boost/coroutine/detail/standard_stack_allocator.hpp\"\n\nextern \"C\" {\n#include \u003cfcntl.h\u003e\n#include \u003csignal.h\u003e\n#include \u003csys/mman.h\u003e\n#include \u003csys/resource.h\u003e\n#include \u003csys/stat.h\u003e\n#include \u003csys/time.h\u003e\n#include \u003csys/types.h\u003e\n#include \u003cunistd.h\u003e\n}\n\n//#if _POSIX_C_SOURCE \u003e= 200112L\n\n#include \u003calgorithm\u003e\n#include \u003ccmath\u003e\n#include \u003ccstring\u003e\n#include \u003cstdexcept\u003e\n\n#include \u003cboost/assert.hpp\u003e\n#include \u003cboost/context/fcontext.hpp\u003e\n\n#include \u003cboost/coroutine/stack_context.hpp\u003e\n\n#if !defined (SIGSTKSZ)\n# define SIGSTKSZ (8 * 1024)\n# define UDEF_SIGSTKSZ\n#endif\n\n#ifdef BOOST_HAS_ABI_HEADERS\n#  include BOOST_ABI_PREFIX\n#endif\n\nnamespace boost {\nnamespace coroutines {\nnamespace detail {\n\nstd::size_t pagesize()\n{\n    // conform to POSIX.1-2001\n    static std::size_t size = ::sysconf( _SC_PAGESIZE);\n    return size;\n}\n\nrlimit stacksize_limit_()\n{\n    rlimit limit;\n    // conforming to POSIX.1-2001\n#if defined(BOOST_DISABLE_ASSERTS)\n    ::getrlimit( RLIMIT_STACK, \u0026 limit);\n#else\n    const int result = ::getrlimit( RLIMIT_STACK, \u0026 limit);\n    BOOST_ASSERT( 0 == result);\n#endif\n    return limit;\n}\n\nrlimit stacksize_limit()\n{\n    static rlimit limit = stacksize_limit_();\n    return limit;\n}\n\nstd::size_t page_count( std::size_t stacksize)\n{\n    return static_cast\u003c std::size_t \u003e( \n        std::ceil(\n            static_cast\u003c float \u003e( stacksize) / pagesize() ) );\n}\n\nbool\nstandard_stack_allocator::is_stack_unbound()\n{ return RLIM_INFINITY == detail::stacksize_limit().rlim_max; }\n\nstd::size_t\nstandard_stack_allocator::default_stacksize()\n{\n    std::size_t size = 8 * minimum_stacksize();\n    if ( is_stack_unbound() ) return size;\n\n    BOOST_ASSERT( maximum_stacksize() \u003e= minimum_stacksize() );\n    return maximum_stacksize() == size\n        ? size\n        : (std::min)( size, maximum_stacksize() );\n}\n\nstd::size_t\nstandard_stack_allocator::minimum_stacksize()\n{ return SIGSTKSZ + sizeof( context::fcontext_t) + 15; }\n\nstd::size_t\nstandard_stack_allocator::maximum_stacksize()\n{\n    BOOST_ASSERT( ! is_stack_unbound() );\n    return static_cast\u003c std::size_t \u003e( detail::stacksize_limit().rlim_max);\n}\n\nvoid\nstandard_stack_allocator::allocate( stack_context \u0026 ctx, std::size_t size)\n{\n    BOOST_ASSERT( minimum_stacksize() \u003c= size);\n    BOOST_ASSERT( is_stack_unbound() || ( maximum_stacksize() \u003e= size) );\n\n    const std::size_t pages( detail::page_count( size) + 1); // add one guard page\n    const std::size_t size_( pages * detail::pagesize() );\n    BOOST_ASSERT( 0 \u003c size \u0026\u0026 0 \u003c size_);\n\n    const int fd( ::open(\"/dev/zero\", O_RDONLY) );\n    BOOST_ASSERT( -1 != fd);\n    // conform to POSIX.4 (POSIX.1b-1993, _POSIX_C_SOURCE=199309L)\n    void * limit =\n# if defined(macintosh) || defined(__APPLE__) || defined(__APPLE_CC__)\n    ::mmap( 0, size_, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANON, -1, 0);\n# else\n    ::mmap( 0, size_, PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, 0);\n# endif\n    ::close( fd);\n    if ( ! limit) throw std::bad_alloc();\n\n    std::memset( limit, '\\0', size_);\n\n    // conforming to POSIX.1-2001\n#if defined(BOOST_DISABLE_ASSERTS)\n    ::mprotect( limit, detail::pagesize(), PROT_NONE);\n#else\n    const int result( ::mprotect( limit, detail::pagesize(), PROT_NONE) );\n    BOOST_ASSERT( 0 == result);\n#endif\n\n    ctx.size = size_;\n    ctx.sp = static_cast\u003c char * \u003e( limit) + ctx.size;\n}\n\nvoid\nstandard_stack_allocator::deallocate( stack_context \u0026 ctx)\n{\n    BOOST_ASSERT( ctx.sp);\n    BOOST_ASSERT( minimum_stacksize() \u003c= ctx.size);\n    BOOST_ASSERT( is_stack_unbound() || ( maximum_stacksize() \u003e= ctx.size) );\n\n    void * limit = static_cast\u003c char * \u003e( ctx.sp) - ctx.size;\n    // conform to POSIX.4 (POSIX.1b-1993, _POSIX_C_SOURCE=199309L)\n    ::munmap( limit, ctx.size);\n}\n\n}}}\n\n#ifdef BOOST_HAS_ABI_HEADERS\n#  include BOOST_ABI_SUFFIX\n#endif\n\n#ifdef UDEF_SIGSTKSZ\n# undef SIGSTKSZ\n#endif\n"}
{"repo_name":"native-m/slmath","ref":"refs/heads/master","path":"source/intersect_util.cpp","copies":"2","language":"C++","content":"#include \u003cslm/intersect_util.h\u003e\r\n\r\nSLMATH_BEGIN()\r\n\r\nintersectLineBox_Line::intersectLineBox_Line( const vec3\u0026 origin, const vec3\u0026 direction ) :\r\n\to( origin ),\r\n\td( direction ),\r\n\tinv_d( fabsf(direction.x) \u003e FLT_MIN ? 1.f/direction.x : FLT_MAX, \r\n\t\t   fabsf(direction.y) \u003e FLT_MIN ? 1.f/direction.y : FLT_MAX, \r\n\t\t   fabsf(direction.z) \u003e FLT_MIN ? 1.f/direction.z : FLT_MAX ),\r\n\tsignx( direction.x \u003c 0.f ),\r\n\tsigny( direction.y \u003c 0.f ),\r\n\tsignz( direction.z \u003c 0.f )\r\n{\r\n}\r\n\r\nbool intersectLineTri( const vec3\u0026 o, const vec3\u0026 d, const vec3\u0026 v0, const vec3\u0026 v1, const vec3\u0026 v2, float* t )\r\n{\r\n\tconst vec3\te1\t\t= v1 - v0;\r\n\tconst vec3\te2\t\t= v2 - v0;\r\n\tconst vec3\tpvec\t= cross( d, e2 );\r\n\tconst float det\t\t= dot( e1, pvec );\r\n\tif ( fabsf(det) \u003c= FLT_MIN )\r\n\t\treturn false;\r\n\r\n\tconst float invdet\t= 1.f / det;\r\n\tconst vec3\ttvec\t= o - v0;\r\n\tconst float u\t\t= dot(tvec,pvec) * invdet;\r\n\tif ( 0.f \u003e u || 1.f \u003c u )\r\n\t\treturn false;\r\n\r\n\tconst vec3\tqvec\t= cross( tvec, e1 );\r\n\tconst float v\t\t= dot(d,qvec) * invdet;\r\n\tif ( 0.f \u003e v || 1.f \u003c u + v )\r\n\t\treturn false;\r\n\tconst float s\t\t= dot(e2,qvec) * invdet;\r\n\tif ( s \u003c 0.f || s \u003e= 1.f )\r\n\t\treturn false;\r\n\r\n\tif (t) \r\n\t\t*t = s;\r\n\r\n\tassert( s \u003e= 0.f \u0026\u0026 s \u003c= 1.f );\r\n\treturn true;\r\n}\r\n\r\nbool intersectLineBox( const intersectLineBox_Line\u0026 r, const vec3* boxminmax )\r\n{\r\n\tconst float t0 = 0.0f;\r\n\tconst float t1 = 1.0f;\r\n\r\n\tconst int* const sign = \u0026r.signx;\r\n\tregister float tmin, tmax, tymin, tymax, tzmin, tzmax;\r\n\ttmin = (boxminmax[sign[0]].x - r.o.x) * r.inv_d.x;\r\n\ttmax = (boxminmax[1-sign[0]].x - r.o.x) * r.inv_d.x;\r\n\ttymin = (boxminmax[sign[1]].y - r.o.y) * r.inv_d.y;\r\n\ttymax = (boxminmax[1-sign[1]].y - r.o.y) * r.inv_d.y;\r\n\tif ( (tmin \u003e tymax) || (tymin \u003e tmax) ) \r\n\t\treturn false;\r\n\tif (tymin \u003e tmin)\r\n\t\ttmin = tymin;\r\n\tif (tymax \u003c tmax)\r\n\t\ttmax = tymax;\r\n\ttzmin = (boxminmax[sign[2]].z - r.o.z) * r.inv_d.z;\r\n\ttzmax = (boxminmax[1-sign[2]].z - r.o.z) * r.inv_d.z;\r\n\tif ( (tmin \u003e tzmax) || (tzmin \u003e tmax) ) \r\n\t\treturn false;\r\n\tif (tzmin \u003e tmin)\r\n\ttmin = tzmin;\r\n\tif (tzmax \u003c tmax)\r\n\t\ttmax = tzmax;\r\n\treturn ( (tmin \u003c t1) \u0026\u0026 (tmax \u003e t0) );\r\n}\r\n\r\nbool intersectLineBox( const vec3\u0026 o, const vec3\u0026 d, const vec3\u0026 boxmin, const vec3\u0026 boxmax )\r\n{\r\n\t// these could be pre-init per line\r\n\tintersectLineBox_Line line( o, d );\r\n\t// these could be pre-init per box\r\n\tconst vec3 boxminmax[2] = {boxmin, boxmax};\r\n\treturn intersectLineBox( line, boxminmax );\r\n}\r\n\r\nSLMATH_END()\r\n\r\n// This file is part of 'slm' C++ library. Copyright (C) 2009 Jani Kajala (kajala@gmail.com). See http://sourceforge.net/projects/slm/\r\n"}
{"repo_name":"kzhong1991/Flight-AR.Drone-2","ref":"refs/heads/master","path":"src/3rdparty/Qt4.8.4/src/3rdparty/webkit/Source/WebCore/platform/graphics/mac/GlyphPageTreeNodeMac.cpp","copies":"43","language":"C++","content":"/*\n * Copyright (C) 2006, 2007 Apple Inc. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1.  Redistributions of source code must retain the above copyright\n *     notice, this list of conditions and the following disclaimer. \n * 2.  Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution. \n * 3.  Neither the name of Apple Computer, Inc. (\"Apple\") nor the names of\n *     its contributors may be used to endorse or promote products derived\n *     from this software without specific prior written permission. \n *\n * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"config.h\"\n#include \"GlyphPageTreeNode.h\"\n\n#include \"Font.h\"\n#include \"SimpleFontData.h\"\n#include \"WebCoreSystemInterface.h\"\n#include \u003cApplicationServices/ApplicationServices.h\u003e\n\nnamespace WebCore {\n\nstatic bool shouldUseCoreText(UChar* buffer, unsigned bufferLength, const SimpleFontData* fontData)\n{\n    if (fontData-\u003eplatformData().widthVariant() != RegularWidth || fontData-\u003ehasVerticalGlyphs()) {\n        // Ideographs don't have a vertical variant or width variants.\n        for (unsigned i = 0; i \u003c bufferLength; ++i) {\n            if (!Font::isCJKIdeograph(buffer[i]))\n                return true;\n        }\n    }\n\n    return false;\n}\n\nbool GlyphPage::fill(unsigned offset, unsigned length, UChar* buffer, unsigned bufferLength, const SimpleFontData* fontData)\n{\n    bool haveGlyphs = false;\n\n    if (!shouldUseCoreText(buffer, bufferLength, fontData)) {\n        Vector\u003cCGGlyph, 512\u003e glyphs(bufferLength);\n        wkGetGlyphsForCharacters(fontData-\u003eplatformData().cgFont(), buffer, glyphs.data(), bufferLength);\n        for (unsigned i = 0; i \u003c length; ++i) {\n            if (!glyphs[i])\n                setGlyphDataForIndex(offset + i, 0, 0);\n            else {\n                setGlyphDataForIndex(offset + i, glyphs[i], fontData);\n                haveGlyphs = true;\n            }\n        }\n    } else {\n        // We ask CoreText for possible vertical variant glyphs\n        RetainPtr\u003cCFStringRef\u003e string(AdoptCF, CFStringCreateWithCharactersNoCopy(kCFAllocatorDefault, buffer, bufferLength, kCFAllocatorNull));\n        RetainPtr\u003cCFAttributedStringRef\u003e attributedString(AdoptCF, CFAttributedStringCreate(kCFAllocatorDefault, string.get(), fontData-\u003egetCFStringAttributes(0, fontData-\u003ehasVerticalGlyphs() ? Vertical : Horizontal)));\n        RetainPtr\u003cCTLineRef\u003e line(AdoptCF, CTLineCreateWithAttributedString(attributedString.get()));\n\n        CFArrayRef runArray = CTLineGetGlyphRuns(line.get());\n        CFIndex runCount = CFArrayGetCount(runArray);\n\n        // Initialize glyph entries\n        for (unsigned index = 0; index \u003c length; ++index)\n            setGlyphDataForIndex(offset + index, 0, 0);\n\n        Vector\u003cCGGlyph, 512\u003e glyphVector;\n        Vector\u003cCFIndex, 512\u003e indexVector;\n        bool done = false;\n\n        // For the CGFont comparison in the loop, use the CGFont that Core Text assigns to the CTFont. This may\n        // be non-CFEqual to fontData-\u003eplatformData().cgFont().\n        RetainPtr\u003cCGFontRef\u003e cgFont(AdoptCF, CTFontCopyGraphicsFont(fontData-\u003eplatformData().ctFont(), 0));\n\n        for (CFIndex r = 0; r \u003c runCount \u0026\u0026 !done ; ++r) {\n            // CTLine could map characters over multiple fonts using its own font fallback list.\n            // We need to pick runs that use the exact font we need, i.e., fontData-\u003eplatformData().ctFont().\n            CTRunRef ctRun = static_cast\u003cCTRunRef\u003e(CFArrayGetValueAtIndex(runArray, r));\n            ASSERT(CFGetTypeID(ctRun) == CTRunGetTypeID());\n\n            CFDictionaryRef attributes = CTRunGetAttributes(ctRun);\n            CTFontRef runFont = static_cast\u003cCTFontRef\u003e(CFDictionaryGetValue(attributes, kCTFontAttributeName));\n            RetainPtr\u003cCGFontRef\u003e runCGFont(AdoptCF, CTFontCopyGraphicsFont(runFont, 0));\n            // Use CGFont here as CFEqual for CTFont counts all attributes for font.\n            if (CFEqual(cgFont.get(), runCGFont.get())) {\n                // This run uses the font we want. Extract glyphs.\n                CFIndex glyphCount = CTRunGetGlyphCount(ctRun);\n                const CGGlyph* glyphs = CTRunGetGlyphsPtr(ctRun);\n                if (!glyphs) {\n                    glyphVector.resize(glyphCount);\n                    CTRunGetGlyphs(ctRun, CFRangeMake(0, 0), glyphVector.data());\n                    glyphs = glyphVector.data();\n                }\n                const CFIndex* stringIndices = CTRunGetStringIndicesPtr(ctRun);\n                if (!stringIndices) {\n                    indexVector.resize(glyphCount);\n                    CTRunGetStringIndices(ctRun, CFRangeMake(0, 0), indexVector.data());\n                    stringIndices = indexVector.data();\n                }\n\n                for (CFIndex i = 0; i \u003c glyphCount; ++i) {\n                    if (stringIndices[i] \u003e= static_cast\u003cCFIndex\u003e(length)) {\n                        done = true;\n                        break;\n                    }\n                    if (glyphs[i]) {\n                        setGlyphDataForIndex(offset + stringIndices[i], glyphs[i], fontData);\n                        haveGlyphs = true;\n                    }\n                }\n            }\n        }\n    }\n\n    return haveGlyphs;\n}\n\n} // namespace WebCore\n"}
{"repo_name":"android-ia/platform_external_chromium_org_third_party_WebKit","ref":"refs/heads/master","path":"Source/core/dom/PseudoElement.cpp","copies":"11","language":"C++","content":"/*\n * Copyright (C) 2012 Google Inc. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Neither the name of Google Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"config.h\"\n#include \"core/dom/PseudoElement.h\"\n\n#include \"core/inspector/InspectorInstrumentation.h\"\n#include \"core/rendering/RenderObject.h\"\n#include \"core/rendering/RenderQuote.h\"\n#include \"core/rendering/style/ContentData.h\"\n\nnamespace blink {\n\nconst QualifiedName\u0026 pseudoElementTagName(PseudoId pseudoId)\n{\n    switch (pseudoId) {\n    case AFTER: {\n        DEFINE_STATIC_LOCAL(QualifiedName, after, (nullAtom, \"\u003cpseudo:after\u003e\", nullAtom));\n        return after;\n    }\n    case BEFORE: {\n        DEFINE_STATIC_LOCAL(QualifiedName, before, (nullAtom, \"\u003cpseudo:before\u003e\", nullAtom));\n        return before;\n    }\n    case BACKDROP: {\n        DEFINE_STATIC_LOCAL(QualifiedName, backdrop, (nullAtom, \"\u003cpseudo:backdrop\u003e\", nullAtom));\n        return backdrop;\n    }\n    default: {\n        ASSERT_NOT_REACHED();\n    }\n    }\n    DEFINE_STATIC_LOCAL(QualifiedName, name, (nullAtom, \"\u003cpseudo\u003e\", nullAtom));\n    return name;\n}\n\nString PseudoElement::pseudoElementNameForEvents(PseudoId pseudoId)\n{\n    DEFINE_STATIC_LOCAL(const String, after, (\"::after\"));\n    DEFINE_STATIC_LOCAL(const String, before, (\"::before\"));\n    switch (pseudoId) {\n    case AFTER:\n        return after;\n    case BEFORE:\n        return before;\n    default:\n        return emptyString();\n    }\n}\n\nPseudoElement::PseudoElement(Element* parent, PseudoId pseudoId)\n    : Element(pseudoElementTagName(pseudoId), \u0026parent-\u003edocument(), CreateElement)\n    , m_pseudoId(pseudoId)\n{\n    ASSERT(pseudoId != NOPSEUDO);\n    setParentOrShadowHostNode(parent);\n    setHasCustomStyleCallbacks();\n}\n\nPassRefPtr\u003cRenderStyle\u003e PseudoElement::customStyleForRenderer()\n{\n    return parentOrShadowHostElement()-\u003erenderer()-\u003egetCachedPseudoStyle(m_pseudoId);\n}\n\nvoid PseudoElement::dispose()\n{\n    ASSERT(parentOrShadowHostElement());\n\n    InspectorInstrumentation::pseudoElementDestroyed(this);\n\n    ASSERT(!nextSibling());\n    ASSERT(!previousSibling());\n\n    detach();\n    RefPtrWillBeRawPtr\u003cElement\u003e parent = parentOrShadowHostElement();\n    setParentOrShadowHostNode(0);\n    removedFrom(parent.get());\n}\n\nvoid PseudoElement::attach(const AttachContext\u0026 context)\n{\n    ASSERT(!renderer());\n\n    Element::attach(context);\n\n    RenderObject* renderer = this-\u003erenderer();\n    if (!renderer)\n        return;\n    RenderStyle* style = renderer-\u003estyle();\n    if (style-\u003estyleType() != BEFORE \u0026\u0026 style-\u003estyleType() != AFTER)\n        return;\n    ASSERT(style-\u003econtentData());\n\n    for (const ContentData* content = style-\u003econtentData(); content; content = content-\u003enext()) {\n        RenderObject* child = content-\u003ecreateRenderer(document(), style);\n        if (renderer-\u003eisChildAllowed(child, style)) {\n            renderer-\u003eaddChild(child);\n            if (child-\u003eisQuote())\n                toRenderQuote(child)-\u003eattachQuote();\n        } else\n            child-\u003edestroy();\n    }\n}\n\nbool PseudoElement::rendererIsNeeded(const RenderStyle\u0026 style)\n{\n    return pseudoElementRendererIsNeeded(\u0026style);\n}\n\nvoid PseudoElement::didRecalcStyle(StyleRecalcChange)\n{\n    if (!renderer())\n        return;\n\n    // The renderers inside pseudo elements are anonymous so they don't get notified of recalcStyle and must have\n    // the style propagated downward manually similar to RenderObject::propagateStyleToAnonymousChildren.\n    RenderObject* renderer = this-\u003erenderer();\n    for (RenderObject* child = renderer-\u003enextInPreOrder(renderer); child; child = child-\u003enextInPreOrder(renderer)) {\n        // We only manage the style for the generated content items.\n        if (!child-\u003eisText() \u0026\u0026 !child-\u003eisQuote() \u0026\u0026 !child-\u003eisImage())\n            continue;\n\n        // The style for the RenderTextFragment for first letter is managed by an enclosing block, not by us.\n        if (child-\u003estyle()-\u003estyleType() == FIRST_LETTER)\n            continue;\n\n        child-\u003esetPseudoStyle(renderer-\u003estyle());\n    }\n}\n\n} // namespace\n"}
{"repo_name":"erdincay/clamav-devel","ref":"refs/heads/master","path":"libclamav/c++/llvm/lib/Target/PowerPC/PPCSelectionDAGInfo.cpp","copies":"51","language":"C++","content":"//===-- PPCSelectionDAGInfo.cpp - PowerPC SelectionDAG Info ---------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n//\n// This file implements the PPCSelectionDAGInfo class.\n//\n//===----------------------------------------------------------------------===//\n\n#define DEBUG_TYPE \"powerpc-selectiondag-info\"\n#include \"PPCTargetMachine.h\"\nusing namespace llvm;\n\nPPCSelectionDAGInfo::PPCSelectionDAGInfo(const PPCTargetMachine \u0026TM)\n  : TargetSelectionDAGInfo(TM) {\n}\n\nPPCSelectionDAGInfo::~PPCSelectionDAGInfo() {\n}\n"}
{"repo_name":"Maximus-/WinObjC","ref":"refs/heads/master","path":"deps/3rdparty/iculegacy/source/test/intltest/testidna.cpp","copies":"179","language":"C++","content":"/*\n *******************************************************************************\n *\n *   Copyright (C) 2003-2010, International Business Machines\n *   Corporation and others.  All Rights Reserved.\n *\n *******************************************************************************\n *   file name:  testidna.cpp\n *   encoding:   US-ASCII\n *   tab size:   8 (not used)\n *   indentation:4\n *\n *   created on: 2003feb1\n *   created by: Ram Viswanadha\n */\n\n#include \"unicode/utypes.h\"\n\n#if !UCONFIG_NO_IDNA \u0026\u0026 !UCONFIG_NO_TRANSLITERATION\n\n#include \u003ctime.h\u003e\n#include \u003climits.h\u003e\n#include \u003cstdlib.h\u003e\n#include \u003cstring.h\u003e\n#include \"unicode/localpointer.h\"\n#include \"unicode/ustring.h\"\n#include \"unicode/usprep.h\"\n#include \"unicode/uniset.h\"\n#include \"testidna.h\"\n#include \"idnaref.h\"\n#include \"nptrans.h\"\n#include \"unicode/putil.h\"\n#include \"idnaconf.h\"\n\nstatic const UChar unicodeIn[][41] ={\n    { \n        0x0644, 0x064A, 0x0647, 0x0645, 0x0627, 0x0628, 0x062A, 0x0643, 0x0644,\n        0x0645, 0x0648, 0x0634, 0x0639, 0x0631, 0x0628, 0x064A, 0x061F, 0x0000\n    },\n    {\n        0x4ED6, 0x4EEC, 0x4E3A, 0x4EC0, 0x4E48, 0x4E0D, 0x8BF4, 0x4E2D, 0x6587, \n        0x0000\n    },\n    {\n        0x0050, 0x0072, 0x006F, 0x010D, 0x0070, 0x0072, 0x006F, 0x0073, 0x0074,\n        0x011B, 0x006E, 0x0065, 0x006D, 0x006C, 0x0075, 0x0076, 0x00ED, 0x010D,\n        0x0065, 0x0073, 0x006B, 0x0079, 0x0000\n    },\n    {\n        0x05DC, 0x05DE, 0x05D4, 0x05D4, 0x05DD, 0x05E4, 0x05E9, 0x05D5, 0x05D8,\n        0x05DC, 0x05D0, 0x05DE, 0x05D3, 0x05D1, 0x05E8, 0x05D9, 0x05DD, 0x05E2,\n        0x05D1, 0x05E8, 0x05D9, 0x05EA, 0x0000\n    },\n    {\n        0x092F, 0x0939, 0x0932, 0x094B, 0x0917, 0x0939, 0x093F, 0x0928, 0x094D,\n        0x0926, 0x0940, 0x0915, 0x094D, 0x092F, 0x094B, 0x0902, 0x0928, 0x0939,\n        0x0940, 0x0902, 0x092C, 0x094B, 0x0932, 0x0938, 0x0915, 0x0924, 0x0947,\n        0x0939, 0x0948, 0x0902, 0x0000\n    },\n    {\n        0x306A, 0x305C, 0x307F, 0x3093, 0x306A, 0x65E5, 0x672C, 0x8A9E, 0x3092,\n        0x8A71, 0x3057, 0x3066, 0x304F, 0x308C, 0x306A, 0x3044, 0x306E, 0x304B,\n        0x0000\n    },\n/*  \n    {\n        0xC138, 0xACC4, 0xC758, 0xBAA8, 0xB4E0, 0xC0AC, 0xB78C, 0xB4E4, 0xC774,\n        0xD55C, 0xAD6D, 0xC5B4, 0xB97C, 0xC774, 0xD574, 0xD55C, 0xB2E4, 0xBA74,\n        0xC5BC, 0xB9C8, 0xB098, 0xC88B, 0xC744, 0xAE4C, 0x0000\n    },\n*/\n    {   \n        0x043F, 0x043E, 0x0447, 0x0435, 0x043C, 0x0443, 0x0436, 0x0435, 0x043E,\n        0x043D, 0x0438, 0x043D, 0x0435, 0x0433, 0x043E, 0x0432, 0x043E, 0x0440,\n        0x044F, 0x0442, 0x043F, 0x043E, 0x0440, 0x0443, 0x0441, 0x0441, 0x043A,\n        0x0438, 0x0000\n    },\n    {\n        0x0050, 0x006F, 0x0072, 0x0071, 0x0075, 0x00E9, 0x006E, 0x006F, 0x0070,\n        0x0075, 0x0065, 0x0064, 0x0065, 0x006E, 0x0073, 0x0069, 0x006D, 0x0070,\n        0x006C, 0x0065, 0x006D, 0x0065, 0x006E, 0x0074, 0x0065, 0x0068, 0x0061,\n        0x0062, 0x006C, 0x0061, 0x0072, 0x0065, 0x006E, 0x0045, 0x0073, 0x0070,\n        0x0061, 0x00F1, 0x006F, 0x006C, 0x0000\n    },\n    {\n        0x4ED6, 0x5011, 0x7232, 0x4EC0, 0x9EBD, 0x4E0D, 0x8AAA, 0x4E2D, 0x6587,\n        0x0000\n    },\n    {\n        0x0054, 0x1EA1, 0x0069, 0x0073, 0x0061, 0x006F, 0x0068, 0x1ECD, 0x006B,\n        0x0068, 0x00F4, 0x006E, 0x0067, 0x0074, 0x0068, 0x1EC3, 0x0063, 0x0068,\n        0x1EC9, 0x006E, 0x00F3, 0x0069, 0x0074, 0x0069, 0x1EBF, 0x006E, 0x0067,\n        0x0056, 0x0069, 0x1EC7, 0x0074, 0x0000\n    },\n    {\n        0x0033, 0x5E74, 0x0042, 0x7D44, 0x91D1, 0x516B, 0x5148, 0x751F, 0x0000\n    },\n    {\n        0x5B89, 0x5BA4, 0x5948, 0x7F8E, 0x6075, 0x002D, 0x0077, 0x0069, 0x0074,\n        0x0068, 0x002D, 0x0053, 0x0055, 0x0050, 0x0045, 0x0052, 0x002D, 0x004D,\n        0x004F, 0x004E, 0x004B, 0x0045, 0x0059, 0x0053, 0x0000\n    },\n    {\n        0x0048, 0x0065, 0x006C, 0x006C, 0x006F, 0x002D, 0x0041, 0x006E, 0x006F,\n        0x0074, 0x0068, 0x0065, 0x0072, 0x002D, 0x0057, 0x0061, 0x0079, 0x002D,\n        0x305D, 0x308C, 0x305E, 0x308C, 0x306E, 0x5834, 0x6240, 0x0000\n    },\n    {\n        0x3072, 0x3068, 0x3064, 0x5C4B, 0x6839, 0x306E, 0x4E0B, 0x0032, 0x0000\n    },\n    {\n        0x004D, 0x0061, 0x006A, 0x0069, 0x3067, 0x004B, 0x006F, 0x0069, 0x3059,\n        0x308B, 0x0035, 0x79D2, 0x524D, 0x0000\n    },\n    {\n        0x30D1, 0x30D5, 0x30A3, 0x30FC, 0x0064, 0x0065, 0x30EB, 0x30F3, 0x30D0,\n        0x0000\n    },\n    {\n        0x305D, 0x306E, 0x30B9, 0x30D4, 0x30FC, 0x30C9, 0x3067, 0x0000\n    },\n    // test non-BMP code points\n    {    \n        0xD800, 0xDF00, 0xD800, 0xDF01, 0xD800, 0xDF02, 0xD800, 0xDF03, 0xD800, 0xDF05,\n        0xD800, 0xDF06, 0xD800, 0xDF07, 0xD800, 0xDF09, 0xD800, 0xDF0A, 0xD800, 0xDF0B,\n        0x0000\n    },\n    {\n        0xD800, 0xDF0D, 0xD800, 0xDF0C, 0xD800, 0xDF1E, 0xD800, 0xDF0F, 0xD800, 0xDF16,\n        0xD800, 0xDF15, 0xD800, 0xDF14, 0xD800, 0xDF12, 0xD800, 0xDF10, 0xD800, 0xDF20,\n        0xD800, 0xDF21,\n        0x0000\n    },\n    // Greek\n    {\n        0x03b5, 0x03bb, 0x03bb, 0x03b7, 0x03bd, 0x03b9, 0x03ba, 0x03ac\n    },\n    // Maltese\n    {\n        0x0062, 0x006f, 0x006e, 0x0121, 0x0075, 0x0073, 0x0061, 0x0127,\n        0x0127, 0x0061\n    },\n    // Russian\n    {\n        0x043f, 0x043e, 0x0447, 0x0435, 0x043c, 0x0443, 0x0436, 0x0435,\n        0x043e, 0x043d, 0x0438, 0x043d, 0x0435, 0x0433, 0x043e, 0x0432,\n        0x043e, 0x0440, 0x044f, 0x0442, 0x043f, 0x043e, 0x0440, 0x0443,\n        0x0441, 0x0441, 0x043a, 0x0438\n    },\n    {\n        0xFB00, 0xFB01\n    }\n\n};\n\nstatic const char *asciiIn[] = {\n    \"xn--egbpdaj6bu4bxfgehfvwxn\",\n    \"xn--ihqwcrb4cv8a8dqg056pqjye\",\n    \"xn--Proprostnemluvesky-uyb24dma41a\",\n    \"xn--4dbcagdahymbxekheh6e0a7fei0b\",\n    \"xn--i1baa7eci9glrd9b2ae1bj0hfcgg6iyaf8o0a1dig0cd\",\n    \"xn--n8jok5ay5dzabd5bym9f0cm5685rrjetr6pdxa\",\n/*  \"xn--989aomsvi5e83db1d2a355cv1e0vak1dwrv93d5xbh15a0dt30a5jpsd879ccm6fea98c\",*/\n    \"xn--b1abfaaepdrnnbgefbaDotcwatmq2g4l\",\n    \"xn--PorqunopuedensimplementehablarenEspaol-fmd56a\",\n    \"xn--ihqwctvzc91f659drss3x8bo0yb\",\n    \"xn--TisaohkhngthchnitingVit-kjcr8268qyxafd2f1b9g\",\n    \"xn--3B-ww4c5e180e575a65lsy2b\",\n    \"xn---with-SUPER-MONKEYS-pc58ag80a8qai00g7n9n\",\n    \"xn--Hello-Another-Way--fc4qua05auwb3674vfr0b\",\n    \"xn--2-u9tlzr9756bt3uc0v\",\n    \"xn--MajiKoi5-783gue6qz075azm5e\",\n    \"xn--de-jg4avhby1noc0d\",\n    \"xn--d9juau41awczczp\",\n    \"XN--097CCDEKGHQJK\",\n    \"XN--db8CBHEJLGH4E0AL\",\n    \"xn--hxargifdar\",                       // Greek\n    \"xn--bonusaa-5bb1da\",                   // Maltese\n    \"xn--b1abfaaepdrnnbgefbadotcwatmq2g4l\", // Russian (Cyrillic)\n    \"fffi\"\n};\n\nstatic const char *domainNames[] = {\n    \"slip129-37-118-146.nc.us.ibm.net\",\n    \"saratoga.pe.utexas.edu\",\n    \"dial-120-45.ots.utexas.edu\",\n    \"woo-085.dorms.waller.net\",\n    \"hd30-049.hil.compuserve.com\",\n    \"pem203-31.pe.ttu.edu\",\n    \"56K-227.MaxTNT3.pdq.net\",\n    \"dial-36-2.ots.utexas.edu\",\n    \"slip129-37-23-152.ga.us.ibm.net\",\n    \"ts45ip119.cadvision.com\",\n    \"sdn-ts-004txaustP05.dialsprint.net\",\n    \"bar-tnt1s66.erols.com\",\n    \"101.st-louis-15.mo.dial-access.att.net\",\n    \"h92-245.Arco.COM\",\n    \"dial-13-2.ots.utexas.edu\",\n    \"net-redynet29.datamarkets.com.ar\",\n    \"ccs-shiva28.reacciun.net.ve\",\n    \"7.houston-11.tx.dial-access.att.net\",\n    \"ingw129-37-120-26.mo.us.ibm.net\",\n    \"dialup6.austintx.com\",\n    \"dns2.tpao.gov.tr\",\n    \"slip129-37-119-194.nc.us.ibm.net\",\n    \"cs7.dillons.co.uk.203.119.193.in-addr.arpa\",\n    \"swprd1.innovplace.saskatoon.sk.ca\",\n    \"bikini.bologna.maraut.it\",\n    \"node91.subnet159-198-79.baxter.com\",\n    \"cust19.max5.new-york.ny.ms.uu.net\",\n    \"balexander.slip.andrew.cmu.edu\",\n    \"pool029.max2.denver.co.dynip.alter.net\",\n    \"cust49.max9.new-york.ny.ms.uu.net\",\n    \"s61.abq-dialin2.hollyberry.com\",\n    \"\\\\u0917\\\\u0928\\\\u0947\\\\u0936.sanjose.ibm.com\", //':'(0x003a) produces U_IDNA_STD3_ASCII_RULES_ERROR\n    \"www.xn--vea.com\",\n   // \"www.\\\\u00E0\\\\u00B3\\\\u00AF.com\",//' ' (0x0020) produces U_IDNA_STD3_ASCII_RULES_ERROR\n    \"www.\\\\u00C2\\\\u00A4.com\",\n    \"www.\\\\u00C2\\\\u00A3.com\",\n    // \"\\\\u0025\", //'%' (0x0025) produces U_IDNA_STD3_ASCII_RULES_ERROR\n    // \"\\\\u005C\\\\u005C\", //'\\' (0x005C) produces U_IDNA_STD3_ASCII_RULES_ERROR\n    //\"@\",\n    //\"\\\\u002F\",\n    //\"www.\\\\u0021.com\",\n    //\"www.\\\\u0024.com\",\n    //\"\\\\u003f\",\n    // These yeild U_IDNA_PROHIBITED_ERROR\n    //\"\\\\u00CF\\\\u0082.com\",\n    //\"\\\\u00CE\\\\u00B2\\\\u00C3\\\\u009Fss.com\",\n    //\"\\\\u00E2\\\\u0098\\\\u00BA.com\",\n    \"\\\\u00C3\\\\u00BC.com\",\n\n};\n\ntypedef struct ErrorCases ErrorCases;\n\nstatic const struct ErrorCases{\n\n    UChar unicode[100];\n    const char *ascii;\n    UErrorCode expected;\n    UBool useSTD3ASCIIRules;\n    UBool testToUnicode;\n    UBool testLabel;\n} errorCases[] = {\n      {\n        \n        { \n            0x0077, 0x0077, 0x0077, 0x002e, /* www. */\n            0xC138, 0xACC4, 0xC758, 0xBAA8, 0xB4E0, 0xC0AC, 0xB78C, 0xB4E4, 0xC774,\n            0x070F,/*prohibited*/\n            0xD55C, 0xAD6D, 0xC5B4, 0xB97C, 0xC774, 0xD574, 0xD55C, 0xB2E4, 0xBA74,\n            0x002e, 0x0063, 0x006f, 0x006d, /* com. */\n            0x0000\n        },\n        \"www.XN--8mb5595fsoa28orucya378bqre2tcwop06c5qbw82a1rffmae0361dea96b.com\",\n        U_IDNA_PROHIBITED_ERROR,\n        FALSE, FALSE, TRUE\n    },\n\n    {\n        { \n            0x0077, 0x0077, 0x0077, 0x002e, /* www. */\n            0xC138, 0xACC4, 0xC758, 0xBAA8, 0xB4E0, 0xC0AC, 0xB78C, 0xB4E4, 0xC774,\n            0x0221, 0x0234/*Unassigned code points*/,\n            0x002e, 0x0063, 0x006f, 0x006d, /* com. */\n            0x0000\n        },\n        \"www.XN--6lA2Bz548Fj1GuA391Bf1Gb1N59Ab29A7iA.com\",\n\n        U_IDNA_UNASSIGNED_ERROR,\n        FALSE, FALSE, TRUE\n    },\n    {\n        { \n            0x0077, 0x0077, 0x0077, 0x002e, /* www. */\n            0xC138, 0xACC4, 0xC758, 0xBAA8, 0xB4E0, 0xC0AC, 0xB78C, 0xB4E4, 0xC774,\n            0x0644, 0x064A, 0x0647,/*Arabic code points. Cannot mix RTL with LTR*/\n            0xD55C, 0xAD6D, 0xC5B4, 0xB97C, 0xC774, 0xD574, 0xD55C, 0xB2E4, 0xBA74,\n            0x002e, 0x0063, 0x006f, 0x006d, /* com. */\n            0x0000\n        },\n        \"www.xn--ghBGI4851OiyA33VqrD6Az86C4qF83CtRv93D5xBk15AzfG0nAgA0578DeA71C.com\",\n        U_IDNA_CHECK_BIDI_ERROR,\n        FALSE, FALSE, TRUE\n    },\n    {\n        { \n            0x0077, 0x0077, 0x0077, 0x002e, /* www. */\n            /* labels cannot begin with an HYPHEN */\n            0x002D, 0xACC4, 0xC758, 0xBAA8, 0xB4E0, 0xC0AC, 0xB78C, 0xB4E4, 0xC774,\n            0x002E, \n            0xD55C, 0xAD6D, 0xC5B4, 0xB97C, 0xC774, 0xD574, 0xD55C, 0xB2E4, 0xBA74,\n            0x002e, 0x0063, 0x006f, 0x006d, /* com. */\n            0x0000\n            \n        },\n        \"www.xn----b95Ew8SqA315Ao5FbuMlnNmhA.com\",\n        U_IDNA_STD3_ASCII_RULES_ERROR,\n        TRUE, FALSE, FALSE\n    },\n    {\n        { \n            /* correct ACE-prefix followed by unicode */\n            0x0077, 0x0077, 0x0077, 0x002e, /* www. */\n            0x0078, 0x006e, 0x002d,0x002d,  /* ACE Prefix */\n            0x002D, 0xACC4, 0xC758, 0xBAA8, 0xB4E0, 0xC0AC, 0xB78C, 0xB4E4, 0xC774,\n            0x002D, \n            0xD55C, 0xAD6D, 0xC5B4, 0xB97C, 0xC774, 0xD574, 0xD55C, 0xB2E4, 0xBA74,\n            0x002e, 0x0063, 0x006f, 0x006d, /* com. */\n            0x0000\n            \n        },\n        /* wrong ACE-prefix followed by valid ACE-encoded ASCII */ \n        \"www.XY-----b91I0V65S96C2A355Cw1E5yCeQr19CsnP1mFfmAE0361DeA96B.com\",\n        U_IDNA_ACE_PREFIX_ERROR,\n        FALSE, FALSE, FALSE\n    },\n    /* cannot verify U_IDNA_VERIFICATION_ERROR */\n\n    { \n      {\n        0x0077, 0x0077, 0x0077, 0x002e, /* www. */\n        0xC138, 0xACC4, 0xC758, 0xBAA8, 0xB4E0, 0xC0AC, 0xB78C, 0xB4E4, 0xC774,\n        0xD55C, 0xAD6D, 0xC5B4, 0xB97C, 0xC774, 0xD574, 0xD55C, 0xB2E4, 0xBA74,\n        0xC5BC, 0xB9C8, 0xB098, 0xC88B, 0xC744, 0xAE4C, \n        0x002e, 0x0063, 0x006f, 0x006d, /* com. */\n        0x0000\n      },\n      \"www.xn--989AoMsVi5E83Db1D2A355Cv1E0vAk1DwRv93D5xBh15A0Dt30A5JpSD879Ccm6FeA98C.com\",\n      U_IDNA_LABEL_TOO_LONG_ERROR,\n      FALSE, FALSE, TRUE\n    },  \n    \n    { \n      {\n        0x0077, 0x0077, 0x0077, 0x002e, /* www. */\n        0x0030, 0x0644, 0x064A, 0x0647, 0x0031, /* Arabic code points squashed between EN codepoints */\n        0x002e, 0x0063, 0x006f, 0x006d, /* com. */\n        0x0000\n      },\n      \"www.xn--01-tvdmo.com\",\n      U_IDNA_CHECK_BIDI_ERROR,\n      FALSE, FALSE, TRUE\n    },  \n    \n    { \n      {\n        0x0077, 0x0077, 0x0077, 0x002e, // www. \n        0x206C, 0x0644, 0x064A, 0x0647, 0x206D, // Arabic code points squashed between BN codepoints \n        0x002e, 0x0063, 0x006f, 0x006d, // com. \n        0x0000\n      },\n      \"www.XN--ghbgi278xia.com\",\n      U_IDNA_PROHIBITED_ERROR,\n      FALSE, FALSE, TRUE\n    },\n    { \n      {\n        0x0077, 0x0077, 0x0077, 0x002e, // www. \n        0x002D, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, // HYPHEN at the start of label \n        0x002e, 0x0063, 0x006f, 0x006d, // com. \n        0x0000\n      },\n      \"www.-abcde.com\",\n      U_IDNA_STD3_ASCII_RULES_ERROR,\n      TRUE, FALSE, FALSE\n    },\n    { \n      {\n        0x0077, 0x0077, 0x0077, 0x002e, // www. \n        0x0041, 0x0042, 0x0043, 0x0044, 0x0045,0x002D, // HYPHEN at the end of the label\n        0x002e, 0x0063, 0x006f, 0x006d, // com. \n        0x0000\n      },\n      \"www.abcde-.com\",\n      U_IDNA_STD3_ASCII_RULES_ERROR,\n      TRUE, FALSE, FALSE\n    },\n    { \n      {\n        0x0077, 0x0077, 0x0077, 0x002e, // www. \n        0x0041, 0x0042, 0x0043, 0x0044, 0x0045,0x0040, // Containing non LDH code point\n        0x002e, 0x0063, 0x006f, 0x006d, // com. \n        0x0000\n      },\n      \"www.abcde@.com\",\n      U_IDNA_STD3_ASCII_RULES_ERROR,\n      TRUE, FALSE, FALSE\n    },\n    { \n      {\n        0x0077, 0x0077, 0x0077, 0x002e, // www. \n        // zero length label\n        0x002e, 0x0063, 0x006f, 0x006d, // com. \n        0x0000\n      },\n      \"www..com\",\n      U_IDNA_ZERO_LENGTH_LABEL_ERROR,\n      TRUE, FALSE, FALSE\n    },\n    { \n      {0},\n      NULL,\n      U_ILLEGAL_ARGUMENT_ERROR,\n      TRUE, TRUE, FALSE\n    }\n};\n\n\n\n\n#define MAX_DEST_SIZE 300\n\nvoid TestIDNA::debug(const UChar* src, int32_t srcLength, int32_t options){\n    UParseError parseError;\n    UErrorCode transStatus = U_ZERO_ERROR;\n    UErrorCode prepStatus  = U_ZERO_ERROR;\n    NamePrepTransform* trans = NamePrepTransform::createInstance(parseError,transStatus);\n    int32_t prepOptions = (((options \u0026 UIDNA_ALLOW_UNASSIGNED) != 0) ? USPREP_ALLOW_UNASSIGNED: 0);\n    LocalUStringPrepProfilePointer prep(usprep_openByType(USPREP_RFC3491_NAMEPREP,\u0026prepStatus));\n    UChar *transOut=NULL, *prepOut=NULL;\n    int32_t transOutLength=0, prepOutLength=0;\n    \n    \n    transOutLength  = trans-\u003eprocess(src,srcLength,transOut, 0, prepOptions\u003e0, \u0026parseError, transStatus);\n    if( transStatus == U_BUFFER_OVERFLOW_ERROR){\n        transStatus = U_ZERO_ERROR;\n        transOut    = (UChar*) malloc(U_SIZEOF_UCHAR * transOutLength);\n        transOutLength = trans-\u003eprocess(src,srcLength,transOut, transOutLength, prepOptions\u003e0, \u0026parseError, transStatus);\n    }\n\n    prepOutLength  = usprep_prepare(prep.getAlias(), src, srcLength, prepOut, 0, prepOptions, \u0026parseError, \u0026prepStatus);\n\n    if( prepStatus == U_BUFFER_OVERFLOW_ERROR){\n        prepStatus = U_ZERO_ERROR;\n        prepOut    = (UChar*) malloc(U_SIZEOF_UCHAR * prepOutLength);\n        prepOutLength  = usprep_prepare(prep.getAlias(), src, srcLength, prepOut, prepOutLength, prepOptions, \u0026parseError, \u0026prepStatus);\n    }\n\n    if(UnicodeString(transOut,transOutLength)!= UnicodeString(prepOut, prepOutLength)){\n        errln(\"Failed. Expected: \" + prettify(UnicodeString(transOut, transOutLength))\n              + \" Got: \" + prettify(UnicodeString(prepOut,prepOutLength)));\n    }\n    free(transOut);\n    free(prepOut);\n    delete trans;\n}\n\nvoid TestIDNA::testAPI(const UChar* src, const UChar* expected, const char* testName, \n            UBool useSTD3ASCIIRules,UErrorCode expectedStatus,\n            UBool doCompare, UBool testUnassigned, TestFunc func, UBool testSTD3ASCIIRules){\n\n    UErrorCode status = U_ZERO_ERROR;\n    UChar destStack[MAX_DEST_SIZE];\n    int32_t destLen = 0;\n    UChar* dest = NULL;\n    int32_t expectedLen = (expected != NULL) ? u_strlen(expected) : 0;\n    int32_t options = (useSTD3ASCIIRules == TRUE) ? UIDNA_USE_STD3_RULES : UIDNA_DEFAULT;\n    UParseError parseError;\n    int32_t tSrcLen = 0; \n    UChar* tSrc = NULL; \n\n    if(src != NULL){\n        tSrcLen = u_strlen(src);\n        tSrc  =(UChar*) malloc( U_SIZEOF_UCHAR * tSrcLen );\n        memcpy(tSrc,src,tSrcLen * U_SIZEOF_UCHAR);\n    }\n\n    // test null-terminated source and return value of number of UChars required\n    destLen = func(src,-1,NULL,0,options, \u0026parseError , \u0026status);\n    if(status == U_BUFFER_OVERFLOW_ERROR){\n        status = U_ZERO_ERROR; // reset error code\n        if(destLen+1 \u003c MAX_DEST_SIZE){\n            dest = destStack;\n            destLen = func(src,-1,dest,destLen+1,options, \u0026parseError, \u0026status);\n            // TODO : compare output with expected\n            if(U_SUCCESS(status) \u0026\u0026 expectedStatus != U_IDNA_STD3_ASCII_RULES_ERROR\u0026\u0026 (doCompare==TRUE) \u0026\u0026 u_strCaseCompare(dest,destLen, expected,expectedLen,0,\u0026status)!=0){\n                errln(\"Did not get the expected result for \"+UnicodeString(testName) +\" null terminated source. Expected : \" \n                       + prettify(UnicodeString(expected,expectedLen))\n                       + \" Got: \" + prettify(UnicodeString(dest,destLen))\n                    );\n            }\n        }else{\n            errln( \"%s null terminated source failed. Requires destCapacity \u003e 300\\n\",testName);\n        }\n    }\n\n    if(status != expectedStatus){\n        errcheckln(status, \"Did not get the expected error for \"+\n                UnicodeString(testName)+\n                \" null terminated source. Expected: \" +UnicodeString(u_errorName(expectedStatus))\n                + \" Got: \"+ UnicodeString(u_errorName(status))\n                + \" Source: \" + prettify(UnicodeString(src))\n               );\n        free(tSrc);\n        return;\n    } \n    if(testUnassigned ){\n        status = U_ZERO_ERROR;\n        destLen = func(src,-1,NULL,0,options | UIDNA_ALLOW_UNASSIGNED, \u0026parseError, \u0026status);\n        if(status == U_BUFFER_OVERFLOW_ERROR){\n            status = U_ZERO_ERROR; // reset error code\n            if(destLen+1 \u003c MAX_DEST_SIZE){\n                dest = destStack;\n                destLen = func(src,-1,dest,destLen+1,options | UIDNA_ALLOW_UNASSIGNED, \u0026parseError, \u0026status);\n                // TODO : compare output with expected\n                if(U_SUCCESS(status) \u0026\u0026 (doCompare==TRUE) \u0026\u0026 u_strCaseCompare(dest,destLen, expected,expectedLen,0,\u0026status)!=0){\n                    //errln(\"Did not get the expected result for %s null terminated source with both options set.\\n\",testName);\n                    errln(\"Did not get the expected result for \"+UnicodeString(testName) +\n                          \" null terminated source \"+ prettify(src) + \n                          \" with both options set. Expected: \"+  prettify(UnicodeString(expected,expectedLen))+\n                          \"Got: \" + prettify(UnicodeString(dest,destLen)));\n\n                    debug(src,-1,options | UIDNA_ALLOW_UNASSIGNED);\n            \n                }\n            }else{\n                errln( \"%s null terminated source failed. Requires destCapacity \u003e 300\\n\",testName);\n            }\n        }\n        //testing query string\n        if(status != expectedStatus \u0026\u0026 expectedStatus != U_IDNA_UNASSIGNED_ERROR){\n                errln( \"Did not get the expected error for \"+\n                    UnicodeString(testName)+\n                    \" null terminated source with options set. Expected: \" +UnicodeString(u_errorName(expectedStatus))\n                    + \" Got: \"+ UnicodeString(u_errorName(status))\n                    + \" Source: \" + prettify(UnicodeString(src))\n                   );\n        }  \n    }\n\n    status = U_ZERO_ERROR;\n\n    // test source with lengthand return value of number of UChars required\n    destLen = func(tSrc, tSrcLen, NULL,0,options, \u0026parseError, \u0026status);\n    if(status == U_BUFFER_OVERFLOW_ERROR){\n        status = U_ZERO_ERROR; // reset error code\n        if(destLen+1 \u003c MAX_DEST_SIZE){\n            dest = destStack;\n            destLen = func(src,u_strlen(src),dest,destLen+1,options, \u0026parseError, \u0026status);\n            // TODO : compare output with expected\n            if(U_SUCCESS(status) \u0026\u0026 (doCompare==TRUE) \u0026\u0026 u_strCaseCompare(dest,destLen, expected,expectedLen,0,\u0026status)!=0){\n                errln(\"Did not get the expected result for %s with source length.\\n\",testName);\n            }\n        }else{\n            errln( \"%s with source length  failed. Requires destCapacity \u003e 300\\n\",testName);\n        }\n    }\n\n    if(status != expectedStatus){\n        errln( \"Did not get the expected error for \"+\n                    UnicodeString(testName)+\n                    \" with source length. Expected: \" +UnicodeString(u_errorName(expectedStatus))\n                    + \" Got: \"+ UnicodeString(u_errorName(status))\n                    + \" Source: \" + prettify(UnicodeString(src))\n                   );\n    } \n    if(testUnassigned){\n        status = U_ZERO_ERROR;\n\n        destLen = func(tSrc,tSrcLen,NULL,0,options | UIDNA_ALLOW_UNASSIGNED, \u0026parseError, \u0026status);\n\n        if(status == U_BUFFER_OVERFLOW_ERROR){\n            status = U_ZERO_ERROR; // reset error code\n            if(destLen+1 \u003c MAX_DEST_SIZE){\n                dest = destStack;\n                destLen = func(src,u_strlen(src),dest,destLen+1,options | UIDNA_ALLOW_UNASSIGNED, \u0026parseError, \u0026status);\n                // TODO : compare output with expected\n                if(U_SUCCESS(status) \u0026\u0026 (doCompare==TRUE) \u0026\u0026 u_strCaseCompare(dest,destLen, expected,expectedLen,0,\u0026status)!=0){\n                    errln(\"Did not get the expected result for %s with source length and both options set.\\n\",testName);\n                }\n            }else{\n                errln( \"%s with source length  failed. Requires destCapacity \u003e 300\\n\",testName);\n            }\n        }\n        //testing query string\n        if(status != expectedStatus \u0026\u0026 expectedStatus != U_IDNA_UNASSIGNED_ERROR){\n            errln( \"Did not get the expected error for \"+\n                    UnicodeString(testName)+\n                    \" with source length and options set. Expected: \" +UnicodeString(u_errorName(expectedStatus))\n                    + \" Got: \"+ UnicodeString(u_errorName(status))\n                    + \" Source: \" + prettify(UnicodeString(src))\n                   );\n        }\n    }\n\n    status = U_ZERO_ERROR;\n    if(testSTD3ASCIIRules==TRUE){\n        destLen = func(src,-1,NULL,0,options | UIDNA_USE_STD3_RULES, \u0026parseError, \u0026status);\n        if(status == U_BUFFER_OVERFLOW_ERROR){\n            status = U_ZERO_ERROR; // reset error code\n            if(destLen+1 \u003c MAX_DEST_SIZE){\n                dest = destStack;\n                destLen = func(src,-1,dest,destLen+1,options | UIDNA_USE_STD3_RULES, \u0026parseError, \u0026status);\n                // TODO : compare output with expected\n                if(U_SUCCESS(status) \u0026\u0026 (doCompare==TRUE) \u0026\u0026 u_strCaseCompare(dest,destLen, expected,expectedLen,0,\u0026status)!=0){\n                    //errln(\"Did not get the expected result for %s null terminated source with both options set.\\n\",testName);\n                    errln(\"Did not get the expected result for \"+UnicodeString(testName) +\" null terminated source with both options set. Expected: \"+ prettify(UnicodeString(expected,expectedLen)));\n        \n                }\n            }else{\n                errln( \"%s null terminated source failed. Requires destCapacity \u003e 300\\n\",testName);\n            }\n        }\n        //testing query string\n        if(status != expectedStatus){\n            errln( \"Did not get the expected error for \"+\n                        UnicodeString(testName)+\n                        \" null terminated source with options set. Expected: \" +UnicodeString(u_errorName(expectedStatus))\n                        + \" Got: \"+ UnicodeString(u_errorName(status))\n                        + \" Source: \" + prettify(UnicodeString(src))\n                       );\n        } \n\n        status = U_ZERO_ERROR;\n\n        destLen = func(tSrc,tSrcLen,NULL,0,options | UIDNA_USE_STD3_RULES, \u0026parseError, \u0026status);\n\n        if(status == U_BUFFER_OVERFLOW_ERROR){\n            status = U_ZERO_ERROR; // reset error code\n            if(destLen+1 \u003c MAX_DEST_SIZE){\n                dest = destStack;\n                destLen = func(src,u_strlen(src),dest,destLen+1,options | UIDNA_USE_STD3_RULES, \u0026parseError, \u0026status);\n                // TODO : compare output with expected\n                if(U_SUCCESS(status) \u0026\u0026 (doCompare==TRUE) \u0026\u0026 u_strCaseCompare(dest,destLen, expected,expectedLen,0,\u0026status)!=0){\n                    errln(\"Did not get the expected result for %s with source length and both options set.\\n\",testName);\n                }\n            }else{\n                errln( \"%s with source length  failed. Requires destCapacity \u003e 300\\n\",testName);\n            }\n        }\n        //testing query string\n        if(status != expectedStatus \u0026\u0026 expectedStatus != U_IDNA_UNASSIGNED_ERROR){\n            errln( \"Did not get the expected error for \"+\n                        UnicodeString(testName)+\n                        \" with source length and options set. Expected: \" +UnicodeString(u_errorName(expectedStatus))\n                        + \" Got: \"+ UnicodeString(u_errorName(status))\n                        + \" Source: \" + prettify(UnicodeString(src))\n                       );\n        }\n    }\n    free(tSrc);\n}\n\nvoid TestIDNA::testCompare(const UChar* s1, int32_t s1Len,\n                        const UChar* s2, int32_t s2Len,\n                        const char* testName, CompareFunc func,\n                        UBool isEqual){\n\n    UErrorCode status = U_ZERO_ERROR;\n    int32_t retVal = func(s1,-1,s2,-1,UIDNA_DEFAULT,\u0026status);\n\n    if(isEqual==TRUE \u0026\u0026  retVal !=0){\n        errln(\"Did not get the expected result for %s with null termniated strings.\\n\",testName);\n    }\n    if(U_FAILURE(status)){\n        errcheckln(status, \"%s null terminated source failed. Error: %s\", testName,u_errorName(status));\n    }\n\n    status = U_ZERO_ERROR;\n    retVal = func(s1,-1,s2,-1,UIDNA_ALLOW_UNASSIGNED,\u0026status);\n\n    if(isEqual==TRUE \u0026\u0026  retVal !=0){\n        errln(\"Did not get the expected result for %s with null termniated strings with options set.\\n\", testName);\n    }\n    if(U_FAILURE(status)){\n        errcheckln(status, \"%s null terminated source and options set failed. Error: %s\",testName, u_errorName(status));\n    }\n    \n    status = U_ZERO_ERROR;\n    retVal = func(s1,s1Len,s2,s2Len,UIDNA_DEFAULT,\u0026status);\n\n    if(isEqual==TRUE \u0026\u0026  retVal !=0){\n        errln(\"Did not get the expected result for %s with string length.\\n\",testName);\n    }\n    if(U_FAILURE(status)){\n        errcheckln(status, \"%s with string length. Error: %s\",testName, u_errorName(status));\n    }\n    \n    status = U_ZERO_ERROR;\n    retVal = func(s1,s1Len,s2,s2Len,UIDNA_ALLOW_UNASSIGNED,\u0026status);\n\n    if(isEqual==TRUE \u0026\u0026  retVal !=0){\n        errln(\"Did not get the expected result for %s with string length and options set.\\n\",testName);\n    }\n    if(U_FAILURE(status)){\n        errcheckln(status, \"%s with string length and options set. Error: %s\", u_errorName(status), testName);\n    }\n}\n\nvoid TestIDNA::testToASCII(const char* testName, TestFunc func){\n\n    int32_t i;\n    UChar buf[MAX_DEST_SIZE];\n\n    for(i=0;i\u003c (int32_t)(sizeof(unicodeIn)/sizeof(unicodeIn[0])); i++){\n        u_charsToUChars(asciiIn[i],buf, (int32_t)(strlen(asciiIn[i])+1));\n        testAPI(unicodeIn[i], buf,testName, FALSE,U_ZERO_ERROR, TRUE, TRUE, func);\n        \n    }\n}\n\nvoid TestIDNA::testToUnicode(const char* testName, TestFunc func){\n\n    int32_t i;\n    UChar buf[MAX_DEST_SIZE];\n    \n    for(i=0;i\u003c (int32_t)(sizeof(asciiIn)/sizeof(asciiIn[0])); i++){\n        u_charsToUChars(asciiIn[i],buf, (int32_t)(strlen(asciiIn[i])+1));\n        testAPI(buf,unicodeIn[i],testName,FALSE,U_ZERO_ERROR, TRUE, TRUE, func);\n    }\n}\n\n\nvoid TestIDNA::testIDNToUnicode(const char* testName, TestFunc func){\n    int32_t i;\n    UChar buf[MAX_DEST_SIZE];\n    UChar expected[MAX_DEST_SIZE];\n    UErrorCode status = U_ZERO_ERROR;\n    int32_t bufLen = 0;\n    UParseError parseError;\n    for(i=0;i\u003c (int32_t)(sizeof(domainNames)/sizeof(domainNames[0])); i++){\n        bufLen = (int32_t)strlen(domainNames[i]);\n        bufLen = u_unescape(domainNames[i],buf, bufLen+1);\n        func(buf,bufLen,expected,MAX_DEST_SIZE, UIDNA_ALLOW_UNASSIGNED, \u0026parseError,\u0026status);\n        if(U_FAILURE(status)){\n            errcheckln(status, \"%s failed to convert domainNames[%i].Error: %s\",testName, i, u_errorName(status));\n            break;\n        }\n        testAPI(buf,expected,testName,FALSE,U_ZERO_ERROR, TRUE, TRUE, func);\n         //test toUnicode with all labels in the string\n        testAPI(buf,expected,testName, FALSE,U_ZERO_ERROR, TRUE, TRUE, func);\n        if(U_FAILURE(status)){\n            errln( \"%s failed to convert domainNames[%i].Error: %s \\n\",testName,i, u_errorName(status));\n            break;\n        }\n    }\n    \n}\n\nvoid TestIDNA::testIDNToASCII(const char* testName, TestFunc func){\n    int32_t i;\n    UChar buf[MAX_DEST_SIZE];\n    UChar expected[MAX_DEST_SIZE];\n    UErrorCode status = U_ZERO_ERROR;\n    int32_t bufLen = 0;\n    UParseError parseError; \n    for(i=0;i\u003c (int32_t)(sizeof(domainNames)/sizeof(domainNames[0])); i++){\n        bufLen = (int32_t)strlen(domainNames[i]);\n        bufLen = u_unescape(domainNames[i],buf, bufLen+1);\n        func(buf,bufLen,expected,MAX_DEST_SIZE, UIDNA_ALLOW_UNASSIGNED, \u0026parseError,\u0026status);\n        if(U_FAILURE(status)){\n            errcheckln(status, \"%s failed to convert domainNames[%i].Error: %s\",testName,i, u_errorName(status));\n            break;\n        }\n        testAPI(buf,expected,testName, FALSE,U_ZERO_ERROR, TRUE, TRUE, func);\n        //test toASCII with all labels in the string\n        testAPI(buf,expected,testName, FALSE,U_ZERO_ERROR, FALSE, TRUE, func);\n        if(U_FAILURE(status)){\n            errln( \"%s failed to convert domainNames[%i].Error: %s \\n\",testName,i, u_errorName(status));\n            break;\n        }\n    }\n    \n}\n\nvoid TestIDNA::testCompare(const char* testName, CompareFunc func){\n    int32_t i;\n\n\n    UChar www[] = {0x0057, 0x0057, 0x0057, 0x002E, 0x0000};\n    UChar com[] = {0x002E, 0x0043, 0x004F, 0x004D, 0x0000};\n    UChar buf[MAX_DEST_SIZE]={0x0057, 0x0057, 0x0057, 0x002E, 0x0000};\n\n    UnicodeString source(www), uni0(www),uni1(www), ascii0(www), ascii1(www);\n\n    uni0.append(unicodeIn[0]);\n    uni0.append(com);\n    uni0.append((UChar)0x0000);\n\n    uni1.append(unicodeIn[1]);\n    uni1.append(com);\n    uni1.append((UChar)0x0000);\n\n    ascii0.append(asciiIn[0]);\n    ascii0.append(com);\n    ascii0.append((UChar)0x0000);\n\n    ascii1.append(asciiIn[1]);\n    ascii1.append(com);\n    ascii1.append((UChar)0x0000);\n\n    for(i=0;i\u003c (int32_t)(sizeof(unicodeIn)/sizeof(unicodeIn[0])); i++){\n\n        u_charsToUChars(asciiIn[i],buf+4, (int32_t)(strlen(asciiIn[i])+1));\n        u_strcat(buf,com);\n\n        // for every entry in unicodeIn array\n        // prepend www. and append .com\n        source.truncate(4);\n        source.append(unicodeIn[i]);\n        source.append(com);\n        source.append((UChar)0x0000);\n        // a) compare it with itself\n        const UChar* src = source.getBuffer();\n        int32_t srcLen = u_strlen(src); //subtract null\n\n        testCompare(src,srcLen,src,srcLen,testName, func, TRUE);\n        \n        // b) compare it with asciiIn equivalent\n        testCompare(src,srcLen,buf,u_strlen(buf),testName, func,TRUE);\n        \n        // c) compare it with unicodeIn not equivalent\n        if(i==0){\n            testCompare(src,srcLen,uni1.getBuffer(),uni1.length()-1,testName, func,FALSE);\n        }else{\n            testCompare(src,srcLen,uni0.getBuffer(),uni0.length()-1,testName, func,FALSE);\n        }\n        // d) compare it with asciiIn not equivalent\n        if(i==0){\n            testCompare(src,srcLen,ascii1.getBuffer(),ascii1.length()-1,testName, func,FALSE);\n        }else{\n            testCompare(src,srcLen,ascii0.getBuffer(),ascii0.length()-1,testName, func,FALSE);\n        }\n\n    }\n}\n\n#if 0\n\nstatic int32_t\ngetNextSeperator(UChar *src,int32_t srcLength,\n                 UChar **limit){\n    if(srcLength == -1){\n        int32_t i;\n        for(i=0 ; ;i++){\n            if(src[i] == 0){\n                *limit = src + i; // point to null\n                return i;\n            }\n            if(src[i]==0x002e){\n                *limit = src + (i+1); // go past the delimiter\n                return i;\n            }\n        }\n        // we have not found the delimiter\n        if(i==srcLength){\n            *limit = src+srcLength;\n        }\n        return i;\n    }else{\n        int32_t i;\n        for(i=0;i\u003csrcLength;i++){\n            if(src[i]==0x002e){\n                *limit = src + (i+1); // go past the delimiter\n                return i;\n            }\n        }\n        // we have not found the delimiter\n        if(i==srcLength){\n            *limit = src+srcLength;\n        }\n        return i;\n    }\n}\n\nvoid printPunycodeOutput(){\n\n    UChar dest[MAX_DEST_SIZE];\n    int32_t destCapacity=MAX_DEST_SIZE;\n    UChar* start;\n    UChar* limit;\n    int32_t labelLen=0;\n    UBool caseFlags[MAX_DEST_SIZE];\n    \n    for(int32_t i=0;i\u003c sizeof(errorCases)/sizeof(errorCases[0]);i++){\n        ErrorCases errorCase = errorCases[i];\n        UErrorCode status = U_ZERO_ERROR;\n        start = errorCase.unicode;\n        int32_t srcLen = u_strlen(start);\n        labelLen = getNextSeperator(start,srcLen,\u0026limit);\n        start = limit;\n        labelLen=getNextSeperator(start,srcLen-labelLen,\u0026limit);\n        int32_t destLen = u_strToPunycode(dest,destCapacity,start,labelLen,caseFlags, \u0026status);\n        if(U_FAILURE(status)){\n            printf(\"u_strToPunycode failed for index %i\\n\",i);\n            continue;\n        }\n        for(int32_t j=0; j\u003cdestLen; j++){\n            printf(\"%c\",(char)dest[j]);\n        }\n        printf(\"\\n\");\n    }\n}\n#endif\n\nvoid TestIDNA::testErrorCases(const char* IDNToASCIIName, TestFunc IDNToASCII,\n                              const char* IDNToUnicodeName, TestFunc IDNToUnicode){\n    UChar buf[MAX_DEST_SIZE];\n    int32_t bufLen=0;\n\n    for(int32_t i=0;i\u003c (int32_t)(sizeof(errorCases)/sizeof(errorCases[0]));i++){\n        ErrorCases errorCase = errorCases[i];\n        UChar* src =NULL;\n        if(errorCase.ascii != NULL){\n            bufLen =  (int32_t)strlen(errorCase.ascii);\n            u_charsToUChars(errorCase.ascii,buf, bufLen+1);\n        }else{\n            bufLen = 1 ;\n            memset(buf,0,U_SIZEOF_UCHAR*MAX_DEST_SIZE);\n        }\n        \n        if(errorCase.unicode[0]!=0){\n            src = errorCase.unicode;\n        }\n        // test toASCII\n        testAPI(src,buf,\n                IDNToASCIIName, errorCase.useSTD3ASCIIRules,\n                errorCase.expected, TRUE, TRUE, IDNToASCII);\n        if(errorCase.testLabel ==TRUE){\n            testAPI(src,buf,\n                IDNToASCIIName, errorCase.useSTD3ASCIIRules,\n                errorCase.expected, FALSE,TRUE, IDNToASCII);\n        }\n        if(errorCase.testToUnicode ==TRUE){\n            testAPI((src==NULL)? NULL : buf,src,\n                    IDNToUnicodeName, errorCase.useSTD3ASCIIRules,\n                    errorCase.expected, TRUE, TRUE, IDNToUnicode);   \n        }\n\n    }\n    \n}\n/*\nvoid TestIDNA::testConformance(const char* toASCIIName, TestFunc toASCII,\n                               const char* IDNToASCIIName, TestFunc IDNToASCII,\n                               const char* IDNToUnicodeName, TestFunc IDNToUnicode,\n                               const char* toUnicodeName, TestFunc toUnicode){\n    UChar src[MAX_DEST_SIZE];\n    int32_t srcLen=0;\n    UChar expected[MAX_DEST_SIZE];\n    int32_t expectedLen = 0;\n    for(int32_t i=0;i\u003c (int32_t)(sizeof(conformanceTestCases)/sizeof(conformanceTestCases[0]));i++){\n        const char* utf8Chars1 = conformanceTestCases[i].in;\n        int32_t utf8Chars1Len = (int32_t)strlen(utf8Chars1);\n        const char* utf8Chars2 = conformanceTestCases[i].out;\n        int32_t utf8Chars2Len = (utf8Chars2 == NULL) ? 0 : (int32_t)strlen(utf8Chars2);\n\n        UErrorCode status = U_ZERO_ERROR;\n        u_strFromUTF8(src,MAX_DEST_SIZE,\u0026srcLen,utf8Chars1,utf8Chars1Len,\u0026status);\n        if(U_FAILURE(status)){\n            errln(UnicodeString(\"Conversion of UTF8 source in conformanceTestCases[\") + i +UnicodeString( \"].in ( \")+prettify(utf8Chars1) +UnicodeString(\" ) failed. Error: \")+ UnicodeString(u_errorName(status)));\n            continue;\n        }\n        if(utf8Chars2 != NULL){\n            u_strFromUTF8(expected,MAX_DEST_SIZE,\u0026expectedLen,utf8Chars2,utf8Chars2Len, \u0026status);\n            if(U_FAILURE(status)){\n                errln(UnicodeString(\"Conversion of UTF8 source in conformanceTestCases[\") + i +UnicodeString( \"].in ( \")+prettify(utf8Chars1) +UnicodeString(\" ) failed. Error: \")+ UnicodeString(u_errorName(status)));\n                continue;\n            }\n        }\n        \n        if(conformanceTestCases[i].expectedStatus != U_ZERO_ERROR){\n            // test toASCII\n            testAPI(src,expected,\n                    IDNToASCIIName, FALSE,\n                    conformanceTestCases[i].expectedStatus, \n                    TRUE, \n                    (conformanceTestCases[i].expectedStatus != U_IDNA_UNASSIGNED_ERROR),\n                    IDNToASCII);\n\n            testAPI(src,expected,\n                    toASCIIName, FALSE,\n                    conformanceTestCases[i].expectedStatus, TRUE, \n                    (conformanceTestCases[i].expectedStatus != U_IDNA_UNASSIGNED_ERROR),\n                    toASCII);\n        }\n\n        testAPI(src,src,\n                IDNToUnicodeName, FALSE,\n                conformanceTestCases[i].expectedStatus, TRUE, TRUE, IDNToUnicode);\n        testAPI(src,src,\n                toUnicodeName, FALSE,\n                conformanceTestCases[i].expectedStatus, TRUE, TRUE, toUnicode);\n\n    }\n    \n}\n*/\n// test and ascertain\n// func(func(func(src))) == func(src)\nvoid TestIDNA::testChaining(const UChar* src,int32_t numIterations,const char* testName,\n                  UBool useSTD3ASCIIRules, UBool caseInsensitive, TestFunc func){\n    UChar even[MAX_DEST_SIZE];\n    UChar odd[MAX_DEST_SIZE];\n    UChar expected[MAX_DEST_SIZE];\n    int32_t i=0,evenLen=0,oddLen=0,expectedLen=0;\n    UErrorCode status = U_ZERO_ERROR;\n    int32_t srcLen = u_strlen(src);\n    int32_t options = (useSTD3ASCIIRules == TRUE) ? UIDNA_USE_STD3_RULES : UIDNA_DEFAULT;\n    UParseError parseError;\n\n    // test null-terminated source \n    expectedLen = func(src,-1,expected,MAX_DEST_SIZE, options, \u0026parseError, \u0026status);\n    if(U_FAILURE(status)){\n        errcheckln(status, \"%s null terminated source failed. Error: %s\",testName, u_errorName(status));\n    }\n    memcpy(odd,expected,(expectedLen+1) * U_SIZEOF_UCHAR);\n    memcpy(even,expected,(expectedLen+1) * U_SIZEOF_UCHAR);\n    for(;i\u003c=numIterations; i++){\n        if((i%2) ==0){\n            evenLen = func(odd,-1,even,MAX_DEST_SIZE,options, \u0026parseError, \u0026status);\n            if(U_FAILURE(status)){\n                errcheckln(status, \"%s null terminated source failed - %s\",testName, u_errorName(status));\n                break;\n            }\n        }else{\n            oddLen = func(even,-1,odd,MAX_DEST_SIZE,options, \u0026parseError, \u0026status);\n            if(U_FAILURE(status)){\n                errln(\"%s null terminated source failed\\n\",testName);\n                break;\n            }\n        }\n    }\n    if(caseInsensitive ==TRUE){\n        if( u_strCaseCompare(even,evenLen, expected,expectedLen, 0, \u0026status) !=0 ||\n            u_strCaseCompare(odd,oddLen, expected,expectedLen, 0, \u0026status) !=0 ){\n\n            errln(\"Chaining for %s null terminated source failed\\n\",testName);\n        }\n    }else{\n        if( u_strncmp(even,expected,expectedLen) != 0 ||\n            u_strncmp(odd,expected,expectedLen) !=0 ){\n        \n            errln(\"Chaining for %s null terminated source failed\\n\",testName);\n        }\n    }\n\n    // test null-terminated source \n    status = U_ZERO_ERROR;\n    expectedLen = func(src,-1,expected,MAX_DEST_SIZE,options|UIDNA_ALLOW_UNASSIGNED, \u0026parseError, \u0026status);\n    if(U_FAILURE(status)){\n        errcheckln(status, \"%s null terminated source with options set failed. Error: %s\",testName, u_errorName(status));\n    }\n    memcpy(odd,expected,(expectedLen+1) * U_SIZEOF_UCHAR);\n    memcpy(even,expected,(expectedLen+1) * U_SIZEOF_UCHAR);\n    for(;i\u003c=numIterations; i++){\n        if((i%2) ==0){\n            evenLen = func(odd,-1,even,MAX_DEST_SIZE,options|UIDNA_ALLOW_UNASSIGNED, \u0026parseError, \u0026status);\n            if(U_FAILURE(status)){\n                errcheckln(status, \"%s null terminated source with options set failed - %s\",testName, u_errorName(status));\n                break;\n            }\n        }else{\n            oddLen = func(even,-1,odd,MAX_DEST_SIZE,options|UIDNA_ALLOW_UNASSIGNED, \u0026parseError, \u0026status);\n            if(U_FAILURE(status)){\n                errln(\"%s null terminated source with options set failed\\n\",testName);\n                break;\n            }\n        }\n    }\n    if(caseInsensitive ==TRUE){\n        if( u_strCaseCompare(even,evenLen, expected,expectedLen, 0, \u0026status) !=0 ||\n            u_strCaseCompare(odd,oddLen, expected,expectedLen, 0, \u0026status) !=0 ){\n\n            errln(\"Chaining for %s null terminated source with options set failed\\n\",testName);\n        }\n    }else{\n        if( u_strncmp(even,expected,expectedLen) != 0 ||\n            u_strncmp(odd,expected,expectedLen) !=0 ){\n        \n            errln(\"Chaining for %s null terminated source with options set failed\\n\",testName);\n        }\n    }\n\n\n    // test source with length \n    status = U_ZERO_ERROR;\n    expectedLen = func(src,srcLen,expected,MAX_DEST_SIZE,options, \u0026parseError, \u0026status);\n    if(U_FAILURE(status)){\n        errcheckln(status, \"%s null terminated source failed. Error: %s\",testName, u_errorName(status));\n    }\n    memcpy(odd,expected,(expectedLen+1) * U_SIZEOF_UCHAR);\n    memcpy(even,expected,(expectedLen+1) * U_SIZEOF_UCHAR);\n    for(;i\u003c=numIterations; i++){\n        if((i%2) ==0){\n            evenLen = func(odd,oddLen,even,MAX_DEST_SIZE,options, \u0026parseError, \u0026status);\n            if(U_FAILURE(status)){\n                errcheckln(status, \"%s source with source length failed - %s\",testName, u_errorName(status));\n                break;\n            }\n        }else{\n            oddLen = func(even,evenLen,odd,MAX_DEST_SIZE,options, \u0026parseError, \u0026status);\n            if(U_FAILURE(status)){\n                errcheckln(status, \"%s source with source length failed - %s\",testName, u_errorName(status));\n                break;\n            }\n        }\n    }\n    if(caseInsensitive ==TRUE){\n        if( u_strCaseCompare(even,evenLen, expected,expectedLen, 0, \u0026status) !=0 ||\n            u_strCaseCompare(odd,oddLen, expected,expectedLen, 0, \u0026status) !=0 ){\n\n            errln(\"Chaining for %s source with source length failed\\n\",testName);\n        }\n    }else{\n        if( u_strncmp(even,expected,expectedLen) != 0 ||\n            u_strncmp(odd,expected,expectedLen) !=0 ){\n        \n            errln(\"Chaining for %s source with source length failed\\n\",testName);\n        }\n    }\n    status = U_ZERO_ERROR;\n    expectedLen = func(src,srcLen,expected,MAX_DEST_SIZE,options|UIDNA_ALLOW_UNASSIGNED, \u0026parseError, \u0026status);\n    if(U_FAILURE(status)){\n        errcheckln(status, \"%s null terminated source with options set failed. Error: %s\",testName, u_errorName(status));\n    }\n    memcpy(odd,expected,(expectedLen+1) * U_SIZEOF_UCHAR);\n    memcpy(even,expected,(expectedLen+1) * U_SIZEOF_UCHAR);\n    for(;i\u003c=numIterations; i++){\n        if((i%2) ==0){\n            evenLen = func(odd,oddLen,even,MAX_DEST_SIZE,options|UIDNA_ALLOW_UNASSIGNED, \u0026parseError, \u0026status);\n            if(U_FAILURE(status)){\n                errcheckln(status, \"%s source with source length and options set failed - %s\",testName, u_errorName(status));\n                break;\n            }\n        }else{\n            oddLen = func(even,evenLen,odd,MAX_DEST_SIZE,options|UIDNA_ALLOW_UNASSIGNED, \u0026parseError, \u0026status);\n            if(U_FAILURE(status)){\n                errcheckln(status, \"%s  source with source length and options set failed - %s\",testName, u_errorName(status));\n                break;\n            }\n        }\n    }\n    if(caseInsensitive ==TRUE){\n        if( u_strCaseCompare(even,evenLen, expected,expectedLen, 0, \u0026status) !=0 ||\n            u_strCaseCompare(odd,oddLen, expected,expectedLen, 0, \u0026status) !=0 ){\n\n            errln(\"Chaining for %s  source with source length and options set failed\\n\",testName);\n        }\n    }else{\n        if( u_strncmp(even,expected,expectedLen) != 0 ||\n            u_strncmp(odd,expected,expectedLen) !=0 ){\n        \n            errln(\"Chaining for %s  source with source length and options set failed\\n\",testName);\n        }\n    }\n}\nvoid TestIDNA::testChaining(const char* toASCIIName, TestFunc toASCII,\n                  const char* toUnicodeName, TestFunc toUnicode){\n    int32_t i;\n    UChar buf[MAX_DEST_SIZE];\n    \n    for(i=0;i\u003c (int32_t)(sizeof(asciiIn)/sizeof(asciiIn[0])); i++){\n        u_charsToUChars(asciiIn[i],buf, (int32_t)(strlen(asciiIn[i])+1));\n        testChaining(buf,5,toUnicodeName, FALSE, FALSE, toUnicode);\n    }\n    for(i=0;i\u003c (int32_t)(sizeof(unicodeIn)/sizeof(unicodeIn[0])); i++){\n        testChaining(unicodeIn[i], 5,toASCIIName, FALSE, TRUE, toASCII);\n    }\n}\n\n\nvoid TestIDNA::testRootLabelSeparator(const char* testName, CompareFunc func, \n                            const char* IDNToASCIIName, TestFunc IDNToASCII,\n                            const char* IDNToUnicodeName, TestFunc IDNToUnicode){\n    int32_t i;\n\n\n    UChar www[] = {0x0057, 0x0057, 0x0057, 0x002E, 0x0000};\n    UChar com[] = {0x002E, 0x0043, 0x004F, 0x004D, 0x002E, /* root label separator */0x0000};\n    UChar buf[MAX_DEST_SIZE]={0x0057, 0x0057, 0x0057, 0x002E, 0x0000};\n\n    UnicodeString source(www), uni0(www),uni1(www), ascii0(www), ascii1(www);\n\n    uni0.append(unicodeIn[0]);\n    uni0.append(com);\n    uni0.append((UChar)0x0000);\n\n    uni1.append(unicodeIn[1]);\n    uni1.append(com);\n    uni1.append((UChar)0x0000);\n\n    ascii0.append(asciiIn[0]);\n    ascii0.append(com);\n    ascii0.append((UChar)0x0000);\n\n    ascii1.append(asciiIn[1]);\n    ascii1.append(com);\n    ascii1.append((UChar)0x0000);\n\n    for(i=0;i\u003c (int32_t)(sizeof(unicodeIn)/sizeof(unicodeIn[0])); i++){\n\n        u_charsToUChars(asciiIn[i],buf+4, (int32_t)(strlen(asciiIn[i])+1));\n        u_strcat(buf,com);\n\n        // for every entry in unicodeIn array\n        // prepend www. and append .com\n        source.truncate(4);\n        source.append(unicodeIn[i]);\n        source.append(com);\n        source.append((UChar)0x0000);\n        \n        const UChar* src = source.getBuffer();\n        int32_t srcLen = u_strlen(src); //subtract null\n        \n        // b) compare it with asciiIn equivalent\n        testCompare(src,srcLen,buf,u_strlen(buf),testName, func,TRUE);\n        \n        // a) compare it with itself\n        testCompare(src,srcLen,src,srcLen,testName, func,TRUE);\n        \n        \n        // IDNToASCII comparison\n        testAPI(src,buf,IDNToASCIIName,FALSE,U_ZERO_ERROR,TRUE, TRUE, IDNToASCII);\n        // IDNToUnicode comparison\n        testAPI(buf,src,IDNToUnicodeName, FALSE,U_ZERO_ERROR, TRUE, TRUE, IDNToUnicode);\n\n        // c) compare it with unicodeIn not equivalent\n        if(i==0){\n            testCompare(src,srcLen,uni1.getBuffer(),uni1.length()-1,testName, func,FALSE);\n        }else{\n            testCompare(src,srcLen,uni0.getBuffer(),uni0.length()-1,testName, func,FALSE);\n        }\n        // d) compare it with asciiIn not equivalent\n        if(i==0){\n            testCompare(src,srcLen,ascii1.getBuffer(),ascii1.length()-1,testName, func,FALSE);\n        }else{\n            testCompare(src,srcLen,ascii0.getBuffer(),ascii0.length()-1,testName, func,FALSE);\n        }\n    }\n}   \n\n//---------------------------------------------\n// runIndexedTest\n//---------------------------------------------\n\nextern IntlTest *createUTS46Test();\n\nvoid TestIDNA::runIndexedTest( int32_t index, UBool exec, const char* \u0026name, char* par)\n{\n    if (exec) logln((UnicodeString)\"TestSuite IDNA API \");\n    switch (index) {\n\n        case 0: name = \"TestToASCII\"; if (exec) TestToASCII(); break;\n        case 1: name = \"TestToUnicode\"; if (exec) TestToUnicode(); break;\n        case 2: name = \"TestIDNToASCII\"; if (exec) TestIDNToASCII(); break;\n        case 3: name = \"TestIDNToUnicode\"; if (exec) TestIDNToUnicode(); break;\n        case 4: name = \"TestCompare\"; if (exec) TestCompare(); break;\n        case 5: name = \"TestErrorCases\"; if (exec) TestErrorCases(); break;\n        case 6: name = \"TestChaining\"; if (exec) TestChaining(); break;\n        case 7: name = \"TestRootLabelSeparator\"; if(exec) TestRootLabelSeparator(); break;\n        case 8: name = \"TestCompareReferenceImpl\"; if(exec) TestCompareReferenceImpl(); break;\n        case 9: name = \"TestDataFile\"; if(exec) TestDataFile(); break;\n#if !UCONFIG_NO_FILE_IO \u0026\u0026 !UCONFIG_NO_LEGACY_CONVERSION\n        case 10: name = \"TestRefIDNA\"; if(exec) TestRefIDNA(); break;\n        case 11: name = \"TestIDNAMonkeyTest\"; if(exec) TestIDNAMonkeyTest(); break;\n#else\n        case 10: case 11: name = \"skip\"; break;\n#endif\n        case 12: \n            {\n                name = \"TestConformanceTestVectors\";\n                if(exec){\n                    logln(\"TestSuite IDNA conf----\"); logln();\n                    IdnaConfTest test;\n                    callTest(test, par);\n                }\n                break;\n            }\n        case 13:\n            name = \"UTS46Test\";\n            if (exec) {\n                logln(\"TestSuite UTS46Test---\"); logln();\n                LocalPointer\u003cIntlTest\u003e test(createUTS46Test());\n                callTest(*test, par);\n            }\n            break;\n        default: name = \"\"; break; /*needed to end loop*/\n    }\n}\nvoid TestIDNA::TestToASCII(){\n    testToASCII(\"uidna_toASCII\", uidna_toASCII);\n}\nvoid TestIDNA::TestToUnicode(){\n    testToUnicode(\"uidna_toUnicode\", uidna_toUnicode);\n}\nvoid TestIDNA::TestIDNToASCII(){\n    testIDNToASCII(\"uidna_IDNToASCII\", uidna_IDNToASCII);\n}\nvoid TestIDNA::TestIDNToUnicode(){\n    testIDNToUnicode(\"uidna_IDNToUnicode\", uidna_IDNToUnicode);\n}\nvoid TestIDNA::TestCompare(){\n    testCompare(\"uidna_compare\",uidna_compare);\n}\nvoid TestIDNA::TestErrorCases(){\n    testErrorCases( \"uidna_IDNToASCII\",uidna_IDNToASCII,\n                    \"uidna_IDNToUnicode\",uidna_IDNToUnicode);\n}\nvoid TestIDNA::TestRootLabelSeparator(){\n    testRootLabelSeparator( \"uidna_compare\",uidna_compare,\n                            \"uidna_IDNToASCII\", uidna_IDNToASCII,\n                            \"uidna_IDNToUnicode\",uidna_IDNToUnicode\n                            );\n}\nvoid TestIDNA::TestChaining(){\n    testChaining(\"uidna_toASCII\",uidna_toASCII, \"uidna_toUnicode\", uidna_toUnicode);\n}\n\n\nstatic const int loopCount = 100;\nstatic const int maxCharCount = 20;\nstatic const int maxCodePoint = 0x10ffff;\nstatic uint32_t\nrandul()\n{\n    static UBool initialized = FALSE;\n    if (!initialized)\n    {\n        srand((unsigned)time(NULL));\n        initialized = TRUE;\n    }\n    // Assume rand has at least 12 bits of precision\n    uint32_t l = 0;\n    for (uint32_t i=0; i\u003csizeof(l); ++i)\n        ((char*)\u0026l)[i] = (char)((rand() \u0026 0x0FF0) \u003e\u003e 4);\n    return l;\n}\n\n/**\n * Return a random integer i where 0 \u003c= i \u003c n.\n * A special function that gets random codepoints from planes 0,1,2 and 14\n */\nstatic int32_t rand_uni()\n{\n   int32_t retVal = (int32_t)(randul()\u0026 0x3FFFF);\n   if(retVal \u003e= 0x30000){\n       retVal+=0xB0000;\n   }\n   return retVal;\n}\n\nstatic int32_t randi(int32_t n){\n    return (int32_t) (randul() % (n+1));\n}\n\nvoid getTestSource(UnicodeString\u0026 fillIn) {\n    int32_t i = 0;\n    int32_t charCount = (randi(maxCharCount) + 1);\n    while (i \u003ccharCount ) {\n        int32_t codepoint = rand_uni();\n        if(codepoint == 0x0000){\n            continue;\n        }\n        fillIn.append((UChar32)codepoint);\n        i++;\n    }\n       \n}\n\nUnicodeString TestIDNA::testCompareReferenceImpl(UnicodeString\u0026 src, \n                                        TestFunc refIDNA, const char* refIDNAName,\n                                        TestFunc uIDNA, const char* uIDNAName,\n                                        int32_t options){\n  \n    const UChar* srcUChars = src.getBuffer();\n    UChar exp[MAX_DEST_SIZE]={0};\n    int32_t expCap = MAX_DEST_SIZE, expLen=0;\n    UErrorCode expStatus = U_ZERO_ERROR;\n    UParseError parseError;\n\n    logln(\"Comparing \"+ UnicodeString(refIDNAName) \n           + \" with \"+ UnicodeString(uIDNAName) \n           +\" for input: \" + prettify(srcUChars));\n    \n    expLen = refIDNA(srcUChars, src.length()-1, exp, expCap,\n                      options, \u0026parseError, \u0026expStatus);\n\n    UChar got[MAX_DEST_SIZE]={0};\n    int32_t gotCap = MAX_DEST_SIZE, gotLen=0;\n    UErrorCode gotStatus = U_ZERO_ERROR;\n\n    gotLen = uIDNA(srcUChars, src.length()-1, got, gotCap,\n                   options, \u0026parseError, \u0026gotStatus);\n\n    if(expStatus != gotStatus){\n        errln(\"Did not get the expected status while comparing \" + UnicodeString(refIDNAName)\n               + \" with \" + UnicodeString(uIDNAName)\n               + \" Expected: \" + UnicodeString(u_errorName(expStatus))\n               + \" Got: \" + UnicodeString(u_errorName(gotStatus))\n               + \" for Source: \"+ prettify(srcUChars) \n               + \" Options: \" + options);\n        return UnicodeString(\"\");\n    }\n    \n    // now we know that both implementations yielded same error\n    if(U_SUCCESS(expStatus)){\n        // compare the outputs if status == U_ZERO_ERROR\n        if(u_strCompare(exp, expLen, got, gotLen, TRUE) != 0){\n            errln(\"Did not get the expected output while comparing \" + UnicodeString(refIDNAName)\n               + \" with \" + UnicodeString(uIDNAName)\n               + \" Expected: \" + prettify(UnicodeString(exp, expLen))\n               + \" Got: \" + prettify(UnicodeString(got, gotLen))\n               + \" for Source: \"+ prettify(srcUChars) \n               + \" Options: \" + options);\n        }\n        return UnicodeString(exp, expLen);\n\n    }else{\n        logln(\"Got the same error while comparing \" \n            + UnicodeString(refIDNAName) \n            + \" with \"+ UnicodeString(uIDNAName) \n            +\" for input: \" + prettify(srcUChars));\n    }\n    return UnicodeString(\"\");\n}\n\nvoid TestIDNA::testCompareReferenceImpl(const UChar* src, int32_t srcLen){\n    UnicodeString label(src,srcLen);\n    label.append((UChar)0x0000);\n\n    //test idnaref_toASCII and idnare\n    UnicodeString asciiLabel = testCompareReferenceImpl(label, \n                                                      idnaref_toASCII, \"idnaref_toASCII\",\n                                                      uidna_toASCII, \"uidna_toASCII\",\n                                                      UIDNA_ALLOW_UNASSIGNED);\n    testCompareReferenceImpl(label, \n                              idnaref_toASCII, \"idnaref_toASCII\",\n                              uidna_toASCII, \"uidna_toASCII\",\n                              UIDNA_DEFAULT);\n    testCompareReferenceImpl(label, \n                              idnaref_toASCII, \"idnaref_toASCII\",\n                              uidna_toASCII, \"uidna_toASCII\",\n                              UIDNA_USE_STD3_RULES);\n    testCompareReferenceImpl(label, \n                              idnaref_toASCII, \"idnaref_toASCII\",\n                              uidna_toASCII, \"uidna_toASCII\",\n                              UIDNA_USE_STD3_RULES | UIDNA_ALLOW_UNASSIGNED);\n\n    if(asciiLabel.length()!=0){\n        asciiLabel.append((UChar)0x0000);\n\n        // test toUnciode\n        testCompareReferenceImpl(asciiLabel, \n                                  idnaref_toUnicode, \"idnaref_toUnicode\",\n                                  uidna_toUnicode, \"uidna_toUnicode\",\n                                  UIDNA_ALLOW_UNASSIGNED);\n        testCompareReferenceImpl(asciiLabel, \n                                  idnaref_toUnicode, \"idnaref_toUnicode\",\n                                  uidna_toUnicode, \"uidna_toUnicode\",\n                                  UIDNA_DEFAULT);\n        testCompareReferenceImpl(asciiLabel, \n                                  idnaref_toUnicode, \"idnaref_toUnicode\",\n                                  uidna_toUnicode, \"uidna_toUnicode\",\n                                  UIDNA_USE_STD3_RULES);\n        testCompareReferenceImpl(asciiLabel, \n                                  idnaref_toUnicode, \"idnaref_toUnicode\",\n                                  uidna_toUnicode, \"uidna_toUnicode\",\n                                  UIDNA_USE_STD3_RULES | UIDNA_ALLOW_UNASSIGNED);\n    }\n\n}\nconst char* failures[] ={\n    \"\\\\uAA42\\\\U0001F8DD\\\\U00019D01\\\\U000149A3\\\\uD385\\\\U000EE0F5\\\\U00018B92\\\\U000179D1\\\\U00018624\\\\U0002227F\\\\U000E83C0\\\\U000E8DCD\\\\u5460\\\\U00017F34\\\\U0001570B\\\\u43D1\\\\U0002C9C9\\\\U000281EC\\\\u2105\\\\U000180AE\\\\uC5D4\",\n    \"\\\\U0002F5A6\\\\uD638\\\\u0D0A\\\\u9E9C\\\\uFE5B\\\\U0001FCCB\\\\u66C4\",\n};\n\nvoid TestIDNA::TestIDNAMonkeyTest(){\n    UnicodeString source;\n    UErrorCode status = U_ZERO_ERROR;\n    int i;\n\n    getInstance(status);    // Init prep\n    if (U_FAILURE(status)) {\n        dataerrln(\"Test could not initialize. Got %s\", u_errorName(status));\n        return;\n    }\n\n    for(i=0; i\u003cloopCount; i++){\n        source.truncate(0);\n        getTestSource(source);\n        source.append((UChar)0x0000);\n        const UChar* src = source.getBuffer();\n        testCompareReferenceImpl(src,source.length()-1);\n        testCompareReferenceImpl(src,source.length()-1);\n    }\n    \n    /* for debugging */\n    for (i=0; i\u003c(int)(sizeof(failures)/sizeof(failures[0])); i++){\n        source.truncate(0);\n        source.append( UnicodeString(failures[i], -1, US_INV) );\n        source = source.unescape();\n        source.append((UChar)0x0000);\n        const UChar *src = source.getBuffer();\n        testCompareReferenceImpl(src,source.length()-1);\n        //debug(source.getBuffer(),source.length(),UIDNA_ALLOW_UNASSIGNED);\n    }\n\n    \n    source.truncate(0);\n    source.append(UNICODE_STRING_SIMPLE(\"\\\\uCF18\\\\U00021161\\\\U000EEF11\\\\U0002BB82\\\\U0001D63C\"));\n    debug(source.getBuffer(),source.length(),UIDNA_ALLOW_UNASSIGNED);\n    \n    { // test deletion of code points\n        UnicodeString source(\"\\\\u043f\\\\u00AD\\\\u034f\\\\u043e\\\\u0447\\\\u0435\\\\u043c\\\\u0443\\\\u0436\\\\u0435\\\\u043e\\\\u043d\\\\u0438\\\\u043d\\\\u0435\\\\u0433\\\\u043e\\\\u0432\\\\u043e\\\\u0440\\\\u044f\\\\u0442\\\\u043f\\\\u043e\\\\u0440\\\\u0443\\\\u0441\\\\u0441\\\\u043a\\\\u0438\\\\u0000\", -1, US_INV);\n        source = source.unescape();\n        UnicodeString expected(\"\\\\u043f\\\\u043e\\\\u0447\\\\u0435\\\\u043c\\\\u0443\\\\u0436\\\\u0435\\\\u043e\\\\u043d\\\\u0438\\\\u043d\\\\u0435\\\\u0433\\\\u043e\\\\u0432\\\\u043e\\\\u0440\\\\u044f\\\\u0442\\\\u043f\\\\u043e\\\\u0440\\\\u0443\\\\u0441\\\\u0441\\\\u043a\\\\u0438\\\\u0000\", -1, US_INV);\n        expected = expected.unescape();\n        UnicodeString ascii(\"xn--b1abfaaepdrnnbgefbadotcwatmq2g4l\");\n        ascii.append((UChar)0x0000);\n        testAPI(source.getBuffer(),ascii.getBuffer(), \"uidna_toASCII\", FALSE, U_ZERO_ERROR, TRUE, TRUE, uidna_toASCII);\n        \n        testAPI(source.getBuffer(),ascii.getBuffer(), \"idnaref_toASCII\", FALSE, U_ZERO_ERROR, TRUE, TRUE, idnaref_toASCII);\n\n        testCompareReferenceImpl(source.getBuffer(), source.length()-1);\n    }\n\n}\n\nvoid TestIDNA::TestCompareReferenceImpl(){\n    \n    UChar src [2] = {0,0};\n    int32_t srcLen = 0;\n    \n\n    for(int32_t i = 0x40000 ; i\u003c 0x10ffff; i++){\n        if(quick==TRUE \u0026\u0026 i\u003e 0x1FFFF){\n            return;\n        }\n        if(i \u003e= 0x30000 \u0026\u0026 i \u003c= 0xF0000){\n           i+=0xB0000;\n        }\n        if(i\u003e0xFFFF){\n           src[0] = U16_LEAD(i);\n           src[1] = U16_TRAIL(i);\n           srcLen =2;\n        }else{\n            src[0] = (UChar)i;\n            src[1] = 0;\n            srcLen = 1;\n        }\n        testCompareReferenceImpl(src, srcLen);\n    }\n}\n\nvoid TestIDNA::TestRefIDNA(){\n    UErrorCode status = U_ZERO_ERROR;\n    getInstance(status);    // Init prep\n    if (U_FAILURE(status)) {\n        if (status == U_FILE_ACCESS_ERROR) {\n            dataerrln(\"Test could not initialize. Got %s\", u_errorName(status));\n        }\n        return;\n    }\n\n    testToASCII(\"idnaref_toASCII\", idnaref_toASCII);\n    testToUnicode(\"idnaref_toUnicode\", idnaref_toUnicode);\n    testIDNToASCII(\"idnaref_IDNToASCII\", idnaref_IDNToASCII);\n    testIDNToUnicode(\"idnaref_IDNToUnicode\", idnaref_IDNToUnicode);\n    testCompare(\"idnaref_compare\",idnaref_compare);\n    testErrorCases( \"idnaref_IDNToASCII\",idnaref_IDNToASCII,\n                    \"idnaref_IDNToUnicode\",idnaref_IDNToUnicode);\n    testChaining(\"idnaref_toASCII\",idnaref_toASCII, \"idnaref_toUnicode\", idnaref_toUnicode);\n\n    testRootLabelSeparator( \"idnaref_compare\",idnaref_compare,\n                            \"idnaref_IDNToASCII\", idnaref_IDNToASCII,\n                            \"idnaref_IDNToUnicode\",idnaref_IDNToUnicode\n                            );\n    testChaining(\"idnaref_toASCII\",idnaref_toASCII, \"idnaref_toUnicode\", idnaref_toUnicode);\n}\n\n\nvoid TestIDNA::TestDataFile(){\n     testData(*this);\n}\nTestIDNA::~TestIDNA(){\n    if(gPrep!=NULL){\n        delete gPrep;\n        gPrep = NULL;\n    }\n}\n\nNamePrepTransform* TestIDNA::gPrep = NULL;\n\nNamePrepTransform* TestIDNA::getInstance(UErrorCode\u0026 status){\n    if(TestIDNA::gPrep == NULL){\n        UParseError parseError;\n        TestIDNA::gPrep = NamePrepTransform::createInstance(parseError, status);\n        if(TestIDNA::gPrep ==NULL){\n           //status = U_MEMORY_ALLOCATION_ERROR;\n           return NULL;\n        }\n    }\n    return TestIDNA::gPrep;\n\n}\n#endif /* #if !UCONFIG_NO_IDNA */\n"}
{"repo_name":"SingularityCore/Singularity","ref":"refs/heads/master","path":"dep/acelite/ace/Log_Msg_IPC.cpp","copies":"545","language":"C++","content":"// $Id: Log_Msg_IPC.cpp 91286 2010-08-05 09:04:31Z johnnyw $\n\n#include \"ace/Log_Msg_IPC.h\"\n#include \"ace/Log_Record.h\"\n#include \"ace/CDR_Stream.h\"\n#include \"ace/Truncate.h\"\n\n\n\nACE_BEGIN_VERSIONED_NAMESPACE_DECL\n\nACE_Log_Msg_IPC::ACE_Log_Msg_IPC (void)\n{\n}\n\nACE_Log_Msg_IPC::~ACE_Log_Msg_IPC (void)\n{\n  (void) this-\u003eclose ();\n}\n\nint\nACE_Log_Msg_IPC::open (const ACE_TCHAR *logger_key)\n{\n  ACE_LOG_MSG_IPC_CONNECTOR con;\n  return con.connect (this-\u003emessage_queue_,\n                      ACE_LOG_MSG_IPC_ADDR (logger_key));\n}\n\nint\nACE_Log_Msg_IPC::reset (void)\n{\n  if (this-\u003emessage_queue_.get_handle () != ACE_INVALID_HANDLE)\n    {\n      // If we don't do this, handles aren't reused on Win32 and the\n      // server eventually crashes!\n      return this-\u003eclose ();\n    }\n  return 0;\n}\n\nint\nACE_Log_Msg_IPC::close (void)\n{\n  return this-\u003emessage_queue_.close ();\n}\n\nssize_t\nACE_Log_Msg_IPC::log (ACE_Log_Record \u0026log_record)\n{\n  // Serialize the log record using a CDR stream, allocate enough\n  // space for the complete \u003cACE_Log_Record\u003e.\n  size_t const max_payload_size =\n    4    // type\n    + 4  // pid\n    + 12 // timestamp\n    + 4  // process id\n    + 4  // data length\n#if defined (ACE_USES_WCHAR)\n    + (log_record.msg_data_len () * ACE_OutputCDR::wchar_maxbytes())  // message\n#else\n    + log_record.msg_data_len () // message\n#endif\n    + ACE_CDR::MAX_ALIGNMENT;     // padding;\n\n  // Insert contents of \u003clog_record\u003e into payload stream.\n  ACE_OutputCDR payload (max_payload_size);\n  if (!(payload \u003c\u003c log_record))\n    return -1;\n\n  // Get the number of bytes used by the CDR stream. If it becomes desireable\n  // to support payloads more than 4GB, this field will need to be changed\n  // to a 64-bit value.\n  ACE_CDR::ULong const length =\n    ACE_Utils::truncate_cast\u003cACE_CDR::ULong\u003e (payload.total_length ());\n\n  // Send a header so the receiver can determine the byte order and\n  // size of the incoming CDR stream.\n  ACE_OutputCDR header (ACE_CDR::MAX_ALIGNMENT + 8);\n  if (!(header \u003c\u003c ACE_OutputCDR::from_boolean (ACE_CDR_BYTE_ORDER)))\n   return -1;\n\n  // Store the size of the payload that follows\n  if (!(header \u003c\u003c ACE_CDR::ULong (length)))\n   return -1;\n\n  // Use an iovec to send both buffer and payload simultaneously.\n  iovec iov[2];\n  iov[0].iov_base = header.begin ()-\u003erd_ptr ();\n  iov[0].iov_len  = 8;\n  iov[1].iov_base = payload.begin ()-\u003erd_ptr ();\n  iov[1].iov_len  = length;\n\n#if (ACE_HAS_STREAM_LOG_MSG_IPC == 1)\n  // Use the \u003cputpmsg\u003e API if supported to ensure correct message\n  // queueing according to priority.\n\n  ACE_Str_Buf header_msg (static_cast\u003cvoid *\u003e (header.begin ()-\u003erd_ptr ()),\n                          static_cast\u003cint\u003e (8));\n\n  ACE_Str_Buf payload_msg (static_cast\u003cvoid *\u003e (payload.begin ()-\u003erd_ptr ()),\n                           static_cast\u003cint\u003e (length));\n\n  return this-\u003emessage_queue_.send (\u0026header_msg,\n                                    \u0026payload_msg,\n                                    static_cast\u003cint\u003e (log_record.priority ()),\n                                    MSG_BAND);\n#else\n  // We're running over sockets, so send header and payload\n  // efficiently using \"gather-write\".\n  return this-\u003emessage_queue_.sendv_n (iov, 2);\n#endif /* ACE_HAS_STREAM_LOG_MSG_IPC */\n}\n\nACE_END_VERSIONED_NAMESPACE_DECL\n"}
{"repo_name":"LEEluoman/MazeScrnSave","ref":"refs/heads/master","path":"MazeScrnSave/Maze.cpp","copies":"3","language":"C++","content":"#include \"Maze.h\"\r\n#include \u003cset\u003e\r\n#include \u003cvector\u003e\r\n#include \u003calgorithm\u003e\r\n\r\nusing namespace std;\r\n\r\nCMaze::CMaze(int nWidth, int nHeight, int nCellWidth, int nCellHeight, bool bCopyScreen)\r\n{\r\n    m_nCounter = 0;\r\n\r\n    m_nWidth = nWidth;\r\n    m_nHeight = nHeight;\r\n    m_nCellWidth = nCellWidth;\r\n    m_nCellHeight = nCellHeight;\r\n    m_nCols = m_nWidth / m_nCellWidth - 1;\r\n    m_nRows = m_nHeight / m_nCellHeight - 1;\r\n    m_nOffsetX = (m_nWidth - m_nCols * m_nCellWidth) / 2;\r\n    m_nOffsetY = (m_nHeight - m_nRows * m_nCellHeight) / 2;\r\n\r\n    m_bReDrawBeforeGenerate = FALSE;\r\n    m_bAllowNonSolution = FALSE;\r\n    m_bFlashPath = TRUE;\r\n\r\n//     m_nOffsetX = 2;\r\n//     m_nOffsetY = 2;\r\n\r\n    HDC hScreenDc = GetDC(NULL);\r\n\r\n    m_hWorkDc = CreateCompatibleDC(NULL);\r\n    m_hWorkBmp = CreateCompatibleBitmap(hScreenDc, m_nWidth, m_nHeight);\r\n    m_hOldBmp = SelectObject(m_hWorkDc, (HGDIOBJ)m_hWorkBmp);\r\n    m_hOldPen = SelectObject(m_hWorkDc, m_mazeColor.GetPen(clWall));\r\n\r\n    if (bCopyScreen)\r\n    {\r\n        BitBlt(m_hWorkDc, 0, 0, m_nWidth, m_nHeight, hScreenDc, 0, 0, SRCCOPY);\r\n    }\r\n\r\n    ReleaseDC(NULL, hScreenDc);\r\n\r\n    RECT rect = {0, 0, m_nWidth, m_nHeight};\r\n    FillRect(m_hWorkDc, \u0026rect, m_mazeColor.GetBrush(clBackGround));\r\n\r\n    if (m_nCols \u003e 0 \u0026\u0026 m_nRows \u003e 0)\r\n    {\r\n        m_cells = new CMazeCell[m_nCols * m_nRows];\r\n\r\n        InitializeCells();\r\n        ResetAndReDrawAllCells();\r\n        m_state = MS_INITIALIZED;\r\n    }\r\n    else\r\n    {\r\n        m_state = MS_ERROR;\r\n        m_cells = NULL;\r\n    }\r\n}\r\n\r\nCMaze::~CMaze(void)\r\n{\r\n    SelectObject(m_hWorkDc, m_hOldPen);\r\n    SelectObject(m_hWorkDc, m_hOldBmp);\r\n    DeleteDC(m_hWorkDc);\r\n    DeleteObject(m_hWorkBmp);\r\n\r\n    if (m_cells != NULL)\r\n    {\r\n        delete []m_cells;\r\n    }\r\n}\r\n\r\nCMazeCell *CMaze::GetCell(int i, int j)\r\n{\r\n    if (i \u003c 0 || j \u003c 0 || i \u003e= m_nCols || j \u003e= m_nRows)\r\n    {\r\n        return NULL;\r\n    }\r\n\r\n    return \u0026m_cells[j * m_nCols + i];\r\n}\r\n\r\nvoid CMaze::InitializeCells()\r\n{\r\n    for (int i = 0; i \u003c m_nCols; ++i)\r\n    {\r\n        for (int j = 0; j \u003c m_nRows; ++j)\r\n        {\r\n            CMazeCell *pCell = GetCell(i, j);\r\n\r\n            pCell-\u003eSetParent(this, i, j);\r\n        }\r\n    }\r\n}\r\n\r\nvoid CMaze::ReDrawSides()\r\n{\r\n    int nPicWidth = m_nCols * m_nCellWidth;\r\n    int nPicHeight = m_nRows * m_nCellHeight;\r\n\r\n    MoveToEx(m_hWorkDc, m_nOffsetX, m_nOffsetY, NULL);\r\n    LineTo(m_hWorkDc, m_nOffsetX + nPicWidth, m_nOffsetY);\r\n    LineTo(m_hWorkDc, m_nOffsetX + nPicWidth, m_nOffsetY + nPicHeight);\r\n    LineTo(m_hWorkDc, m_nOffsetX, m_nOffsetY + nPicHeight);\r\n    LineTo(m_hWorkDc, m_nOffsetX, m_nOffsetY);\r\n}\r\n\r\nvoid CMaze::ResetAllCells()\r\n{\r\n    for (int i = 0; i \u003c m_nCols; ++i)\r\n    {\r\n        for (int j = 0; j \u003c m_nRows; ++j)\r\n        {\r\n            CMazeCell *pCell = GetCell(i, j);\r\n\r\n            pCell-\u003eReset();\r\n        }\r\n    }\r\n}\r\n\r\nvoid CMaze::ResetAndReDrawAllCells()\r\n{\r\n    for (int i = 0; i \u003c m_nCols; ++i)\r\n    {\r\n        for (int j = 0; j \u003c m_nRows; ++j)\r\n        {\r\n            CMazeCell *pCell = GetCell(i, j);\r\n\r\n            pCell-\u003eReset();\r\n            pCell-\u003eReDraw();\r\n        }\r\n    }\r\n\r\n    ReDrawSides();\r\n}\r\n\r\nvoid CMaze::ReDrawAllCells()\r\n{\r\n    for (int i = 0; i \u003c m_nCols; ++i)\r\n    {\r\n        for (int j = 0; j \u003c m_nRows; ++j)\r\n        {\r\n            CMazeCell *pCell = GetCell(i, j);\r\n\r\n            pCell-\u003eReDraw();\r\n        }\r\n    }\r\n\r\n    ReDrawSides();\r\n}\r\n\r\nvoid CMaze::Next(BOOL bDelay)\r\n{\r\n    DWORD dwDelayValue = 0;\r\n\r\n    switch (m_state)\r\n    {\r\n    case MS_INITIALIZED:\r\n        m_cellGenerating = GetRandomCell();\r\n        m_cellStack.Init();\r\n        m_cellStack.Push(m_cellGenerating);\r\n        m_cellGenerating-\u003em_bGenerated = true;\r\n        ChangeState(MS_GENERATING);\r\n        break;\r\n\r\n    case MS_GENERATING:\r\n        if (m_cellStack.IsEmpty())\r\n        {\r\n            ChangeState(MS_GENERATED);\r\n        }\r\n        else\r\n        {\r\n            bool bGetNewCell = false;\r\n            CMazeCell *pTopCell = m_cellStack.Top();\r\n\r\n            pTopCell-\u003eReDraw();\r\n            pTopCell-\u003eGoGenerate(\u0026bGetNewCell);\r\n\r\n            if (bGetNewCell)\r\n            {\r\n                //dwDelayValue = 1;\r\n            }\r\n        }\r\n        break;\r\n\r\n    case MS_GENERATED:\r\n        // Ëæ»ú´òÂÒÒ»Ð©Ç½Ãæ\r\n        if (m_bAllowNonSolution \u0026\u0026 m_nRows * m_nCols \u003e= 10 \u0026\u0026 m_nCols \u003e 1 \u0026\u0026 m_nRows \u003e 1)\r\n        {\r\n            int nRightWallsCount = (m_nCols - 1) * m_nRows;\r\n            int nBottomWallsCount = (m_nRows - 1) * m_nCols;\r\n            int nWallsCount = nRightWallsCount + nBottomWallsCount;\r\n            int nChangedWallsCount = nWallsCount * 2 / 100;\r\n            set\u003cint\u003e setChangedWalls;\r\n            vector\u003cint\u003e vectorChangedWalls;\r\n\r\n            if (nChangedWallsCount \u003e 100)\r\n            {\r\n                // µ÷ÕûµÄÇ½Ãæ²»ÒË¹ý¶à£¬·ñÔò×ÜÊÇÎÞ½â\r\n                nChangedWallsCount = 100;\r\n            }\r\n\r\n            while ((int)setChangedWalls.size() \u003c nChangedWallsCount)\r\n            {\r\n                setChangedWalls.insert(BigRand() % nWallsCount);\r\n            }\r\n\r\n            vectorChangedWalls.assign(setChangedWalls.begin(), setChangedWalls.end());\r\n            random_shuffle(vectorChangedWalls.begin(), vectorChangedWalls.end());\r\n\r\n            for (int i = 0; i \u003c nChangedWallsCount; ++i)\r\n            {\r\n                int nOffset = vectorChangedWalls.at(i);\r\n\r\n                if (nOffset \u003c nRightWallsCount)\r\n                {\r\n                    int nRow = nOffset / (m_nCols - 1);\r\n                    int nCol = nOffset % (m_nCols - 1);\r\n                    CMazeCell *pCell = GetCell(nCol, nRow);\r\n\r\n                    pCell-\u003eSetWall(DIR_RIGHT, !pCell-\u003eGetWall(DIR_RIGHT));\r\n                }\r\n                else\r\n                {\r\n                    nOffset -= nRightWallsCount;\r\n\r\n                    int nRow = nOffset / m_nCols;\r\n                    int nCol = nOffset % m_nCols;\r\n                    CMazeCell *pCell = GetCell(nCol, nRow);\r\n\r\n                    pCell-\u003eSetWall(DIR_BOTTOM, !pCell-\u003eGetWall(DIR_BOTTOM));\r\n                }\r\n            }\r\n        }\r\n        ReDrawAllCells();\r\n        ChangeState(MS_SETTING);\r\n        break;\r\n\r\n    case MS_SETTING:\r\n        if (true)\r\n        {\r\n            int nCounter = GetCounter();\r\n\r\n            if (nCounter == 0)\r\n            {\r\n                if (rand() % 5 == 0)\r\n                {\r\n                    int bx[] = {0, 0, 1, 1};\r\n                    int by[] = {0, 1, 0, 1};\r\n                    int ex[] = {1, 1, 0, 0};\r\n                    int ey[] = {1, 0, 1, 0};\r\n                    int offset = rand() % 4;\r\n\r\n                    m_cellBegin = GetCell((GetCols() - 1) * bx[offset], (GetRows() - 1) * by[offset]);\r\n                    m_cellEnd = GetCell((GetCols() - 1) * ex[offset], (GetRows() - 1) * ey[offset]);\r\n                }\r\n                else\r\n                {\r\n                    m_cellBegin = GetRandomCell();\r\n\r\n                    do\r\n                    {\r\n                        m_cellEnd = GetRandomCell();\r\n\r\n                    } while (m_cellEnd == m_cellBegin);\r\n                }\r\n\r\n                m_cellBegin-\u003em_bIsBegin = true;\r\n                m_cellEnd-\u003em_bIsEnd = true;\r\n            }\r\n            else if (nCounter \u003c 19)\r\n            {\r\n                m_cellBegin-\u003em_bIsBegin = !m_cellBegin-\u003em_bIsBegin;\r\n                m_cellBegin-\u003eReDraw();\r\n                dwDelayValue = 55;\r\n            }\r\n            else if (nCounter \u003c 37)\r\n            {\r\n                m_cellEnd-\u003em_bIsEnd = !m_cellEnd-\u003em_bIsEnd;\r\n                m_cellEnd-\u003eReDraw();\r\n                dwDelayValue = 55;\r\n            }\r\n            else\r\n            {\r\n                ChangeState(MS_SET);\r\n            }\r\n        }\r\n        break;\r\n\r\n    case MS_SET:\r\n        m_cellStack.Init();\r\n        m_cellStack.Push(m_cellBegin);\r\n        m_cellBegin-\u003em_bVisited = true;\r\n        ChangeState(MS_RESOLVING);\r\n        break;\r\n\r\n    case MS_RESOLVING:\r\n        if (m_cellStack.IsEmpty())\r\n        {\r\n            ChangeState(MS_RESOLVEFAILED);\r\n        }\r\n        else\r\n        {\r\n            bool bGetNewCell = false;\r\n            CMazeCell *pTopCell = m_cellStack.Top();\r\n\r\n            pTopCell-\u003eReDraw();\r\n\r\n            if (pTopCell == m_cellEnd)\r\n            {\r\n                ChangeState(MS_RESOLVED);\r\n                break;\r\n            }\r\n\r\n            pTopCell-\u003eGoResolve(\u0026bGetNewCell);\r\n\r\n            if (bGetNewCell)\r\n            {\r\n                //dwDelayValue = 1;\r\n            }\r\n        }\r\n        dwDelayValue = 10;\r\n        break;\r\n\r\n    case MS_RESOLVED:\r\n        {\r\n            int nCounter = GetCounter();\r\n\r\n            if (nCounter \u003e 5)\r\n            {\r\n                if (m_bReDrawBeforeGenerate)\r\n                {\r\n                    ResetAndReDrawAllCells();\r\n                }\r\n                else\r\n                {\r\n                    ResetAllCells();\r\n                }\r\n\r\n                ChangeState(MS_INITIALIZED);\r\n            }\r\n            else\r\n            {\r\n                if (m_bFlashPath)\r\n                {\r\n                    COLORREF cl = m_mazeColor.GetColor(clVisited);\r\n\r\n                    m_mazeColor.SetColor(clVisited, GetReverseColor(cl));\r\n\r\n                    ReDrawAllCells();\r\n                }\r\n\r\n                dwDelayValue = 500;\r\n            }\r\n        }\r\n        break;\r\n\r\n    case MS_RESOLVEFAILED:\r\n        dwDelayValue = 3000;\r\n        if (m_bReDrawBeforeGenerate)\r\n        {\r\n            ResetAndReDrawAllCells();\r\n        }\r\n        else\r\n        {\r\n            ResetAllCells();\r\n        }\r\n        ChangeState(MS_INITIALIZED);\r\n\r\n    case MS_PAUSED:\r\n        break;\r\n\r\n    case MS_ERROR:\r\n        break;\r\n\r\n    default:\r\n        break;\r\n    }\r\n\r\n    if (bDelay \u0026\u0026 dwDelayValue \u003e 0)\r\n    {\r\n        Sleep(dwDelayValue);\r\n    }\r\n}\r\n\r\nHDC CMaze::GetDc() const\r\n{\r\n    return m_hWorkDc;\r\n}\r\n\r\nCMazeColor \u0026CMaze::GetColorManager()\r\n{\r\n    return m_mazeColor;\r\n}\r\n\r\nMazeState CMaze::GetState() const\r\n{\r\n    return m_state;\r\n}\r\n\r\nCMazeCell *CMaze::GetRandomCell()\r\n{\r\n    return GetCell(rand() % m_nCols, rand() % m_nRows);\r\n}\r\n\r\nvoid CMaze::MakeRandomBeginAndEndCell()\r\n{\r\n    m_cellBegin = GetRandomCell();\r\n    m_cellEnd = GetRandomCell();\r\n\r\n    while (m_cellEnd == m_cellBegin)\r\n    {\r\n        m_cellEnd = GetRandomCell();\r\n    }\r\n}\r\n\r\nint CMaze::GetWidth() const\r\n{\r\n    return m_nWidth;\r\n}\r\n\r\nint CMaze::GetHeight() const\r\n{\r\n    return m_nHeight;\r\n}\r\n\r\nint CMaze::GetCellWidth() const\r\n{\r\n    return m_nCellWidth;\r\n}\r\n\r\nint CMaze::GetCellHeight() const\r\n{\r\n    return m_nCellHeight;\r\n}\r\n\r\nint CMaze::GetRows() const\r\n{\r\n    return m_nRows;\r\n}\r\n\r\nint CMaze::GetCols() const\r\n{\r\n    return m_nCols;\r\n}\r\n\r\nint CMaze::GetOffsetX() const\r\n{\r\n    return m_nOffsetX;\r\n}\r\n\r\nint CMaze::GetOffsetY() const\r\n{\r\n    return m_nOffsetY;\r\n}\r\n\r\nCMazeCellStack \u0026CMaze::GetCellStack()\r\n{\r\n    return m_cellStack;\r\n}\r\n\r\nvoid CMaze::ChangeState(MazeState state)\r\n{\r\n    if (m_state != state)\r\n    {\r\n        m_state = state;\r\n        m_nCounter = 0;\r\n    }\r\n}\r\n\r\nint CMaze::GetCounter()\r\n{\r\n    return m_nCounter++;\r\n}\r\n\r\nint CMaze::BigRand()\r\n{\r\n    return\r\n        (((rand() % 0x100) \u003c\u003c 0) |\r\n        ((rand() % 0x100) \u003c\u003c 8) |\r\n        ((rand() % 0x100) \u003c\u003c 16) |\r\n        ((rand() % 0x100) \u003c\u003c 24)) \u0026\r\n        ((unsigned)-1 \u003e\u003e 1);\r\n}\r\n\r\nCOLORREF CMaze::GetReverseColor(COLORREF cl)\r\n{\r\n    return RGB(~GetRValue(cl), ~GetGValue(cl), ~GetBValue(cl));\r\n}\r\n\r\nvoid CMaze::SetReDrawBeforeGenerate(BOOL bReDrawBeforeGenerate)\r\n{\r\n    m_bReDrawBeforeGenerate = bReDrawBeforeGenerate;\r\n}\r\n\r\nvoid CMaze:: SetAllowNonSolution(BOOL bAllowNonSolution)\r\n{\r\n    m_bAllowNonSolution = bAllowNonSolution;\r\n}\r\n\r\nvoid CMaze::SetFlashPath(BOOL bFlashPath)\r\n{\r\n    m_bFlashPath = bFlashPath;\r\n}\r\n\r\nvoid CMaze::UpdateColors()\r\n{\r\n    SelectObject(m_hWorkDc, m_mazeColor.GetPen(clWall));    \r\n}\r\n\r\nvoid CMaze::Restart()\r\n{\r\n    if (m_bReDrawBeforeGenerate)\r\n    {\r\n        ResetAndReDrawAllCells();\r\n    }\r\n    else\r\n    {\r\n        ResetAllCells();\r\n    }\r\n\r\n    ChangeState(MS_INITIALIZED);\r\n}\r\n"}
{"repo_name":"krf/kdevelop","ref":"refs/heads/master","path":"debuggers/gdb/printers/tests/qmapint.cpp","copies":"7","language":"C++","content":"#include \u003cQMap\u003e\nint main()\n{\n    QMap\u003cint, int\u003e m;\n    m[10] = 100;\n    m[20] = 200;\n    m[30] = 300;\n    return 0;\n}\n"}
{"repo_name":"Voyager1/xbmc","ref":"refs/heads/master","path":"xbmc/windowing/rpi/GLContextEGL.cpp","copies":"42","language":"C++","content":"/*\n *      Copyright (C) 2005-2013 Team XBMC\n *      http://xbmc.org\n *\n *  This Program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  This Program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with XBMC; see the file COPYING.  If not, see\n *  \u003chttp://www.gnu.org/licenses/\u003e.\n *\n */\n\n#include \"GLContextEGL.h\"\n\n#include \"guilib/IDirtyRegionSolver.h\"\n#include \"settings/AdvancedSettings.h\"\n#include \"utils/log.h\"\n\nCGLContextEGL::CGLContextEGL() :\n  m_eglDisplay(EGL_NO_DISPLAY),\n  m_eglSurface(EGL_NO_SURFACE),\n  m_eglContext(EGL_NO_CONTEXT),\n  m_eglConfig(0)\n{\n}\n\nCGLContextEGL::~CGLContextEGL()\n{\n  Destroy();\n}\n\nbool CGLContextEGL::CreateDisplay(EGLDisplay display,\n                                  EGLint renderable_type,\n                                  EGLint rendering_api)\n{\n  EGLint neglconfigs = 0;\n  int major, minor;\n\n  EGLint surface_type = EGL_WINDOW_BIT;\n  // for the non-trivial dirty region modes, we need the EGL buffer to be preserved across updates\n  if (g_advancedSettings.m_guiAlgorithmDirtyRegions == DIRTYREGION_SOLVER_COST_REDUCTION ||\n      g_advancedSettings.m_guiAlgorithmDirtyRegions == DIRTYREGION_SOLVER_UNION)\n    surface_type |= EGL_SWAP_BEHAVIOR_PRESERVED_BIT;\n\n  EGLint attribs[] =\n  {\n    EGL_RED_SIZE,        8,\n    EGL_GREEN_SIZE,      8,\n    EGL_BLUE_SIZE,       8,\n    EGL_ALPHA_SIZE,      8,\n    EGL_DEPTH_SIZE,     16,\n    EGL_STENCIL_SIZE,    0,\n    EGL_SAMPLE_BUFFERS,  0,\n    EGL_SAMPLES,         0,\n    EGL_SURFACE_TYPE,    surface_type,\n    EGL_RENDERABLE_TYPE, renderable_type,\n    EGL_NONE\n  };\n\n  if (m_eglDisplay == EGL_NO_DISPLAY)\n  {\n    m_eglDisplay = eglGetDisplay((EGLNativeDisplayType)display);\n  }\n\n  if (m_eglDisplay == EGL_NO_DISPLAY)\n  {\n    CLog::Log(LOGERROR, \"failed to get EGL display\");\n    return false;\n  }\n\n  if (!eglInitialize(m_eglDisplay, \u0026major, \u0026minor))\n  {\n    CLog::Log(LOGERROR, \"failed to initialize EGL display\");\n    return false;\n  }\n\n  eglBindAPI(rendering_api);\n\n  if (!eglChooseConfig(m_eglDisplay, attribs,\n                       \u0026m_eglConfig, 1, \u0026neglconfigs))\n  {\n    CLog::Log(LOGERROR, \"Failed to query number of EGL configs\");\n    return false;\n  }\n\n  if (neglconfigs \u003c= 0)\n  {\n    CLog::Log(LOGERROR, \"No suitable EGL configs found\");\n    return false;\n  }\n\n  return true;\n}\n\nbool CGLContextEGL::CreateContext()\n{\n  int client_version = 2;\n\n  const EGLint context_attribs[] = {\n    EGL_CONTEXT_CLIENT_VERSION, client_version, EGL_NONE\n  };\n\n  if (m_eglContext == EGL_NO_CONTEXT)\n  {\n  m_eglContext = eglCreateContext(m_eglDisplay, m_eglConfig,\n                                  EGL_NO_CONTEXT, context_attribs);\n  }\n\n  if (m_eglContext == EGL_NO_CONTEXT)\n  {\n    CLog::Log(LOGERROR, \"failed to create EGL context\");\n    return false;\n  }\n\n  return true;\n}\n\nbool CGLContextEGL::BindContext()\n{\n  if (!eglMakeCurrent(m_eglDisplay, m_eglSurface,\n                      m_eglSurface, m_eglContext))\n  {\n    CLog::Log(LOGERROR, \"Failed to make context current %p %p %p\",\n                         m_eglDisplay, m_eglSurface, m_eglContext);\n    return false;\n  }\n\n  return true;\n}\n\nbool CGLContextEGL::SurfaceAttrib()\n{\n  // for the non-trivial dirty region modes, we need the EGL buffer to be preserved across updates\n  if (g_advancedSettings.m_guiAlgorithmDirtyRegions == DIRTYREGION_SOLVER_COST_REDUCTION ||\n      g_advancedSettings.m_guiAlgorithmDirtyRegions == DIRTYREGION_SOLVER_UNION)\n  {\n    if ((m_eglDisplay == EGL_NO_DISPLAY) || (m_eglSurface == EGL_NO_SURFACE))\n    {\n      return false;\n    }\n\n    if (!eglSurfaceAttrib(m_eglDisplay, m_eglSurface, EGL_SWAP_BEHAVIOR, EGL_BUFFER_PRESERVED))\n    {\n      CLog::Log(LOGDEBUG, \"%s: Could not set EGL_SWAP_BEHAVIOR\",__FUNCTION__);\n    }\n  }\n\n  return true;\n}\n\nbool CGLContextEGL::CreateSurface(EGLNativeWindowType surface)\n{\n  m_eglSurface = eglCreateWindowSurface(m_eglDisplay,\n                                        m_eglConfig,\n\t\t\t\t\tsurface,\n\t\t\t\t\tnullptr);\n\n  if (m_eglSurface == EGL_NO_SURFACE)\n  {\n    CLog::Log(LOGERROR, \"failed to create EGL window surface %d\", eglGetError());\n    return false;\n  }\n\n  return true;\n}\n\nvoid CGLContextEGL::Destroy()\n{\n  if (m_eglContext != EGL_NO_CONTEXT)\n  {\n    eglDestroyContext(m_eglDisplay, m_eglContext);\n    eglMakeCurrent(m_eglDisplay, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);\n    m_eglContext = EGL_NO_CONTEXT;\n  }\n\n  if (m_eglSurface != EGL_NO_SURFACE)\n  {\n    eglDestroySurface(m_eglDisplay, m_eglSurface);\n    m_eglSurface = EGL_NO_SURFACE;\n  }\n\n  if (m_eglDisplay != EGL_NO_DISPLAY)\n  {\n    eglTerminate(m_eglDisplay);\n    m_eglDisplay = EGL_NO_DISPLAY;\n  }\n}\n\nvoid CGLContextEGL::Detach()\n{\n  if (m_eglContext != EGL_NO_CONTEXT)\n  {\n    eglMakeCurrent(m_eglDisplay, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);\n  }\n\n  if (m_eglSurface != EGL_NO_SURFACE)\n  {\n    eglDestroySurface(m_eglDisplay, m_eglSurface);\n    m_eglSurface = EGL_NO_SURFACE;\n  }\n}\n\nbool CGLContextEGL::SetVSync(bool enable)\n{\n  if (!eglSwapInterval(m_eglDisplay, enable))\n  {\n    return false;\n  }\n\n  return true;\n}\n\nvoid CGLContextEGL::SwapBuffers()\n{\n  if (m_eglDisplay == EGL_NO_DISPLAY || m_eglSurface == EGL_NO_SURFACE)\n  {\n    return;\n  }\n\n  eglSwapBuffers(m_eglDisplay, m_eglSurface);\n}\n"}
{"repo_name":"LiveAsynchronousVisualizedArchitecture/lava","ref":"refs/heads/master","path":"nuklear/unified.cpp","copies":"1","language":"C++","content":"\n\n#define LAVA_INDEXED_VERTS_IMPL\n#include \"IndexedVerts.h\"\n\n#include \"nanogui/src/screen.cpp\"\n\n#include \"main.cpp\"\n"}
{"repo_name":"quang-ha/lammps","ref":"refs/heads/master","path":"lib/kokkos/core/src/eti/OpenMP/Kokkos_OpenMP_ViewCopyETIInst_int64_t_double_LayoutStride_Rank3.cpp","copies":"15","language":"C++","content":"//@HEADER\n// ************************************************************************\n// \n//                        Kokkos v. 2.0\n//              Copyright (2014) Sandia Corporation\n// \n// Under the terms of Contract DE-AC04-94AL85000 with Sandia Corporation,\n// the U.S. Government retains certain rights in this software.\n//\n// Kokkos is licensed under 3-clause BSD terms of use:\n// \n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n// 1. Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright\n// notice, this list of conditions and the following disclaimer in the\n// documentation and/or other materials provided with the distribution.\n//\n// 3. Neither the name of the Corporation nor the names of the\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY SANDIA CORPORATION \"AS IS\" AND ANY\n// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n// PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL SANDIA CORPORATION OR THE\n// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Questions? Contact Christian R. Trott (crtrott@sandia.gov)\n// \n// ************************************************************************\n//@HEADER\n\n#define KOKKOS_IMPL_COMPILING_LIBRARY true\n#include\u003cKokkos_Core.hpp\u003e\nnamespace Kokkos {\nnamespace Impl {\nKOKKOS_IMPL_VIEWCOPY_ETI_INST(double***,LayoutStride,LayoutRight, OpenMP,int64_t)\nKOKKOS_IMPL_VIEWCOPY_ETI_INST(double***,LayoutStride,LayoutLeft,  OpenMP,int64_t)\nKOKKOS_IMPL_VIEWCOPY_ETI_INST(double***,LayoutStride,LayoutStride,OpenMP,int64_t)\nKOKKOS_IMPL_VIEWFILL_ETI_INST(double***,LayoutStride,OpenMP,int64_t)\n\n}\n}\n"}
{"repo_name":"tjaffri/msiot-samples","ref":"refs/heads/develop","path":"AllJoyn/Samples/ZWaveAdapter/open-zwave/cpp/src/command_classes/UserCode.cpp","copies":"23","language":"C++","content":"//-----------------------------------------------------------------------------\n//\n//\tUserCode.cpp\n//\n//\tImplementation of the Z-Wave COMMAND_CLASS_USER_CODE\n//\n//\tCopyright (c) 2012 Greg Satz \u003csatz@iranger.com\u003e\n//\n//\tSOFTWARE NOTICE AND LICENSE\n//\n//\tThis file is part of OpenZWave.\n//\n//\tOpenZWave is free software: you can redistribute it and/or modify\n//\tit under the terms of the GNU Lesser General Public License as published\n//\tby the Free Software Foundation, either version 3 of the License,\n//\tor (at your option) any later version.\n//\n//\tOpenZWave is distributed in the hope that it will be useful,\n//\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n//\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//\tGNU Lesser General Public License for more details.\n//\n//\tYou should have received a copy of the GNU Lesser General Public License\n//\talong with OpenZWave.  If not, see \u003chttp://www.gnu.org/licenses/\u003e.\n//\n//-----------------------------------------------------------------------------\n\n#include \"tinyxml.h\"\n#include \"command_classes/CommandClasses.h\"\n#include \"command_classes/UserCode.h\"\n#include \"Node.h\"\n#include \"Options.h\"\n#include \"platform/Log.h\"\n\n#include \"value_classes/ValueByte.h\"\n#include \"value_classes/ValueRaw.h\"\n\nusing namespace OpenZWave;\n\nenum UserCodeCmd\n{\n\tUserCodeCmd_Set\t\t\t= 0x01,\n\tUserCodeCmd_Get\t\t\t= 0x02,\n\tUserCodeCmd_Report\t\t= 0x03,\n\tUserNumberCmd_Get\t\t= 0x04,\n\tUserNumberCmd_Report\t\t= 0x05\n};\n\nenum\n{\n\tUserCodeIndex_Refresh\t= 254,\n\tUserCodeIndex_Count\t\t= 255\n};\n\nconst uint8 UserCodeLength = 10;\n\n//-----------------------------------------------------------------------------\n// \u003cUserCode::UserCode\u003e\n// Constructor\n//-----------------------------------------------------------------------------\nUserCode::UserCode\n(\n\tuint32 const _homeId,\n\tuint8 const _nodeId\n):\n\tCommandClass( _homeId, _nodeId ),\n\tm_queryAll( false ),\n\tm_currentCode( 0 ),\n\tm_userCodeCount( 0 ),\n\tm_refreshUserCodes(false)\n{\n\tSetStaticRequest( StaticRequest_Values );\n\tmemset( m_userCodesStatus, 0xff, sizeof(m_userCodesStatus) );\n\tOptions::Get()-\u003eGetOptionAsBool(\"RefreshAllUserCodes\", \u0026m_refreshUserCodes );\n\n}\n\n//-----------------------------------------------------------------------------\n// \u003cUserCode::ReadXML\u003e\n// Class specific configuration\n//-----------------------------------------------------------------------------\nvoid UserCode::ReadXML\n(\n\tTiXmlElement const* _ccElement\n)\n{\n\tint32 intVal;\n\n\tCommandClass::ReadXML( _ccElement );\n\tif( TIXML_SUCCESS == _ccElement-\u003eQueryIntAttribute( \"codes\", \u0026intVal ) )\n\t{\n\t\tm_userCodeCount = intVal;\n\t}\n}\n\n//-----------------------------------------------------------------------------\n// \u003cUserCode::WriteXML\u003e\n// Class specific configuration\n//-----------------------------------------------------------------------------\nvoid UserCode::WriteXML\n(\n\tTiXmlElement* _ccElement\n)\n{\n\tchar str[32];\n\n\tCommandClass::WriteXML( _ccElement );\n\tsnprintf( str, sizeof(str), \"%d\", m_userCodeCount );\n\t_ccElement-\u003eSetAttribute( \"codes\", str);\n}\n\n//-----------------------------------------------------------------------------\n// \u003cUserCode::RequestState\u003e\n// Nothing to do for UserCode\n//-----------------------------------------------------------------------------\nbool UserCode::RequestState\n(\n\tuint32 const _requestFlags,\n\tuint8 const _instance,\n\tDriver::MsgQueue const _queue\n)\n{\n\tbool requests = false;\n\tif( ( _requestFlags \u0026 RequestFlag_Static ) \u0026\u0026 HasStaticRequest( StaticRequest_Values ) )\n\t{\n\t\trequests |= RequestValue( _requestFlags, UserCodeIndex_Count, _instance, _queue );\n\t}\n\n\tif( _requestFlags \u0026 RequestFlag_Session )\n\t{\n\t\tif( m_userCodeCount \u003e 0 )\n\t\t{\n\t\t\tm_queryAll = true;\n\t\t\tm_currentCode = 1;\n\t\t\trequests |= RequestValue( _requestFlags, m_currentCode, _instance, _queue );\n\t\t}\n\t}\n\n\treturn requests;\n}\n\n//-----------------------------------------------------------------------------\n// \u003cUserCode::RequestValue\u003e\n// Nothing to do for UserCode\n//-----------------------------------------------------------------------------\nbool UserCode::RequestValue\n(\n\tuint32 const _requestFlags,\n\tuint8 const _userCodeIdx,\n\tuint8 const _instance,\n\tDriver::MsgQueue const _queue\n)\n{\n\tif( _instance != 1 )\n\t{\n\t\t// This command class doesn't work with multiple instances\n\t\treturn false;\n\t}\n\tif ( !IsGetSupported() )\n\t{\n\t\tLog::Write(  LogLevel_Info, GetNodeId(), \"UserNumberCmd_Get Not Supported on this node\");\n\t\treturn false;\n\t}\n\tif( _userCodeIdx == UserCodeIndex_Count )\n\t{\n\t\t// Get number of supported user codes.\n\t\tMsg* msg = new Msg( \"UserNumberCmd_Get\", GetNodeId(), REQUEST, FUNC_ID_ZW_SEND_DATA, true, true, FUNC_ID_APPLICATION_COMMAND_HANDLER, GetCommandClassId() );\n\t\tmsg-\u003eAppend( GetNodeId() );\n\t\tmsg-\u003eAppend( 2 );\n\t\tmsg-\u003eAppend( GetCommandClassId() );\n\t\tmsg-\u003eAppend( UserNumberCmd_Get );\n\t\tmsg-\u003eAppend( GetDriver()-\u003eGetTransmitOptions() );\n\t\tGetDriver()-\u003eSendMsg( msg, _queue );\n\t\treturn true;\n\t}\n\tif (_userCodeIdx == 0)\n\t{\n\t\tLog::Write( LogLevel_Warning, GetNodeId(), \"UserCodeCmd_Get with Index 0 not Supported\");\n\t\treturn false;\n\t}\n\tMsg* msg = new Msg( \"UserCodeCmd_Get\", GetNodeId(), REQUEST, FUNC_ID_ZW_SEND_DATA, true, true, FUNC_ID_APPLICATION_COMMAND_HANDLER, GetCommandClassId() );\n\tmsg-\u003eAppend( GetNodeId() );\n\tmsg-\u003eAppend( 3 );\n\tmsg-\u003eAppend( GetCommandClassId() );\n\tmsg-\u003eAppend( UserCodeCmd_Get );\n\tmsg-\u003eAppend( _userCodeIdx );\n\tmsg-\u003eAppend( GetDriver()-\u003eGetTransmitOptions() );\n\tGetDriver()-\u003eSendMsg( msg, _queue );\n\treturn true;\n}\n\n//-----------------------------------------------------------------------------\n// \u003cUserCode::HandleMsg\u003e\n// Handle a message from the Z-Wave network\n//-----------------------------------------------------------------------------\nbool UserCode::HandleMsg\n(\n\tuint8 const* _data,\n\tuint32 const _length,\n\tuint32 const _instance\t// = 1\n)\n{\n\tif( UserNumberCmd_Report == (UserCodeCmd)_data[0] )\n\t{\n\t\tm_userCodeCount = _data[1];\n\t\tif( m_userCodeCount \u003e 254 )\n\t\t{\n\t\t\t// Make space for code count.\n\t\t\tm_userCodeCount = 254;\n\t\t}\n\t\tClearStaticRequest( StaticRequest_Values );\n\t\tif( m_userCodeCount == 0 )\n\t\t{\n\t\t\tLog::Write( LogLevel_Info, GetNodeId(), \"Received User Number report from node %d: Not supported\", GetNodeId() );\n\t\t}\n\t\telse\n\t\t{\n\t\t\tLog::Write( LogLevel_Info, GetNodeId(), \"Received User Number report from node %d: Supported Codes %d (%d)\", GetNodeId(), m_userCodeCount, _data[1] );\n\t\t}\n\n\t\tif( ValueByte* value = static_cast\u003cValueByte*\u003e( GetValue( _instance, UserCodeIndex_Count ) ) )\n\t\t{\n\t\t\tvalue-\u003eOnValueRefreshed( m_userCodeCount );\n\t\t\tvalue-\u003eRelease();\n\t\t}\n\n\t\tif( Node* node = GetNodeUnsafe() )\n\t\t{\n\t\t\tuint8 data[UserCodeLength];\n\n\t\t\tmemset( data, 0, UserCodeLength );\n\t\t\tfor( uint8 i = 0; i \u003c= m_userCodeCount; i++ )\n\t\t\t{\n\t\t\t\tchar str[16];\n\t\t\t\tif (i == 0)\n\t\t\t\t{\n\t\t\t\t\tsnprintf( str, sizeof(str), \"Enrollment Code\");\n\t\t\t\t\tnode-\u003eCreateValueRaw( ValueID::ValueGenre_User, GetCommandClassId(), _instance, i, str, \"\", true, false, data, UserCodeLength, 0 );\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tsnprintf( str, sizeof(str), \"Code %d:\", i);\n\t\t\t\t\tnode-\u003eCreateValueRaw( ValueID::ValueGenre_User, GetCommandClassId(), _instance, i, str, \"\", false, false, data, UserCodeLength, 0 );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\telse if( UserCodeCmd_Report == (UserCodeCmd)_data[0] )\n\t{\n\t\tint i = _data[1];\n\t\tif( ValueRaw* value = static_cast\u003cValueRaw*\u003e( GetValue( _instance, i ) ) )\n\t\t{\n\t\t\tuint8 data[UserCodeLength];\n\t\t\tuint8 size = _length - 4;\n\t\t\tif( size \u003e UserCodeLength )\n\t\t\t{\n\t\t\t\tLog::Write( LogLevel_Warning, GetNodeId(), \"User Code length %d is larger then maximum %d\", size, UserCodeLength );\n\t\t\t\tsize = UserCodeLength;\n\t\t\t}\n\t\t\tm_userCodesStatus[i] = _data[2];\n\t\t\tmemcpy( data, \u0026_data[3], size );\n\t\t\tvalue-\u003eOnValueRefreshed( data, size );\n\t\t\tvalue-\u003eRelease();\n\t\t}\n\t\tLog::Write( LogLevel_Info, GetNodeId(), \"Received User Code Report from node %d for User Code %d (%s)\", GetNodeId(), i, CodeStatus( _data[2] ).c_str() );\n\t\tif( m_queryAll \u0026\u0026 i == m_currentCode )\n\t\t{\n\n\t\t\tif (m_refreshUserCodes || (_data[2] != UserCode_Available)) {\n\t\t\t\tif( ++i \u003c= m_userCodeCount )\n\t\t\t\t{\n\t\t\t\t\tm_currentCode = i;\n\t\t\t\t\tRequestValue( 0, m_currentCode, _instance, Driver::MsgQueue_Query );\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tm_queryAll = false;\n\t\t\t\t\t/* we might have reset this as part of the RefreshValues Button Value */\n\t\t\t\t\tOptions::Get()-\u003eGetOptionAsBool(\"RefreshAllUserCodes\", \u0026m_refreshUserCodes );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tLog::Write( LogLevel_Info, GetNodeId(), \"Not Requesting additional UserCode Slots as RefreshAllUserCodes is false, and slot %d is available\", i);\n\t\t\t\tm_queryAll = false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n//-----------------------------------------------------------------------------\n// \u003cUserCode::SetValue\u003e\n// Set a User Code value\n//-----------------------------------------------------------------------------\nbool UserCode::SetValue\n(\n\tValue const\u0026 _value\n)\n{\n\tif( (ValueID::ValueType_Raw == _value.GetID().GetType()) \u0026\u0026 (_value.GetID().GetIndex() \u003c UserCodeIndex_Refresh) )\n\t{\n\t\tValueRaw const* value = static_cast\u003cValueRaw const*\u003e(\u0026_value);\n\t\tuint8* s = value-\u003eGetValue();\n\t\tuint8 len = value-\u003eGetLength();\n\n\t\tif( len \u003e UserCodeLength )\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tm_userCodesStatus[value-\u003eGetID().GetIndex()] = UserCode_Occupied;\n\t\tMsg* msg = new Msg( \"UserCodeCmd_Set\", GetNodeId(), REQUEST, FUNC_ID_ZW_SEND_DATA, true );\n\t\tmsg-\u003eSetInstance( this, _value.GetID().GetInstance() );\n\t\tmsg-\u003eAppend( GetNodeId() );\n\t\tmsg-\u003eAppend( 4 + len );\n\t\tmsg-\u003eAppend( GetCommandClassId() );\n\t\tmsg-\u003eAppend( UserCodeCmd_Set );\n\t\tmsg-\u003eAppend( value-\u003eGetID().GetIndex() );\n\t\tmsg-\u003eAppend( UserCode_Occupied );\n\t\tfor( uint8 i = 0; i \u003c len; i++ )\n\t\t{\n\t\t\tmsg-\u003eAppend( s[i] );\n\t\t}\n\t\tmsg-\u003eAppend( GetDriver()-\u003eGetTransmitOptions() );\n\t\tGetDriver()-\u003eSendMsg( msg, Driver::MsgQueue_Send );\n\t\treturn true;\n\t}\n\tif ( (ValueID::ValueType_Button == _value.GetID().GetType()) \u0026\u0026 (_value.GetID().GetIndex() == UserCodeIndex_Refresh) )\n\t{\n\t\tm_refreshUserCodes = true;\n\t\tm_currentCode = 1;\n\t\tm_queryAll = true;\n\t\tRequestValue( 0, m_currentCode, _value.GetID().GetInstance(), Driver::MsgQueue_Query );\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n//-----------------------------------------------------------------------------\n// \u003cUserCode::CreateVars\u003e\n// Create the values managed by this command class\n//-----------------------------------------------------------------------------\nvoid UserCode::CreateVars\n(\n\tuint8 const _instance\n\n)\n{\n\tif( Node* node = GetNodeUnsafe() )\n\t{\n\t\tnode-\u003eCreateValueByte( ValueID::ValueGenre_System, GetCommandClassId(), _instance, UserCodeIndex_Count, \"Code Count\", \"\", true, false, 0, 0 );\n\t\tnode-\u003eCreateValueButton( ValueID::ValueGenre_System, GetCommandClassId(), _instance, UserCodeIndex_Refresh, \"Refresh All UserCodes\", 0);\n\t}\n}\n"}
{"repo_name":"sunblithe/qt-everywhere-opensource-src-4.7.1","ref":"refs/heads/master","path":"src/gui/kernel/qeventdispatcher_x11.cpp","copies":"2","language":"C++","content":"/****************************************************************************\n**\n** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).\n** All rights reserved.\n** Contact: Nokia Corporation (qt-info@nokia.com)\n**\n** This file is part of the QtGui module of the Qt Toolkit.\n**\n** $QT_BEGIN_LICENSE:LGPL$\n** Commercial Usage\n** Licensees holding valid Qt Commercial licenses may use this file in\n** accordance with the Qt Commercial License Agreement provided with the\n** Software or, alternatively, in accordance with the terms contained in\n** a written agreement between you and Nokia.\n**\n** GNU Lesser General Public License Usage\n** Alternatively, this file may be used under the terms of the GNU Lesser\n** General Public License version 2.1 as published by the Free Software\n** Foundation and appearing in the file LICENSE.LGPL included in the\n** packaging of this file.  Please review the following information to\n** ensure the GNU Lesser General Public License version 2.1 requirements\n** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.\n**\n** In addition, as a special exception, Nokia gives you certain additional\n** rights.  These rights are described in the Nokia Qt LGPL Exception\n** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.\n**\n** GNU General Public License Usage\n** Alternatively, this file may be used under the terms of the GNU\n** General Public License version 3.0 as published by the Free Software\n** Foundation and appearing in the file LICENSE.GPL included in the\n** packaging of this file.  Please review the following information to\n** ensure the GNU General Public License version 3.0 requirements will be\n** met: http://www.gnu.org/copyleft/gpl.html.\n**\n** If you have questions regarding the use of this file, please contact\n** Nokia at qt-info@nokia.com.\n** $QT_END_LICENSE$\n**\n****************************************************************************/\n\n#include \"qeventdispatcher_x11_p.h\"\n\n#include \"qapplication.h\"\n#include \"qx11info_x11.h\"\n\n#include \"qt_x11_p.h\"\n#include \u003cprivate/qeventdispatcher_unix_p.h\u003e\n\nQT_BEGIN_NAMESPACE\n\nclass QEventDispatcherX11Private : public QEventDispatcherUNIXPrivate\n{\n    Q_DECLARE_PUBLIC(QEventDispatcherX11)\npublic:\n    inline QEventDispatcherX11Private()\n        : xfd(-1)\n    { }\n    int xfd;\n    QList\u003cXEvent\u003e queuedUserInputEvents;\n};\n\nQEventDispatcherX11::QEventDispatcherX11(QObject *parent)\n    : QEventDispatcherUNIX(*new QEventDispatcherX11Private, parent)\n{ }\n\nQEventDispatcherX11::~QEventDispatcherX11()\n{ }\n\nbool QEventDispatcherX11::processEvents(QEventLoop::ProcessEventsFlags flags)\n{\n    Q_D(QEventDispatcherX11);\n\n    d-\u003einterrupt = false;\n    QApplication::sendPostedEvents();\n\n    ulong marker = XNextRequest(X11-\u003edisplay);\n    int nevents = 0;\n    do {\n        while (!d-\u003einterrupt) {\n            XEvent event;\n            if (!(flags \u0026 QEventLoop::ExcludeUserInputEvents)\n                \u0026\u0026 !d-\u003equeuedUserInputEvents.isEmpty()) {\n                // process a pending user input event\n                event = d-\u003equeuedUserInputEvents.takeFirst();\n            } else if (XEventsQueued(X11-\u003edisplay, QueuedAlready)) {\n                // process events from the X server\n                XNextEvent(X11-\u003edisplay, \u0026event);\n\n                if (flags \u0026 QEventLoop::ExcludeUserInputEvents) {\n                    // queue user input events\n                    switch (event.type) {\n                    case ButtonPress:\n                    case ButtonRelease:\n                    case MotionNotify:\n                    case XKeyPress:\n                    case XKeyRelease:\n                    case EnterNotify:\n                    case LeaveNotify:\n                        d-\u003equeuedUserInputEvents.append(event);\n                        continue;\n\n                    case ClientMessage:\n                        // only keep the wm_take_focus and\n                        // _qt_scrolldone protocols, queue all other\n                        // client messages\n                        if (event.xclient.format == 32) {\n                            if (event.xclient.message_type == ATOM(WM_PROTOCOLS) \u0026\u0026\n                                (Atom) event.xclient.data.l[0] == ATOM(WM_TAKE_FOCUS)) {\n                                break;\n                            } else if (event.xclient.message_type == ATOM(_QT_SCROLL_DONE)) {\n                                break;\n                            }\n                        }\n                        d-\u003equeuedUserInputEvents.append(event);\n                        continue;\n\n                    default:\n                        break;\n                    }\n                }\n            } else {\n                // no event to process\n                break;\n            }\n\n            // send through event filter\n            if (filterEvent(\u0026event))\n                continue;\n\n            nevents++;\n            if (qApp-\u003ex11ProcessEvent(\u0026event) == 1)\n                return true;\n\n            if (event.xany.serial \u003e= marker) {\n                if (XEventsQueued(X11-\u003edisplay, QueuedAfterFlush))\n                    flags \u0026= ~QEventLoop::WaitForMoreEvents;\n                goto out;\n            }\n        }\n    } while (!d-\u003einterrupt \u0026\u0026 XEventsQueued(X11-\u003edisplay, QueuedAfterFlush));\n\n out:\n    if (!d-\u003einterrupt) {\n        const uint exclude_all =\n            QEventLoop::ExcludeSocketNotifiers | QEventLoop::X11ExcludeTimers | QEventLoop::WaitForMoreEvents;\n        if (nevents \u003e 0 \u0026\u0026 ((uint)flags \u0026 exclude_all) == exclude_all) {\n            QApplication::sendPostedEvents();\n            return nevents \u003e 0;\n        }\n        // return true if we handled events, false otherwise\n        return QEventDispatcherUNIX::processEvents(flags) ||  (nevents \u003e 0);\n    }\n    return nevents \u003e 0;\n}\n\nbool QEventDispatcherX11::hasPendingEvents()\n{\n    extern uint qGlobalPostedEventsCount(); // from qapplication.cpp\n    return (qGlobalPostedEventsCount() || XPending(X11-\u003edisplay));\n}\n\nvoid QEventDispatcherX11::flush()\n{\n    XFlush(X11-\u003edisplay);\n}\n\nvoid QEventDispatcherX11::startingUp()\n{\n    Q_D(QEventDispatcherX11);\n    d-\u003exfd = XConnectionNumber(X11-\u003edisplay);\n}\n\nvoid QEventDispatcherX11::closingDown()\n{\n    Q_D(QEventDispatcherX11);\n    d-\u003exfd = -1;\n}\n\nint QEventDispatcherX11::select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds,\n                                timeval *timeout)\n{\n    Q_D(QEventDispatcherX11);\n    if (d-\u003exfd \u003e 0) {\n        nfds = qMax(nfds - 1, d-\u003exfd) + 1;\n        FD_SET(d-\u003exfd, readfds);\n    }\n    return QEventDispatcherUNIX::select(nfds, readfds, writefds, exceptfds, timeout);\n}\n\nQT_END_NAMESPACE\n"}
{"repo_name":"pokowaka/xbmc","ref":"refs/heads/master","path":"xbmc/filesystem/MusicDatabaseDirectory/DirectoryNodeAlbumCompilations.cpp","copies":"166","language":"C++","content":"/*\n *      Copyright (C) 2005-2013 Team XBMC\n *      http://xbmc.org\n *\n *  This Program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  This Program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with XBMC; see the file COPYING.  If not, see\n *  \u003chttp://www.gnu.org/licenses/\u003e.\n *\n */\n\n#include \"DirectoryNodeAlbumCompilations.h\"\n#include \"QueryParams.h\"\n#include \"music/MusicDatabase.h\"\n\nusing namespace XFILE::MUSICDATABASEDIRECTORY;\n\nCDirectoryNodeAlbumCompilations::CDirectoryNodeAlbumCompilations(const std::string\u0026 strName, CDirectoryNode* pParent)\n  : CDirectoryNode(NODE_TYPE_ALBUM_COMPILATIONS, strName, pParent)\n{\n\n}\n\nNODE_TYPE CDirectoryNodeAlbumCompilations::GetChildType() const\n{\n  if (GetName()==\"-1\")\n    return NODE_TYPE_ALBUM_COMPILATIONS_SONGS;\n\n  return NODE_TYPE_SONG;\n}\n\nstd::string CDirectoryNodeAlbumCompilations::GetLocalizedName() const\n{\n  if (GetID() == -1)\n    return g_localizeStrings.Get(15102); // All Albums\n  CMusicDatabase db;\n  if (db.Open())\n    return db.GetAlbumById(GetID());\n  return \"\";\n}\n\nbool CDirectoryNodeAlbumCompilations::GetContent(CFileItemList\u0026 items) const\n{\n  CMusicDatabase musicdatabase;\n  if (!musicdatabase.Open())\n    return false;\n\n  CQueryParams params;\n  CollectQueryParams(params);\n\n  bool bSuccess=musicdatabase.GetCompilationAlbums(BuildPath(), items);\n\n  musicdatabase.Close();\n\n  return bSuccess;\n}\n"}
{"repo_name":"dominik-th/xbmc","ref":"refs/heads/master","path":"xbmc/ApplicationPlayer.cpp","copies":"17","language":"C++","content":"/*\n *      Copyright (C) 2005-2013 Team XBMC\n *      http://xbmc.org\n *\n *  This Program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  This Program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with XBMC; see the file COPYING.  If not, see\n *  \u003chttp://www.gnu.org/licenses/\u003e.\n *\n */\n\n#include \"ApplicationPlayer.h\"\n#include \"cores/IPlayer.h\"\n#include \"Application.h\"\n#include \"settings/MediaSettings.h\"\n\nCApplicationPlayer::CApplicationPlayer()\n{\n  m_iPlayerOPSeq = 0;\n  m_eCurrentPlayer = EPC_NONE;\n}\n\nstd::shared_ptr\u003cIPlayer\u003e CApplicationPlayer::GetInternal() const\n{\n  CSingleLock lock(m_player_lock);\n  return m_pPlayer;\n}\n\nvoid CApplicationPlayer::ClosePlayer()\n{\n  std::shared_ptr\u003cIPlayer\u003e player = GetInternal();\n  if (player)\n  {\n    CloseFile();\n    // we need to do this directly on the member\n    CSingleLock lock(m_player_lock);\n    m_pPlayer.reset();\n  }\n}\n\nvoid CApplicationPlayer::CloseFile(bool reopen)\n{\n  std::shared_ptr\u003cIPlayer\u003e player = GetInternal();\n  if (player)\n  {\n    ++m_iPlayerOPSeq;\n    player-\u003eCloseFile(reopen);\n  }\n}\n\nvoid CApplicationPlayer::ClosePlayerGapless(PLAYERCOREID newCore)\n{\n  std::shared_ptr\u003cIPlayer\u003e player = GetInternal();\n  if (!player)\n    return;\n\n  bool gaplessSupported = (m_eCurrentPlayer == EPC_DVDPLAYER || m_eCurrentPlayer == EPC_PAPLAYER);\n  gaplessSupported = gaplessSupported \u0026\u0026 (m_eCurrentPlayer == newCore);\n  if (!gaplessSupported)\n  {\n    ClosePlayer();\n  }\n  else\n  {\n    // XXX: we had to stop the previous playing item, it was done in dvdplayer::OpenFile.\n    // but in paplayer::OpenFile, it sometimes just fade in without call CloseFile.\n    // but if we do not stop it, we can not distingush callbacks from previous\n    // item and current item, it will confused us then we can not make correct delay\n    // callback after the starting state.\n    CloseFile(true);\n  }\n}\n\nvoid CApplicationPlayer::CreatePlayer(PLAYERCOREID newCore, IPlayerCallback\u0026 callback)\n{\n  CSingleLock lock(m_player_lock);\n  if (!m_pPlayer)\n  {\n    m_eCurrentPlayer = newCore;\n    m_pPlayer.reset(CPlayerCoreFactory::Get().CreatePlayer(newCore, callback));\n  }\n}\n\nPlayBackRet CApplicationPlayer::OpenFile(const CFileItem\u0026 item, const CPlayerOptions\u0026 options)\n{\n  std::shared_ptr\u003cIPlayer\u003e player = GetInternal();\n  PlayBackRet iResult = PLAYBACK_FAIL;\n  if (player)\n  {\n    // op seq for detect cancel (CloseFile be called or OpenFile be called again) during OpenFile.\n    unsigned int startingSeq = ++m_iPlayerOPSeq;\n\n    iResult = player-\u003eOpenFile(item, options) ? PLAYBACK_OK : PLAYBACK_FAIL;\n    // check whether the OpenFile was canceled by either CloseFile or another OpenFile.\n    if (m_iPlayerOPSeq != startingSeq)\n      iResult = PLAYBACK_CANCELED;\n  }\n  return iResult;\n}\n\nbool CApplicationPlayer::HasPlayer() const \n{ \n  std::shared_ptr\u003cIPlayer\u003e player = GetInternal();\n  return player != NULL; \n}\n\nint CApplicationPlayer::GetChapter()\n{\n  std::shared_ptr\u003cIPlayer\u003e player = GetInternal();\n  if (player)\n    return player-\u003eGetChapter();\n  else \n    return -1;\n}\n\nint CApplicationPlayer::GetChapterCount()\n{\n  std::shared_ptr\u003cIPlayer\u003e player = GetInternal();\n  if (player)\n    return player-\u003eGetChapterCount();\n  else \n    return 0;\n}\n\nvoid CApplicationPlayer::GetChapterName(std::string\u0026 strChapterName,\n                                        int chapterIdx)\n{\n  std::shared_ptr\u003cIPlayer\u003e player = GetInternal();\n  if (player)\n    player-\u003eGetChapterName(strChapterName, chapterIdx);\n}\n\nint64_t CApplicationPlayer::GetChapterPos(int chapterIdx)\n{\n  std::shared_ptr\u003cIPlayer\u003e player = GetInternal();\n  if (player)\n    return player-\u003eGetChapterPos(chapterIdx);\n\n  return -1;\n}\n\nbool CApplicationPlayer::HasAudio() const\n{\n  std::shared_ptr\u003cIPlayer\u003e player = GetInternal();\n  return (player \u0026\u0026 player-\u003eHasAudio());\n}\n\nbool CApplicationPlayer::HasVideo() const\n{\n  std::shared_ptr\u003cIPlayer\u003e player = GetInternal();\n  return (player \u0026\u0026 player-\u003eHasVideo());\n}\n\nint CApplicationPlayer::GetPreferredPlaylist() const\n{\n  if (IsPlayingVideo())\n    return PLAYLIST_VIDEO;\n\n  if (IsPlayingAudio())\n    return PLAYLIST_MUSIC;\n\n  return PLAYLIST_NONE;\n}\n\nbool CApplicationPlayer::IsPaused() const\n{\n  std::shared_ptr\u003cIPlayer\u003e player = GetInternal();\n  return (player \u0026\u0026 player-\u003eIsPaused());\n}\n\nbool CApplicationPlayer::IsPlaying() const\n{\n  std::shared_ptr\u003cIPlayer\u003e player = GetInternal();\n  return (player \u0026\u0026 player-\u003eIsPlaying());\n}\n\nbool CApplicationPlayer::IsPausedPlayback() const\n{\n  return (IsPlaying() \u0026\u0026 IsPaused());\n}\n\nbool CApplicationPlayer::IsPlayingAudio() const\n{\n  return (IsPlaying() \u0026\u0026 !HasVideo() \u0026\u0026 HasAudio());\n}\n\nbool CApplicationPlayer::IsPlayingVideo() const\n{\n  return (IsPlaying() \u0026\u0026 HasVideo());\n}\n\nvoid CApplicationPlayer::Pause()\n{\n  std::shared_ptr\u003cIPlayer\u003e player = GetInternal();\n  if (player)\n    player-\u003ePause();\n}\n\nbool CApplicationPlayer::ControlsVolume() const\n{\n  std::shared_ptr\u003cIPlayer\u003e player = GetInternal();\n  return (player \u0026\u0026 player-\u003eControlsVolume());\n}\n\nvoid CApplicationPlayer::SetMute(bool bOnOff)\n{\n  std::shared_ptr\u003cIPlayer\u003e player = GetInternal();\n  if (player)\n    player-\u003eSetMute(bOnOff);\n}\n\nvoid CApplicationPlayer::SetVolume(float volume)\n{\n  std::shared_ptr\u003cIPlayer\u003e player = GetInternal();\n  if (player)\n    player-\u003eSetVolume(volume);\n}\n\nvoid CApplicationPlayer::Seek(bool bPlus, bool bLargeStep, bool bChapterOverride)\n{\n  std::shared_ptr\u003cIPlayer\u003e player = GetInternal();\n  if (player)\n    player-\u003eSeek(bPlus, bLargeStep, bChapterOverride);\n}\n\nvoid CApplicationPlayer::SeekPercentage(float fPercent)\n{\n  std::shared_ptr\u003cIPlayer\u003e player = GetInternal();\n  if (player)\n    player-\u003eSeekPercentage(fPercent);\n}\n\nbool CApplicationPlayer::IsPassthrough() const\n{\n  std::shared_ptr\u003cIPlayer\u003e player = GetInternal();\n  return (player \u0026\u0026 player-\u003eIsPassthrough());\n}\n\nbool CApplicationPlayer::CanSeek()\n{\n  std::shared_ptr\u003cIPlayer\u003e player = GetInternal();\n  return (player \u0026\u0026 player-\u003eCanSeek());\n}\n\nbool CApplicationPlayer::SeekScene(bool bPlus)\n{\n  std::shared_ptr\u003cIPlayer\u003e player = GetInternal();\n  return (player \u0026\u0026 player-\u003eSeekScene(bPlus));\n}\n\nvoid CApplicationPlayer::SeekTime(int64_t iTime)\n{\n  std::shared_ptr\u003cIPlayer\u003e player = GetInternal();\n  if (player)\n    player-\u003eSeekTime(iTime);\n}\n\nvoid CApplicationPlayer::SeekTimeRelative(int64_t iTime)\n{\n  std::shared_ptr\u003cIPlayer\u003e player = GetInternal();\n  if (player)\n  {\n    // use relative seeking if implemented by player\n    if (!player-\u003eSeekTimeRelative(iTime))\n    {\n      int64_t abstime = player-\u003eGetTime() + iTime;\n      player-\u003eSeekTime(abstime);\n    }\n  }\n}\n\nstd::string CApplicationPlayer::GetPlayingTitle()\n{\n  std::shared_ptr\u003cIPlayer\u003e player = GetInternal();\n  if (player)\n    return player-\u003eGetPlayingTitle();\n  else\n    return \"\";\n}\n\nint64_t CApplicationPlayer::GetTime() const\n{\n  std::shared_ptr\u003cIPlayer\u003e player = GetInternal();\n  if (player)\n    return player-\u003eGetTime();\n  else\n    return 0;\n}\n\nint64_t CApplicationPlayer::GetDisplayTime() const\n{\n  std::shared_ptr\u003cIPlayer\u003e player = GetInternal();\n  if (player)\n    return player-\u003eGetDisplayTime();\n  else\n    return 0;\n}\n\nbool CApplicationPlayer::IsCaching() const\n{\n  std::shared_ptr\u003cIPlayer\u003e player = GetInternal();\n  return (player \u0026\u0026 player-\u003eIsCaching());\n}\n\nbool CApplicationPlayer::IsInMenu() const\n{\n  std::shared_ptr\u003cIPlayer\u003e player = GetInternal();\n  return (player \u0026\u0026 player-\u003eIsInMenu());\n}\n\nbool CApplicationPlayer::HasMenu() const\n{\n  std::shared_ptr\u003cIPlayer\u003e player = GetInternal();\n  return (player \u0026\u0026 player-\u003eHasMenu());\n}\n\nint CApplicationPlayer::GetCacheLevel() const\n{\n  std::shared_ptr\u003cIPlayer\u003e player = GetInternal();\n  if (player)\n    return player-\u003eGetCacheLevel();\n  else\n    return 0;\n}\n\nint CApplicationPlayer::GetSubtitleCount()\n{\n  std::shared_ptr\u003cIPlayer\u003e player = GetInternal();\n  if (player)\n    return player-\u003eGetSubtitleCount();\n  else\n    return 0;\n}\n\nint CApplicationPlayer::GetAudioStream()\n{\n  if (!m_audioStreamUpdate.IsTimePast())\n    return m_iAudioStream;\n\n  std::shared_ptr\u003cIPlayer\u003e player = GetInternal();\n  if (player)\n  {\n    m_iAudioStream = player-\u003eGetAudioStream();\n    m_audioStreamUpdate.Set(1000);\n    return m_iAudioStream;\n  }\n  else\n    return 0;\n}\n\nint CApplicationPlayer::GetSubtitle()\n{\n  if (!m_subtitleStreamUpdate.IsTimePast())\n    return m_iSubtitleStream;\n\n  std::shared_ptr\u003cIPlayer\u003e player = GetInternal();\n  if (player)\n  {\n    m_iSubtitleStream = player-\u003eGetSubtitle();\n    m_subtitleStreamUpdate.Set(1000);\n    return m_iSubtitleStream;\n  }\n  else\n    return 0;\n}\n\nbool CApplicationPlayer::GetSubtitleVisible()\n{\n  std::shared_ptr\u003cIPlayer\u003e player = GetInternal();\n  return (player \u0026\u0026 player-\u003eGetSubtitleVisible());\n}\n\nbool CApplicationPlayer::CanRecord()\n{\n  std::shared_ptr\u003cIPlayer\u003e player = GetInternal();\n  return (player \u0026\u0026 player-\u003eCanRecord());\n}\n\nbool CApplicationPlayer::CanPause()\n{\n  std::shared_ptr\u003cIPlayer\u003e player = GetInternal();\n  return (player \u0026\u0026 player-\u003eCanPause());\n}\n\nbool CApplicationPlayer::IsRecording() const\n{\n  std::shared_ptr\u003cIPlayer\u003e player = GetInternal();\n  return (player \u0026\u0026 player-\u003eIsRecording());\n}\n\nTextCacheStruct_t* CApplicationPlayer::GetTeletextCache()\n{\n  std::shared_ptr\u003cIPlayer\u003e player = GetInternal();\n  if (player)\n    return player-\u003eGetTeletextCache();\n  else\n    return NULL;\n}\n\nint64_t CApplicationPlayer::GetTotalTime() const\n{\n  std::shared_ptr\u003cIPlayer\u003e player = GetInternal();\n  if (player)\n    return player-\u003eGetTotalTime();\n  else\n    return 0;\n}\n\nfloat CApplicationPlayer::GetPercentage() const\n{\n  std::shared_ptr\u003cIPlayer\u003e player = GetInternal();\n  if (player)\n    return player-\u003eGetPercentage();\n  else\n    return 0.0;\n}\n\nfloat CApplicationPlayer::GetCachePercentage() const\n{\n  std::shared_ptr\u003cIPlayer\u003e player = GetInternal();\n  if (player)\n    return player-\u003eGetCachePercentage();\n  else\n    return 0.0;\n}\n\nvoid CApplicationPlayer::ToFFRW(int iSpeed)\n{\n  std::shared_ptr\u003cIPlayer\u003e player = GetInternal();\n  if (player)\n    player-\u003eToFFRW(iSpeed);\n}\n\nvoid CApplicationPlayer::DoAudioWork()\n{\n  std::shared_ptr\u003cIPlayer\u003e player = GetInternal();\n  if (player)\n    player-\u003eDoAudioWork();\n}\n\nstd::string CApplicationPlayer::GetPlayerState()\n{\n  std::shared_ptr\u003cIPlayer\u003e player = GetInternal();\n  if (player)\n    return player-\u003eGetPlayerState();\n  else\n    return \"\";\n}\n\nbool CApplicationPlayer::QueueNextFile(const CFileItem \u0026file)\n{\n  std::shared_ptr\u003cIPlayer\u003e player = GetInternal();\n  return (player \u0026\u0026 player-\u003eQueueNextFile(file));\n}\n\nbool CApplicationPlayer::GetStreamDetails(CStreamDetails \u0026details)\n{\n  std::shared_ptr\u003cIPlayer\u003e player = GetInternal();\n  return (player \u0026\u0026 player-\u003eGetStreamDetails(details));\n}\n\nbool CApplicationPlayer::SetPlayerState(const std::string\u0026 state)\n{\n  std::shared_ptr\u003cIPlayer\u003e player = GetInternal();\n  return (player \u0026\u0026 player-\u003eSetPlayerState(state));\n}\n\nvoid CApplicationPlayer::OnNothingToQueueNotify()\n{\n  std::shared_ptr\u003cIPlayer\u003e player = GetInternal();\n  if (player)\n    player-\u003eOnNothingToQueueNotify();\n}\n\nvoid CApplicationPlayer::GetVideoStreamInfo(SPlayerVideoStreamInfo \u0026info)\n{\n  std::shared_ptr\u003cIPlayer\u003e player = GetInternal();\n  if (player)\n    player-\u003eGetVideoStreamInfo(info);\n}\n\nvoid CApplicationPlayer::GetAudioStreamInfo(int index, SPlayerAudioStreamInfo \u0026info)\n{\n  std::shared_ptr\u003cIPlayer\u003e player = GetInternal();\n  if (player)\n    player-\u003eGetAudioStreamInfo(index, info);\n}\n\nbool CApplicationPlayer::OnAction(const CAction \u0026action)\n{\n  std::shared_ptr\u003cIPlayer\u003e player = GetInternal();\n  return (player \u0026\u0026 player-\u003eOnAction(action));\n}\n\nbool CApplicationPlayer::Record(bool bOnOff)\n{\n  std::shared_ptr\u003cIPlayer\u003e player = GetInternal();\n  return (player \u0026\u0026 player-\u003eRecord(bOnOff));\n}\n\nint  CApplicationPlayer::GetAudioStreamCount()\n{\n  std::shared_ptr\u003cIPlayer\u003e player = GetInternal();\n  if (player)\n    return player-\u003eGetAudioStreamCount();\n  else\n    return 0;\n}\n\nvoid CApplicationPlayer::SetAudioStream(int iStream)\n{\n  std::shared_ptr\u003cIPlayer\u003e player = GetInternal();\n  if (player)\n  {\n    player-\u003eSetAudioStream(iStream);\n    m_iAudioStream = iStream;\n    m_audioStreamUpdate.Set(1000);\n    CMediaSettings::Get().GetCurrentVideoSettings().m_AudioStream = iStream;\n  }\n}\n\nvoid CApplicationPlayer::GetSubtitleStreamInfo(int index, SPlayerSubtitleStreamInfo \u0026info)\n{\n  std::shared_ptr\u003cIPlayer\u003e player = GetInternal();\n  if (player)\n    player-\u003eGetSubtitleStreamInfo(index, info);\n}\n\nvoid CApplicationPlayer::SetSubtitle(int iStream)\n{\n  std::shared_ptr\u003cIPlayer\u003e player = GetInternal();\n  if (player)\n  {\n    player-\u003eSetSubtitle(iStream);\n    m_iSubtitleStream = iStream;\n    m_subtitleStreamUpdate.Set(1000);\n    CMediaSettings::Get().GetCurrentVideoSettings().m_SubtitleStream = iStream;\n  }\n}\n\nvoid CApplicationPlayer::SetSubtitleVisible(bool bVisible)\n{\n  std::shared_ptr\u003cIPlayer\u003e player = GetInternal();\n  if (player)\n  {\n    player-\u003eSetSubtitleVisible(bVisible);\n    CMediaSettings::Get().GetCurrentVideoSettings().m_SubtitleOn = bVisible;\n    CMediaSettings::Get().GetCurrentVideoSettings().m_SubtitleStream = player-\u003eGetSubtitle();\n  }\n}\n\nvoid CApplicationPlayer::AddSubtitle(const std::string\u0026 strSubPath)\n{\n  std::shared_ptr\u003cIPlayer\u003e player = GetInternal();\n  if (player)\n    player-\u003eAddSubtitle(strSubPath);\n}\n\nvoid CApplicationPlayer::SetSubTitleDelay(float fValue)\n{\n  std::shared_ptr\u003cIPlayer\u003e player = GetInternal();\n  if (player)\n    player-\u003eSetSubTitleDelay(fValue);\n}\n\nvoid CApplicationPlayer::SetAVDelay(float fValue)\n{\n  std::shared_ptr\u003cIPlayer\u003e player = GetInternal();\n  if (player)\n    player-\u003eSetAVDelay(fValue);\n}\n\nvoid CApplicationPlayer::SetDynamicRangeCompression(long drc)\n{\n  std::shared_ptr\u003cIPlayer\u003e player = GetInternal();\n  if (player)\n    player-\u003eSetDynamicRangeCompression(drc);\n}\n\nbool CApplicationPlayer::SwitchChannel(const PVR::CPVRChannelPtr \u0026channel)\n{\n  std::shared_ptr\u003cIPlayer\u003e player = GetInternal();\n  return (player \u0026\u0026 player-\u003eSwitchChannel(channel));\n}\n\nvoid CApplicationPlayer::LoadPage(int p, int sp, unsigned char* buffer)\n{\n  std::shared_ptr\u003cIPlayer\u003e player = GetInternal();\n  if (player)\n    player-\u003eLoadPage(p, sp, buffer);\n}\n\nvoid CApplicationPlayer::GetAudioCapabilities(std::vector\u003cint\u003e \u0026audioCaps)\n{\n  std::shared_ptr\u003cIPlayer\u003e player = GetInternal();\n  if (player)\n    player-\u003eGetAudioCapabilities(audioCaps);\n}\n\nvoid CApplicationPlayer::GetSubtitleCapabilities(std::vector\u003cint\u003e \u0026subCaps)\n{\n  std::shared_ptr\u003cIPlayer\u003e player = GetInternal();\n  if (player)\n    player-\u003eGetSubtitleCapabilities(subCaps);\n}\n\nvoid CApplicationPlayer::GetAudioInfo(std::string\u0026 strAudioInfo)\n{\n  std::shared_ptr\u003cIPlayer\u003e player = GetInternal();\n  if (player)\n    player-\u003eGetAudioInfo(strAudioInfo);\n}\n\nvoid CApplicationPlayer::GetVideoInfo(std::string\u0026 strVideoInfo)\n{\n  std::shared_ptr\u003cIPlayer\u003e player = GetInternal();\n  if (player)\n    player-\u003eGetVideoInfo(strVideoInfo);\n}\n\nvoid CApplicationPlayer::GetGeneralInfo(std::string\u0026 strVideoInfo)\n{\n  std::shared_ptr\u003cIPlayer\u003e player = GetInternal();\n  if (player)\n    player-\u003eGetGeneralInfo(strVideoInfo);\n}\n\nint  CApplicationPlayer::SeekChapter(int iChapter)\n{\n  std::shared_ptr\u003cIPlayer\u003e player = GetInternal();\n  if (player)\n    return player-\u003eSeekChapter(iChapter);\n  else\n    return 0;\n}\n\nvoid CApplicationPlayer::GetRenderFeatures(std::vector\u003cint\u003e \u0026renderFeatures)\n{\n  std::shared_ptr\u003cIPlayer\u003e player = GetInternal();\n  if (player)\n    player-\u003eOMXGetRenderFeatures(renderFeatures);\n}\n\nvoid CApplicationPlayer::GetDeinterlaceMethods(std::vector\u003cint\u003e \u0026deinterlaceMethods)\n{\n  std::shared_ptr\u003cIPlayer\u003e player = GetInternal();\n  if (player)\n    player-\u003eOMXGetDeinterlaceMethods(deinterlaceMethods);\n}\n\nvoid CApplicationPlayer::GetDeinterlaceModes(std::vector\u003cint\u003e \u0026deinterlaceModes)\n{\n  std::shared_ptr\u003cIPlayer\u003e player = GetInternal();\n  if (player)\n    player-\u003eOMXGetDeinterlaceModes(deinterlaceModes);\n}\n\nvoid CApplicationPlayer::GetScalingMethods(std::vector\u003cint\u003e \u0026scalingMethods)\n{\n  std::shared_ptr\u003cIPlayer\u003e player = GetInternal();\n  if (player)\n    player-\u003eOMXGetScalingMethods(scalingMethods);\n}\n\nvoid CApplicationPlayer::SetPlaySpeed(int iSpeed, bool bApplicationMuted)\n{\n  std::shared_ptr\u003cIPlayer\u003e player = GetInternal();\n  if (!player)\n    return;\n\n  if (!IsPlayingAudio() \u0026\u0026 !IsPlayingVideo())\n    return ;\n  if (m_iPlaySpeed == iSpeed)\n    return ;\n  if (!CanSeek())\n    return;\n  if (IsPaused())\n  {\n    if (\n      ((m_iPlaySpeed \u003e 1) \u0026\u0026 (iSpeed \u003e m_iPlaySpeed)) ||\n      ((m_iPlaySpeed \u003c -1) \u0026\u0026 (iSpeed \u003c m_iPlaySpeed))\n    )\n    {\n      iSpeed = m_iPlaySpeed; // from pause to ff/rw, do previous ff/rw speed\n    }\n    Pause();\n  }\n  m_iPlaySpeed = iSpeed;\n\n  ToFFRW(m_iPlaySpeed);\n\n  // if player has volume control, set it.\n  if (ControlsVolume())\n  {\n    if (m_iPlaySpeed == 1)\n    { // restore volume\n      player-\u003eSetVolume(g_application.GetVolume(false));\n    }\n    else\n    { // mute volume\n      player-\u003eSetVolume(VOLUME_MINIMUM);\n    }\n    player-\u003eSetMute(bApplicationMuted);\n  }\n}\n\nint CApplicationPlayer::GetPlaySpeed() const\n{\n  return m_iPlaySpeed;\n}\n"}
{"repo_name":"osgcc/ryzom","ref":"refs/heads/master","path":"ryzom/tools/leveldesign/georges_dll/form_dialog.cpp","copies":"3","language":"C++","content":"// Ryzom - MMORPG Framework \u003chttp://dev.ryzom.com/projects/ryzom/\u003e\n// Copyright (C) 2010  Winch Gate Property Limited\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as\n// published by the Free Software Foundation, either version 3 of the\n// License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see \u003chttp://www.gnu.org/licenses/\u003e.\n\n// form_dialog.cpp : implementation file\n//\n\n#include \"stdafx.h\"\n#include \"georges_edit.h\"\n#include \"georges_edit_view.h\"\n#include \"georges_edit_doc.h\"\n#include \"form_dialog.h\"\n#include \"action.h\"\n#include \"left_view.h\"\n\n#include \"nel/misc/path.h\"\n#include \"nel/georges/type.h\"\n#include \"nel/georges/form_elm.h\"\n\nusing namespace std;\nusing namespace NLMISC;\nusing namespace NLGEORGES;\n\n\n// Define this to show Formula value evaluation intstead of value evaluation\n// #define TEST_EVAL_FORMULA\n\n// ***************************************************************************\n// CFormDialog dialog\n// ***************************************************************************\n\nCFormDialog::CFormDialog () : CBaseDialog (IDR_MAINFRAME)\n{\n\t//{{AFX_DATA_INIT(CFormDialog)\n\t\t// NOTE: the ClassWizard will add member initialization here\n\t//}}AFX_DATA_INIT\n\tView = NULL;\n\tWidgetIndexCount = 0;\n\tWidgetFocused = 0xffffffff;\n}\n\n// ***************************************************************************\n\nCFormDialog::~CFormDialog ()\n{\n\tclear ();\n}\n\n// ***************************************************************************\n\nvoid CFormDialog::clear ()\n{\n\tunRegisterLastControl ();\n\tfor (uint i=0; i\u003cWidgets.size (); i++)\n\t\tdelete Widgets[i];\n\tWidgets.clear ();\n\tWidgetFocused = 0xffffffff;\n\tWidgetIndexCount = 0;\n}\n\n// ***************************************************************************\n\nvoid CFormDialog::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialog::DoDataExchange(pDX);\n\t//{{AFX_DATA_MAP(CFormDialog)\n\t\t// NOTE: the ClassWizard will add DDX and DDV calls here\n\t//}}AFX_DATA_MAP\n}\n\n// ***************************************************************************\n\nBEGIN_MESSAGE_MAP(CFormDialog, CDialog)\n\t//{{AFX_MSG_MAP(CFormDialog)\n\tON_WM_SIZE()\n\tON_WM_LBUTTONDOWN()\n\tON_WM_SETFOCUS()\n\tON_WM_KILLFOCUS()\n\t//}}AFX_MSG_MAP\nEND_MESSAGE_MAP()\n\n// ***************************************************************************\n// CFormDialog message handlers\n\n// ***************************************************************************\n\nvoid CFormDialog::OnSize(UINT nType, int cx, int cy) \n{\n\tCBaseDialog::OnSize(nType, cx, cy);\n\t\n\t// TODO: Add your message handler code here\n\t\n}\n\n// ***************************************************************************\n\nBOOL CFormDialog::OnInitDialog() \n{\n\tCBaseDialog::OnInitDialog();\n\n\tSetDefID ( 0xffffffff );\n\n\tUpdateData (FALSE);\n\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t              // EXCEPTION: OCX Property Pages should return FALSE\n}\n\n// ***************************************************************************\n\nvoid CFormDialog::OnOK ()\n{\n\tfor (uint i=0; i\u003cWidgets.size(); i++)\n\t{\n\t\tWidgets[i]-\u003eupdateData ();\n\t\tif (Widgets[i]-\u003ehaveFocus ())\n\t\t{\n\t\t\tWidgets[i]-\u003eonOk ();\n\t\t}\n\t}\n}\n\n// ***************************************************************************\n\nvoid CFormDialog::OnCancel ()\n{\n\tfor (uint i=0; i\u003cWidgets.size(); i++)\n\t{\n\t\tWidgets[i]-\u003eupdateData ();\n\t\tif (Widgets[i]-\u003ehaveFocus ())\n\t\t{\n\t\t\tWidgets[i]-\u003eonCancel ();\n\t\t\treturn;\n\t\t}\n\t}\n\tCBaseDialog::OnCancel ();\n}\n\n// ***************************************************************************\n\nCWnd* CFormDialog::addTypeWidget (const NLGEORGES::CType \u0026type, uint elmIndex, const char *title, const char *atomName, const char *typeFilename, RECT \u0026currentPos, CForm \u0026form, IFormWidget::TTypeSrc typeWidget, const char *filenameExt, uint slot)\n{\n\t// What kind of UI ?\n\tswitch (type.UIType)\n\t{\n\tcase CType::FileBrowser:\n\tcase CType::Edit:\n\tcase CType::EditSpin:\n\t\t{\n\t\t\t// For edit type, use a memory combobox\n\t\t\tCFormMemCombo *memCombo = new CFormMemCombo (this, elmIndex, atomName, typeWidget, slot);\n\t\t\tWidgets.push_back (memCombo);\n\n\t\t\t// Create a reg key\n\t\t\tstring tfn = typeFilename;\n\t\t\tstring key = GEORGES_EDIT_BASE_REG_KEY\"\\\\\"+strlwr (typeFilename)+\" MemCombo\";\n\n\t\t\t// Create the widget\n\t\t\tmemCombo-\u003ecreate (WS_CHILD|WS_TABSTOP, currentPos, this, WidgetIndexCount, title, key.c_str(), type.UIType==CType::EditSpin, type.UIType==CType::FileBrowser, filenameExt);\n\n\t\t\t// Get from document\n\t\t\tmemCombo-\u003egetFromDocument (form);\n\n\t\t\treturn \u0026memCombo-\u003eCombo;\n\t\t}\n\t\tbreak;\n\tcase CType::NonEditableCombo:\n\t\t{\n\t\t\t// For edit type, use a memory combobox\n\t\t\tCFormCombo *memCombo = new CFormCombo (this, elmIndex, atomName, typeWidget, slot);\n\t\t\tWidgets.push_back (memCombo);\n\n\t\t\t// Create the widget\n\t\t\tmemCombo-\u003ecreate (WS_CHILD|WS_TABSTOP, currentPos, this, WidgetIndexCount, title);\n\n\t\t\t// Get from document\n\t\t\tmemCombo-\u003egetFromDocument (form);\n\n\t\t\treturn \u0026memCombo-\u003eCombo;\n\t\t}\n\t\tbreak;\n\tcase CType::BigEdit:\n\t\t{\n\t\t\t// For edit type, use a memory combobox\n\t\t\tCFormBigEdit *memCombo = new CFormBigEdit (this, elmIndex, atomName, typeWidget, slot);\n\t\t\tWidgets.push_back (memCombo);\n\n\t\t\t// Create the widget\n\t\t\tmemCombo-\u003ecreate (WS_CHILD|WS_TABSTOP, currentPos, this, WidgetIndexCount, title);\n\n\t\t\t// Get from document\n\t\t\tmemCombo-\u003egetFromDocument (form);\n\n\t\t\treturn \u0026memCombo-\u003eEdit;\n\t\t}\n\t\tbreak;\n\tcase CType::ColorEdit:\n\t\t{\n\t\t\t// For edit type, use a memory combobox\n\t\t\tCColorEdit *memCombo = new CColorEdit (this, elmIndex, atomName, typeWidget, slot);\n\t\t\tWidgets.push_back (memCombo);\n\n\t\t\t// Create the widget\n\t\t\tmemCombo-\u003ecreate (WS_CHILD|WS_TABSTOP, currentPos, this, WidgetIndexCount, title);\n\n\t\t\t// Get from document\n\t\t\tmemCombo-\u003egetFromDocument (form);\n\n\t\t\treturn \u0026memCombo-\u003eColor;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn NULL;\n}\n\n// ***************************************************************************\n\nvoid CFormDialog::getVirtualDfnFromDocument (const NLGEORGES::CFormDfn *_dfn, const char *structName, uint slot)\n{\n\tif (View)\n\t{\n\t\tCGeorgesEditDoc *doc = View-\u003eGetDocument ();\n\t\tif (doc)\n\t\t{\n\t\t\t// Clear the current dialog\n\t\t\tclear ();\n\n\t\t\t// Reserve some widget pointers\n\t\t\tWidgets.reserve (10);\n\n\t\t\t// Widget placement\n\t\t\tRECT currentPos;\n\t\t\tgetFirstItemPos (currentPos);\n\n\t\t\t// For edit type, use a memory combobox\n\t\t\tCFormMemCombo *memCombo = new CFormMemCombo (this, 0xffffffff, structName, IFormWidget::TypeVirtualDfn, slot);\n\t\t\tWidgets.push_back (memCombo);\n\n\t\t\t// Create the widget\n\t\t\tmemCombo-\u003ecreate (WS_CHILD|WS_TABSTOP, currentPos, this, WidgetIndexCount, \"Dfn:\", \n\t\t\t\tGEORGES_EDIT_BASE_REG_KEY\"\\\\Virtual Dfn MemCombo\", false, true, \"*.dfn\");\n\n\t\t\t// Get from document\n\t\t\tmemCombo-\u003egetFromDocument (*doc-\u003egetFormPtr ());\n\n\t\t\t// Dfn selected ?\n\t\t\tif (_dfn)\n\t\t\t{\n\t\t\t\t// Get the parent DFN\n\t\t\t\tstd::vector\u003cconst CFormDfn*\u003e arrayDfn;\n\t\t\t\tarrayDfn.reserve (_dfn-\u003ecountParentDfn ());\n\t\t\t\t_dfn-\u003egetParentDfn (arrayDfn);\n\n\t\t\t\t// Element index\n\t\t\t\tuint elmIndex = 0;\n\n\t\t\t\t// For each DFN\n\t\t\t\tfor (uint dfnIndex=0; dfnIndex\u003carrayDfn.size (); dfnIndex++)\n\t\t\t\t{\n\t\t\t\t\t// Form must be editable only if all DFN and TYPE have been found\n\t\t\t\t\tnlassert (arrayDfn[dfnIndex]);\n\n\t\t\t\t\t// Ref on the DFN\n\t\t\t\t\tconst CFormDfn \u0026dfn = *arrayDfn[dfnIndex];\n\n\t\t\t\t\t// For each structure element\n\t\t\t\t\tfor (uint i=0; i\u003cdfn.getNumEntry (); i++)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Get a ref on the entry\n\t\t\t\t\t\tconst CFormDfn::CEntry \u0026entry = dfn.getEntry (i);\n\n\t\t\t\t\t\t// Is it an atom ?\n\t\t\t\t\t\tif (entry.getType () == UFormDfn::EntryType \u0026\u0026 !entry.getArrayFlag ())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Some string\n\t\t\t\t\t\t\tstring title = entry.getName() + \":\";\n\t\t\t\t\t\t\tstring atomName = string (structName)+\".\"+entry.getName();\n\t\t\t\t\t\t\taddTypeWidget (*entry.getTypePtr(), elmIndex, title.c_str (), atomName.c_str(), \n\t\t\t\t\t\t\t\t\t\t\tentry.getFilename ().c_str (), currentPos, *doc-\u003egetFormPtr (), IFormWidget::TypeForm,\n\t\t\t\t\t\t\t\t\t\t\tentry.getFilenameExt ().c_str (), slot);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Next form index\n\t\t\t\t\t\telmIndex++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Register last control for tab selection\n\t\t\tregisterLastControl ();\n\t\t}\n\t}\n}\n\n// ***************************************************************************\nvoid CFormDialog::getDfnFromDocument (const NLGEORGES::CFormDfn \u0026_dfn, const char *structName, uint slot)\n{\n\tif (View)\n\t{\n\t\tCGeorgesEditDoc *doc = View-\u003eGetDocument ();\n\t\tif (doc)\n\t\t{\n\t\t\t// Clear the current dialog\n\t\t\tclear ();\n\n\t\t\t// Reserve some widget pointers\n\t\t\tWidgets.reserve (10);\n\n\t\t\t// Widget placement\n\t\t\tRECT currentPos;\n\t\t\tgetFirstItemPos (currentPos);\n\n\t\t\t// Get the parent DFN\n\t\t\tstd::vector\u003cconst CFormDfn*\u003e arrayDfn;\n\t\t\tarrayDfn.reserve (_dfn.countParentDfn ());\n\t\t\t_dfn.getParentDfn (arrayDfn);\n\n\t\t\t// For edit type, use a memory combobox\n\t\t\tif (strcmp (structName, \"\") == 0)\n\t\t\t{\n\t\t\t\tCListWidget *listWidget = new CListWidget (this, 0xffffffff, \"\", IFormWidget::TypeFormParent, slot);\n\t\t\t\tWidgets.push_back (listWidget);\n\n\t\t\t\t// Create the widget\n\t\t\t\tlistWidget-\u003ecreate (WS_CHILD|WS_TABSTOP, currentPos, this, WidgetIndexCount, \"Parent Form:\", \n\t\t\t\t\tGEORGES_EDIT_BASE_REG_KEY\"\\\\Parent Form MemCombo\", 1);\n\n\t\t\t\t// Add one column\n\t\t\t\tlistWidget-\u003eaddColumn (\"Parent filename\");\n\n\t\t\t\t// Get from document\n\t\t\t\tlistWidget-\u003egetFromDocument (*doc-\u003egetFormPtr ());\n\t\t\t}\n\n\t\t\t// store icon related infos\n\t\t\tCWnd *pWnd\t\t\t\t\t= NULL;\n\t\t\tCWnd *pWndIcon\t\t\t\t= NULL;\n\t\t\tCWnd *pWndIconColor\t\t\t= NULL;\n\t\t\tCWnd *pWndIconBack\t\t\t= NULL;\n\t\t\tCWnd *pWndIconBackColor\t\t= NULL;\n\t\t\tCWnd *pWndIconOver\t\t\t= NULL;\n\t\t\tCWnd *pWndIconOverColor\t\t= NULL;\n\t\t\tCWnd *pWndIconOver2\t\t\t= NULL;\n\t\t\tCWnd *pWndIconOver2Color\t= NULL;\n\n\t\t\t// Element index\n\t\t\tuint elmIndex = 0;\n\n\t\t\t// For each DFN\n\t\t\tfor (uint dfnIndex=0; dfnIndex\u003carrayDfn.size (); dfnIndex++)\n\t\t\t{\n\t\t\t\t// Form must be editable only if all DFN and TYPE have been found\n\t\t\t\tnlassert (arrayDfn[dfnIndex]);\n\n\t\t\t\t// Ref on the DFN\n\t\t\t\tconst CFormDfn \u0026dfn = *arrayDfn[dfnIndex];\n\n\t\t\t\t// For each structure element\n\t\t\t\tfor (uint i=0; i\u003cdfn.getNumEntry (); i++)\n\t\t\t\t{\n\t\t\t\t\t// Get a ref on the entry\n\t\t\t\t\tconst CFormDfn::CEntry \u0026entry = dfn.getEntry (i);\n\n\t\t\t\t\t// Is it an atom ?\n\t\t\t\t\tif (entry.getType () == UFormDfn::EntryType \u0026\u0026 !entry.getArrayFlag ())\n\t\t\t\t\t{\n\t\t\t\t\t\t// Some string\n\t\t\t\t\t\tstring title = entry.getName() + \":\";\n\t\t\t\t\t\tstring atomName = string (structName)+\".\"+entry.getName();\n\t\t\t\t\t\tpWnd = addTypeWidget (*entry.getTypePtr(), elmIndex, title.c_str (), atomName.c_str(), \n\t\t\t\t\t\t\t\t\t\t\t   entry.getFilename ().c_str (), currentPos, *doc-\u003egetFormPtr (), IFormWidget::TypeForm, \n\t\t\t\t\t\t\t\t\t\t\t   entry.getFilenameExt ().c_str (), slot);\n\n\t\t\t\t\t\tif (entry.getName() == \"Icon\" || entry.getName() == \"icon\")\n\t\t\t\t\t\t\tpWndIcon = pWnd;\n\t\t\t\t\t\telse if (entry.getName() == \"IconColor\")\n\t\t\t\t\t\t\tpWndIconColor = pWnd;\n\t\t\t\t\t\telse if (entry.getName() == \"IconBack\" || entry.getName() == \"icon background\")\n\t\t\t\t\t\t\tpWndIconBack = pWnd;\n\t\t\t\t\t\telse if (entry.getName() == \"IconBackColor\")\n\t\t\t\t\t\t\tpWndIconBackColor = pWnd;\n\t\t\t\t\t\telse if (entry.getName() == \"IconOver\" || entry.getName() == \"icon overlay\")\n\t\t\t\t\t\t\tpWndIconOver = pWnd;\n\t\t\t\t\t\telse if (entry.getName() == \"IconOverColor\")\n\t\t\t\t\t\t\tpWndIconOverColor = pWnd;\n\t\t\t\t\t\telse if (entry.getName() == \"IconOver2\" || entry.getName() == \"icon overlay2\")\n\t\t\t\t\t\t\tpWndIconOver2 = pWnd;\n\t\t\t\t\t\telse if (entry.getName() == \"IconOver2Color\")\n\t\t\t\t\t\t\tpWndIconOver2Color = pWnd;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Next form index\n\t\t\t\t\telmIndex++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Special case for \".Client\" and \".3d\" : add a widget to draw icons\n\t\t\tif ((string(structName) == \".Client\") || (string(structName) == \".3d\"))\n\t\t\t{\n\t\t\t\tstring title = \"Icon bitmap:\";\n\t\t\t\t\n\t\t\t\tCIconWidget *w = new CIconWidget (this, elmIndex, \"\", IFormWidget::TypeFormParent, slot);\n\t\t\t\tWidgets.push_back (w);\n\n\t\t\t\t// Create the widget\n\t\t\t\tw-\u003ecreate (WS_CHILD|WS_TABSTOP, currentPos, this, WidgetIndexCount, title.c_str());\n\n\t\t\t\t//\n\t\t\t\tw-\u003eIcon.pWndIcon\t\t\t= pWndIcon;\n\t\t\t\tw-\u003eIcon.pWndIconColor\t\t= pWndIconColor;\n\n\t\t\t\tw-\u003eIcon.pWndIconBack\t\t= pWndIconBack;\n\t\t\t\tw-\u003eIcon.pWndIconBackColor\t= pWndIconBackColor;\n\n\t\t\t\tw-\u003eIcon.pWndIconOver\t\t= pWndIconOver;\n\t\t\t\tw-\u003eIcon.pWndIconOverColor\t= pWndIconOverColor;\n\t\t\t\t\n\t\t\t\tw-\u003eIcon.pWndIconOver2\t\t= pWndIconOver2;\n\t\t\t\tw-\u003eIcon.pWndIconOver2Color\t= pWndIconOver2Color;\n\t\t\t}\n\n\t\t\t// Register last control for tab selection\n\t\t\tregisterLastControl ();\n\t\t}\n\t}\n}\n\n// ***************************************************************************\n\nvoid CFormDialog::getArrayFromDocument (const char *structName, uint structId, uint slot)\n{\n\tif (View)\n\t{\n\t\tCGeorgesEditDoc *doc = View-\u003eGetDocument ();\n\t\tif (doc)\n\t\t{\n\t\t\t// Clear the current dialog\n\t\t\tclear ();\n\n\t\t\t// Reserve some widget pointers\n\t\t\tWidgets.reserve (10);\n\n\t\t\t// Widget placement\n\t\t\tRECT currentPos;\n\t\t\tgetFirstItemPos (currentPos);\n\n\t\t\tCFormMemCombo *memCombo = new CFormMemCombo (this, structId, structName, IFormWidget::TypeArray, slot);\n\t\t\tWidgets.push_back (memCombo);\n\n\t\t\t// Create the widget\n\t\t\tmemCombo-\u003ecreate (WS_CHILD|WS_TABSTOP, currentPos, this, WidgetIndexCount, \"Array size:\", \n\t\t\t\tGEORGES_EDIT_BASE_REG_KEY\"\\\\Array Size MemCombo\", true, false, NULL);\n\n\t\t\t// Get from document\n\t\t\tmemCombo-\u003egetFromDocument (*doc-\u003egetFormPtr ());\n\n\t\t\t// Register last control for tab selection\n\t\t\tregisterLastControl ();\n\t\t}\n\t}\n}\n\n// ***************************************************************************\n\nvoid CFormDialog::getTypeFromDocument (const NLGEORGES::CType \u0026_type, const char *name, const char *typeFilename, const char *structName, uint slot)\n{\n\tif (View)\n\t{\n\t\tCGeorgesEditDoc *doc = View-\u003eGetDocument ();\n\t\tif (doc)\n\t\t{\n\t\t\t// Clear the current dialog\n\t\t\tclear ();\n\n\t\t\t// Reserve some widget pointers\n\t\t\tWidgets.reserve (10);\n\n\t\t\t// Widget placement\n\t\t\tRECT currentPos;\n\t\t\tgetFirstItemPos (currentPos);\n\n\t\t\t// Some string\n\t\t\taddTypeWidget (_type, 0xffffffff, name, structName, typeFilename, currentPos, *doc-\u003egetFormPtr (), IFormWidget::TypeType, NULL, slot);\n\n\t\t\t// Register last control for tab selection\n\t\t\tregisterLastControl ();\n\t\t}\n\t}\n}\n\n// ***************************************************************************\n\nvoid CFormDialog::updateLabels ()\n{\n\tfor (uint i=0; i\u003cWidgets.size (); i++)\n\t{\n\t\tWidgets[i]-\u003eupdateLabel ();\n\t}\n}\n\n// ***************************************************************************\n\nvoid CFormDialog::updateValues  ()\n{\n\tfor (uint i=0; i\u003cWidgets.size (); i++)\n\t{\n\t\tWidgets[i]-\u003eupdateLabel ();\n\t\tWidgets[i]-\u003egetFromDocument (*(View-\u003eGetDocument ()-\u003egetFormPtr ()));\n\t}\n}\n\n// ***************************************************************************\n\nvoid CFormDialog::setToDocument (uint widget)\n{\n\tCGeorgesEditDoc *doc = View-\u003eGetDocument ();\n\tif (doc)\n\t{\n\t\t// discard CIconWidget\n\t\tCIconWidget *iconWidget = dynamic_cast\u003cCIconWidget*\u003e (Widgets[widget]);\n\t\tif (iconWidget)\n\t\t\treturn;\n\n\t\t// Check if this command will build a new array / virtual dfn that was inherited..\n\t\tif (Widgets[widget]-\u003egetFormName () != \"NULL\")\n\t\t{\n\t\t\t// Get current node\n\t\t\tconst CFormDfn *parentDfn;\n\t\t\tuint indexDfn;\n\t\t\tconst CFormDfn *nodeDfn;\n\t\t\tconst CType *nodeType;\n\t\t\tCFormElm *node;\n\t\t\tUFormDfn::TEntryType type;\n\t\t\tbool array;\n\t\t\tbool parentVDfnArray;\n\t\t\tCForm *form=doc-\u003egetFormPtr ();\n\t\t\tCFormElm *elm = doc-\u003egetRootNode (Widgets[widget]-\u003egetSlot ());\n\t\t\tnlverify ( elm-\u003egetNodeByName (Widgets[widget]-\u003egetFormName ().c_str (), \u0026parentDfn, indexDfn, \n\t\t\t\t\u0026nodeDfn, \u0026nodeType, \u0026node, type, array, parentVDfnArray, true, NLGEORGES_FIRST_ROUND) );\n\n\t\t\t// Must create array or virtual dfn ?\n\t\t\tif (parentVDfnArray)\n\t\t\t{\n\t\t\t\t// Warn the user\n\t\t\t\tif (!theApp.yesNo (\"Warning, this action will create an array/virtual dfn over an inherited array/virtual dfn.\\nDo you want to continue ?\"))\n\t\t\t\t\t// Quit\n\t\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// Get the widget type\n\t\tIFormWidget::TTypeSrc typeSrc = Widgets[widget]-\u003egetSrcType ();\n\t\tif (typeSrc == IFormWidget::TypeForm)\n\t\t{\n\t\t\t// Get the value\n\t\t\tstd::string result;\n\t\t\tWidgets[widget]-\u003egetValue (result);\n\n\t\t\t// Document modified\n\t\t\tdoc-\u003emodify (new CActionString (IAction::FormValue, result.c_str (), *doc, Widgets[widget]-\u003egetFormName ().c_str (), \"\",\n\t\t\t\tdoc-\u003egetLeftView ()-\u003egetCurrentSelectionId (), Widgets[widget]-\u003egetSlot ()));\n\t\t}\n\t\telse if (typeSrc == IFormWidget::TypeFormParent)\n\t\t{\n\t\t\t// The form\n\t\t\tCForm *form = doc-\u003egetFormPtr ();\n\n\t\t\t// Build an array of strings\n\t\t\tuint count = Widgets[widget]-\u003egetNumValue ();\n\t\t\tvector\u003cstring\u003e stringVector (count);\n\t\t\tfor (uint value = 0; value\u003ccount; value++)\n\t\t\t{\n\t\t\t\t// Get the result\n\t\t\t\tWidgets[widget]-\u003egetValue (stringVector[value], value);\n\t\t\t}\n\n\t\t\t// Modify document\n\t\t\tdoc-\u003emodify (new CActionStringVector (IAction::FormParents, stringVector, *doc, \"\", \n\t\t\t\tdoc-\u003egetLeftView ()-\u003egetCurrentSelectionId (), Widgets[widget]-\u003egetSlot ()));\n\t\t}\t\n\t\telse if (typeSrc == IFormWidget::TypeArray)\n\t\t{\n\t\t\t// Get the value\n\t\t\tstd::string result;\n\t\t\tWidgets[widget]-\u003egetValue (result);\n\n\t\t\t// Modify document\n\t\t\tdoc-\u003emodify (new CActionBuffer (IAction::FormArraySize, NULL, 0, *doc, Widgets[widget]-\u003egetFormName ().c_str(), \n\t\t\t\tresult.c_str (), doc-\u003egetLeftView ()-\u003egetCurrentSelectionId (), Widgets[widget]-\u003egetSlot ()));\n\t\t}\n\t\telse if (typeSrc == IFormWidget::TypeType)\n\t\t{\n\t\t\t// Get the result value\n\t\t\tstd::string result;\n\t\t\tWidgets[widget]-\u003egetValue (result);\n\n\t\t\t// Document is modified by this view\n\t\t\tdoc-\u003emodify (new CActionString (IAction::FormTypeValue, result.c_str (), *doc, Widgets[widget]-\u003egetFormName().c_str(), \"\",\n\t\t\t\tdoc-\u003egetLeftView ()-\u003egetCurrentSelectionId (), Widgets[widget]-\u003egetSlot ()));\n\t\t}\n\t\telse if (typeSrc == IFormWidget::TypeVirtualDfn)\n\t\t{\n\t\t\t// Get the value\n\t\t\tstd::string result;\n\t\t\tWidgets[widget]-\u003egetValue (result);\n\n\t\t\t// Modify the document\n\t\t\tdoc-\u003emodify (new CActionBuffer (IAction::FormVirtualDfnName, NULL, 0, *doc, Widgets[widget]-\u003egetFormName ().c_str (), \n\t\t\t\tresult.c_str (), doc-\u003egetLeftView ()-\u003egetCurrentSelectionId (), Widgets[widget]-\u003egetSlot ()));\n\t\t}\n\t}\n\n\t// Notify the plugin that the value has changed\n\tif (!Widgets[widget]-\u003egetFormName ().empty ())\n\t\tdoc-\u003enotifyPlugins (Widgets[widget]-\u003egetFormName ().c_str ());\n}\n\n// ***************************************************************************\n\nLRESULT CFormDialog::WindowProc(UINT message, WPARAM wParam, LPARAM lParam) \n{\n\tswitch (message)\n\t{\n\tcase CL_CHANGED:\n\t\t{\n\t\t\tuint widgetId = getWidget (wParam);\n\t\t\tCColorEdit *colorEdit = safe_cast\u003cCColorEdit*\u003e (Widgets[widgetId]);\n\t\t\tcolorEdit-\u003eEmpty = false;\n\t\t\tsetToDocument (getWidget (wParam));\n\t\t}\n\t\tbreak;\n\tcase MC_STRINGCHANGE:\n\t\t{\n\t\t\tsetToDocument (getWidget (wParam));\n\t\t}\n\t\tbreak;\n\n\tcase CBN_CHANGED:\n\t\t{\n\t\t\tfor (uint i=0 ; i\u003cWidgets.size() ; i++)\n\t\t\t{\n\t\t\t\tCIconWidget *iconWidget = dynamic_cast\u003cCIconWidget*\u003e (Widgets[i]);\n\t\t\t\tif (iconWidget)\n\t\t\t\t\ticonWidget-\u003eIcon.Invalidate();\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\t\n\treturn CDialog::WindowProc(message, wParam, lParam);\n}\n\n// ***************************************************************************\n\nvoid CFormDialog::onOpenSelected ()\n{\n\t// Get the focus windows\n\tfor (uint i=0; i\u003cWidgets.size(); i++)\n\t{\n\t\tif (Widgets[i]-\u003ehaveFocus ())\n\t\t{\n\t\t\tWidgets[i]-\u003eonOpenSelected ();\n\t\t\t/*CFormMemCombo *combo = dynamic_cast\u003cCFormMemCombo*\u003e (Widgets[i]);\n\t\t\tif (combo)\n\t\t\t{\n\t\t\t\tCString str;\n\t\t\t\tcombo-\u003eCombo.GetWindowText (str);\n\t\t\t\tif (combo-\u003eBrowse \u0026\u0026 (str != \"\"))\n\t\t\t\t{\n\t\t\t\t\tstd::string str2=CPath::lookup ((const char*)str, false, false);\n\t\t\t\t\tif (str2.empty())\n\t\t\t\t\t\tstr2 = (const char*)str;\n\t\t\t\t\ttheApp.OpenDocumentFile (str2.c_str ());\n\t\t\t\t}\n\t\t\t}*/\n\t\t}\n\t}\n}\n\n// ***************************************************************************\n\nCWnd* CFormDialog::GetNextDlgTabItem( CWnd* pWndCtl, BOOL bPrevious) const\n{\n\treturn NULL;\n}\n\n// ***************************************************************************\n\nvoid CFormDialog::onFirstFocus ()\n{\n\tView-\u003eSetFocus ();\n\tWidgetFocused = 0xffffffff;\n}\n\n// ***************************************************************************\n\nvoid CFormDialog::onLastFocus ()\n{\n\tView-\u003esetFocusLeftView ();\n\tWidgetFocused = 0xffffffff;\n}\n\n// ***************************************************************************\n\nint CFormDialog::getWidget (uint dialogId) const\n{\n\tfor (uint i=0; i\u003cWidgets.size(); i++)\n\t{\n\t\tif (Widgets[i]-\u003eisDialog (dialogId))\n\t\t\treturn i;\n\t}\n\treturn -1;\n}\n\n// ***************************************************************************\n\nBOOL CFormDialog::OnCommand(WPARAM wParam, LPARAM lParam) \n{\n\tswitch (HIWORD(wParam))\n\t{\n\tcase CBN_SETFOCUS:\n\t\t{\n\t\t\tonGetSubFocus (LOWORD(wParam));\n\t\t}\n\t\treturn TRUE;\n\tcase EN_SETFOCUS:\n\t\t{\n\t\t\tonGetSubFocus (LOWORD(wParam));\n\t\t}\n\t\treturn TRUE;\n\t/*case CBN_SELENDOK:\n\t\t{\n\t\t\t// Look for the widget\n\t\t\tint widgetId = getWidget (LOWORD(wParam));\n\t\t\tif (widgetId != -1)\n\t\t\t\tsetToDocument (widgetId);\n\t\t}\n\t\treturn TRUE;*/\n\tcase CBN_SELCHANGE:\n\t\t{\n\t\t\t// Look for the widget\n\t\t\tint widgetId = getWidget (LOWORD(wParam));\n\t\t\tif (widgetId != -1)\n\t\t\t\tsetToDocument (widgetId);\n\t\t}\n\t\treturn TRUE;\n\tcase EN_CHANGE:\n\t\t{\n\t\t\t// Look for the widget\n\t\t\tint widgetId = getWidget (LOWORD(wParam));\n\t\t\tif (widgetId != -1)\n\t\t\t{\n\t\t\t\tCColorEdit *colorEdit = dynamic_cast\u003cCColorEdit*\u003e (Widgets[widgetId]);\n\t\t\t\tif (colorEdit)\n\t\t\t\t{\n\t\t\t\t\tCString str;\n\t\t\t\t\tcolorEdit-\u003eEdit.GetWindowText (str);\n\n\t\t\t\t\tsint r, g, b;\n\t\t\t\t\tif (sscanf (str, \"%d,%d,%d\", \u0026r, \u0026g, \u0026b) == 3)\n\t\t\t\t\t{\n\t\t\t\t\t\tclamp (r, 0, 255);\n\t\t\t\t\t\tclamp (g, 0, 255);\n\t\t\t\t\t\tclamp (b, 0, 255);\n\t\t\t\t\t\tCRGBA color (r, g, b);\n\t\t\t\t\t\tcolorEdit-\u003eColor.setColor (color);\n\t\t\t\t\t\tif (r != 255 \u0026\u0026 g != 255 \u0026\u0026 b != 255)\n\t\t\t\t\t\t\tcolorEdit-\u003eEmpty = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn TRUE;\n\tcase BN_CLICKED:\n\t\t{\n\t\t\t// Get the window\n\t\t\tint widgetId = getWidget (LOWORD(wParam));\n\n\t\t\t// Dialog Pointer\n\t\t\tif (widgetId != -1)\n\t\t\t{\n\t\t\t\tif ( (Widgets[widgetId]-\u003egetSrcType () == IFormWidget::TypeForm) || (Widgets[widgetId]-\u003egetSrcType () == IFormWidget::TypeType))\n\t\t\t\t{\n\t\t\t\t\tCFormMemCombo *combo = dynamic_cast\u003cCFormMemCombo*\u003e (Widgets[widgetId]);\n\t\t\t\t\tif (combo \u0026\u0026 IsWindow (combo-\u003eBrowse))\n\t\t\t\t\t{\n\t\t\t\t\t\tCGeorgesEditDoc *doc = View-\u003eGetDocument ();\n\t\t\t\t\t\tif (doc)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Get current node\n\t\t\t\t\t\t\tconst CFormDfn *parentDfn;\n\t\t\t\t\t\t\tuint indexDfn;\n\t\t\t\t\t\t\tconst CFormDfn *nodeDfn;\n\t\t\t\t\t\t\tconst CType *nodeType;\n\t\t\t\t\t\t\tCFormElm *node;\n\t\t\t\t\t\t\tUFormDfn::TEntryType type;\n\t\t\t\t\t\t\tbool array;\n\t\t\t\t\t\t\tbool parentVDfnArray;\n\t\t\t\t\t\t\tCForm *form=doc-\u003egetFormPtr ();\n\t\t\t\t\t\t\tCFormElm *elm = doc-\u003egetRootNode (Widgets[widgetId]-\u003egetSlot ());\n\t\t\t\t\t\t\tnlverify ( elm-\u003egetNodeByName (Widgets[widgetId]-\u003egetFormName ().c_str (), \u0026parentDfn, indexDfn, \n\t\t\t\t\t\t\t\t\u0026nodeDfn, \u0026nodeType, \u0026node, type, array, parentVDfnArray, true, NLGEORGES_FIRST_ROUND) );\n\t\t\t\t\t\t\tnlassert (parentDfn);\n\n\t\t\t\t\t\t\t// Get the current filename extension\n\t\t\t\t\t\t\tstring ext = parentDfn-\u003egetEntry (indexDfn).getFilenameExt ();\n\n\t\t\t\t\t\t\t// Build a nice type name\n\t\t\t\t\t\t\tchar typeName[512];\n\t\t\t\t\t\t\tsmprintf (typeName, 512, \"%s\", strlwr (ext).c_str());\n\t\t\t\t\t\t\tuint i=0;\n\t\t\t\t\t\t\twhile ((typeName[i] == '.') || (typeName[i] == '*'))\n\t\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\tif (typeName[i])\n\t\t\t\t\t\t\t\ttypeName[i] = toupper (typeName[i]);\n\n\t\t\t\t\t\t\t// Biuld the filter string\n\t\t\t\t\t\t\tchar filter[512];\n\t\t\t\t\t\t\tsmprintf (filter, 512, \"%s Files (%s)|%s|All Files(*.*)|*.*|\", typeName+i, ext.c_str(), ext.c_str());\n\n\t\t\t\t\t\t\t// Open the dialog\n\t\t\t\t\t\t\tCFileDialog dlgFile (TRUE, ext.c_str (), ext.c_str (), OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT, filter, theApp.m_pMainWnd);\n\t\t\t\t\t\t\tif (dlgFile.DoModal () == IDOK)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcombo-\u003eCombo.UpdateData ();\n\t\t\t\t\t\t\t\tcombo-\u003eCombo.SetWindowText (dlgFile.GetFileName ());\n\t\t\t\t\t\t\t\tcombo-\u003eCombo.UpdateData (FALSE);\n\t\t\t\t\t\t\t\tsetToDocument (widgetId);\n\t\t\t\t\t\t\t\tPostMessage (CBN_CHANGED, 0, 0);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// Reset button of color edit ?\n\t\t\t\t\t\tCColorEdit *colorEdit = dynamic_cast\u003cCColorEdit*\u003e (Widgets[widgetId]);\n\t\t\t\t\t\tif (colorEdit \u0026\u0026 IsWindow (colorEdit-\u003eColor))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcolorEdit-\u003eEmpty = true;\n\t\t\t\t\t\t\tcolorEdit-\u003eEdit.SetWindowText(\"\");\n\t\t\t\t\t\t\tsetToDocument (getWidget (wParam));\n\t\t\t\t\t\t\tupdateValues ();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (Widgets[widgetId]-\u003egetSrcType () == IFormWidget::TypeVirtualDfn)\n\t\t\t\t{\n\t\t\t\t\tCFormMemCombo *combo = dynamic_cast\u003cCFormMemCombo*\u003e (Widgets[widgetId]);\n\t\t\t\t\tif (combo \u0026\u0026 IsWindow (combo-\u003eBrowse))\n\t\t\t\t\t{\n\t\t\t\t\t\tCGeorgesEditDoc *doc = View-\u003eGetDocument ();\n\t\t\t\t\t\tif (doc)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Build the filter string\n\t\t\t\t\t\t\tchar filter[512];\n\t\t\t\t\t\t\tsmprintf (filter, 512, \"Dfn Files (*.dfn)|*.dfn|All Files(*.*)|*.*|\");\n\n\t\t\t\t\t\t\t// Open the dialog\n\t\t\t\t\t\t\tCFileDialog dlgFile (TRUE, \"*.dfn\", \"*.dfn\", OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT, filter, theApp.m_pMainWnd);\n\t\t\t\t\t\t\tif (dlgFile.DoModal () == IDOK)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcombo-\u003eCombo.UpdateData ();\n\t\t\t\t\t\t\t\tcombo-\u003eCombo.SetWindowText (dlgFile.GetFileName ());\n\t\t\t\t\t\t\t\tcombo-\u003eCombo.UpdateData (FALSE);\n\t\t\t\t\t\t\t\tsetToDocument (widgetId);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (Widgets[widgetId]-\u003egetSrcType () == IFormWidget::TypeFormParent)\n\t\t\t\t{\n\t\t\t\t\tsetToDocument (widgetId);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn TRUE;\n\t}\n\t\n\treturn CWnd::OnCommand(wParam, lParam);\n}\n\n// ***************************************************************************\n\nBOOL CFormDialog::OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult) \n{\n\tLPNMHDR pnmh = (LPNMHDR) lParam;\n\n\t// Get the CTRL ID\n\tint idCtrl = (int) wParam;\n\n\tswitch (pnmh-\u003ecode)\n\t{\n\t\tcase NM_SETFOCUS:\n\t\t{\n\t\t\tonGetSubFocus (idCtrl);\n\t\t}\n\t\tbreak;\n\t\t// Spinner control\n\t\tcase UDN_DELTAPOS:\n\t\t{\n\t\t\t// Get the window\n\t\t\tfor (uint i=0; i\u003cWidgets.size(); i++)\n\t\t\t{\n\t\t\t\tif (Widgets[i]-\u003eisDialog (idCtrl))\n\t\t\t\t{\n\t\t\t\t\t// Get the node type\n\t\t\t\t\tWidgets[i]-\u003egetFormName ();\n\t\t\t\t\t\t\n\t\t\t\t\t// Get the structure\n\t\t\t\t\tLPNMUPDOWN lpnmud = (LPNMUPDOWN) lParam;\n\n\t\t\t\t\t// Get a good pointer\n\t\t\t\t\tCFormMemCombo *combo = (CFormMemCombo*)Widgets[i];\n\n\t\t\t\t\t// Get the widget value\n\t\t\t\t\tfloat value;\n\t\t\t\t\tCString str;\n\t\t\t\t\tcombo-\u003eCombo.UpdateData ();\n\t\t\t\t\tcombo-\u003eCombo.GetWindowText (str);\n\t\t\t\t\tif (sscanf (str, \"%f\", \u0026value) == 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tCGeorgesEditDoc *doc = View-\u003eGetDocument();\n\t\t\t\t\t\tif (doc)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Get the node\n\t\t\t\t\t\t\tconst CFormDfn *parentDfn;\n\t\t\t\t\t\t\tconst CFormDfn *nodeDfn;\n\t\t\t\t\t\t\tconst CType *nodeType;\n\t\t\t\t\t\t\tCFormElm *node;\n\t\t\t\t\t\t\tuint lastElement;\n\t\t\t\t\t\t\tbool array;\n\t\t\t\t\t\t\tbool parentVDfnArray;\n\t\t\t\t\t\t\tUFormDfn::TEntryType type;\n\n\t\t\t\t\t\t\t// Search for the node\n\t\t\t\t\t\t\tnlverify ((const CFormElm*)(doc-\u003egetRootNode (Widgets[i]-\u003egetSlot ()))-\u003egetNodeByName \n\t\t\t\t\t\t\t\t(Widgets[i]-\u003egetFormName ().c_str (), \u0026parentDfn, lastElement, \u0026nodeDfn, \u0026nodeType, \n\t\t\t\t\t\t\t\t\u0026node, type, array, parentVDfnArray, true, NLGEORGES_FIRST_ROUND));\n\n\t\t\t\t\t\t\t// Todo: multiply here by the spinner precision\n\t\t\t\t\t\t\tfloat increment = 1;\n\t\t\t\t\t\t\tif (nodeType)\n\t\t\t\t\t\t\t\tsscanf (nodeType-\u003eIncrement.c_str (), \"%f\", \u0026increment);\n\n\t\t\t\t\t\t\tvalue -= (float)(lpnmud-\u003eiDelta) * increment;\n\n\t\t\t\t\t\t\t// Print the result\n\t\t\t\t\t\t\tchar result[512];\n\t\t\t\t\t\t\tsprintf (result, \"%g\", value);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Set the windnow text\n\t\t\t\t\t\t\tcombo-\u003eCombo.SetWindowText (result);\n\t\t\t\t\t\t\tcombo-\u003eCombo.UpdateData (FALSE);\n\n\t\t\t\t\t\t\t// Update the widget\n\t\t\t\t\t\t\tsetToDocument (i);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\t\n\treturn CDialog::OnNotify(wParam, lParam, pResult);\n}\n\n// ***************************************************************************\n\nvoid CFormDialog::resizeWidgets ()\n{\n\tif (Widgets.size ())\n\t{\n\t\tRECT viewRect;\n\t\tView-\u003eGetClientRect (\u0026viewRect);\n\t\tuint virtualWidth = std::max ((uint)MinViewWidth, (uint)(viewRect.right-viewRect.left));\n\n\t\t// Refresh sizes\n\t\tCBaseDialog::resizeWidgets (virtualWidth, 0);\n\n\t\t// Get first item coordinate\n\t\tRECT currentPos;\n\t\tgetFirstItemPos (currentPos);\n\t\t\n\t\t// For each widgets\n\t\tuint bigWidgetCount[2] = {0, 0};\n\t\tuint i;\n\t\tuint biggestBottom[2] = {0, 0};\n\t\tuint nextSplit = Widgets.size ()/2;\n\t\tfor (i=0; i\u003cWidgets.size (); i++)\n\t\t{\n\t\t\tuint column = (i\u003enextSplit) ? 1:0;\n\n\t\t\tWidgets[i]-\u003eresizeScan (currentPos, bigWidgetCount[column], 0, false);\n\n\t\t\tif (currentPos.bottom \u003e (int)biggestBottom[column])\n\t\t\t{\n\t\t\t\tbiggestBottom[column] = currentPos.bottom;\n\t\t\t}\n\t\t\t\n\t\t\tif (nextSplit == i)\n\t\t\t{\n\t\t\t\tgetNextColumn (currentPos);\n\t\t\t\tcurrentPos.top = 0;\n\t\t\t}\n\t\t}\n\n\t\t// Refresh sizes\n\t\tuint adjust[2];\n\t\tCBaseDialog::resizeWidgets (virtualWidth, biggestBottom[0]);\n\t\tadjust[0] = AdjusteHeight;\n\t\tCBaseDialog::resizeWidgets (virtualWidth, biggestBottom[1]);\n\t\tadjust[1] = AdjusteHeight;\n\n\t\t// Get first item coordinate\n\t\tcurrentPos;\n\t\tgetFirstItemPos (currentPos);\n\n\t\tuint adjustSum[2] = { \n\t\t\tbigWidgetCount[0] ? adjust[0] / bigWidgetCount[0] : 0,\n\t\t\t\tbigWidgetCount[1] ? adjust[1] / bigWidgetCount[1] : 0 };\n\t\tbiggestBottom[0] = 0;\n\t\tbiggestBottom[1] = 0;\n\t\tfor (i=0; i\u003cWidgets.size () - 1; i++)\n\t\t{\n\t\t\tuint column = (i\u003enextSplit) ? 1:0;\n\n\t\t\tif (Widgets[i]-\u003eextendableHeight ())\n\t\t\t{\n\t\t\t\tWidgets[i]-\u003eresizeScan (currentPos, bigWidgetCount[column], adjustSum[column], true);\n\t\t\t\tadjust[column] -= adjustSum[column];\n\t\t\t}\n\t\t\telse\n\t\t\t\tWidgets[i]-\u003eresizeScan (currentPos, bigWidgetCount[column], 0, true);\n\n\t\t\tif (currentPos.bottom \u003e (int)biggestBottom[column])\n\t\t\t{\n\t\t\t\tbiggestBottom[column] = currentPos.bottom;\n\t\t\t}\n\t\t\t\n\t\t\tif (nextSplit == i)\n\t\t\t{\n\t\t\t\tgetNextColumn (currentPos);\n\t\t\t\tcurrentPos.top = 0;\n\t\t\t}\n\t\t}\n\n\t\tuint column = (i\u003enextSplit) ? 1:0;\n\t\tWidgets[i]-\u003eresizeScan (currentPos, bigWidgetCount[column], adjust[column], true);\n\t\n\t\tif (currentPos.bottom \u003e (int)biggestBottom[column])\n\t\t{\n\t\t\tbiggestBottom[column] = currentPos.bottom;\n\t\t}\n\t\t\t\n\t\t// Resize the current view\n\t\tView-\u003esetViewSize (virtualWidth, std::max (biggestBottom[0], biggestBottom[1])+CGeorgesEditView::WidgetTopMargin+CGeorgesEditView::WidgetBottomMargin);\n\t}\n}\n\n// ***************************************************************************\n\nvoid CFormDialog::getFromDocument ()\n{\n\tCGeorgesEditDoc *doc = View-\u003eGetDocument();\n\tif (doc)\n\t{\n\t\t// Save current focus\n\t\tuint widgetFocus;\n\t\tfor (widgetFocus=0; widgetFocus\u003cWidgets.size (); widgetFocus++)\n\t\t{\n\t\t\tif (Widgets[widgetFocus]-\u003ehaveFocus ())\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\t// Current selection\n\t\tCGeorgesEditDocSub *subObject = doc-\u003egetSelectedObject ();\n\n\t\t// Get the node\n\t\tconst CFormDfn *parentDfn;\n\t\tconst CFormDfn *nodeDfn;\n\t\tconst CType *nodeType;\n\t\tCFormElm *node;\n\t\tuint lastElement;\n\t\tbool array;\n\t\tbool parentVDfnArray;\n\t\tUFormDfn::TEntryType type;\n\n\t\t// Search for the node\n\t\tnlverify (((const CFormElm*)(doc-\u003egetRootNode (subObject-\u003egetSlot ())))-\u003egetNodeByName (subObject-\u003egetFormName ().c_str (), \u0026parentDfn, lastElement, \u0026nodeDfn, \u0026nodeType, \u0026node, type, array, parentVDfnArray, true, NLGEORGES_FIRST_ROUND));\n\n\t\t// Should have a parent DFN, else it is the root element\n\t\tif (parentDfn)\n\t\t{\n\t\t\t// Is an array ?\n\t\t\tif ( array )\n\t\t\t{\n\t\t\t\t// Must be a dfn\n\t\t\t\tnlassert ( (type==UFormDfn::EntryDfn) || (type==UFormDfn::EntryType));\n\t\t\t\tgetArrayFromDocument (subObject-\u003egetFormName ().c_str (), lastElement, subObject-\u003egetSlot ());\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Is a struct ?\n\t\t\t\tswitch (parentDfn-\u003egetEntry (lastElement).getType ())\n\t\t\t\t{\n\t\t\t\t// Type\n\t\t\t\tcase UFormDfn::EntryType:\n\t\t\t\t\tnlassert ( !array );\n\t\t\t\t\tnlassert ( nodeType );\n\t\t\t\t\tnlassert ( parentDfn );\n\t\t\t\t\tnlassert (type==UFormDfn::EntryType);\n\t\t\t\t\tgetTypeFromDocument (*nodeType, \n\t\t\t\t\t\t\t\t\t\t\t\t\t(parentDfn-\u003egetEntry(lastElement).getName()+\":\").c_str (), \n\t\t\t\t\t\t\t\t\t\t\t\t\tparentDfn-\u003egetEntry(lastElement).getFilename().c_str(), \n\t\t\t\t\t\t\t\t\t\t\t\t\tsubObject-\u003egetFormName ().c_str (), subObject-\u003egetSlot ());\n\t\t\t\t\tbreak;\n\t\t\t\t// Dfn\n\t\t\t\tcase UFormDfn::EntryDfn:\n\t\t\t\t\tnlassert ( !array );\n\t\t\t\t\tnlassert ((nodeDfn) \u0026\u0026 (type==UFormDfn::EntryDfn));\n\t\t\t\t\tgetDfnFromDocument (*nodeDfn, subObject-\u003egetFormName ().c_str (), subObject-\u003egetSlot ());\n\t\t\t\t\tbreak;\n\t\t\t\t// Virtual Dfn\n\t\t\t\tcase UFormDfn::EntryVirtualDfn:\n\t\t\t\t\tnlassert ( !array );\n\t\t\t\t\tgetVirtualDfnFromDocument (nodeDfn, subObject-\u003egetFormName ().c_str (), subObject-\u003egetSlot ());\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnlassert ( !array );\n\t\t\tnlassert ((nodeDfn) \u0026\u0026 (type==UFormDfn::EntryDfn));\n\t\t\tgetDfnFromDocument (*nodeDfn, subObject-\u003egetFormName ().c_str (), subObject-\u003egetSlot ());\n\t\t}\n\n\t\t// Update labels\n\t\tfor (uint i=0; i\u003cWidgets.size (); i++)\n\t\t{\n\t\t\t// Update labels\n\t\t\tWidgets[i]-\u003eupdateLabel ();\n\t\t}\n\n\t\t// Set the focus\n\t\tif (widgetFocus\u003cWidgets.size ())\n\t\t{\n\t\t\tWidgets[widgetFocus]-\u003esetFocus ();\n\t\t}\n\t\t\n\t\t// Resize the widgets\n\t\tresizeWidgets ();\n\t}\n}\n\n// ***************************************************************************\n\nvoid CFormDialog::getDfnName (string \u0026result) const\n{\n\tCGeorgesEditDoc *doc = View-\u003eGetDocument ();\n\tif (doc)\n\t{\n\t\t// Get the DFN filename\n\t\tCString str = doc-\u003eGetPathName ();\n\t\tchar extension[512];\n\t\t_splitpath (str, NULL, NULL, NULL, extension);\n\t\tresult = (*extension == '.') ? extension+1 : extension;\n\t}\n\telse\n\t\tresult = \"\";\n}\n\n// ***************************************************************************\n\nvoid CFormDialog::OnLButtonDown(UINT nFlags, CPoint point) \n{\n\t// Get the focus\n\tView-\u003eTabCtrl.SetFocus ();\n\t\n\tCDialog::OnLButtonDown(nFlags, point);\n}\n\n// ***************************************************************************\n\nvoid CFormDialog::onGetSubFocus (uint id)\n{\n\t// Get the widget\n\tint widget = getWidget (id);\n\tWidgetFocused = widget;\n\n\t// Window view\n\tRECT widgetRect;\n\tif (Widgets[widget]-\u003egetWindowRect (widgetRect))\n\t{\n\t\tView-\u003eScreenToClient (\u0026widgetRect);\n\n\t\t// Scroll the view to be visible\n\t\tRECT viewRect;\n\t\tView-\u003eGetClientRect (\u0026viewRect);\n\t\tint bottom = viewRect.bottom - viewRect.top;\n\t\tif (widgetRect.bottom \u003e bottom)\n\t\t{\n\t\t\tCPoint pt = View-\u003eGetScrollPosition ();\n\t\t\tView-\u003eScrollToPosition (CPoint (pt.x, pt.y + widgetRect.bottom - bottom + 10));\n\t\t}\n\t\tif (widgetRect.top \u003c 0)\n\t\t{\n\t\t\tCPoint pt = View-\u003eGetScrollPosition ();\n\t\t\tView-\u003eScrollToPosition (CPoint (pt.x, pt.y + widgetRect.top - 10));\n\t\t}\n\t}\n}\n\n// ***************************************************************************\n\nvoid CFormDialog::OnSetFocus(CWnd* pNewWnd) \n{\n\tCDialog::OnSetFocus(pNewWnd);\n\tif (WidgetFocused != 0xffffffff)\n\t\tWidgets[WidgetFocused]-\u003esetFocus ();\n}\n\n// ***************************************************************************\n\nvoid CFormDialog::OnKillFocus(CWnd* pNewWnd) \n{\n\tCDialog::OnKillFocus(pNewWnd);\n}\n\n// ***************************************************************************\n// IFormWidget\n// ***************************************************************************\n\nIFormWidget::IFormWidget (CFormDialog *dialog, uint structId, const char *atomName, TTypeSrc typeSrc, uint slot) \n{ \n\tFormName = atomName;\n\tDialog = dialog; \n\tStructId = structId;\n\tSrcType = typeSrc;\n\tSlot = slot;\n}\n\n// ***************************************************************************\n\nbool IFormWidget::isDialog (uint id) const \n{ \n\treturn (id\u003e=FirstId) \u0026\u0026 (id\u003c=LastId); \n};\n\n// ***************************************************************************\n\nuint IFormWidget::getSlot () const \n{ \n\treturn Slot; \n};\n\n// ***************************************************************************\n\nuint IFormWidget::getStructId () const\n{\n\treturn StructId;\n}\n\n// ***************************************************************************\n\nvoid IFormWidget::updateLabel ()\n{\n\t// Does the node in the same form ?\n\tCGeorgesEditDoc *doc = Dialog-\u003eView-\u003eGetDocument ();\n\tif (doc)\n\t{\n\t\t// Is the label a window ?\n\t\tif (IsWindow (Label))\n\t\t{\n\t\t\t// No label for parent widget\n\t\t\tif (SrcType != TypeFormParent)\n\t\t\t{\n\t\t\t\t// Value type ?\n\t\t\t\tif ((SrcType == TypeForm) || (SrcType == TypeType))\n\t\t\t\t{\n\t\t\t\t\t// Get the value\n\t\t\t\t\tstd::string result;\n\t\t\t\t\tUFormElm::TWhereIsValue where;\n\t\t\t\t\tCForm *form=doc-\u003egetFormPtr ();\n\t\t\t\t\tCFormElm *elm = doc-\u003egetRootNode (getSlot ());\n\t\t\t\t\tnlverify (elm-\u003egetValueByName (result, FormName.c_str (), UFormElm::NoEval, \u0026where));\n\n\t\t\t\t\t// Get the value evaluated\n\t\t\t\t\tstd::string resultEvaluated;\n#ifdef TEST_EVAL_FORMULA\n\t\t\t\t\tbool error = !elm-\u003egetValueByName (resultEvaluated, FormName.c_str (), UFormElm::Formula, \u0026where);\n#else // TEST_EVAL_FORMULA\n\t\t\t\t\tbool error = !elm-\u003egetValueByName (resultEvaluated, FormName.c_str (), UFormElm::Eval, \u0026where);\n#endif // TEST_EVAL_FORMULA\n\n\t\t\t\t\t// Complete the array ?\n\t\t\t\t\tstring comp;\n\t\t\t\t\tif (error)\n\t\t\t\t\t\tcomp = \" (Value = Error)\";\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (resultEvaluated != result)\n\t\t\t\t\t\t\tcomp=\" (Value = \\\"\"+resultEvaluated+\"\\\")\";\n\t\t\t\t\t}\n\n\t\t\t\t\t// Does the node exist ?\n\t\t\t\t\tswitch (where)\n\t\t\t\t\t{\n\t\t\t\t\tcase UFormElm::ValueForm:\n\t\t\t\t\t\tLabel.SetWindowText ((SavedLabel+comp).c_str());\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase UFormElm::ValueParentForm:\n\t\t\t\t\t\tLabel.SetWindowText ((SavedLabel+\" (in parent form)\"+comp).c_str());\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase UFormElm::ValueDefaultDfn:\n\t\t\t\t\t\tLabel.SetWindowText ((SavedLabel+\" (default DFN value)\"+comp).c_str());\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase UFormElm::ValueDefaultType:\n\t\t\t\t\t\tLabel.SetWindowText ((SavedLabel+\" (default TYPE value)\"+comp).c_str());\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// Get the node\n\t\t\t\t\tconst CFormDfn *parentDfn;\n\t\t\t\t\tuint indexDfn;\n\t\t\t\t\tconst CFormDfn *nodeDfn;\n\t\t\t\t\tconst CType *nodeType;\n\t\t\t\t\tCFormElm *node;\n\t\t\t\t\tUFormDfn::TEntryType type;\n\t\t\t\t\tbool array;\n\t\t\t\t\tbool parentVDfnArray;\n\t\t\t\t\tCForm *form=doc-\u003egetFormPtr ();\n\t\t\t\t\tCFormElm *elm = doc-\u003egetRootNode (getSlot ());\n\t\t\t\t\tnlverify ( elm-\u003egetNodeByName (FormName.c_str (), \u0026parentDfn, indexDfn, \n\t\t\t\t\t\t\u0026nodeDfn, \u0026nodeType, \u0026node, type, array, parentVDfnArray, true, NLGEORGES_FIRST_ROUND) );\n\n\t\t\t\t\t// Does the node exist ?\n\t\t\t\t\tif (node)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Same form ?\n\t\t\t\t\t\tif (node-\u003egetForm () == doc-\u003egetFormPtr ())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// The node exist\n\t\t\t\t\t\t\tLabel.SetWindowText (SavedLabel.c_str());\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// The node exist in the parent form\n\t\t\t\t\t\t\tLabel.SetWindowText ((SavedLabel+\" (in parent form)\").c_str());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\t\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// The node is empty\n\t\t\t\t\t\tLabel.SetWindowText ((SavedLabel+\" (undefined)\").c_str());\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Update widget\n\t\t\t\tLabel.UpdateData (FALSE);\n\t\t\t}\n\t\t}\n\t}\n}\n\n// ***************************************************************************\n\nIFormWidget::TTypeSrc IFormWidget::getSrcType () const\n{\n\treturn SrcType;\n}\n\n// ***************************************************************************\n\nbool IFormWidget::extendableHeight () const\n{\n\treturn false;\n}\n\n// ***************************************************************************\n\nbool IFormWidget::getNode (const CFormDfn **parentDfn, uint \u0026lastElement, const CFormDfn **nodeDfn, const CType **nodeType, \n\t\t\t\t\tCFormElm **node, UFormDfn::TEntryType \u0026type, bool \u0026array) const\n{\n\t// Get the document\n\tCGeorgesEditDoc *doc = Dialog-\u003eView-\u003eGetDocument ();\n\tif (doc)\n\t{\n\t\t// Return the node\n\t\tbool parentVDfnArray;\n\t\tCForm *form=doc-\u003egetFormPtr ();\n\t\tCFormElm *elm = doc-\u003egetRootNode (getSlot ());\n\t\treturn (elm-\u003egetNodeByName (FormName.c_str (), parentDfn, \n\t\t\tlastElement, nodeDfn, nodeType, node, type, array, parentVDfnArray, true, NLGEORGES_FIRST_ROUND) );\n\t}\n\treturn false;\n}\n\n// ***************************************************************************\n\nCFormElm *IFormWidget::getFormElmNode () const\n{\n\tconst CFormDfn\t\t\t*parentDfn;\n\tuint\t\t\t\t\tparentDfnIndex;\n\tconst CFormDfn\t\t\t*nodeDfn;\n\tconst CType\t\t\t\t*nodeType;\n\tCFormElm\t\t\t\t*node;\n\tUFormDfn::TEntryType\ttype;\n\tbool array;\n\tif (getNode (\u0026parentDfn, parentDfnIndex, \u0026nodeDfn, \u0026nodeType, \u0026node, type, array))\n\t{\n\t\treturn node;\n\t}\n\treturn NULL;\n}\n\n// ***************************************************************************\n\nCFormElmStruct *IFormWidget::getFormElmStructNode () const\n{\n\tCFormElm *elm = getFormElmNode ();\n\treturn elm ? safe_cast\u003cCFormElmStruct*\u003e (elm) : NULL;\n}\n\n// ***************************************************************************\n\nCFormElmVirtualStruct *IFormWidget::getFormElmVirtualStructNode () const\n{\n\tCFormElm *elm = getFormElmNode ();\n\treturn elm ? safe_cast\u003cCFormElmVirtualStruct*\u003e (elm) : NULL;\n}\n\n// ***************************************************************************\n\nCFormElmArray *IFormWidget::getFormElmArrayNode () const\n{\n\tCFormElm *elm = getFormElmNode ();\n\treturn elm ? safe_cast\u003cCFormElmArray*\u003e (elm) : NULL;\n}\n\n// ***************************************************************************\n\nCFormElmAtom *IFormWidget::getFormElmAtomNode () const\n{\n\tCFormElm *elm = getFormElmNode ();\n\treturn elm ? safe_cast\u003cCFormElmAtom*\u003e (elm) : NULL;\n}\n\n// ***************************************************************************\n\nconst string \u0026IFormWidget::getFormName () const\n{\n\treturn FormName;\n}\n\n// ***************************************************************************\n\nuint IFormWidget::getNumValue ()\n{\n\t// Not implemented for this widget\n\tnlstop;\n\treturn 0;\n}\n\n// ***************************************************************************\n\nvoid IFormWidget::getValue (std::string \u0026result)\n{\n\t// Not implemented for this widget\n\tnlstop;\n}\n\n// ***************************************************************************\n\nvoid IFormWidget::getValue (std::string \u0026result, uint value)\n{\n\t// Not implemented for this widget\n\tnlstop;\n}\n\n// ***************************************************************************\n\nbool IFormWidget::getWindowRect (RECT \u0026rect) const\n{\n\tif (IsWindow (Label))\n\t{\n\t\tLabel.GetWindowRect (\u0026rect);\n\t\treturn true;\n\t}\n\telse\n\t\treturn false;\n}\n\n// ***************************************************************************\n\nvoid IFormWidget::onOpenSelected ()\n{\n\tstring str;\n\tgetValue (str);\n\n\tstd::string str2=CPath::lookup (str.c_str (), false, false);\n\tif (str2.empty())\n\t\tstr2 = str.c_str ();\n\ttheApp.OpenDocumentFile (str2.c_str ());\n}\n\n// ***************************************************************************\n// CFormMemCombo\n// ***************************************************************************\n\nCFormMemCombo::CFormMemCombo (CFormDialog *dialog, uint structId, const char *atomName, TTypeSrc typeSrc, uint slot) : IFormWidget (dialog, structId, atomName, typeSrc, slot)\n{\n\tUseSpinner = false;\n\tFileBrowser = false;\n}\n\n// ***************************************************************************\n\nCFormMemCombo::~CFormMemCombo ()\n{\n\tif (IsWindow (Label))\n\t\tLabel.DestroyWindow ();\n\tif (IsWindow (Combo))\n\t\tCombo.DestroyWindow ();\n\tif (IsWindow (Spin))\n\t\tSpin.DestroyWindow ();\n\tif (IsWindow (Browse))\n\t\tBrowse.DestroyWindow ();\n}\n\n// ***************************************************************************\n\nvoid CFormMemCombo::create (DWORD wStyle, RECT \u0026currentPos, CFormDialog *parent, uint \u0026dialog_index, const char *label, const char *reg, bool useSpinner, bool fileBrowser, const char *filenameExt)\n{\n\t// Get the doc\n\tCGeorgesEditDoc *doc = Dialog-\u003eView-\u003eGetDocument ();\n\tnlassert (doc);\n\n\t// Get the node type (if any)\n\tconst CFormDfn *parentDfn;\n\tuint indexDfn;\n\tconst CFormDfn *nodeDfn;\n\tconst CType *nodeType = NULL;\n\tCFormElm *node;\n\tUFormDfn::TEntryType type;\n\tbool array;\n\tbool parentVDfnArray;\n\tCForm *form=doc-\u003egetFormPtr ();\n\tCFormElm *elm = doc-\u003egetRootNode (getSlot ());\n\tnlverify ( elm-\u003egetNodeByName (FormName.c_str (), \u0026parentDfn, indexDfn, \n\t\t\u0026nodeDfn, \u0026nodeType, \u0026node, type, array, parentVDfnArray, true, NLGEORGES_FIRST_ROUND) );\n\n\tFirstId = dialog_index;\n\tLastId = FirstId+1;\n\n\t// Save the label \n\tSavedLabel = label;\n\n\t// Create the type combo\n\tparent-\u003esetStaticSize (currentPos);\n\tLabel.Create (label, WS_VISIBLE, currentPos, parent);\n\tparent-\u003einitWidget (Label);\n\tparent-\u003egetNextPosLabel (currentPos);\n\n\tUseSpinner = useSpinner;\n\tFileBrowser = fileBrowser;\n\n\t// Create the spinner\n\tif (useSpinner)\n\t{\n\t\t// Create the mem combobox\n\t\tparent-\u003esetComboSpinSize (currentPos);\n\t\tCombo.create (WS_CHILD|WS_TABSTOP, currentPos, parent, dialog_index, reg, theApp.RememberListSize);\n\t\tparent-\u003einitWidget (Combo);\n\n\t\t// Create the spin\n\t\tRECT spinPos = currentPos;\n\t\tparent-\u003egetNextSpinPos (spinPos);\n\t\tparent-\u003esetSpinSize (spinPos);\n\t\tSpin.Create (WS_CHILD|WS_VISIBLE, spinPos, parent, dialog_index+1);\n\t\t//Spin.SetBuddy (\u0026Combo.ComboBox);\n\t\tparent-\u003egetNextPos (currentPos);\n\t}\n\telse if (fileBrowser)\n\t{\n\t\t// Create the mem combobox\n\t\tparent-\u003esetComboBrowseSize (currentPos);\n\t\tCombo.create (WS_CHILD|WS_TABSTOP, currentPos, parent, dialog_index, reg, theApp.RememberListSize);\n\t\tparent-\u003einitWidget (Combo);\n\n\t\t// Create the spin\n\t\tRECT spinPos = currentPos;\n\t\tparent-\u003egetNextBrowsePos (spinPos);\n\t\tparent-\u003esetBrowseSize (spinPos);\n\t\tBrowse.Create (\"...\", WS_CHILD|WS_VISIBLE|WS_TABSTOP, spinPos, parent, dialog_index+1);\n\t\tparent-\u003einitWidget (Browse);\n\t\tparent-\u003egetNextPos (currentPos);\n\n\t\t// Set autocomplete mode\n\t\tif (filenameExt)\n\t\t{\n\t\t\tif (strcmp (filenameExt, \"*.*\") != 0)\n\t\t\t\tCombo.enableAutoCompleteExtension (true, filenameExt);\n\t\t}\n\t}\n\telse\n\t{\n\t\t// Create the mem combobox\n\t\tparent-\u003esetComboSize (currentPos, parent-\u003eSmallWidget);\n\t\tCombo.create (WS_CHILD|WS_TABSTOP, currentPos, parent, dialog_index, reg, theApp.RememberListSize);\n\t\tparent-\u003einitWidget (Combo);\n\t\tparent-\u003egetNextPos (currentPos);\n\t}\n\n\t// Get predefs\n\tif (nodeType)\n\t{\n\t\tfor (uint predef=0; predef\u003cnodeType-\u003eDefinitions.size(); predef++)\n\t\t{\n\t\t\tCombo.addStaticStrings (nodeType-\u003eDefinitions[predef].Label.c_str());\n\t\t}\n\t}\n\n\tdialog_index += 2;\n}\n\n// ***************************************************************************\n\nvoid CFormMemCombo::updateData (bool update)\n{\n\tCombo.UpdateData (update?TRUE:FALSE);\n}\n\n// ***************************************************************************\n\nbool CFormMemCombo::haveFocus ()\n{\n\treturn (Combo.haveFocus ());\n}\n\n// ***************************************************************************\n\nvoid CFormMemCombo::setFocus ()\n{\n\tCombo.SetFocus ();\t\n}\n\n// ***************************************************************************\n\nvoid CFormMemCombo::onOk ()\n{\n\tCombo.onOK ();\n}\n\n// ***************************************************************************\n\nvoid CFormMemCombo::getValue (std::string \u0026result)\n{\n\tCombo.UpdateData ();\n\n\tCString str;\n\tCombo.GetWindowText (str);\n\n\tCombo.UpdateData (FALSE);\n\t\n\t// Set the atom value\n\tresult = (const char*)str;\n}\n\n// ***************************************************************************\n\nvoid CFormMemCombo::getFromDocument (CForm \u0026form)\n{\n\tCGeorgesEditDoc *doc = Dialog-\u003eView-\u003eGetDocument ();\n\tnlassert (doc);\n\n\tif ((SrcType == TypeForm) || (SrcType == TypeType))\n\t{\n\t\tstring result;\n\t\tif (doc-\u003egetRootNode(getSlot ())-\u003egetValueByName (result, FormName.c_str(), UFormElm::NoEval, NULL))\n\t\t{\n\t\t\tCombo.UpdateData ();\n\t\t\tCombo.SetWindowText (result.c_str());\n\t\t\tCombo.UpdateData (FALSE);\n\t\t\tupdateLabel ();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnlstop;\n\t\t}\n\t}\n\telse if (SrcType == TypeArray)\n\t{\n\t\tconst CFormDfn *parentDfn;\n\t\tuint lastElement;\n\t\tconst CFormDfn *nodeDfn;\n\t\tconst CType *nodeType;\n\t\tCFormElm *node;\n\t\tUFormDfn::TEntryType type;\n\t\tbool array;\n\t\tbool parentVDfnArray;\n\t\tnlverify (((const CFormElm*)doc-\u003egetRootNode(getSlot ()))-\u003egetNodeByName (FormName.c_str(), \u0026parentDfn, lastElement, \u0026nodeDfn, \u0026nodeType, \u0026node, type, array, parentVDfnArray, true, NLGEORGES_FIRST_ROUND));\n\t\tnlassert (array);\n\n\t\t// Node exist ?\n\t\tCombo.UpdateData ();\n\t\tif (node)\n\t\t{\n\t\t\tCFormElmArray *arrayNode = safe_cast\u003cCFormElmArray*\u003e (node);\n\t\t\tchar label[512];\n\t\t\tsmprintf (label, 512, \"%d\", arrayNode-\u003eElements.size ());\n\t\t\tCombo.SetWindowText (label);\n\n\t\t\tif (arrayNode-\u003egetForm () == \u0026form)\n\t\t\t\tLabel.SetWindowText (\"Array size:\");\n\t\t\telse\n\t\t\t\tLabel.SetWindowText (\"Array size: (in parent form)\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tCombo.SetWindowText (\"0\");\n\t\t}\n\t\tCombo.UpdateData (FALSE);\n\t}\n\telse if (SrcType == TypeVirtualDfn)\n\t{\n\t\tconst CFormDfn *parentDfn;\n\t\tuint lastElement;\n\t\tconst CFormDfn *nodeDfn;\n\t\tconst CType *nodeType;\n\t\tCFormElm *node;\n\t\tUFormDfn::TEntryType type;\n\t\tbool array;\n\t\tbool parentVDfnArray;\n\t\tnlverify (((const CFormElm*)doc-\u003egetRootNode (getSlot ()))-\u003egetNodeByName (FormName.c_str(), \u0026parentDfn, lastElement, \u0026nodeDfn, \u0026nodeType, \u0026node, type, array, parentVDfnArray, true, NLGEORGES_FIRST_ROUND));\n\t\tnlassert (!array);\n\n\t\t// Node exist ?\n\t\tCombo.UpdateData ();\n\t\tif (node)\n\t\t{\n\t\t\tCFormElmVirtualStruct *virtualNode = safe_cast\u003cCFormElmVirtualStruct*\u003e (node);\n\t\t\tCombo.SetWindowText (virtualNode-\u003eDfnFilename.c_str());\n\t\t}\n\t\telse\n\t\t{\n\t\t\tCombo.SetWindowText (\"\");\n\t\t}\n\t\tCombo.UpdateData (FALSE);\n\t}\n}\n\n// ***************************************************************************\n\nbool CFormMemCombo::isWnd (const CWnd *wnd) const\n{\n\treturn Combo.isWnd (wnd);\n}\n\n// ***************************************************************************\n\nvoid CFormMemCombo::resizeScan (RECT \u0026currentPos, uint \u0026widgetCount, uint adjust, bool resize)\n{\n\t// Create the type combo\n\tDialog-\u003esetStaticSize (currentPos);\n\tif (resize)\n\t{\n\t\tLabel.SetWindowPos (NULL, currentPos.left, currentPos.top, currentPos.right - currentPos.left, \n\t\t\tcurrentPos.bottom - currentPos.top, SWP_NOZORDER|SWP_NOOWNERZORDER);\n\t}\n\tDialog-\u003egetNextPosLabel (currentPos);\n\n\t// Create the spinner\n\tif (UseSpinner)\n\t{\n\t\t// Create the mem combobox\n\t\tDialog-\u003esetComboSpinSize (currentPos);\n\t\tif (resize)\n\t\t{\n\t\t\tCombo.SetWindowPos (NULL, currentPos.left, currentPos.top, currentPos.right - currentPos.left, \n\t\t\t\tcurrentPos.bottom - currentPos.top, SWP_NOZORDER|SWP_NOOWNERZORDER);\n\t\t}\n\n\t\t// Create the spin\n\t\tRECT spinPos = currentPos;\n\t\tDialog-\u003egetNextSpinPos (spinPos);\n\t\tDialog-\u003esetSpinSize (spinPos);\n\t\tif (resize)\n\t\t{\n\t\t\tSpin.SetWindowPos (NULL, spinPos.left, spinPos.top, spinPos.right - spinPos.left, \n\t\t\t\tspinPos.bottom - spinPos.top, SWP_NOZORDER|SWP_NOOWNERZORDER);\n\t\t}\n\t}\n\telse if (FileBrowser)\n\t{\n\t\t// Create the mem combobox\n\t\tDialog-\u003esetComboBrowseSize (currentPos);\n\t\tif (resize)\n\t\t{\n\t\t\tCombo.SetWindowPos (NULL, currentPos.left, currentPos.top, currentPos.right - currentPos.left, \n\t\t\t\tcurrentPos.bottom - currentPos.top, SWP_NOZORDER|SWP_NOOWNERZORDER);\n\t\t}\n\n\t\t// Create the spin\n\t\tRECT spinPos = currentPos;\n\t\tDialog-\u003egetNextBrowsePos (spinPos);\n\t\tDialog-\u003esetBrowseSize (spinPos);\n\t\tif (resize)\n\t\t{\n\t\t\tBrowse.SetWindowPos (NULL, spinPos.left, spinPos.top, spinPos.right - spinPos.left, \n\t\t\t\tspinPos.bottom - spinPos.top, SWP_NOZORDER|SWP_NOOWNERZORDER);\n\t\t}\n\t}\n\telse\n\t{\n\t\t// Create the mem combobox\n\t\tDialog-\u003esetComboSize (currentPos, Dialog-\u003eSmallWidget);\n\t\tif (resize)\n\t\t{\n\t\t\tCombo.SetWindowPos (NULL, currentPos.left, currentPos.top, currentPos.right - currentPos.left, \n\t\t\t\tcurrentPos.bottom - currentPos.top, SWP_NOZORDER|SWP_NOOWNERZORDER);\n\t\t}\n\t}\n\tDialog-\u003egetNextPos (currentPos);\n}\n\n// ***************************************************************************\n\nbool CFormMemCombo::getWindowRect (RECT \u0026rect) const\n{\n\tif (Combo)\n\t{\n\t\t// Get parent rect\n\t\tRECT parentRect;\n\t\tIFormWidget::getWindowRect (parentRect);\n\n\t\t// Add my rect\n\t\tRECT myRect;\n\t\tCombo.GetWindowRect (\u0026myRect);\n\t\tUnionRect(\u0026rect, \u0026myRect, \u0026parentRect);\n\t\treturn true;\n\t}\n\telse\n\t\treturn false;\n}\n\n// ***************************************************************************\n// CFormCombo\n// ***************************************************************************\n\nCFormCombo::CFormCombo (CFormDialog *dialog, uint structId, const char *atomName, IFormWidget::TTypeSrc typeForm, uint slot) : IFormWidget (dialog, structId, atomName, typeForm, slot)\n{\n}\n\n// ***************************************************************************\n\nCFormCombo::~CFormCombo ()\n{\n\tif (IsWindow (Label))\n\t\tLabel.DestroyWindow ();\n\tif (IsWindow (Combo))\n\t\tCombo.DestroyWindow ();\n}\n\n// ***************************************************************************\n\nvoid CFormCombo::create (DWORD wStyle, RECT \u0026currentPos, CFormDialog *parent, uint \u0026dialog_index, const char *label)\n{\n\t// Get the doc\n\tCGeorgesEditDoc *doc = Dialog-\u003eView-\u003eGetDocument ();\n\tnlassert (doc);\n\n\tFirstId = dialog_index;\n\tLastId = FirstId;\n\n\t// Get the value for the type pointer (if any)\n\tconst CFormDfn *parentDfn;\n\tuint indexDfn;\n\tconst CFormDfn *nodeDfn;\n\tconst CType *nodeType;\n\tCFormElm *node;\n\tUFormDfn::TEntryType type;\n\tbool array;\n\tbool parentVDfnArray;\n\tCForm *form=doc-\u003egetFormPtr ();\n\tCFormElm *elm = doc-\u003egetRootNode (getSlot ());\n\tnlverify ( elm-\u003egetNodeByName (FormName.c_str (), \u0026parentDfn, indexDfn, \n\t\t\u0026nodeDfn, \u0026nodeType, \u0026node, type, array, parentVDfnArray, true, NLGEORGES_FIRST_ROUND) );\n\n\t// Save the label \n\tSavedLabel = label;\n\n\t// Create the type combo\n\tparent-\u003esetStaticSize (currentPos);\n\tLabel.Create (label, WS_VISIBLE, currentPos, parent);\n\tparent-\u003einitWidget (Label);\n\tparent-\u003egetNextPosLabel (currentPos);\n\n\t// Create the mem combobox\n\tparent-\u003esetComboSize (currentPos, parent-\u003eSmallWidget);\n\tRECT comboPos = currentPos;\n\tparent-\u003eadjusteComboSize (comboPos);\n\tCombo.Create (WS_CHILD|WS_VSCROLL|WS_VISIBLE|CBS_DROPDOWNLIST|CBS_HASSTRINGS|WS_CHILD|WS_TABSTOP, comboPos, parent, dialog_index);\n\tparent-\u003einitWidget (Combo);\n\tparent-\u003egetNextPos (currentPos);\n\n\t// Get predefs\n\tif (nodeType)\n\t{\n\t\tCombo.InsertString (0, \"\");\n\t\tfor (uint predef=0; predef\u003cnodeType-\u003eDefinitions.size(); predef++)\n\t\t{\n\t\t\tCombo.InsertString (predef+1, nodeType-\u003eDefinitions[predef].Label.c_str());\n\t\t}\n\t}\n\n\tdialog_index += 1;\n}\n\n// ***************************************************************************\n\nvoid CFormCombo::updateData (bool update)\n{\n\tCombo.UpdateData (update?TRUE:FALSE);\n}\n\n// ***************************************************************************\n\nbool CFormCombo::haveFocus ()\n{\n\tCWnd *focus = CWnd::GetFocus ();\n\tif (focus)\n\t{\n\t\treturn (focus == \u0026Combo);\n\t}\n\treturn false;\n}\n\n// ***************************************************************************\n\nvoid CFormCombo::setFocus ()\n{\n\tCombo.SetFocus ();\n}\n\n// ***************************************************************************\n\nvoid CFormCombo::onOk ()\n{\n\t//Combo.onOK ();\n}\n\n// ***************************************************************************\n\nvoid CFormCombo::getValue (std::string \u0026result)\n{\n\tCombo.UpdateData ();\n\n\tCString str;\n\tCombo.GetWindowText (str);\n\n\tCombo.UpdateData (FALSE);\n\n\t// Set the atom value\n\tresult = (const char*)str;\n}\n\n// ***************************************************************************\n\nvoid CFormCombo::getFromDocument (CForm \u0026form)\n{\n\tCGeorgesEditDoc *doc = Dialog-\u003eView-\u003eGetDocument ();\n\tnlassert (doc);\n\tstring result;\n\tif (doc-\u003egetRootNode (getSlot ())-\u003egetValueByName (result, FormName.c_str(), UFormElm::NoEval, NULL))\n\t{\n\t\tCombo.UpdateData ();\n\t\tuint itemCount = Combo.GetCount ();\n\t\tfor (uint i=0; i\u003citemCount; i++)\n\t\t{\n\t\t\tCString item;\n\t\t\tCombo.GetLBText (i, item);\n\t\t\tif (item == result.c_str())\n\t\t\t{\n\t\t\t\tCombo.SetCurSel (i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tCombo.UpdateData (FALSE);\n\t\tupdateLabel ();\n\t}\n\telse\n\t{\n\t\tnlstop;\n\t}\n}\n\n// ***************************************************************************\n\nbool CFormCombo::isWnd (const CWnd *wnd) const\n{\n\treturn \u0026Combo == (const CWnd*)wnd;\n}\n\n// ***************************************************************************\n\nvoid CFormCombo::resizeScan (RECT \u0026currentPos, uint \u0026widgetCount, uint adjust, bool resize)\n{\n\t// Create the type combo\n\tDialog-\u003esetStaticSize (currentPos);\n\tif (resize)\n\t{\n\t\tLabel.SetWindowPos (NULL, currentPos.left, currentPos.top, currentPos.right - currentPos.left, \n\t\t\tcurrentPos.bottom - currentPos.top, SWP_NOZORDER|SWP_NOOWNERZORDER);\n\t}\n\tDialog-\u003egetNextPosLabel (currentPos);\n\n\t// Create the mem combobox\n\tDialog-\u003esetComboSize (currentPos, Dialog-\u003eSmallWidget);\n\tif (resize)\n\t{\n\t\tRECT comboPos = currentPos;\n\t\tDialog-\u003eadjusteComboSize (comboPos);\n\t\tCombo.SetWindowPos (NULL, comboPos.left, comboPos.top, comboPos.right - comboPos.left, \n\t\t\tcomboPos.bottom - comboPos.top, SWP_NOZORDER|SWP_NOOWNERZORDER);\n\t}\n\tDialog-\u003egetNextPos (currentPos);\n}\n\n// ***************************************************************************\n\nbool CFormCombo::getWindowRect (RECT \u0026rect) const\n{\n\tif (IsWindow (Combo))\n\t{\n\t\t// Get parent rect\n\t\tRECT parentRect;\n\t\tIFormWidget::getWindowRect (parentRect);\n\n\t\t// Add my rect\n\t\tRECT myRect;\n\t\tCombo.GetWindowRect (\u0026myRect);\n\t\tUnionRect(\u0026rect, \u0026myRect, \u0026parentRect);\n\t\treturn true;\n\t}\n\telse\n\t\treturn false;\n}\n\n// ***************************************************************************\n// CFormBigEdit\n// ***************************************************************************\n\nCFormBigEdit::CFormBigEdit (CFormDialog *dialog, uint structId, const char *atomName, IFormWidget::TTypeSrc typeForm, uint slot) : IFormWidget (dialog, structId, atomName, typeForm, slot)\n{\n}\n\n// ***************************************************************************\n\nCFormBigEdit::~CFormBigEdit ()\n{\n\tif (IsWindow (Label))\n\t\tLabel.DestroyWindow ();\n\tif (IsWindow (Edit))\n\t\tEdit.DestroyWindow ();\n}\n\n// ***************************************************************************\n\nvoid CFormBigEdit::create (DWORD wStyle, RECT \u0026currentPos, CFormDialog *parent, uint \u0026dialog_index, const char *label)\n{\n\tFirstId = dialog_index;\n\tLastId = FirstId;\n\n\t// Save the label \n\tSavedLabel = label;\n\n\t// Create the type combo\n\tparent-\u003esetStaticSize (currentPos);\n\tLabel.Create (label, WS_VISIBLE, currentPos, parent);\n\tparent-\u003einitWidget (Label);\n\tparent-\u003egetNextPosLabel (currentPos);\n\n\t// Create the mem combobox\n\tparent-\u003esetBigEditSize (currentPos, parent-\u003eSmallWidget);\n\tEdit.CreateEx (WS_EX_CLIENTEDGE, _T(\"EDIT\"), \"\", WS_VSCROLL|ES_OEMCONVERT|ES_MULTILINE|ES_WANTRETURN|WS_CHILD|WS_VISIBLE|WS_TABSTOP|ES_AUTOHSCROLL|ES_AUTOVSCROLL, currentPos, parent, dialog_index);\n\tparent-\u003einitWidget (Edit);\n\tparent-\u003egetNextPos (currentPos);\n\n\tdialog_index += 1;\n}\n\n// ***************************************************************************\n\nvoid CFormBigEdit::updateData (bool update)\n{\n\tEdit.UpdateData (update?TRUE:FALSE);\n}\n\n// ***************************************************************************\n\nbool CFormBigEdit::haveFocus ()\n{\n\tCWnd *focus = CWnd::GetFocus ();\n\tif (focus)\n\t{\n\t\treturn (focus == \u0026Edit);\n\t}\n\treturn false;\n}\n\n// ***************************************************************************\n\nvoid CFormBigEdit::setFocus ()\n{\n\tEdit.SetFocus ();\n}\n\n// ***************************************************************************\n\nvoid CFormBigEdit::onOk ()\n{\n\t//Combo.onOK ();\n}\n\n// ***************************************************************************\n\nvoid CFormBigEdit::getValue (std::string \u0026result)\n{\n\tEdit.UpdateData ();\n\n\tCString str;\n\tEdit.GetWindowText (str);\n\n\tEdit.UpdateData (FALSE);\n\t\n\t// Set the atom value\n\tresult = (const char*)str;\n}\n\n// ***************************************************************************\n\nvoid CFormBigEdit::getFromDocument (CForm \u0026form)\n{\n\tCGeorgesEditDoc *doc = Dialog-\u003eView-\u003eGetDocument ();\n\tnlassert (doc);\n\tstring result;\n\tif (doc-\u003egetRootNode (getSlot ())-\u003egetValueByName (result, FormName.c_str(), UFormElm::NoEval, NULL))\n\t{\n\t\tEdit.UpdateData ();\n\t\tDialog-\u003esetEditTextMultiLine (Edit, result.c_str());\n\t\tEdit.UpdateData (FALSE);\n\t\tupdateLabel ();\n\t}\n\telse\n\t{\n\t\tnlstop;\n\t}\n}\n\n// ***************************************************************************\n\nbool CFormBigEdit::isWnd (const CWnd *wnd) const\n{\n\treturn \u0026Edit == wnd;\n}\n\n// ***************************************************************************\n\nvoid CFormBigEdit::resizeScan (RECT \u0026currentPos, uint \u0026widgetCount, uint adjust, bool resize)\n{\n\tif (!resize)\n\t\twidgetCount++;\n\n\t// Create the type combo\n\tDialog-\u003esetStaticSize (currentPos);\n\tif (resize)\n\t{\n\t\tLabel.SetWindowPos (NULL, currentPos.left, currentPos.top, currentPos.right - currentPos.left, \n\t\t\tcurrentPos.bottom - currentPos.top, SWP_NOZORDER|SWP_NOOWNERZORDER);\n\t}\n\tDialog-\u003egetNextPosLabel (currentPos);\n\n\t// Create the mem combobox\n\tDialog-\u003esetBigEditSize (currentPos, Dialog-\u003eSmallWidgetNotLimited, Dialog-\u003eBigEditHeight + adjust);\n\tif (resize)\n\t{\n\t\tEdit.SetWindowPos (NULL, currentPos.left, currentPos.top, currentPos.right - currentPos.left, \n\t\t\tcurrentPos.bottom - currentPos.top, SWP_NOZORDER|SWP_NOOWNERZORDER);\n\t}\n\tDialog-\u003egetNextPos (currentPos);\n}\n\n// ***************************************************************************\n\nbool CFormBigEdit::extendableHeight () const\n{\n\treturn true;\n}\n\n// ***************************************************************************\n\nbool CFormBigEdit::getWindowRect (RECT \u0026rect) const\n{\n\tif (IsWindow (Edit))\n\t{\n\t\t// Get parent rect\n\t\tRECT parentRect;\n\t\tIFormWidget::getWindowRect (parentRect);\n\n\t\t// Add my rect\n\t\tRECT myRect;\n\t\tEdit.GetWindowRect (\u0026myRect);\n\t\tUnionRect(\u0026rect, \u0026myRect, \u0026parentRect);\n\t\treturn true;\n\t}\n\telse\n\t\treturn false;\n}\n\n// ***************************************************************************\n// CColorEdit\n// ***************************************************************************\n\nCColorEdit::CColorEdit (CFormDialog *dialog, uint structId, const char *atomName, IFormWidget::TTypeSrc typeForm, uint slot) : IFormWidget (dialog, structId, atomName, typeForm, slot)\n{\n\tEmpty = true;\n}\n\n// ***************************************************************************\n\nCColorEdit::~CColorEdit ()\n{\n\tif (IsWindow (Label))\n\t\tLabel.DestroyWindow ();\n\tif (IsWindow (Color))\n\t\tColor.DestroyWindow ();\n\tif (IsWindow (Edit))\n\t\tEdit.DestroyWindow ();\n}\n\n// ***************************************************************************\n\nvoid CColorEdit::create (DWORD wStyle, RECT \u0026currentPos, CFormDialog *parent, uint \u0026dialog_index, const char *label)\n{\n\tFirstId = dialog_index;\n\tLastId = FirstId+2;\n\n\t// Save the label \n\tSavedLabel = label;\n\n\t// Create the type combo\n\tparent-\u003esetStaticSize (currentPos);\n\tLabel.Create (label, WS_VISIBLE, currentPos, parent);\n\tparent-\u003einitWidget (Label);\n\tparent-\u003egetNextPosLabel (currentPos);\n\n\t// Create the mem combobox\n\tparent-\u003esetColorSize (currentPos, parent-\u003eSmallWidget);\n\tColor.create (WS_CHILD|WS_VISIBLE|WS_TABSTOP, currentPos, parent, dialog_index);\n\tparent-\u003einitWidget (Color);\n\n\t// Create the reset button\n\tRECT resetPos = currentPos;\n\tparent-\u003egetNextColorPos (resetPos);\n\tparent-\u003esetResetColorSize (resetPos);\n\tReset.Create (\"Reset\", WS_CHILD|WS_VISIBLE|WS_TABSTOP, resetPos, parent, dialog_index+1);\n\tparent-\u003einitWidget (Reset);\n\tparent-\u003egetNextPosLabel (currentPos);\n\n\t// Create the Edit\n\tparent-\u003esetBigEditSize (currentPos, parent-\u003eSmallWidget);\n\tEdit.CreateEx (WS_EX_CLIENTEDGE, _T(\"EDIT\"), \"\", ES_OEMCONVERT|ES_WANTRETURN|WS_CHILD|WS_VISIBLE|WS_TABSTOP|ES_AUTOHSCROLL, currentPos, parent, dialog_index+2);\n\tparent-\u003einitWidget (Edit);\n\tparent-\u003egetNextPos (currentPos);\n\n\tColor.setEdit(\u0026Edit);\n\n\tdialog_index += 3;\n}\n\n// ***************************************************************************\n\nvoid CColorEdit::updateData (bool update)\n{\n\tColor.UpdateData (update?TRUE:FALSE);\n\tEdit.UpdateData (update?TRUE:FALSE);\n}\n\n// ***************************************************************************\n\nbool CColorEdit::haveFocus ()\n{\n\tCWnd *focus = CWnd::GetFocus ();\n\tif (focus)\n\t{\n\t\treturn (focus == \u0026Color);\n\t}\n\treturn false;\n}\n\n// ***************************************************************************\n\nvoid CColorEdit::setFocus ()\n{\n\tColor.SetFocus ();\n}\n\n// ***************************************************************************\n\nvoid CColorEdit::onOk ()\n{\n\t// Color.onOk ();\n}\n\n// ***************************************************************************\n\nvoid CColorEdit::getValue (std::string \u0026result)\n{\n\tif (!Empty)\n\t{\n\t\tColor.UpdateData ();\n\n\t\t// Get the color\n\t\tCRGBA color = Color.getColor ();\n\n\t\t// Make a string\n\t\tchar colorName[512];\n\t\tsmprintf (colorName, 512, \"%d,%d,%d\", color.R, color.G, color.B);\n\n\t\t// Set the atom value\n\t\tresult = colorName;\n\t}\n\telse\n\t{\n\t\tresult = \"\";\n\t}\n}\n\n// ***************************************************************************\n\nvoid CColorEdit::getFromDocument (CForm \u0026form)\n{\n\tCGeorgesEditDoc *doc = Dialog-\u003eView-\u003eGetDocument ();\n\tnlassert (doc);\n\tstring result;\n\tif (doc-\u003egetRootNode (getSlot ())-\u003egetValueByName (result, FormName.c_str(), UFormElm::NoEval, NULL))\n\t{\n\t\tColor.UpdateData ();\n\n\t\t// Make a color\n\t\tsint r, g, b;\n\t\tif (sscanf (result.c_str(), \"%d,%d,%d\", \u0026r, \u0026g, \u0026b) == 3)\n\t\t{\n\t\t\tclamp (r, 0, 255);\n\t\t\tclamp (g, 0, 255);\n\t\t\tclamp (b, 0, 255);\n\t\t\tCRGBA color (r, g, b);\n\t\t\tColor.setColor (color);\n\t\t\tif (r != 255 \u0026\u0026 g != 255 \u0026\u0026 b != 255)\n\t\t\t\tColor.updateEdit();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tColor.setColor (CRGBA::Black);\n\t\t\tColor.updateEdit();\n\t\t}\n\t\tColor.UpdateData (FALSE);\n\t\tupdateLabel ();\n\t}\n\telse\n\t{\n\t\tnlstop;\n\t}\n}\n\n\n// ***************************************************************************\n\nbool CColorEdit::isWnd (const CWnd *wnd) const\n{\n\treturn \u0026Color == wnd;\n}\n\n// ***************************************************************************\n\nvoid CColorEdit::resizeScan (RECT \u0026currentPos, uint \u0026widgetCount, uint adjust, bool resize)\n{\n\t// Create the type combo\n\tDialog-\u003esetStaticSize (currentPos);\n\tif (resize)\n\t{\n\t\tLabel.SetWindowPos (NULL, currentPos.left, currentPos.top, currentPos.right - currentPos.left, \n\t\t\tcurrentPos.bottom - currentPos.top, SWP_NOZORDER|SWP_NOOWNERZORDER);\n\t}\n\tDialog-\u003egetNextPosLabel (currentPos);\n\n\t// Create the mem combobox\n\tDialog-\u003esetColorSize (currentPos, Dialog-\u003eSmallWidget);\n\tif (resize)\n\t{\n\t\tColor.SetWindowPos (NULL, currentPos.left, currentPos.top, currentPos.right - currentPos.left, \n\t\t\tcurrentPos.bottom - currentPos.top, SWP_NOZORDER|SWP_NOOWNERZORDER);\n\t}\n\n\t// Create the spin\n\tRECT resetPos = currentPos;\n\tDialog-\u003egetNextColorPos (resetPos);\n\tDialog-\u003esetResetColorSize (resetPos);\n\tif (resize)\n\t{\n\t\tReset.SetWindowPos (NULL, resetPos.left, resetPos.top, resetPos.right - resetPos.left, \n\t\t\tresetPos.bottom - resetPos.top, SWP_NOZORDER|SWP_NOOWNERZORDER);\n\t}\n\tDialog-\u003egetNextPosLabel (currentPos);\n\n\t// Create the Edit\n\tDialog-\u003esetEditSize (currentPos, Dialog-\u003eSmallWidget, Dialog-\u003eEditHeight);\n\tif (resize)\n\t{\n\t\tEdit.SetWindowPos (NULL, currentPos.left, currentPos.top, currentPos.right - currentPos.left, \n\t\t\tcurrentPos.bottom - currentPos.top, SWP_NOZORDER|SWP_NOOWNERZORDER);\n\t}\n\n\tDialog-\u003egetNextPos (currentPos);\n}\n\n// ***************************************************************************\n\nbool CColorEdit::getWindowRect (RECT \u0026rect) const\n{\n\tif (IsWindow (Color))\n\t{\n\t\t// Get parent rect\n\t\tRECT parentRect;\n\t\tIFormWidget::getWindowRect (parentRect);\n\n\t\t// Add my rect\n\t\tRECT myRect;\n\t\tColor.GetWindowRect (\u0026myRect);\n\t\tUnionRect(\u0026rect, \u0026myRect, \u0026parentRect);\n\t\treturn true;\n\t}\n\telse\n\t\treturn false;\n}\n\n// ***************************************************************************\n// CListWidget\n// ***************************************************************************\n\nCListWidget::CListWidget (CFormDialog *dialog, uint structId, const char *atomName, IFormWidget::TTypeSrc typeForm, uint slot)  : IFormWidget (dialog, structId, atomName, typeForm, slot)\n{\n\tListCtrl.Ctrl = this;\n}\n\n// ***************************************************************************\n\nCListWidget::~CListWidget ()\n{\n\tif (IsWindow (Label))\n\t\tLabel.DestroyWindow ();\n\tif (IsWindow (ListCtrl))\n\t\tListCtrl.DestroyWindow ();\n\tif (IsWindow (Button))\n\t\tButton.DestroyWindow ();\n}\n\n// ***************************************************************************\n\nvoid CListWidget::create (DWORD wStyle, RECT \u0026currentPos, CFormDialog *parent, uint \u0026dialog_index, const char *label, const char *reg, uint divid)\n{\n\tFirstId = dialog_index;\n\tLastId = FirstId+1;\n\n\tDivid = divid;\n\tRegAdr = reg;\n\n\t// Save the label \n\tSavedLabel = label;\n\n\t// Create the type combo\n\tparent-\u003esetStaticSize (currentPos);\n\tLabel.Create (label, WS_VISIBLE, currentPos, parent);\n\tparent-\u003einitWidget (Label);\n\tparent-\u003egetNextPosLabel (currentPos);\n\n\t// Create the mem combobox\n\tparent-\u003esetListSize (currentPos, parent-\u003eSmallWidget);\n\tListCtrl.create (WS_CHILD|WS_VISIBLE|WS_TABSTOP, currentPos, parent, dialog_index);\n\tparent-\u003einitWidget (ListCtrl);\n\tparent-\u003egetNextPos (currentPos);\n\n\t// Create the assign parent\n\tparent-\u003esetButtonSize (currentPos, parent-\u003eSmallWidget);\n\tButton.Create (\"Assign parents\", WS_CHILD|WS_VISIBLE|WS_TABSTOP, currentPos, parent, dialog_index+1);\n\tparent-\u003einitWidget (Button);\n\tparent-\u003egetNextPos (currentPos);\n\n\tdialog_index += 2;\n}\n\n// ***************************************************************************\n\nvoid CListWidget::addColumn (const char *name)\n{\n\tListCtrl.insertColumn (0, name);\n\tListCtrl.recalcColumn ();\n}\n\n// ***************************************************************************\n\nvoid CListWidget::onOk ()\n{\n\tListCtrl.onOK ();\n}\n\n// ***************************************************************************\n\nvoid CListWidget::updateData (bool update)\n{\n\tListCtrl.UpdateData (update);\n}\n\n// ***************************************************************************\n\nbool CListWidget::haveFocus ()\n{\n\tCWnd *wnd = Dialog-\u003eGetFocus ();\n\tif (wnd)\n\t{\n\t\treturn (wnd-\u003eGetParent () == \u0026ListCtrl);\n\t}\n\treturn false;\n}\n\n// ***************************************************************************\n\nvoid CListWidget::setFocus ()\n{\n\tListCtrl.SetFocus ();\n}\n\n// ***************************************************************************\n\nvoid CListWidget::getFromDocument (NLGEORGES::CForm \u0026form)\n{\n\t// Erase the list\n\tListCtrl.ListCtrl.DeleteAllItems ();\n\t\n\t// For each parent\n\tfor (uint parent=0; parent\u003cform.getParentCount (); parent++)\n\t{\n\t\t// Get the parent filename\n\t\tstring filename = form.getParentFilename (parent);\n\n\t\t// Insert in the list\n\t\tListCtrl.ListCtrl.InsertItem (parent, filename.c_str ());\n\n\t\tListCtrl.ListCtrl.UpdateData (FALSE);\n\t\tupdateLabel ();\n\t}\n}\n\n// ***************************************************************************\n\nuint CListWidget::getNumValue ()\n{\n\treturn ListCtrl.ListCtrl.GetItemCount ();\n}\n\n// ***************************************************************************\n\nvoid CListWidget::getValue (std::string \u0026result, uint value)\n{\n\tCString str = ListCtrl.ListCtrl.GetItemText (value, 0);\n\tresult = str;\n}\n\n// ***************************************************************************\n\nbool CListWidget::isWnd (const CWnd *wnd) const\n{\n\treturn (((\u0026ListCtrl) == wnd) || ((\u0026ListCtrl.ListCtrl) == wnd));\n}\n\n// ***************************************************************************\n\nvoid CListWidget::resizeScan (RECT \u0026currentPos, uint \u0026widgetCount, uint adjust, bool resize)\n{\n\tif (!resize)\n\t\twidgetCount++;\n\n\t// Create the type combo\n\tDialog-\u003esetStaticSize (currentPos);\n\tif (resize)\n\t{\n\t\tLabel.SetWindowPos (NULL, currentPos.left, currentPos.top, currentPos.right - currentPos.left, \n\t\t\tcurrentPos.bottom - currentPos.top, SWP_NOZORDER|SWP_NOOWNERZORDER);\n\t}\n\tDialog-\u003egetNextPosLabel (currentPos);\n\n\t// Create the mem combobox\n\tDialog-\u003esetListSize (currentPos, Dialog-\u003eSmallWidgetNotLimited / Divid, Dialog-\u003eListHeight + adjust);\n\tif (resize)\n\t{\n\t\tListCtrl.SetWindowPos (NULL, currentPos.left, currentPos.top, currentPos.right - currentPos.left, \n\t\t\tcurrentPos.bottom - currentPos.top, SWP_NOZORDER|SWP_NOOWNERZORDER);\n\t\tListCtrl.recalcColumn ();\n\t}\n\tDialog-\u003egetNextPos (currentPos);\n\n\t// Create the mem combobox\n\tDialog-\u003esetButtonSize (currentPos, Dialog-\u003eSmallWidget);\n\tif (resize)\n\t{\n\t\tButton.SetWindowPos (NULL, currentPos.left, currentPos.top, currentPos.right - currentPos.left, \n\t\t\tcurrentPos.bottom - currentPos.top, SWP_NOZORDER|SWP_NOOWNERZORDER);\n\t}\n\tDialog-\u003egetNextPos (currentPos);\n}\n\n// ***************************************************************************\n\nbool CListWidget::extendableHeight () const\n{\n\treturn true;\n}\n\n// ***************************************************************************\n\nCEditListCtrl::TItemEdit CListWidget::CMyEditListCtrl::getItemEditMode (uint item, uint subItem)\n{\n\treturn CEditListCtrl::EditMemCombo;\n}\n\n// ***************************************************************************\n\nvoid CListWidget::CMyEditListCtrl::getMemComboBoxProp (uint item, uint subItem, std::string \u0026regAdr, bool \u0026browse)\n{\n\tregAdr = Ctrl-\u003eRegAdr;\n\tbrowse = true;\n}\n\n// ***************************************************************************\n\nvoid CListWidget::CMyEditListCtrl::getNewItemText (uint item, uint subItem, std::string \u0026ret)\n{\n\tCtrl-\u003eDialog-\u003egetDfnName (ret);\n\tret = \"default.\" + ret;\n}\n\n// ***************************************************************************\n\nvoid CListWidget::CMyEditListCtrl::getBrowseInfo (uint item, uint subItem, std::string \u0026defExt, std::string \u0026defFilename, std::string \u0026defDir, std::string \u0026filter)\n{\n\tstring ret;\n\tCtrl-\u003eDialog-\u003egetDfnName (ret);\n\tdefExt = \"*.\" + ret;\n\tdefFilename = defExt;\n\n\tfilter = \"Form Files (*.\" + ret + \")|*.\" + ret + \"|All Files (*.*)|*.*||\";\n\tdefDir = theApp.RootSearchPath;\n}\n\n// ***************************************************************************\n\nbool CListWidget::getWindowRect (RECT \u0026rect) const\n{\n\tif (IsWindow (ListCtrl))\n\t{\n\t\t// Get parent rect\n\t\tRECT parentRect;\n\t\tIFormWidget::getWindowRect (parentRect);\n\n\t\t// Add my rect\n\t\tRECT myRect;\n\t\tListCtrl.ListCtrl.GetWindowRect (\u0026myRect);\n\t\tUnionRect(\u0026rect, \u0026myRect, \u0026parentRect);\n\t\treturn true;\n\t}\n\telse\n\t\treturn false;\n}\n\n// ***************************************************************************\n\nvoid CListWidget::onOpenSelected ()\n{\n\t// For each selected\n\tPOSITION pos = ListCtrl.ListCtrl.GetFirstSelectedItemPosition();\n\twhile (pos)\n\t{\n\t\tint nItem = ListCtrl.ListCtrl.GetNextSelectedItem(pos);\n\n\t\t// Get the string\n\t\tCString str = ListCtrl.ListCtrl.GetItemText (nItem, 0);\n\t\tif (str != \"\")\n\t\t{\n\t\t\t// Look for the file\n\t\t\tstring name = CPath::lookup ((const char*)str, false, false);\n\t\t\tif (name.empty ())\n\t\t\t\tname = str;\n\n\t\t\t// Open the file\n\t\t\ttheApp.OpenDocumentFile (name.c_str ());\n\t\t}\n\t}\n}\n\n// ***************************************************************************\n\n// ***************************************************************************\n// CIconWidget\n// ***************************************************************************\n\nCIconWidget::CIconWidget (CFormDialog *dialog, uint structId, const char *atomName, IFormWidget::TTypeSrc typeForm, uint slot) : IFormWidget (dialog, structId, atomName, typeForm, slot)\n{\n\n}\n\n// ***************************************************************************\n\nCIconWidget::~CIconWidget ()\n{\n\tif (IsWindow (Icon))\n\t\tIcon.DestroyWindow ();\n}\n\n// ***************************************************************************\n\nvoid CIconWidget::create (DWORD wStyle, RECT \u0026currentPos, CFormDialog *parent, uint \u0026dialog_index, const char *label)\n{\n\tFirstId = dialog_index;\n\tLastId = FirstId;\n\n\t// Save the label \n\tSavedLabel = label;\n\n\t// Create the type combo\n\tparent-\u003esetStaticSize (currentPos);\n\tLabel.Create (label, WS_VISIBLE, currentPos, parent);\n\tparent-\u003einitWidget (Label);\n\tparent-\u003egetNextPosLabel (currentPos);\n\n\t// Create the mem combobox\n\tparent-\u003esetEditSize (currentPos, parent-\u003eIconHeight, parent-\u003eIconHeight);\n\tIcon.create (WS_CHILD|WS_VISIBLE|WS_TABSTOP, currentPos, parent, dialog_index);\n\tparent-\u003einitWidget (Icon);\n\n\tparent-\u003egetNextPos (currentPos);\n\n\tdialog_index += 1;\n}\n\n// ***************************************************************************\n\nvoid CIconWidget::updateData (bool update)\n{\n\tIcon.UpdateData (update?TRUE:FALSE);\n}\n\n// ***************************************************************************\n\nbool CIconWidget::haveFocus ()\n{\n\tCWnd *focus = CWnd::GetFocus ();\n\tif (focus)\n\t{\n\t\treturn (focus == \u0026Icon);\n\t}\n\treturn false;\n}\n\n// ***************************************************************************\n\nvoid CIconWidget::setFocus ()\n{\n\tIcon.SetFocus ();\n}\n\n// ***************************************************************************\n\nvoid CIconWidget::onOk ()\n{\n\n}\n\n// ***************************************************************************\n\nvoid CIconWidget::getValue (std::string \u0026result)\n{\n\tresult = \"\";\n}\n\n// ***************************************************************************\n\nvoid CIconWidget::getFromDocument (CForm \u0026form)\n{\n\n}\n\n\n// ***************************************************************************\n\nbool CIconWidget::isWnd (const CWnd *wnd) const\n{\n\treturn \u0026Icon == wnd;\n}\n\n// ***************************************************************************\n\nvoid CIconWidget::resizeScan (RECT \u0026currentPos, uint \u0026widgetCount, uint adjust, bool resize)\n{\n\t// Create the type combo\n\tDialog-\u003esetStaticSize (currentPos);\n\tif (resize)\n\t{\n\t\tLabel.SetWindowPos (NULL, currentPos.left, currentPos.top, currentPos.right - currentPos.left, \n\t\t\tcurrentPos.bottom - currentPos.top, SWP_NOZORDER|SWP_NOOWNERZORDER);\n\t}\n\tDialog-\u003egetNextPosLabel (currentPos);\n\t\n\t// Create the icon\n\tDialog-\u003esetEditSize (currentPos, Dialog-\u003eIconHeight, Dialog-\u003eIconHeight);\n\tif (resize)\n\t{\n\t\tIcon.SetWindowPos (NULL, currentPos.left, currentPos.top, currentPos.right - currentPos.left, \n\t\t\tcurrentPos.bottom - currentPos.top, SWP_NOZORDER|SWP_NOOWNERZORDER);\n\t}\n\n\tDialog-\u003egetNextPos (currentPos);\n}\n\n// ***************************************************************************\n\nbool CIconWidget::getWindowRect (RECT \u0026rect) const\n{\n\tif (IsWindow (Icon))\n\t{\n\t\t// Get parent rect\n\t\tRECT parentRect;\n\t\tIFormWidget::getWindowRect (parentRect);\n\n\t\t// Add my rect\n\t\tRECT myRect;\n\t\tIcon.GetWindowRect (\u0026myRect);\n\t\tUnionRect(\u0026rect, \u0026myRect, \u0026parentRect);\n\t\treturn true;\n\t}\n\telse\n\t\treturn false;\n}"}
{"repo_name":"wakashige/TrinityCore","ref":"refs/heads/6.x","path":"src/server/scripts/EasternKingdoms/zone_arathi_highlands.cpp","copies":"43","language":"C++","content":"/*\n * Copyright (C) 2008-2015 TrinityCore \u003chttp://www.trinitycore.org/\u003e\n * Copyright (C) 2006-2009 ScriptDev2 \u003chttps://scriptdev2.svn.sourceforge.net/\u003e\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the\n * Free Software Foundation; either version 2 of the License, or (at your\n * option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n * more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program. If not, see \u003chttp://www.gnu.org/licenses/\u003e.\n */\n\n/* ScriptData\nSDName: Arathi Highlands\nSD%Complete: 100\nSDComment: Quest support: 665\nSDCategory: Arathi Highlands\nEndScriptData */\n\n/* ContentData\nnpc_professor_phizzlethorpe\nEndContentData */\n\n#include \"ScriptMgr.h\"\n#include \"ScriptedCreature.h\"\n#include \"ScriptedEscortAI.h\"\n#include \"Player.h\"\n\n/*######\n## npc_professor_phizzlethorpe\n######*/\n\nenum ProfessorPhizzlethorpe\n{\n    // Yells\n    SAY_PROGRESS_1          = 0,\n    SAY_PROGRESS_2          = 1,\n    SAY_PROGRESS_3          = 2,\n    EMOTE_PROGRESS_4        = 3,\n    SAY_AGGRO               = 4,\n    SAY_PROGRESS_5          = 5,\n    SAY_PROGRESS_6          = 6,\n    SAY_PROGRESS_7          = 7,\n    EMOTE_PROGRESS_8        = 8,\n    SAY_PROGRESS_9          = 9,\n    EVENT_SAY_3         = 1,\n    EVENT_SAY_6         = 2,\n    EVENT_SAY_8         = 3,\n\n    // Quests\n    QUEST_SUNKEN_TREASURE   = 665,\n    QUEST_GOGGLE_BOGGLE     = 26050,\n    // Creatures\n    NPC_VENGEFUL_SURGE      = 2776,\n    FACTION_SUNKEN_TREASURE = 113\n};\n\nclass npc_professor_phizzlethorpe : public CreatureScript\n{\n    public:\n        npc_professor_phizzlethorpe() : CreatureScript(\"npc_professor_phizzlethorpe\") { }\n\n        struct npc_professor_phizzlethorpeAI : public npc_escortAI\n        {\n            npc_professor_phizzlethorpeAI(Creature* creature) : npc_escortAI(creature) { }\n\n            void WaypointReached(uint32 waypointId) override\n            {\n                Player* player = GetPlayerForEscort();\n                if (!player)\n                    return;\n\n                switch (waypointId)\n                {\n                    case 6:\n                        Talk(SAY_PROGRESS_2, player);\n                        events.ScheduleEvent(EVENT_SAY_3, 3000);\n                        break;\n                    case 8:\n                        Talk(EMOTE_PROGRESS_4);\n                        me-\u003eSummonCreature(NPC_VENGEFUL_SURGE, -2065.505f, -2136.88f, 22.20362f, 1.0f, TEMPSUMMON_CORPSE_DESPAWN, 0);\n                        me-\u003eSummonCreature(NPC_VENGEFUL_SURGE, -2059.249f, -2134.88f, 21.51582f, 1.0f, TEMPSUMMON_CORPSE_DESPAWN, 0);\n                        break;\n                    case 11:\n                        Talk(SAY_PROGRESS_5, player);\n                        events.ScheduleEvent(EVENT_SAY_6, 11000);\n                        break;\n                    case 17:\n                        Talk(SAY_PROGRESS_7, player);\n                        events.ScheduleEvent(EVENT_SAY_8, 6000);\n                        break;\n                }\n            }\n\n            void JustSummoned(Creature* summoned) override\n            {\n                summoned-\u003eAI()-\u003eAttackStart(me);\n            }\n\n            void EnterCombat(Unit* /*who*/) override\n            {\n                Talk(SAY_AGGRO);\n            }\n\n            void sQuestAccept(Player* player, Quest const* quest) override\n            {\n                if (quest-\u003eGetQuestId() == QUEST_SUNKEN_TREASURE)\n                {\n                    Talk(SAY_PROGRESS_1, player);\n                    npc_escortAI::Start(false, false, player-\u003eGetGUID(), quest);\n                    me-\u003esetFaction(FACTION_SUNKEN_TREASURE);\n                }\n            }\n\n            void UpdateAI(uint32 diff) override\n            {\n                Player* player = GetPlayerForEscort();\n                if (!player)\n                    return;\n\n                events.Update(diff);\n\n                while (uint32 event = events.ExecuteEvent())\n                {\n                    switch (event)\n                    {\n                        case EVENT_SAY_3:\n                            Talk(SAY_PROGRESS_3, player);\n                            break;\n                        case EVENT_SAY_6:\n                            Talk(SAY_PROGRESS_6, player);\n                            SetRun();\n                            break;\n                        case EVENT_SAY_8:\n                            Talk(EMOTE_PROGRESS_8);\n                            Talk(SAY_PROGRESS_9, player);\n                            player-\u003eGroupEventHappens(QUEST_GOGGLE_BOGGLE, me);\n                            break;\n                    }\n                }\n                npc_escortAI::UpdateAI(diff);\n            }\n\n            EventMap events;\n        };\n\n    CreatureAI* GetAI(Creature* creature) const override\n    {\n        return new npc_professor_phizzlethorpeAI(creature);\n    }\n};\n\nvoid AddSC_arathi_highlands()\n{\n    new npc_professor_phizzlethorpe();\n}\n"}
{"repo_name":"StevenBlack/phantomjs","ref":"refs/heads/master","path":"src/qt/qtwebkit/Source/WebCore/platform/audio/AudioFIFO.cpp","copies":"119","language":"C++","content":"/*\n * Copyright (C) 2012 Google Inc. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1.  Redistributions of source code must retain the above copyright\n *     notice, this list of conditions and the following disclaimer.\n * 2.  Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n * 3.  Neither the name of Apple Computer, Inc. (\"Apple\") nor the names of\n *     its contributors may be used to endorse or promote products derived\n *     from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"config.h\"\n\n#if ENABLE(WEB_AUDIO)\n\n#include \"AudioFIFO.h\"\n\nnamespace WebCore {\n\nAudioFIFO::AudioFIFO(unsigned numberOfChannels, size_t fifoLength)\n    : m_fifoAudioBus(AudioBus::create(numberOfChannels, fifoLength))\n    , m_fifoLength(fifoLength)\n    , m_framesInFifo(0)\n    , m_readIndex(0)\n    , m_writeIndex(0)\n{\n}\n\nvoid AudioFIFO::consume(AudioBus* destination, size_t framesToConsume)\n{\n    bool isGood = destination \u0026\u0026 (framesToConsume \u003c= m_fifoLength) \u0026\u0026 (framesToConsume \u003c= m_framesInFifo) \u0026\u0026 (destination-\u003elength() \u003e= framesToConsume);\n    ASSERT(isGood);\n    if (!isGood)\n        return;\n\n    // Copy the requested number of samples to the destination.\n\n    size_t part1Length;\n    size_t part2Length;\n    findWrapLengths(m_readIndex, framesToConsume, part1Length, part2Length);\n\n    size_t numberOfChannels = m_fifoAudioBus-\u003enumberOfChannels();\n\n    for (size_t channelIndex = 0; channelIndex \u003c numberOfChannels; ++channelIndex) {\n        float* destinationData = destination-\u003echannel(channelIndex)-\u003emutableData();\n        const float* sourceData = m_fifoAudioBus-\u003echannel(channelIndex)-\u003edata();\n\n        bool isCopyGood = ((m_readIndex \u003c m_fifoLength)\n                           \u0026\u0026 (m_readIndex + part1Length) \u003c= m_fifoLength\n                           \u0026\u0026 (part1Length \u003c= destination-\u003elength())\n                           \u0026\u0026 (part1Length + part2Length) \u003c= destination-\u003elength());\n        ASSERT(isCopyGood);\n        if (!isCopyGood)\n            return;\n\n        memcpy(destinationData, sourceData + m_readIndex, part1Length * sizeof(*sourceData));\n        // Handle wrap around of the FIFO, if needed.\n        if (part2Length)\n            memcpy(destinationData + part1Length, sourceData, part2Length * sizeof(*sourceData));\n    }\n    m_readIndex = updateIndex(m_readIndex, framesToConsume);\n    ASSERT(m_framesInFifo \u003e= framesToConsume);\n    m_framesInFifo -= framesToConsume;\n}\n\nvoid AudioFIFO::push(const AudioBus* sourceBus)\n{\n    // Copy the sourceBus into the FIFO buffer.\n\n    bool isGood = sourceBus \u0026\u0026 (m_framesInFifo + sourceBus-\u003elength() \u003c= m_fifoLength);\n    if (!isGood)\n        return;\n\n    size_t sourceLength = sourceBus-\u003elength();\n    size_t part1Length;\n    size_t part2Length;\n    findWrapLengths(m_writeIndex, sourceLength, part1Length, part2Length);\n\n    size_t numberOfChannels = m_fifoAudioBus-\u003enumberOfChannels();\n\n    for (size_t channelIndex = 0; channelIndex \u003c numberOfChannels; ++channelIndex) {\n        float* destination = m_fifoAudioBus-\u003echannel(channelIndex)-\u003emutableData();\n        const float* source = sourceBus-\u003echannel(channelIndex)-\u003edata();\n\n        bool isCopyGood = ((m_writeIndex \u003c m_fifoLength)\n                           \u0026\u0026 (m_writeIndex + part1Length) \u003c= m_fifoLength\n                           \u0026\u0026 part2Length \u003c m_fifoLength\n                           \u0026\u0026 part1Length + part2Length \u003c= sourceLength);\n        ASSERT(isCopyGood);\n        if (!isCopyGood)\n            return;\n\n        memcpy(destination + m_writeIndex, source, part1Length * sizeof(*destination));\n\n        // Handle wrap around of the FIFO, if needed.\n        if (part2Length)\n            memcpy(destination, source + part1Length, part2Length * sizeof(*destination));\n    }\n        \n    m_framesInFifo += sourceLength;\n    ASSERT(m_framesInFifo \u003c= m_fifoLength);\n    m_writeIndex = updateIndex(m_writeIndex, sourceLength);\n}\n\nvoid AudioFIFO::findWrapLengths(size_t index, size_t size, size_t\u0026 part1Length, size_t\u0026 part2Length)\n{\n    ASSERT_WITH_SECURITY_IMPLICATION(index \u003c m_fifoLength \u0026\u0026 size \u003c= m_fifoLength);\n    if (index \u003c m_fifoLength \u0026\u0026 size \u003c= m_fifoLength) {\n        if (index + size \u003e m_fifoLength) {\n            // Need to wrap. Figure out the length of each piece.\n            part1Length = m_fifoLength - index;\n            part2Length = size - part1Length;\n        } else {\n            // No wrap needed.\n            part1Length = size;\n            part2Length = 0;\n        }\n    } else {\n        // Invalid values for index or size. Set the part lengths to zero so nothing is copied.\n        part1Length = 0;\n        part2Length = 0;\n    }\n}\n\n} // namespace WebCore\n\n#endif // ENABLE(WEB_AUDIO)\n"}
{"repo_name":"ThomasXBMC/XCSoar","ref":"refs/heads/master","path":"src/Engine/Task/Computer/DistanceStatComputer.cpp","copies":"11","language":"C++","content":"/* Copyright_License {\n\n  XCSoar Glide Computer - http://www.xcsoar.org/\n  Copyright (C) 2000-2015 The XCSoar Project\n  A detailed list of copyright holders can be found in the file \"AUTHORS\".\n\n  This program is free software; you can redistribute it and/or\n  modify it under the terms of the GNU General Public License\n  as published by the Free Software Foundation; either version 2\n  of the License, or (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program; if not, write to the Free Software\n  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n}\n */\n\n#include \"DistanceStatComputer.hpp\"\n#include \"Task/Stats/DistanceStat.hpp\"\n\nvoid\nDistanceStatComputer::CalcSpeed(DistanceStat \u0026data, fixed time)\n{\n  if (positive(time) \u0026\u0026 data.IsDefined())\n    data.speed = data.GetDistance() / time;\n  else\n    data.speed = fixed(0);\n}\n"}
{"repo_name":"mantidproject/cxxtest","ref":"refs/heads/master","path":"cxxtest/TestTracker.cpp","copies":"60","language":"C++","content":"/*\n-------------------------------------------------------------------------\n CxxTest: A lightweight C++ unit testing library.\n Copyright (c) 2008 Sandia Corporation.\n This software is distributed under the LGPL License v3\n For more information, see the COPYING file in the top CxxTest directory.\n Under the terms of Contract DE-AC04-94AL85000 with Sandia Corporation,\n the U.S. Government retains certain rights in this software.\n-------------------------------------------------------------------------\n*/\n\n#ifndef __cxxtest__TestTracker_cpp__\n#define __cxxtest__TestTracker_cpp__\n\n#include \u003ccxxtest/TestTracker.h\u003e\n\nnamespace CxxTest\n{\nbool TestTracker::_created = false;\nbool TestTracker::print_tracing = false;\n\nTestTracker::TestTracker()\n{\n    if (!_created)\n    {\n        initialize();\n        setListener(0);\n        _created = true;\n    }\n}\n\nTestTracker::~TestTracker()\n{\n}\n\nTestTracker \u0026 TestTracker::tracker()\n{\n    static TestTracker theTracker;\n    return theTracker;\n}\n\nvoid TestTracker::initialize()\n{\n    _warnings = 0;\n    _skippedTests = 0;\n    _testSkipped = false;\n    _failedTests = 0;\n    _testFailedAsserts = 0;\n    _suiteFailedTests = 0;\n    _failedSuites = 0;\n    _world = 0;\n    _suite = 0;\n    _test = 0;\n}\n\nconst TestDescription *TestTracker::fixTest(const TestDescription *d) const\n{\n    return d ? d : \u0026dummyTest();\n}\n\nconst SuiteDescription *TestTracker::fixSuite(const SuiteDescription *d) const\n{\n    return d ? d : \u0026dummySuite();\n}\n\nconst WorldDescription *TestTracker::fixWorld(const WorldDescription *d) const\n{\n    return d ? d : \u0026dummyWorld();\n}\n\nconst TestDescription \u0026TestTracker::dummyTest() const\n{\n    return dummySuite().testDescription(0);\n}\n\nconst SuiteDescription \u0026TestTracker::dummySuite() const\n{\n    return dummyWorld().suiteDescription(0);\n}\n\nconst WorldDescription \u0026TestTracker::dummyWorld() const\n{\n    return _dummyWorld;\n}\n\nvoid TestTracker::setListener(TestListener *l)\n{\n    _l = l ? l : \u0026_dummyListener;\n}\n\nvoid TestTracker::enterWorld(const WorldDescription \u0026wd)\n{\n    setWorld(\u0026wd);\n    _warnings = _skippedTests = _failedTests = _testFailedAsserts = _suiteFailedTests = _failedSuites = 0;\n    _testSkipped = false;\n    _l-\u003eenterWorld(wd);\n}\n\nvoid TestTracker::enterSuite(const SuiteDescription \u0026sd)\n{\n    setSuite(\u0026sd);\n    _testFailedAsserts = _suiteFailedTests = 0;\n    _testSkipped = false;\n    _l-\u003eenterSuite(sd);\n}\n\nvoid TestTracker::enterTest(const TestDescription \u0026td)\n{\n    setTest(\u0026td);\n    _testFailedAsserts = false;\n    _testSkipped = false;\n    _l-\u003eenterTest(td);\n}\n\nvoid TestTracker::leaveTest(const TestDescription \u0026td)\n{\n    _l-\u003eleaveTest(td);\n    setTest(0);\n}\n\nvoid TestTracker::leaveSuite(const SuiteDescription \u0026sd)\n{\n    _l-\u003eleaveSuite(sd);\n    setSuite(0);\n}\n\nvoid TestTracker::leaveWorld(const WorldDescription \u0026wd)\n{\n    _l-\u003eleaveWorld(wd);\n    setWorld(0);\n}\n\nvoid TestTracker::trace(const char *file, int line, const char *expression)\n{\n    _l-\u003etrace(file, line, expression);\n}\n\nvoid TestTracker::warning(const char *file, int line, const char *expression)\n{\n    countWarning();\n    _l-\u003ewarning(file, line, expression);\n}\n\nvoid TestTracker::skippedTest(const char *file, int line, const char *expression)\n{\n    countSkipped();\n    _testSkipped = true;\n    _l-\u003eskippedTest(file, line, expression);\n}\n\nvoid TestTracker::failedTest(const char *file, int line, const char *expression)\n{\n    countFailure();\n    _l-\u003efailedTest(file, line, expression);\n}\n\nvoid TestTracker::failedAssert(const char *file, int line, const char *expression)\n{\n    countFailure();\n    _l-\u003efailedAssert(file, line, expression);\n}\n\nvoid TestTracker::failedAssertEquals(const char *file, int line,\n                                     const char *xStr, const char *yStr,\n                                     const char *x, const char *y)\n{\n    countFailure();\n    _l-\u003efailedAssertEquals(file, line, xStr, yStr, x, y);\n}\n\nvoid TestTracker::failedAssertSameData(const char *file, int line,\n                                       const char *xStr, const char *yStr,\n                                       const char *sizeStr, const void *x,\n                                       const void *y, unsigned size)\n{\n    countFailure();\n    _l-\u003efailedAssertSameData(file, line, xStr, yStr, sizeStr, x, y, size);\n}\n\nvoid TestTracker::failedAssertDelta(const char *file, int line,\n                                    const char *xStr, const char *yStr, const char *dStr,\n                                    const char *x, const char *y, const char *d)\n{\n    countFailure();\n    _l-\u003efailedAssertDelta(file, line, xStr, yStr, dStr, x, y, d);\n}\n\nvoid TestTracker::failedAssertDiffers(const char *file, int line,\n                                      const char *xStr, const char *yStr,\n                                      const char *value)\n{\n    countFailure();\n    _l-\u003efailedAssertDiffers(file, line, xStr, yStr, value);\n}\n\nvoid TestTracker::failedAssertLessThan(const char *file, int line,\n                                       const char *xStr, const char *yStr,\n                                       const char *x, const char *y)\n{\n    countFailure();\n    _l-\u003efailedAssertLessThan(file, line, xStr, yStr, x, y);\n}\n\nvoid TestTracker::failedAssertLessThanEquals(const char *file, int line,\n        const char *xStr, const char *yStr,\n        const char *x, const char *y)\n{\n    countFailure();\n    _l-\u003efailedAssertLessThanEquals(file, line, xStr, yStr, x, y);\n}\n\nvoid TestTracker::failedAssertPredicate(const char *file, int line,\n                                        const char *predicate, const char *xStr, const char *x)\n{\n    countFailure();\n    _l-\u003efailedAssertPredicate(file, line, predicate, xStr, x);\n}\n\nvoid TestTracker::failedAssertRelation(const char *file, int line,\n                                       const char *relation, const char *xStr, const char *yStr,\n                                       const char *x, const char *y)\n{\n    countFailure();\n    _l-\u003efailedAssertRelation(file, line, relation, xStr, yStr, x, y);\n}\n\nvoid TestTracker::failedAssertThrows(const char *file, int line,\n                                     const char *expression, const char *type,\n                                     bool otherThrown)\n{\n    countFailure();\n    _l-\u003efailedAssertThrows(file, line, expression, type, otherThrown);\n}\n\nvoid TestTracker::failedAssertThrowsNot(const char *file, int line, const char *expression)\n{\n    countFailure();\n    _l-\u003efailedAssertThrowsNot(file, line, expression);\n}\n\nvoid TestTracker::failedAssertSameFiles(const char *file, int line, const char *file1, const char* file2, const char* explanation)\n{\n    countFailure();\n    _l-\u003efailedAssertSameFiles(file, line, file1, file2, explanation);\n}\n\nvoid TestTracker::setWorld(const WorldDescription *w)\n{\n    _world = fixWorld(w);\n    setSuite(0);\n}\n\nvoid TestTracker::setSuite(const SuiteDescription *s)\n{\n    _suite = fixSuite(s);\n    setTest(0);\n}\n\nvoid TestTracker::setTest(const TestDescription *t)\n{\n    _test = fixTest(t);\n}\n\nvoid TestTracker::countWarning()\n{\n    ++ _warnings;\n}\n\nvoid TestTracker::countSkipped()\n{\n    ++ _skippedTests;\n}\n\nvoid TestTracker::countFailure()\n{\n    if (++ _testFailedAsserts == 1)\n    {\n        ++ _failedTests;\n        if (++ _suiteFailedTests == 1)\n        {\n            ++ _failedSuites;\n        }\n    }\n}\n}\n\n#endif // __cxxtest__TestTracker_cpp__\n\n"}
{"repo_name":"dandan94/OpenGLTest","ref":"refs/heads/master","path":"finalOpenGL/HelloGLFW/lib/boost_1_59_0/libs/lexical_cast/test/lexical_cast_iterator_range_test.cpp","copies":"39","language":"C++","content":"//  Unit test for boost::lexical_cast.\n//\n//  See http://www.boost.org for most recent version, including documentation.\n//\n//  Copyright Antony Polukhin, 2012.\n//\n//  Distributed under the Boost\n//  Software License, Version 1.0. (See accompanying file\n//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt).\n\n#include \u003cboost/config.hpp\u003e\n\n#if defined(__INTEL_COMPILER)\n#pragma warning(disable: 193 383 488 981 1418 1419)\n#elif defined(BOOST_MSVC)\n#pragma warning(disable: 4097 4100 4121 4127 4146 4244 4245 4511 4512 4701 4800)\n#endif\n\n#include \u003cboost/lexical_cast.hpp\u003e\n\n#include \u003cboost/test/unit_test.hpp\u003e\n#include \u003cboost/range/iterator_range.hpp\u003e\n\nusing namespace boost;\n\n#if defined(BOOST_NO_STRINGSTREAM) || defined(BOOST_NO_STD_WSTRING)\n#define BOOST_LCAST_NO_WCHAR_T\n#endif\n\n\n#if !defined(BOOST_NO_CXX11_CHAR16_T) \u0026\u0026 !defined(BOOST_NO_CXX11_UNICODE_LITERALS) \u0026\u0026 !defined(_LIBCPP_VERSION)\n#define BOOST_LC_RUNU16\n#endif\n\n#if !defined(BOOST_NO_CXX11_CHAR32_T) \u0026\u0026 !defined(BOOST_NO_CXX11_UNICODE_LITERALS) \u0026\u0026 !defined(_LIBCPP_VERSION)\n#define BOOST_LC_RUNU32\n#endif\n\nstruct class_with_user_defined_sream_operators {\n    int i;\n\n    operator int() const {\n        return i;\n    }\n};\n\ntemplate \u003cclass CharT\u003e\ninline std::basic_istream\u003cCharT\u003e\u0026 operator \u003e\u003e (std::basic_istream\u003cCharT\u003e\u0026 istr, class_with_user_defined_sream_operators\u0026 rhs)\n{\n    return istr \u003e\u003e rhs.i;\n}\n\n\ntemplate \u003cclass RngT\u003e\nvoid do_test_iterator_range_impl(const RngT\u0026 rng)\n{\n    BOOST_CHECK_EQUAL(lexical_cast\u003cint\u003e(rng), 1);\n    BOOST_CHECK_EQUAL(lexical_cast\u003cint\u003e(rng.begin(), rng.size()), 1);\n    BOOST_CHECK_EQUAL(lexical_cast\u003cunsigned int\u003e(rng), 1u);\n    BOOST_CHECK_EQUAL(lexical_cast\u003cunsigned int\u003e(rng.begin(), rng.size()), 1u);\n    BOOST_CHECK_EQUAL(lexical_cast\u003cshort\u003e(rng), 1);\n    BOOST_CHECK_EQUAL(lexical_cast\u003cshort\u003e(rng.begin(), rng.size()), 1);\n    BOOST_CHECK_EQUAL(lexical_cast\u003cunsigned short\u003e(rng), 1u);\n    BOOST_CHECK_EQUAL(lexical_cast\u003cunsigned short\u003e(rng.begin(), rng.size()), 1u);\n    BOOST_CHECK_EQUAL(lexical_cast\u003clong int\u003e(rng), 1);\n    BOOST_CHECK_EQUAL(lexical_cast\u003clong int\u003e(rng.begin(), rng.size()), 1);\n    BOOST_CHECK_EQUAL(lexical_cast\u003cunsigned long int\u003e(rng), 1u);\n    BOOST_CHECK_EQUAL(lexical_cast\u003cunsigned long int\u003e(rng.begin(), rng.size()), 1u);\n\n#ifdef BOOST_STL_SUPPORTS_NEW_UNICODE_LOCALES\n    BOOST_CHECK_EQUAL(lexical_cast\u003cfloat\u003e(rng), 1.0f);\n    BOOST_CHECK_EQUAL(lexical_cast\u003cfloat\u003e(rng.begin(), rng.size()), 1.0f);\n    BOOST_CHECK_EQUAL(lexical_cast\u003cdouble\u003e(rng), 1.0);\n    BOOST_CHECK_EQUAL(lexical_cast\u003cdouble\u003e(rng.begin(), rng.size()), 1.0);\n#ifndef BOOST_MATH_NO_LONG_DOUBLE_MATH_FUNCTIONS\n    BOOST_CHECK_EQUAL(lexical_cast\u003clong double\u003e(rng), 1.0L);\n    BOOST_CHECK_EQUAL(lexical_cast\u003clong double\u003e(rng.begin(), rng.size()), 1.0L);\n#endif\n    BOOST_CHECK_EQUAL(lexical_cast\u003cclass_with_user_defined_sream_operators\u003e(rng), 1);\n#endif\n#if defined(BOOST_HAS_LONG_LONG)\n    BOOST_CHECK_EQUAL(lexical_cast\u003cboost::ulong_long_type\u003e(rng), 1u);\n    BOOST_CHECK_EQUAL(lexical_cast\u003cboost::ulong_long_type\u003e(rng.begin(), rng.size()), 1u);\n    BOOST_CHECK_EQUAL(lexical_cast\u003cboost::long_long_type\u003e(rng), 1);\n    BOOST_CHECK_EQUAL(lexical_cast\u003cboost::long_long_type\u003e(rng.begin(), rng.size()), 1);\n#elif defined(BOOST_HAS_MS_INT64)\n    BOOST_CHECK_EQUAL(lexical_cast\u003cunsigned __int64\u003e(rng), 1u);\n    BOOST_CHECK_EQUAL(lexical_cast\u003cunsigned __int64\u003e(rng.begin(), rng.size()), 1u);\n    BOOST_CHECK_EQUAL(lexical_cast\u003c__int64\u003e(rng), 1);\n    BOOST_CHECK_EQUAL(lexical_cast\u003c__int64\u003e(rng.begin(), rng.size()), 1);\n#endif\n}\n\ntemplate \u003cclass CharT\u003e\nvoid test_it_range_using_any_chars(CharT* one, CharT* eleven)\n{\n    typedef CharT test_char_type;\n\n    // Zero terminated\n    iterator_range\u003ctest_char_type*\u003e rng1(one, one + 1);\n    do_test_iterator_range_impl(rng1);\n\n    iterator_range\u003cconst test_char_type*\u003e crng1(one, one + 1);\n    do_test_iterator_range_impl(crng1);\n\n    // Non zero terminated\n    iterator_range\u003ctest_char_type*\u003e rng2(eleven, eleven + 1);\n    do_test_iterator_range_impl(rng2);\n\n    iterator_range\u003cconst test_char_type*\u003e crng2(eleven, eleven + 1);\n    do_test_iterator_range_impl(crng2);\n}\n\ntemplate \u003cclass CharT\u003e\nvoid test_it_range_using_char(CharT* one, CharT* eleven)\n{\n    typedef CharT test_char_type;\n\n    iterator_range\u003ctest_char_type*\u003e rng1(one, one + 1);\n    BOOST_CHECK_EQUAL(lexical_cast\u003cstd::string\u003e(rng1), \"1\");\n\n    iterator_range\u003cconst test_char_type*\u003e crng1(one, one + 1);\n    BOOST_CHECK_EQUAL(lexical_cast\u003cstd::string\u003e(crng1), \"1\");\n\n    iterator_range\u003ctest_char_type*\u003e rng2(eleven, eleven + 1);\n    BOOST_CHECK_EQUAL(lexical_cast\u003cstd::string\u003e(rng2), \"1\");\n\n    iterator_range\u003cconst test_char_type*\u003e crng2(eleven, eleven + 1);\n    BOOST_CHECK_EQUAL(lexical_cast\u003cstd::string\u003e(crng2), \"1\");\n\n    BOOST_CHECK_EQUAL(lexical_cast\u003cfloat\u003e(rng1), 1.0f);\n    BOOST_CHECK_EQUAL(lexical_cast\u003cdouble\u003e(rng1), 1.0);\n#ifndef BOOST_MATH_NO_LONG_DOUBLE_MATH_FUNCTIONS\n    BOOST_CHECK_EQUAL(lexical_cast\u003clong double\u003e(rng1), 1.0L);\n#endif\n    BOOST_CHECK_EQUAL(lexical_cast\u003cclass_with_user_defined_sream_operators\u003e(rng1), 1);\n\n    BOOST_CHECK_EQUAL(lexical_cast\u003cfloat\u003e(crng2), 1.0f);\n    BOOST_CHECK_EQUAL(lexical_cast\u003cdouble\u003e(crng2), 1.0);\n#ifndef BOOST_MATH_NO_LONG_DOUBLE_MATH_FUNCTIONS\n    BOOST_CHECK_EQUAL(lexical_cast\u003clong double\u003e(crng2), 1.0L);\n#endif\n    BOOST_CHECK_EQUAL(lexical_cast\u003cclass_with_user_defined_sream_operators\u003e(crng2), 1);\n\n#ifndef BOOST_LCAST_NO_WCHAR_T\n    BOOST_CHECK(lexical_cast\u003cstd::wstring\u003e(rng1) == L\"1\");\n    BOOST_CHECK(lexical_cast\u003cstd::wstring\u003e(crng1) == L\"1\");\n    BOOST_CHECK(lexical_cast\u003cstd::wstring\u003e(rng2) == L\"1\");\n    BOOST_CHECK(lexical_cast\u003cstd::wstring\u003e(crng2) == L\"1\");\n#endif\n\n#if defined(BOOST_LC_RUNU16) \u0026\u0026 defined(BOOST_STL_SUPPORTS_NEW_UNICODE_LOCALES)\n    typedef std::basic_string\u003cchar16_t\u003e my_char16_string;\n    BOOST_CHECK(lexical_cast\u003cmy_char16_string\u003e(rng1) == u\"1\");\n    BOOST_CHECK(lexical_cast\u003cmy_char16_string\u003e(crng1) == u\"1\");\n    BOOST_CHECK(lexical_cast\u003cmy_char16_string\u003e(rng2) == u\"1\");\n    BOOST_CHECK(lexical_cast\u003cmy_char16_string\u003e(crng2) == u\"1\");\n#endif\n\n#if defined(BOOST_LC_RUNU32) \u0026\u0026 defined(BOOST_STL_SUPPORTS_NEW_UNICODE_LOCALES)\n    typedef std::basic_string\u003cchar32_t\u003e my_char32_string;\n    BOOST_CHECK(lexical_cast\u003cmy_char32_string\u003e(rng1) == U\"1\");\n    BOOST_CHECK(lexical_cast\u003cmy_char32_string\u003e(crng1) == U\"1\");\n    BOOST_CHECK(lexical_cast\u003cmy_char32_string\u003e(rng2) == U\"1\");\n    BOOST_CHECK(lexical_cast\u003cmy_char32_string\u003e(crng2) == U\"1\");\n#endif\n}\n\nvoid test_char_iterator_ranges()\n{\n    typedef char test_char_type;\n    test_char_type data1[] = \"1\";\n    test_char_type data2[] = \"11\";\n    test_it_range_using_any_chars(data1, data2);\n    test_it_range_using_char(data1, data2);\n}\n\n\n\nvoid test_unsigned_char_iterator_ranges()\n{\n    typedef unsigned char test_char_type;\n    test_char_type data1[] = \"1\";\n    test_char_type data2[] = \"11\";\n    test_it_range_using_any_chars(data1, data2);\n    test_it_range_using_char(data1, data2);\n}\n\nvoid test_signed_char_iterator_ranges()\n{\n    typedef signed char test_char_type;\n    test_char_type data1[] = \"1\";\n    test_char_type data2[] = \"11\";\n    test_it_range_using_any_chars(data1, data2);\n    test_it_range_using_char(data1, data2);\n}\n\nvoid test_wchar_iterator_ranges()\n{\n#ifndef BOOST_LCAST_NO_WCHAR_T\n    typedef wchar_t test_char_type;\n    test_char_type data1[] = L\"1\";\n    test_char_type data2[] = L\"11\";\n    test_it_range_using_any_chars(data1, data2);\n#endif\n\n    BOOST_CHECK(true);\n}\n\nvoid test_char16_iterator_ranges()\n{\n#if defined(BOOST_LC_RUNU16)\n    typedef char16_t test_char_type;\n    test_char_type data1[] = u\"1\";\n    test_char_type data2[] = u\"11\";\n    test_it_range_using_any_chars(data1, data2);\n#endif\n\n    BOOST_CHECK(true);\n}\n\nvoid test_char32_iterator_ranges()\n{\n#if defined(BOOST_LC_RUNU32)\n    typedef char32_t test_char_type;\n    test_char_type data1[] = U\"1\";\n    test_char_type data2[] = U\"11\";\n    test_it_range_using_any_chars(data1, data2);\n#endif\n\n    BOOST_CHECK(true);\n}\n\nunit_test::test_suite *init_unit_test_suite(int, char *[])\n{\n    unit_test::test_suite *suite = BOOST_TEST_SUITE(\"lexical_cast. Testing conversions using iterator_range\u003c\u003e\");\n    suite-\u003eadd(BOOST_TEST_CASE(\u0026test_char_iterator_ranges));\n    suite-\u003eadd(BOOST_TEST_CASE(\u0026test_unsigned_char_iterator_ranges));\n    suite-\u003eadd(BOOST_TEST_CASE(\u0026test_signed_char_iterator_ranges));\n    suite-\u003eadd(BOOST_TEST_CASE(\u0026test_wchar_iterator_ranges));\n    suite-\u003eadd(BOOST_TEST_CASE(\u0026test_char16_iterator_ranges));\n    suite-\u003eadd(BOOST_TEST_CASE(\u0026test_char32_iterator_ranges));\n\n    return suite;\n}\n"}
{"repo_name":"LiquidShockGames/bongobucks","ref":"refs/heads/master","path":"src/qt/sendcoinsdialog.cpp","copies":"1083","language":"C++","content":"#include \"sendcoinsdialog.h\"\n#include \"ui_sendcoinsdialog.h\"\n#include \"walletmodel.h\"\n#include \"bitcoinunits.h\"\n#include \"addressbookpage.h\"\n#include \"optionsmodel.h\"\n#include \"sendcoinsentry.h\"\n#include \"guiutil.h\"\n#include \"askpassphrasedialog.h\"\n\n#include \u003cQMessageBox\u003e\n#include \u003cQLocale\u003e\n#include \u003cQTextDocument\u003e\n#include \u003cQScrollBar\u003e\n\nSendCoinsDialog::SendCoinsDialog(QWidget *parent) :\n    QDialog(parent),\n    ui(new Ui::SendCoinsDialog),\n    model(0)\n{\n    ui-\u003esetupUi(this);\n\n#ifdef Q_WS_MAC // Icons on push buttons are very uncommon on Mac\n    ui-\u003eaddButton-\u003esetIcon(QIcon());\n    ui-\u003eclearButton-\u003esetIcon(QIcon());\n    ui-\u003esendButton-\u003esetIcon(QIcon());\n#endif\n\n    addEntry();\n\n    connect(ui-\u003eaddButton, SIGNAL(clicked()), this, SLOT(addEntry()));\n    connect(ui-\u003eclearButton, SIGNAL(clicked()), this, SLOT(clear()));\n\n    fNewRecipientAllowed = true;\n}\n\nvoid SendCoinsDialog::setModel(WalletModel *model)\n{\n    this-\u003emodel = model;\n\n    for(int i = 0; i \u003c ui-\u003eentries-\u003ecount(); ++i)\n    {\n        SendCoinsEntry *entry = qobject_cast\u003cSendCoinsEntry*\u003e(ui-\u003eentries-\u003eitemAt(i)-\u003ewidget());\n        if(entry)\n        {\n            entry-\u003esetModel(model);\n        }\n    }\n    if(model \u0026\u0026 model-\u003egetOptionsModel())\n    {\n        setBalance(model-\u003egetBalance(), model-\u003egetUnconfirmedBalance(), model-\u003egetImmatureBalance());\n        connect(model, SIGNAL(balanceChanged(qint64, qint64, qint64)), this, SLOT(setBalance(qint64, qint64, qint64)));\n        connect(model-\u003egetOptionsModel(), SIGNAL(displayUnitChanged(int)), this, SLOT(updateDisplayUnit()));\n    }\n}\n\nSendCoinsDialog::~SendCoinsDialog()\n{\n    delete ui;\n}\n\nvoid SendCoinsDialog::on_sendButton_clicked()\n{\n    QList\u003cSendCoinsRecipient\u003e recipients;\n    bool valid = true;\n\n    if(!model)\n        return;\n\n    for(int i = 0; i \u003c ui-\u003eentries-\u003ecount(); ++i)\n    {\n        SendCoinsEntry *entry = qobject_cast\u003cSendCoinsEntry*\u003e(ui-\u003eentries-\u003eitemAt(i)-\u003ewidget());\n        if(entry)\n        {\n            if(entry-\u003evalidate())\n            {\n                recipients.append(entry-\u003egetValue());\n            }\n            else\n            {\n                valid = false;\n            }\n        }\n    }\n\n    if(!valid || recipients.isEmpty())\n    {\n        return;\n    }\n\n    // Format confirmation message\n    QStringList formatted;\n    foreach(const SendCoinsRecipient \u0026rcp, recipients)\n    {\n        formatted.append(tr(\"\u003cb\u003e%1\u003c/b\u003e to %2 (%3)\").arg(BitcoinUnits::formatWithUnit(BitcoinUnits::BTC, rcp.amount), Qt::escape(rcp.label), rcp.address));\n    }\n\n    fNewRecipientAllowed = false;\n\n    QMessageBox::StandardButton retval = QMessageBox::question(this, tr(\"Confirm send coins\"),\n                          tr(\"Are you sure you want to send %1?\").arg(formatted.join(tr(\" and \"))),\n          QMessageBox::Yes|QMessageBox::Cancel,\n          QMessageBox::Cancel);\n\n    if(retval != QMessageBox::Yes)\n    {\n        fNewRecipientAllowed = true;\n        return;\n    }\n\n    WalletModel::UnlockContext ctx(model-\u003erequestUnlock());\n    if(!ctx.isValid())\n    {\n        // Unlock wallet was cancelled\n        fNewRecipientAllowed = true;\n        return;\n    }\n\n    WalletModel::SendCoinsReturn sendstatus = model-\u003esendCoins(recipients);\n    switch(sendstatus.status)\n    {\n    case WalletModel::InvalidAddress:\n        QMessageBox::warning(this, tr(\"Send Coins\"),\n            tr(\"The recepient address is not valid, please recheck.\"),\n            QMessageBox::Ok, QMessageBox::Ok);\n        break;\n    case WalletModel::InvalidAmount:\n        QMessageBox::warning(this, tr(\"Send Coins\"),\n            tr(\"The amount to pay must be larger than 0.\"),\n            QMessageBox::Ok, QMessageBox::Ok);\n        break;\n    case WalletModel::AmountExceedsBalance:\n        QMessageBox::warning(this, tr(\"Send Coins\"),\n            tr(\"The amount exceeds your balance.\"),\n            QMessageBox::Ok, QMessageBox::Ok);\n        break;\n    case WalletModel::AmountWithFeeExceedsBalance:\n        QMessageBox::warning(this, tr(\"Send Coins\"),\n            tr(\"The total exceeds your balance when the %1 transaction fee is included.\").\n            arg(BitcoinUnits::formatWithUnit(BitcoinUnits::BTC, sendstatus.fee)),\n            QMessageBox::Ok, QMessageBox::Ok);\n        break;\n    case WalletModel::DuplicateAddress:\n        QMessageBox::warning(this, tr(\"Send Coins\"),\n            tr(\"Duplicate address found, can only send to each address once per send operation.\"),\n            QMessageBox::Ok, QMessageBox::Ok);\n        break;\n    case WalletModel::TransactionCreationFailed:\n        QMessageBox::warning(this, tr(\"Send Coins\"),\n            tr(\"Error: Transaction creation failed.\"),\n            QMessageBox::Ok, QMessageBox::Ok);\n        break;\n    case WalletModel::TransactionCommitFailed:\n        QMessageBox::warning(this, tr(\"Send Coins\"),\n            tr(\"Error: The transaction was rejected. This might happen if some of the coins in your wallet were already spent, such as if you used a copy of wallet.dat and coins were spent in the copy but not marked as spent here.\"),\n            QMessageBox::Ok, QMessageBox::Ok);\n        break;\n    case WalletModel::Aborted: // User aborted, nothing to do\n        break;\n    case WalletModel::OK:\n        accept();\n        break;\n    }\n    fNewRecipientAllowed = true;\n}\n\nvoid SendCoinsDialog::clear()\n{\n    // Remove entries until only one left\n    while(ui-\u003eentries-\u003ecount())\n    {\n        delete ui-\u003eentries-\u003etakeAt(0)-\u003ewidget();\n    }\n    addEntry();\n\n    updateRemoveEnabled();\n\n    ui-\u003esendButton-\u003esetDefault(true);\n}\n\nvoid SendCoinsDialog::reject()\n{\n    clear();\n}\n\nvoid SendCoinsDialog::accept()\n{\n    clear();\n}\n\nSendCoinsEntry *SendCoinsDialog::addEntry()\n{\n    SendCoinsEntry *entry = new SendCoinsEntry(this);\n    entry-\u003esetModel(model);\n    ui-\u003eentries-\u003eaddWidget(entry);\n    connect(entry, SIGNAL(removeEntry(SendCoinsEntry*)), this, SLOT(removeEntry(SendCoinsEntry*)));\n\n    updateRemoveEnabled();\n\n    // Focus the field, so that entry can start immediately\n    entry-\u003eclear();\n    entry-\u003esetFocus();\n    ui-\u003escrollAreaWidgetContents-\u003eresize(ui-\u003escrollAreaWidgetContents-\u003esizeHint());\n    QCoreApplication::instance()-\u003eprocessEvents();\n    QScrollBar* bar = ui-\u003escrollArea-\u003everticalScrollBar();\n    if(bar)\n        bar-\u003esetSliderPosition(bar-\u003emaximum());\n    return entry;\n}\n\nvoid SendCoinsDialog::updateRemoveEnabled()\n{\n    // Remove buttons are enabled as soon as there is more than one send-entry\n    bool enabled = (ui-\u003eentries-\u003ecount() \u003e 1);\n    for(int i = 0; i \u003c ui-\u003eentries-\u003ecount(); ++i)\n    {\n        SendCoinsEntry *entry = qobject_cast\u003cSendCoinsEntry*\u003e(ui-\u003eentries-\u003eitemAt(i)-\u003ewidget());\n        if(entry)\n        {\n            entry-\u003esetRemoveEnabled(enabled);\n        }\n    }\n    setupTabChain(0);\n}\n\nvoid SendCoinsDialog::removeEntry(SendCoinsEntry* entry)\n{\n    delete entry;\n    updateRemoveEnabled();\n}\n\nQWidget *SendCoinsDialog::setupTabChain(QWidget *prev)\n{\n    for(int i = 0; i \u003c ui-\u003eentries-\u003ecount(); ++i)\n    {\n        SendCoinsEntry *entry = qobject_cast\u003cSendCoinsEntry*\u003e(ui-\u003eentries-\u003eitemAt(i)-\u003ewidget());\n        if(entry)\n        {\n            prev = entry-\u003esetupTabChain(prev);\n        }\n    }\n    QWidget::setTabOrder(prev, ui-\u003eaddButton);\n    QWidget::setTabOrder(ui-\u003eaddButton, ui-\u003esendButton);\n    return ui-\u003esendButton;\n}\n\nvoid SendCoinsDialog::pasteEntry(const SendCoinsRecipient \u0026rv)\n{\n    if(!fNewRecipientAllowed)\n        return;\n\n    SendCoinsEntry *entry = 0;\n    // Replace the first entry if it is still unused\n    if(ui-\u003eentries-\u003ecount() == 1)\n    {\n        SendCoinsEntry *first = qobject_cast\u003cSendCoinsEntry*\u003e(ui-\u003eentries-\u003eitemAt(0)-\u003ewidget());\n        if(first-\u003eisClear())\n        {\n            entry = first;\n        }\n    }\n    if(!entry)\n    {\n        entry = addEntry();\n    }\n\n    entry-\u003esetValue(rv);\n}\n\nbool SendCoinsDialog::handleURI(const QString \u0026uri)\n{\n    SendCoinsRecipient rv;\n    // URI has to be valid\n    if (GUIUtil::parseBitcoinURI(uri, \u0026rv))\n    {\n        pasteEntry(rv);\n        return true;\n    }\n\n    return false;\n}\n\nvoid SendCoinsDialog::setBalance(qint64 balance, qint64 unconfirmedBalance, qint64 immatureBalance)\n{\n    Q_UNUSED(unconfirmedBalance);\n    Q_UNUSED(immatureBalance);\n    if(!model || !model-\u003egetOptionsModel())\n        return;\n\n    int unit = model-\u003egetOptionsModel()-\u003egetDisplayUnit();\n    ui-\u003elabelBalance-\u003esetText(BitcoinUnits::formatWithUnit(unit, balance));\n}\n\nvoid SendCoinsDialog::updateDisplayUnit()\n{\n    if(model \u0026\u0026 model-\u003egetOptionsModel())\n    {\n        // Update labelBalance with the current balance and the current unit\n        ui-\u003elabelBalance-\u003esetText(BitcoinUnits::formatWithUnit(model-\u003egetOptionsModel()-\u003egetDisplayUnit(), model-\u003egetBalance()));\n    }\n}\n"}
{"repo_name":"BenKeyFSI/poedit","ref":"refs/heads/master","path":"deps/boost/libs/wave/test/testwave/testfiles/t_6_044.cpp","copies":"56","language":"C++","content":"/*=============================================================================\n    Boost.Wave: A Standard compliant C++ preprocessor library\n    http://www.boost.org/\n\n    Copyright (c) 2001-2012 Hartmut Kaiser. Distributed under the Boost\n    Software License, Version 1.0. (See accompanying file\n    LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n\n    The tests included in this file were initially taken from the mcpp V2.5\n    preprocessor validation suite and were modified to fit into the Boost.Wave \n    unit test requirements.\n    The original files of the mcpp preprocessor are distributed under the \n    license reproduced at the end of this file.\n=============================================================================*/\n\n// Tests error reporting: The ## operator shall not occur at the beginning or at \n//                        the end of replacement list for either form of macro \n//                        definition.\n\n// 23.3: In object-like macro (left).\n#define CON     ## name\n\n//E t_6_044.cpp(24): error: ill formed preprocessing operator: concat ('##')\nCON\n\n/*-\n * Copyright (c) 1998, 2002-2005 Kiyoshi Matsui \u003ckmatsui@t3.rim.or.jp\u003e\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n"}
{"repo_name":"MestreLion/boinc-debian","ref":"refs/heads/master","path":"clientgui/BOINCGUIApp.cpp","copies":"1","language":"C++","content":"// This file is part of BOINC.\n// http://boinc.berkeley.edu\n// Copyright (C) 2008 University of California\n//\n// BOINC is free software; you can redistribute it and/or modify it\n// under the terms of the GNU Lesser General Public License\n// as published by the Free Software Foundation,\n// either version 3 of the License, or (at your option) any later version.\n//\n// BOINC is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n// See the GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with BOINC.  If not, see \u003chttp://www.gnu.org/licenses/\u003e.\n\n#if defined(__GNUG__) \u0026\u0026 !defined(__APPLE__)\n#pragma implementation \"BOINCGUIApp.h\"\n#endif\n\n#ifdef __WXMAC__\n#include \u003cCarbon/Carbon.h\u003e\n#include \"filesys.h\"\n#include \"util.h\"\n#if (defined(SANDBOX) \u0026\u0026 defined(_DEBUG))\n#include \"SetupSecurity.h\"\n#endif\n#include \"sandbox.h\"\n#endif\n\n#include \"stdwx.h\"\n#include \"diagnostics.h\"\n#include \"network.h\"\n#include \"util.h\"\n#include \"mfile.h\"\n#include \"miofile.h\"\n#include \"parse.h\"\n#include \"idlemon.h\"\n#include \"Events.h\"\n#include \"common/wxFlatNotebook.h\"\n#include \"BOINCInternetFSHandler.h\"\n#include \"LogBOINC.h\"\n#include \"BOINCGUIApp.h\"\n#include \"SkinManager.h\"\n#include \"MainDocument.h\"\n#include \"BOINCClientManager.h\"\n#include \"BOINCTaskBar.h\"\n#include \"BOINCBaseFrame.h\"\n#include \"AdvancedFrame.h\"\n#include \"DlgExitMessage.h\"\n#include \"DlgEventLog.h\"\n#include \"procinfo.h\"\n#include \"sg_BoincSimpleFrame.h\"\n\n\nDEFINE_EVENT_TYPE(wxEVT_RPC_FINISHED)\n\nIMPLEMENT_APP(CBOINCGUIApp)\nIMPLEMENT_DYNAMIC_CLASS(CBOINCGUIApp, wxApp)\n\nBEGIN_EVENT_TABLE (CBOINCGUIApp, wxApp)\n    EVT_ACTIVATE_APP(CBOINCGUIApp::OnActivateApp)\n    EVT_RPC_FINISHED(CBOINCGUIApp::OnRPCFinished)\nEND_EVENT_TABLE ()\n\n\nbool s_bSkipExitConfirmation = false;\n\n#ifdef __WXMAC__\n\n// Set s_bSkipExitConfirmation to true if cancelled because of logging out or shutting down\nOSErr QuitAppleEventHandler( const AppleEvent *appleEvt, AppleEvent* reply, UInt32 refcon ) {\n        DescType            senderType;\n        Size                actualSize;\n        ProcessSerialNumber SenderPSN;\n        ProcessInfoRec      pInfo;\n        FSSpec              fileSpec;\n        OSStatus            anErr;\n\n        // Refuse to quit if a modal dialog is open.  \n        // Unfortunately, I know of no way to disable the Quit item in our Dock menu\n        if (wxGetApp().IsModalDialogDisplayed()) {\n            SysBeep(4);\n            return userCanceledErr;\n        }\n                \n        anErr = AEGetAttributePtr(appleEvt, keyAddressAttr, typeProcessSerialNumber,\n                                    \u0026senderType, \u0026SenderPSN, sizeof(SenderPSN), \u0026actualSize);\n\n        if (anErr == noErr) {\n            pInfo.processInfoLength = sizeof( ProcessInfoRec );\n            pInfo.processName = NULL;\n            pInfo.processAppSpec = \u0026fileSpec;\n\n            anErr = GetProcessInformation(\u0026SenderPSN, \u0026pInfo);\n\n            // Consider a Quit command from our Dock menu as coming from this application\n            if ( (pInfo.processSignature != 'dock') \u0026\u0026 (pInfo.processSignature != 'BNC!') ) {\n                s_bSkipExitConfirmation = true; // Not from our app, our dock icon or our taskbar icon\n                wxGetApp().ExitMainLoop();  // Prevents wxMac from issuing events to closed frames\n            }\n        }\n    \n    return wxGetApp().MacHandleAEQuit((AppleEvent*)appleEvt, reply);\n}\n\n#endif\n\n\nbool CBOINCGUIApp::OnInit() {\n    // Initialize globals\n#ifdef SANDBOX\n    g_use_sandbox = true;\n#else\n    g_use_sandbox = false;\n#endif\n\n    s_bSkipExitConfirmation = false;\n    m_bFilterEvents = false;\n\n    // Initialize class variables\n    m_pLocale = NULL;\n    m_pSkinManager = NULL;\n    m_pFrame = NULL;\n    m_pDocument = NULL;\n    m_pTaskBarIcon = NULL;\n    m_pEventLog = NULL;\n#ifdef __WXMAC__\n    m_pMacSystemMenu = NULL;\n#endif\n    m_strBOINCMGRExecutableName = wxEmptyString;\n    m_strBOINCMGRRootDirectory = wxEmptyString;\n    m_strBOINCMGRDataDirectory = wxEmptyString;\n    m_strHostNameArg = wxEmptyString;\n    m_strPasswordArg = wxEmptyString;\n    m_iRPCPortArg = GUI_RPC_PORT;\n    m_strBOINCArguments = wxEmptyString;\n    m_bGUIVisible = true;\n    m_bDebugSkins = false;\n    m_bMultipleInstancesOK = false;\n    m_bBOINCMGRAutoStarted = false;\n    m_iBOINCMGRDisableAutoStart = 0;\n    m_iShutdownCoreClient = 0;\n    m_iDisplayExitDialog = 1;\n    m_iGUISelected = BOINC_SIMPLEGUI;\n    m_bSafeMessageBoxDisplayed = 0;\n#ifdef __WXMSW__\n    m_hClientLibraryDll = NULL;\n#endif\n\n\n    // Initialize local variables\n    int      iErrorCode = 0;\n    int      iSelectedLanguage = 0;\n    bool     bOpenEventLog = false;\n    wxString strDesiredSkinName = wxEmptyString;\n    wxString strDialogMessage = wxEmptyString;\n    bool     success = false;\n\n\n    // Configure wxWidgets platform specific code\n#ifdef __WXMSW__\n    wxSystemOptions::SetOption(wxT(\"msw.staticbox.optimized-paint\"), 0);\n#endif\n#ifdef __WXMAC__\n    // In wxMac-2.8.7, default wxListCtrl::RefreshItem() does not work\n    // so use traditional generic implementation.\n    // This has been fixed in wxMac-2.8.8, but the Mac native implementation:\n    //  - takes 3 times the CPU time as the Mac generic version.\n    //  - seems to always redraw entire control even if asked to refresh only one row.\n    //  - causes major flicker of progress bars, (probably due to full redraws.)\n    wxSystemOptions::SetOption(wxT(\"mac.listctrl.always_use_generic\"), 1);\n\n    AEInstallEventHandler( kCoreEventClass, kAEQuitApplication, NewAEEventHandlerUPP((AEEventHandlerProcPtr)QuitAppleEventHandler), 0, false );\n\n    // Cache the current process serial number\n    GetCurrentProcess(\u0026m_psnCurrentProcess);\n#endif\n\n\n    // Commandline parsing is done in wxApp::OnInit()\n    if (!wxApp::OnInit()) {\n        return false;\n    }\n\n    if (g_use_sandbox) {\n        wxCHANGE_UMASK(2);  // Set file creation mask to be writable by both user and group\n                            // Our umask will be inherited by all our child processes\n    }\n\n    // Setup application and company information\n    SetAppName(wxT(\"BOINC Manager\"));\n    SetVendorName(wxT(\"Space Sciences Laboratory, U.C. Berkeley\"));\n\n\n    // Initialize the configuration storage module\n    m_pConfig = new wxConfig(GetAppName());\n    wxConfigBase::Set(m_pConfig);\n    wxASSERT(m_pConfig);\n\n\n    // Restore Application State\n    m_pConfig-\u003eSetPath(wxT(\"/\"));\n    m_pConfig-\u003eRead(wxT(\"AutomaticallyShutdownClient\"), \u0026m_iShutdownCoreClient, 0L);\n    m_pConfig-\u003eRead(wxT(\"DisplayShutdownClientDialog\"), \u0026m_iDisplayExitDialog, 1L);\n    m_pConfig-\u003eRead(wxT(\"DisableAutoStart\"), \u0026m_iBOINCMGRDisableAutoStart, 0L);\n    m_pConfig-\u003eRead(wxT(\"Language\"), \u0026iSelectedLanguage, 0L);\n    m_pConfig-\u003eRead(wxT(\"GUISelection\"), \u0026m_iGUISelected, BOINC_SIMPLEGUI);\n    m_pConfig-\u003eRead(wxT(\"EventLogOpen\"), \u0026bOpenEventLog);\n\n\n    // Should we abort the BOINC Manager startup process?\n    if (m_bBOINCMGRAutoStarted \u0026\u0026 m_iBOINCMGRDisableAutoStart) {\n        return false;\n    }\n\n    // Detect where BOINC Manager executable name.\n    DetectExecutableName();\n\n    // Detect where BOINC Manager was installed too.\n    DetectRootDirectory();\n\n    // Detect where the BOINC Data files are.\n    DetectDataDirectory();\n\n\n    // Switch the current directory to the BOINC Data directory\n    if (!GetDataDirectory().IsEmpty()) {\n    \tsuccess = wxSetWorkingDirectory(GetDataDirectory());\n        if (!success) {\n            if (!g_use_sandbox) {\n                if (!wxDirExists(GetDataDirectory())) {\n                    success = wxMkdir(GetDataDirectory(), 0777);    // Does nothing if dir exists\n                }\n            }\n        }\n    }\n\n    if (!success) iErrorCode = -1016;\n\n    // Initialize the BOINC Diagnostics Framework\n    int dwDiagnosticsFlags =\n        BOINC_DIAG_DUMPCALLSTACKENABLED | \n        BOINC_DIAG_HEAPCHECKENABLED |\n        BOINC_DIAG_MEMORYLEAKCHECKENABLED |\n#if defined(__WXMSW__) || defined(__WXMAC__)\n        BOINC_DIAG_REDIRECTSTDERR |\n        BOINC_DIAG_REDIRECTSTDOUT |\n#endif\n        BOINC_DIAG_TRACETOSTDOUT;\n\n    diagnostics_init(\n        dwDiagnosticsFlags,\n        \"stdoutgui\",\n        \"stderrgui\"\n    );\n\n\n    // Enable Logging and Trace Masks\n    m_pLog = new wxLogBOINC();\n    wxLog::SetActiveTarget(m_pLog);\n\n    m_pLog-\u003eAddTraceMask(wxT(\"Function Start/End\"));\n    m_pLog-\u003eAddTraceMask(wxT(\"Function Status\"));\n\n\n    // Initialize the internationalization module\n#ifdef __WXMSW__\n    // On Windows, set all locales for this thread on a per-thread basis\n    _configthreadlocale(_ENABLE_PER_THREAD_LOCALE);\n#endif\n    m_pLocale = new wxLocale();\n    wxASSERT(m_pLocale);\n\n\n    // Look for the localization files by absolute and relative locations.\n    //   preference given to the absolute location.\n    m_pLocale-\u003eInit(iSelectedLanguage);\n    if (!m_strBOINCMGRRootDirectory.IsEmpty()) {\n        m_pLocale-\u003eAddCatalogLookupPathPrefix(\n            wxString(m_strBOINCMGRRootDirectory + wxT(\"locale\"))\n        );\n    }\n    m_pLocale-\u003eAddCatalogLookupPathPrefix(wxT(\"locale\"));\n    m_pLocale-\u003eAddCatalog(wxT(\"BOINC-Manager\"));\n    m_pLocale-\u003eAddCatalog(wxT(\"BOINC-Client\"));\n    m_pLocale-\u003eAddCatalog(wxT(\"BOINC-Web\"));\n\n    InitSupportedLanguages();\n\n\n    // Note: JAWS for Windows will only speak the context-sensitive\n    // help if you use this help provider:\n    wxHelpProvider::Set(new wxHelpControllerHelpProvider());\n\n \n    // Enable known image types\n    wxInitAllImageHandlers();\n\n    // Enable additional file system type handlers\n    wxFileSystem::AddHandler(new wxMemoryFSHandler);\n    m_pInternetFSHandler = new CBOINCInternetFSHandler;\n    wxFileSystem::AddHandler(m_pInternetFSHandler);\n\n    // Initialize the skin manager\n    m_pSkinManager = new CSkinManager(m_bDebugSkins);\n    wxASSERT(m_pSkinManager);\n\n\n    // Load desired manager skin\n    m_pConfig-\u003eRead(wxT(\"Skin\"), \u0026strDesiredSkinName, m_pSkinManager-\u003eGetDefaultSkinName());\n    m_pSkinManager-\u003eReloadSkin(strDesiredSkinName);\n\n\n#ifdef SANDBOX\n    // Make sure owners, groups and permissions are correct for the current setting of g_use_sandbox\n    char path_to_error[MAXPATHLEN];\n    path_to_error[0] = '\\0';\n    \n    if (!iErrorCode) {\n#if (defined(__WXMAC__) \u0026\u0026 defined(_DEBUG))     // TODO: implement this for other platforms\n        // GDB can't attach to applications which are running as a different user   \n        //  or group, so fix up data with current user and group during debugging\n        if (check_security(g_use_sandbox, true)) {\n            CreateBOINCUsersAndGroups();\n            SetBOINCDataOwnersGroupsAndPermissions();\n            SetBOINCAppOwnersGroupsAndPermissions(NULL);\n        }\n#endif\n        iErrorCode = check_security(g_use_sandbox, true, path_to_error);\n    }\n\n    if (iErrorCode) {\n\n        ShowApplication(true);\n\n        if (iErrorCode == -1099) {\n            strDialogMessage.Printf(\n                _(\"You currently are not authorized to manage the client.\\n\\nTo run %s as this user, please:\\n  - reinstall %s answering \\\"Yes\\\" to the question about\\n     non-administrative users\\n or\\n  - contact your administrator to add you to the 'boinc_master'\\n     user group.\"),\n                m_pSkinManager-\u003eGetAdvanced()-\u003eGetApplicationShortName().c_str(),\n                m_pSkinManager-\u003eGetAdvanced()-\u003eGetApplicationShortName().c_str()\n            );\n        } else {\n            strDialogMessage.Printf(\n                _(\"%s ownership or permissions are not set properly; please reinstall %s.\\n(Error code %d\"),\n                m_pSkinManager-\u003eGetAdvanced()-\u003eGetApplicationShortName().c_str(),\n                m_pSkinManager-\u003eGetAdvanced()-\u003eGetApplicationShortName().c_str(),\n                iErrorCode\n            );\n            if (path_to_error[0]) {\n                strDialogMessage += _(\" at \");\n                strDialogMessage += wxString::FromUTF8(path_to_error);\n            }\n            strDialogMessage += _(\")\");\n            \n            fprintf(stderr, \"%ls ownership or permissions are not set properly; please reinstall %ls.\\n(Error code %d at %s)\", \n                    m_pSkinManager-\u003eGetAdvanced()-\u003eGetApplicationShortName().c_str(),\n                    m_pSkinManager-\u003eGetAdvanced()-\u003eGetApplicationShortName().c_str(),\n                    iErrorCode, path_to_error\n                );\n        }\n        wxMessageDialog* pDlg = new wxMessageDialog(\n                                    NULL, \n                                    strDialogMessage, \n                                    m_pSkinManager-\u003eGetAdvanced()-\u003eGetApplicationName(), \n                                    wxOK\n                                    );\n\n        pDlg-\u003eShowModal();\n        if (pDlg)\n            pDlg-\u003eDestroy();\n\n        return false;\n    }\n#endif      // SANDBOX\n\n\n#ifdef __WXMSW__\n    // Perform any last minute checks that should keep the manager\n    // from starting up.\n    wxString strRebootPendingFile = \n        GetRootDirectory() + wxFileName::GetPathSeparator() + wxT(\"RebootPending.txt\");\n    \n    if (wxFile::Exists(strRebootPendingFile)) {\n        wxMessageDialog dialog(\n            NULL,\n            _(\"A reboot is required in order for BOINC to run properly.\\nPlease reboot your computer and try again.\"),\n            _(\"BOINC Manager\"),\n            wxOK|wxICON_ERROR\n        );\n\n        dialog.ShowModal();\n        return false;\n    }\n#endif\n\n    // Detect if BOINC Manager is already running, if so, bring it into the\n    // foreground and then exit.\n    if (!m_bMultipleInstancesOK) {\n        if (DetectDuplicateInstance()) {\n            return false;\n        }\n    }\n\n    // Initialize the main document\n    m_pDocument = new CMainDocument();\n    wxASSERT(m_pDocument);\n\n    m_pDocument-\u003eOnInit();\n\n\n    // Is there a condition in which the Simple GUI should not be used?\n    if (BOINC_SIMPLEGUI == m_iGUISelected) {\n        // Screen too small?\n        if (wxGetDisplaySize().GetHeight() \u003c 600) {\n            m_iGUISelected = BOINC_ADVANCEDGUI;\n        }\n    }\n\n\n    // Initialize the task bar icon\n\tm_pTaskBarIcon = new CTaskBarIcon(\n        m_pSkinManager-\u003eGetAdvanced()-\u003eGetApplicationName(), \n        m_pSkinManager-\u003eGetAdvanced()-\u003eGetApplicationIcon(),\n        m_pSkinManager-\u003eGetAdvanced()-\u003eGetApplicationDisconnectedIcon(),\n        m_pSkinManager-\u003eGetAdvanced()-\u003eGetApplicationSnoozeIcon()\n    );\n    wxASSERT(m_pTaskBarIcon);\n#ifdef __WXMAC__\n    m_pMacSystemMenu = new CMacSystemMenu(\n        m_pSkinManager-\u003eGetAdvanced()-\u003eGetApplicationName(), \n        m_pSkinManager-\u003eGetAdvanced()-\u003eGetApplicationIcon(),\n        m_pSkinManager-\u003eGetAdvanced()-\u003eGetApplicationDisconnectedIcon(),\n        m_pSkinManager-\u003eGetAdvanced()-\u003eGetApplicationSnoozeIcon()\n    );\n    wxASSERT(m_pMacSystemMenu);\n#endif\n\n\n    // Startup the System Idle Detection code\n    IdleTrackerAttach();\n\n#ifdef __WXMAC__\n    ProcessSerialNumber psn;\n    ProcessInfoRec pInfo;\n    OSStatus err;\n    \n    memset(\u0026pInfo, 0, sizeof(pInfo));\n    pInfo.processInfoLength = sizeof( ProcessInfoRec );\n    err = GetProcessInformation(\u0026m_psnCurrentProcess, \u0026pInfo);\n    if (!err) {\n        psn = pInfo.processLauncher;\n        memset(\u0026pInfo, 0, sizeof(pInfo));\n        pInfo.processInfoLength = sizeof( ProcessInfoRec );\n        err = GetProcessInformation(\u0026psn, \u0026pInfo);\n    }\n    // Don't open main window if we were started automatically at login\n    if (pInfo.processSignature == 'lgnw') {  // Login Window app\n        m_bGUIVisible = false;\n\n        // If the system was just started, we usually get a \"Connection \n        // failed\" error if we try to connect too soon, so delay a bit.\n        sleep(10);\n    }\n#endif\n\n\n    // Show the UI\n    SetActiveGUI(m_iGUISelected, false);\n    if (m_bGUIVisible) {\n        SetActiveGUI(m_iGUISelected);\n    } else {\n        ShowApplication(false);\n\t}\n    \n    if(bOpenEventLog) {\n        DisplayEventLog(m_bGUIVisible);\n        m_pFrame-\u003eRaise();\n    }\n    \n    return true;\n}\n\n\nint CBOINCGUIApp::OnExit() {\n    // Shutdown the System Idle Detection code\n    IdleTrackerDetach();\n\n    if (m_pDocument) {\n        m_pDocument-\u003eOnExit();\n        delete m_pDocument;\n        m_pDocument = NULL;\n    }\n\n    m_pConfig-\u003eSetPath(wxT(\"/\"));\n    if (m_pSkinManager) {\n        m_pConfig-\u003eWrite(wxT(\"Skin\"), m_pSkinManager-\u003eGetSelectedSkin());\n        delete m_pSkinManager;\n    }\n\n    if (m_pLocale) {\n        delete m_pLocale;\n        m_pLocale = NULL;\n    }\n\n    if (m_pEventLog) {\n        m_pEventLog-\u003eDestroy();\n        m_pEventLog = NULL;\n    }\n\n\n    // Save Application State\n    m_pConfig-\u003eWrite(wxT(\"AutomaticallyShutdownClient\"), m_iShutdownCoreClient);\n    m_pConfig-\u003eWrite(wxT(\"DisplayShutdownClientDialog\"), m_iDisplayExitDialog);\n    m_pConfig-\u003eWrite(wxT(\"DisableAutoStart\"), m_iBOINCMGRDisableAutoStart);\n\n    diagnostics_finish();\n\n    return wxApp::OnExit();\n}\n\n\n///\n/// Pass the command line parameters and discriptions to wxWidgets for displaying.\n///\nvoid CBOINCGUIApp::OnInitCmdLine(wxCmdLineParser \u0026parser) {\n    wxApp::OnInitCmdLine(parser);\n    static const wxCmdLineEntryDesc cmdLineDesc[] = {\n        { wxCMD_LINE_SWITCH, wxT(\"a\"), wxT(\"autostart\"), _(\"BOINC Manager was started by the operating system automatically\")},\n#if defined(__WXMSW__) || defined(__WXMAC__)\n        { wxCMD_LINE_SWITCH, wxT(\"s\"), wxT(\"systray\"), _(\"Startup BOINC so only the system tray icon is visible\")},\n#else\n        { wxCMD_LINE_OPTION, wxT(\"e\"), wxT(\"clientdir\"), _(\"Directory containing the BOINC Client executable\")},\n        { wxCMD_LINE_OPTION, wxT(\"d\"), wxT(\"datadir\"), _(\"BOINC data directory\")},\n#endif\n        { wxCMD_LINE_OPTION, wxT(\"n\"), wxT(\"namehost\"), _(\"Host name or IP address\")},\n        { wxCMD_LINE_OPTION, wxT(\"g\"), wxT(\"gui_rpc_port\"), _(\"GUI RPC port number\")},\n        { wxCMD_LINE_OPTION, wxT(\"p\"), wxT(\"password\"), _(\"Password\")},\n        { wxCMD_LINE_OPTION, wxT(\"b\"), wxT(\"boincargs\"), _(\"Startup BOINC with these optional arguments\")},\n        { wxCMD_LINE_SWITCH, wxT(\"i\"), wxT(\"insecure\"), _(\"disable BOINC security users and permissions\")},\n        { wxCMD_LINE_SWITCH, wxT(\"c\"), wxT(\"checkskins\"), _(\"set skin debugging mode to enable skin manager error messages\")},\n        { wxCMD_LINE_SWITCH, wxT(\"m\"), wxT(\"multiple\"), _(\"multiple instances of BOINC Manager allowed\")},\n#if (defined(__WXMAC__) \u0026\u0026 defined(_DEBUG))\n        { wxCMD_LINE_OPTION, wxT(\"NSDocumentRevisionsDebugMode\"), NULL, _(\"Not used: workaround for bug in XCode 4.2\")},\n#endif\n        { wxCMD_LINE_NONE}  //DON'T forget this line!!\n    };\n    parser.SetDesc(cmdLineDesc);\n}\n\n\n///\n/// Parse command line parameters.\n///\nbool CBOINCGUIApp::OnCmdLineParsed(wxCmdLineParser \u0026parser) {\n    // Give default processing (-?, --help and --verbose) the chance to do something.\n    wxApp::OnCmdLineParsed(parser);\n    wxString portNum = wxEmptyString;\n    long longPort;\n    bool hostNameSpecified = false;\n    bool passwordSpecified = false;\n\n    parser.Found(wxT(\"boincargs\"), \u0026m_strBOINCArguments);\n    if (parser.Found(wxT(\"autostart\"))) {\n        m_bBOINCMGRAutoStarted = true;\n    }\n#if defined(__WXMSW__) || defined(__WXMAC__)\n    if (parser.Found(wxT(\"systray\"))) {\n        m_bGUIVisible = false;\n    }\n#endif\n    if (parser.Found(wxT(\"insecure\"))) {\n        g_use_sandbox = false;\n    }\n    if (parser.Found(wxT(\"checkskins\"))) {\n        m_bDebugSkins = true;\n    }\n    if (parser.Found(wxT(\"multiple\"))) {\n        m_bMultipleInstancesOK = true;\n    }\n\n#if !(defined(__WXMSW__) || defined(__WXMAC__))\n    if (!parser.Found(wxT(\"clientdir\"), \u0026m_strBOINCMGRRootDirectory)) {\n        m_strBOINCMGRRootDirectory = ::wxGetCwd();\n    }\n    if (m_strBOINCMGRRootDirectory.Last() != '/') {\n        m_strBOINCMGRRootDirectory.Append('/');\n    }\n\n    if (!parser.Found(wxT(\"datadir\"), \u0026m_strBOINCMGRDataDirectory)) {\n        m_strBOINCMGRDataDirectory = m_strBOINCMGRRootDirectory;\n    }\n    if (m_strBOINCMGRDataDirectory.Last() != '/') {\n        m_strBOINCMGRDataDirectory.Append('/');\n    }\n#endif    \n\n    if (parser.Found(wxT(\"namehost\"), \u0026m_strHostNameArg)) {\n        hostNameSpecified = true;\n    } else {\n        m_strHostNameArg = wxT(\"localhost\");\n    }\n\n     if (parser.Found(wxT(\"gui_rpc_port\"), \u0026portNum)) {\n        if (portNum.ToLong(\u0026longPort)) {\n            m_iRPCPortArg = longPort;\n        } else {\n            m_iRPCPortArg = GUI_RPC_PORT;  // conversion failed\n        }\n    } else {\n        m_iRPCPortArg = GUI_RPC_PORT;\n    }\n    \n    if (parser.Found(wxT(\"password\"), \u0026m_strPasswordArg)) {\n        passwordSpecified = true;\n    } else {\n        m_strPasswordArg = wxEmptyString;\n    }\n\n    if (hostNameSpecified \u0026\u0026 passwordSpecified) {\n        m_bMultipleInstancesOK = true;\n    }\n    return true;\n}\n\n\n///\n/// Detect if another instance of this application is running.\n//  Returns true if there is, otherwise false\n///\nbool CBOINCGUIApp::DetectDuplicateInstance() {\n#ifdef __WXMSW__\n    if (CTaskBarIcon::FireAppRestore()) {\n        return true;\n    }\n#endif\n#ifdef __WXMAC__\n    ProcessSerialNumber PSN;\n    int iInstanceID = wxGetApp().IsAnotherInstanceRunning();\n    if (iInstanceID) {\n        // Bring other instance to the front and exit this instance\n        OSStatus err = GetProcessForPID(iInstanceID, \u0026PSN);\n        if (!err) SetFrontProcess(\u0026PSN);\n        return true;\n    }\n#endif\n    return false;\n}\n\n\n///\n/// Determines what name BOINC Manager is called.\n///\nvoid CBOINCGUIApp::DetectExecutableName() {\n#ifdef __WXMSW__\n    TCHAR   szPath[MAX_PATH-1];\n\n    // change the current directory to the boinc install directory\n    GetModuleFileName(NULL, szPath, (sizeof(szPath)/sizeof(TCHAR)));\n\t\t\n    TCHAR *pszProg = _tcsrchr(szPath, '\\\\');\n    if (pszProg) {\n        pszProg++;\n    }\n\n    // Store the root directory for later use.\n    m_strBOINCMGRExecutableName = pszProg;\n#endif\n}\n\n\n///\n/// Determines where the BOINC Manager is executing from.\n///\nvoid CBOINCGUIApp::DetectRootDirectory() {\n#ifdef __WXMSW__\n    TCHAR   szPath[MAX_PATH-1];\n\n    // change the current directory to the boinc install directory\n    GetModuleFileName(NULL, szPath, (sizeof(szPath)/sizeof(TCHAR)));\n\t\t\n    TCHAR *pszProg = _tcsrchr(szPath, '\\\\');\n    if (pszProg) {\n        szPath[pszProg - szPath + 1] = 0;\n    }\n\n    // Store the root directory for later use.\n    m_strBOINCMGRRootDirectory = szPath;\n#endif\n}\n\n\n///\n/// Determines where the BOINC data directory is.\n///\nvoid CBOINCGUIApp::DetectDataDirectory() {\n#ifdef __WXMSW__\n    //\n    // Determine BOINCMgr Data Directory\n    //\n\tLONG    lReturnValue;\n\tHKEY    hkSetupHive;\n    LPTSTR  lpszRegistryValue = NULL;\n\tDWORD   dwSize = 0;\n\n    // change the current directory to the boinc data directory if it exists\n\tlReturnValue = RegOpenKeyEx(\n        HKEY_LOCAL_MACHINE, \n        _T(\"SOFTWARE\\\\Space Sciences Laboratory, U.C. Berkeley\\\\BOINC Setup\"),\n\t\t0, \n        KEY_READ,\n        \u0026hkSetupHive\n    );\n    if (lReturnValue == ERROR_SUCCESS) {\n        // How large does our buffer need to be?\n        lReturnValue = RegQueryValueEx(\n            hkSetupHive,\n            _T(\"DATADIR\"),\n            NULL,\n            NULL,\n            NULL,\n            \u0026dwSize\n        );\n        if (lReturnValue != ERROR_FILE_NOT_FOUND) {\n            // Allocate the buffer space.\n            lpszRegistryValue = (LPTSTR) malloc(dwSize);\n            (*lpszRegistryValue) = NULL;\n\n            // Now get the data\n            lReturnValue = RegQueryValueEx( \n                hkSetupHive,\n                _T(\"DATADIR\"),\n                NULL,\n                NULL,\n                (LPBYTE)lpszRegistryValue,\n                \u0026dwSize\n            );\n\n            // Store the root directory for later use.\n            m_strBOINCMGRDataDirectory = lpszRegistryValue;\n        }\n    }\n\n    // Cleanup\n\tif (hkSetupHive) RegCloseKey(hkSetupHive);\n    if (lpszRegistryValue) free(lpszRegistryValue);\n#endif\n#ifdef __WXMAC__\n    m_strBOINCMGRDataDirectory = wxT(\"/Library/Application Support/BOINC Data\");\n#endif\n}\n\n\nvoid CBOINCGUIApp::InitSupportedLanguages() {\n    wxInt32               iIndex = 0;\n    const wxLanguageInfo* liLanguage = NULL;\n\n    // Prepare the array\n    m_astrLanguages.Insert(wxEmptyString, 0, wxLANGUAGE_USER_DEFINED+1);\n\n    // These are just special tags so deal with them in a special way\n    m_astrLanguages[wxLANGUAGE_DEFAULT]                    = _(\"(Automatic Detection)\");\n    m_astrLanguages[wxLANGUAGE_UNKNOWN]                    = _(\"(Unknown)\");\n    m_astrLanguages[wxLANGUAGE_USER_DEFINED]               = _(\"(User Defined)\");\n\n    for (iIndex = 0; iIndex \u003c= wxLANGUAGE_USER_DEFINED; iIndex++) {\n        liLanguage = wxLocale::GetLanguageInfo(iIndex);\n        if (liLanguage) {\n            m_astrLanguages[iIndex] = liLanguage-\u003eDescription;\n        }\n    }\n}\n\n\nint CBOINCGUIApp::IdleTrackerAttach() {\n#ifdef __WXMSW__\n    ::attach_idle_monitor();\n#endif\n    return 0;\n}\n\n\nint CBOINCGUIApp::IdleTrackerDetach() {\n#ifdef __WXMSW__\n    ::detach_idle_monitor();\n#endif\n    return 0;\n}\n\n\nvoid CBOINCGUIApp::OnActivateApp(wxActivateEvent\u0026 event) {\n#ifdef __WXMAC__\n    // Make sure any modal dialog (such as Attach Wizard) ends up in front.\n    if (IsModalDialogDisplayed()) {\n        event.Skip();\n        return;\n    }\n#endif\n\n    if (event.GetActive()) {\n        if (m_pEventLog \u0026\u0026 !m_pEventLog-\u003eIsIconized()) {\n            m_pEventLog-\u003eRaise();\n        }\n        if (m_pFrame) m_pFrame-\u003eRaise();\n    }\n    event.Skip();\n}\n\n\nvoid CBOINCGUIApp::OnRPCFinished( CRPCFinishedEvent\u0026 event ) {\n    CMainDocument*      pDoc = wxGetApp().GetDocument();\n   \n    wxASSERT(pDoc);\n    wxASSERT(wxDynamicCast(pDoc, CMainDocument));\n    \n    pDoc-\u003eOnRPCComplete(event);\n}\n\n\nint CBOINCGUIApp::UpdateSystemIdleDetection() {\n#ifdef __WXMSW__\n    return get_idle_tick_count();\n#else\n    return TRUE;\n#endif\n}\n\n\nint CBOINCGUIApp::StartBOINCScreensaverTest() {\n#ifdef __WXMSW__\n    wxString strExecute = wxEmptyString;\n    wxChar   szExecutableDirectory[4096];\n    memset(szExecutableDirectory, 0, sizeof(szExecutableDirectory));\n\n    // On Windows the screensaver is located in the Windows directory.\n    GetWindowsDirectory(\n        szExecutableDirectory,\n        (sizeof(szExecutableDirectory) / sizeof(wxChar))\n    );\n\n    // Append boinc.scr to the end of the strExecute string and get ready to rock\n    strExecute = wxT(\"\\\"\") + wxString(szExecutableDirectory) + wxT(\"\\\\boinc.scr\\\" /t\");\n    ::wxExecute(strExecute);\n#endif\n    return 0;\n}\n\n\nint CBOINCGUIApp::StartBOINCDefaultScreensaverTest() {\n#ifdef __WXMSW__\n    wxString strExecute = wxEmptyString;\n    strExecute = wxT(\"\\\"\") + m_strBOINCMGRRootDirectory + wxT(\"\\\\boincscr.exe\\\" --test\");\n    ::wxExecute(strExecute);\n#endif\n    return 0;\n}\n\n\n// Display the Event Log, it is a modeless dialog not owned by any\n// other UI element.\nvoid CBOINCGUIApp::DisplayEventLog(bool bShowWindow) {\n    if (m_pEventLog) {\n        if (bShowWindow) {\n            if (m_pEventLog-\u003eIsIconized()) {\n                m_pEventLog-\u003eIconize(false);\n            }\n            m_pEventLog-\u003eRaise();\n        }\n    } else {\n        m_pEventLog = new CDlgEventLog();\n        if (m_pEventLog) {\n            m_pEventLog-\u003eShow(bShowWindow);\n            if (bShowWindow) {\n                m_pEventLog-\u003eRaise();\n            }\n            if (m_pFrame) {\n                m_pFrame-\u003eUpdateRefreshTimerInterval();\n            }\n        }\n    }\n}\n\n\nvoid CBOINCGUIApp::OnEventLogClose() {\n    m_pEventLog = NULL;\n    if (m_pFrame) {\n        m_pFrame-\u003eUpdateRefreshTimerInterval();\n    }\n}\n\n    \n// The skin has changed and all UI elements need to reload their bitmaps.\n//\nvoid CBOINCGUIApp::FireReloadSkin() {\n    if (m_pFrame) {\n\t    m_pFrame-\u003eFireReloadSkin();\n    }\n    if (m_pTaskBarIcon) {\n\t    m_pTaskBarIcon-\u003eFireReloadSkin();\n    }\n}\n\n\nbool CBOINCGUIApp::SetActiveGUI(int iGUISelection, bool bShowWindow) {\n    wxLogTrace(wxT(\"Function Start/End\"), wxT(\"CBOINCGUIApp::SetActiveGUI - Function Begin\"));\n    wxLogTrace(wxT(\"Function Start/End\"), wxT(\"CBOINCGUIApp::SetActiveGUI - GUI Selection: '%d', Show: %d'\"), iGUISelection, (int)bShowWindow);\n\n    CBOINCBaseFrame* pNewFrame = NULL;\n    CBOINCBaseFrame* pOldFrame = m_pFrame;\n    wxInt32          iTop = 0;\n    wxInt32          iLeft = 0;\n    wxInt32          iHeight = 0;\n    wxInt32          iWidth = 0;\n\n\n    // Create the new window\n    if ((iGUISelection != m_iGUISelected) || !m_pFrame) {\n\n        // Reterieve the desired window state before creating the\n        //   desired frames\n        if (BOINC_ADVANCEDGUI == iGUISelection) {\n            m_pConfig-\u003eSetPath(wxT(\"/\"));\n            m_pConfig-\u003eRead(wxT(\"YPos\"), \u0026iTop, 30);\n            m_pConfig-\u003eRead(wxT(\"XPos\"), \u0026iLeft, 30);\n            m_pConfig-\u003eRead(wxT(\"Width\"), \u0026iWidth, 800);\n            m_pConfig-\u003eRead(wxT(\"Height\"), \u0026iHeight, 600);\n        } else {\n            m_pConfig-\u003eSetPath(wxT(\"/Simple\"));\n            m_pConfig-\u003eRead(wxT(\"YPos\"), \u0026iTop, 30);\n            m_pConfig-\u003eRead(wxT(\"XPos\"), \u0026iLeft, 30);\n\n            // We don't save Simple View's width \u0026 height since it's \n            // window is not resizable, so don't try to read them\n#ifdef __WXMAC__\n//            m_pConfig-\u003eRead(wxT(\"Width\"), \u0026iWidth, 409);\n//            m_pConfig-\u003eRead(wxT(\"Height\"), \u0026iHeight, 561);\n            iWidth = 409;\n            iHeight = 561;\n#else\n//            m_pConfig-\u003eRead(wxT(\"Width\"), \u0026iWidth, 416);\n//            m_pConfig-\u003eRead(wxT(\"Height\"), \u0026iHeight, 570);\n            iWidth = 416;\n            iHeight = 570;\n#endif\n        }\n\n\n        // Make sure that the new window is going to be visible\n        //   on a screen\n#ifdef __WXMAC__\n    if (!IsWindowOnScreen(iLeft, iTop, iWidth, iHeight)) {\n        iTop = iLeft = 30;\n    }\n#else\n\t    // If either co-ordinate is less then 0 then set it equal to 0 to ensure\n\t    // it displays on the screen.\n\t    if ( iLeft \u003c 0 ) iLeft = 30;\n\t    if ( iTop \u003c 0 ) iTop = 30;\n\n\t    // Read the size of the screen\n\t    wxInt32 iMaxWidth = wxSystemSettings::GetMetric( wxSYS_SCREEN_X );\n\t    wxInt32 iMaxHeight = wxSystemSettings::GetMetric( wxSYS_SCREEN_Y );\n\n\t    // Max sure that it doesn't go off to the right or bottom\n\t    if ( iLeft + iWidth \u003e iMaxWidth ) iLeft = iMaxWidth - iWidth;\n\t    if ( iTop + iHeight \u003e iMaxHeight ) iTop = iMaxHeight - iHeight;\n#endif\n\n        // Create the main window\n        //\n        if (BOINC_ADVANCEDGUI == iGUISelection) {\n            // Initialize the advanced gui window\n            pNewFrame = new CAdvancedFrame(\n                m_pSkinManager-\u003eGetAdvanced()-\u003eGetApplicationName(), \n                m_pSkinManager-\u003eGetAdvanced()-\u003eGetApplicationIcon(),\n                m_pSkinManager-\u003eGetAdvanced()-\u003eGetApplicationIcon32(),\n                wxPoint(iLeft, iTop),\n                wxSize(iWidth, iHeight)\n            );\n        } else {\n            // Initialize the simple gui window\n            pNewFrame = new CSimpleFrame(\n                m_pSkinManager-\u003eGetAdvanced()-\u003eGetApplicationName(), \n                m_pSkinManager-\u003eGetAdvanced()-\u003eGetApplicationIcon(),\n                m_pSkinManager-\u003eGetAdvanced()-\u003eGetApplicationIcon32(),\n                wxPoint(iLeft, iTop),\n                wxSize(iWidth, iHeight)\n            );\n        }\n\n        wxASSERT(pNewFrame);\n\n        if (pNewFrame) {\n            SetTopWindow(pNewFrame);\n\n            // Store the new frame for future use\n            m_pFrame = pNewFrame;\n\n            // Hide the old one if it exists.  We must do this \n            // after updating m_pFrame to prevent Mac OSX from\n            // hiding the application\n            if (pOldFrame) pOldFrame-\u003eHide();\n\n            // Delete the old one if it exists\n            // Note: this has the side effect of hiding the Event Log\n            if (pOldFrame) pOldFrame-\u003eDestroy();\n        }\n    }\n\n    // Show the new frame if needed \n    if (m_pFrame \u0026\u0026 bShowWindow) {\n        if (m_pEventLog) {\n            m_pEventLog-\u003eShow();\n            m_pEventLog-\u003eRaise();\n#ifdef __WXMSW__\n            ::SetForegroundWindow((HWND)m_pEventLog-\u003eGetHWND());\n#endif\n        }\n\n        if (!m_pFrame-\u003eIsShown()) {\n            m_pFrame-\u003eShow();\n        }\n        if (m_pFrame-\u003eIsIconized()) {\n            m_pFrame-\u003eMaximize(false);\n        }\n        m_pFrame-\u003eRaise();\n\n#ifdef __WXMSW__\n        ::SetForegroundWindow((HWND)m_pFrame-\u003eGetHWND());\n#endif\n    }\n\n    m_iGUISelected = iGUISelection;\n    m_pConfig-\u003eSetPath(wxT(\"/\"));\n    m_pConfig-\u003eWrite(wxT(\"GUISelection\"), iGUISelection);\n\n    wxLogTrace(wxT(\"Function Start/End\"), wxT(\"CBOINCGUIApp::SetActiveGUI - Function End\"));\n    return true;\n}\n\n\nint CBOINCGUIApp::ConfirmExit() {\n    CSkinAdvanced*  pSkinAdvanced = wxGetApp().GetSkinManager()-\u003eGetAdvanced();\n    CMainDocument*  pDoc = wxGetApp().GetDocument();\n    wxString        strConnectedCompter = wxEmptyString;\n    bool            bWasVisible;\n    int             retval = 0;\n\n    wxASSERT(pDoc);\n    wxASSERT(pSkinAdvanced);\n    wxASSERT(wxDynamicCast(pDoc, CMainDocument));\n    wxASSERT(wxDynamicCast(pSkinAdvanced, CSkinAdvanced));\n    \n    pDoc-\u003eGetConnectedComputerName(strConnectedCompter);\n    if (!pDoc-\u003eIsComputerNameLocal(strConnectedCompter)) {\n        // Don't shut down remote clients on Manager exit\n        return 1;\n    }\n\n    // Don't run confirmation dialog if logging out or shutting down Mac, \n    // or if emergency exit from AsyncRPCDlg\n    if (s_bSkipExitConfirmation) return 1;\n\n    // Don't run confirmation dialog if second instance of Manager \n    if (IsMgrMultipleInstance()) return 1;\n\n    if (!m_iDisplayExitDialog) {\n        // Mac: User doesn't want to display the dialog and just wants to use their previous value.\n        // Win \u0026 Linux: User doesn't want to display the dialog and wants to shutdown the client.\n        return 1;\n    }\n\n    bWasVisible = IsApplicationVisible();\n    ShowApplication(true);\n\n    CDlgExitMessage dlg(NULL);\n\n    if (!pSkinAdvanced-\u003eGetExitMessage().IsEmpty()) {\n        dlg.m_DialogExitMessage-\u003eSetLabel(pSkinAdvanced-\u003eGetExitMessage());\n    }\n\n#ifdef __WXMSW__\n    if (m_iShutdownCoreClient) {\n        dlg.m_DialogShutdownCoreClient-\u003eSetValue(TRUE);\n    }\n#endif\n\n    if (m_iDisplayExitDialog) {\n        dlg.m_DialogDisplay-\u003eSetValue(FALSE);\n    }\n\n    dlg.Fit();\n    dlg.Centre();\n\n    if (wxID_OK == dlg.ShowModal()) {\n#ifdef __WXMAC__\n        s_bSkipExitConfirmation = true;     // Don't ask twice (only affects Mac)\n#else\n        m_iShutdownCoreClient = dlg.m_DialogShutdownCoreClient-\u003eGetValue();\n#endif\n        m_iDisplayExitDialog = !dlg.m_DialogDisplay-\u003eGetValue();\n        retval = true;\n\n    }\n\n    if (!bWasVisible) {\n        ShowApplication(false);\n    }\n\n    return retval;       // User cancelled exit\n}\n\n\n// Use this instead of wxMessageBox from all tab Views to suppress \n// Periodic RPCs.  See comment in CMainDocument::RunPeriodicRPCs()\n// for a fuller explanation.\nint CBOINCGUIApp::SafeMessageBox(const wxString\u0026 message, const wxString\u0026 caption, long style,\n                 wxWindow *parent, int x, int y )\n{\n    int retval;\n    \n    m_bSafeMessageBoxDisplayed++;\n    \n    retval = wxMessageBox(message, caption, style, parent, x, y);\n\n    m_bSafeMessageBoxDisplayed--;\n\n    return retval;\n}\n\n\n///\n/// Determines if another instance of BOINC Manager is running.\n///\n/// @return\n///  true if another instance of BOINC Manager is running, otherwise false.\n///\n/// Note: will always return false on Win95, Win98, WinME\n/// \nint CBOINCGUIApp::IsAnotherInstanceRunning() {\n    PROC_MAP pm;\n    int retval;\n    char myName[256];\n    int otherInstanceID = 0;\n    int myPid;\n\n    // Look for BOINC Manager in list of all running processes\n    retval = procinfo_setup(pm);\n    if (retval) return false;     // Should never happen\n\n#ifdef _WIN32\n    myPid = (int)GetCurrentProcessId();\n#else\n    myPid = getpid();\n#endif\n\n    // Get the name of this Application\n    myName[0] = 0;\n    PROC_MAP::iterator i;\n    for (i=pm.begin(); i!=pm.end(); i++) {\n        PROCINFO\u0026 pi = i-\u003esecond;\n        if (pi.id == myPid) {\n            strncpy(myName, pi.command, sizeof(myName));\n            break;\n        }\n    }\n\n    if (myName[0] == 0) {\n         return false;     // Should never happen\n    }\n    \n    // Search process list for other applications with same name\n    for (i=pm.begin(); i!=pm.end(); i++) {\n        PROCINFO\u0026 pi = i-\u003esecond;\n        if (pi.id == myPid) continue;\n        if (!strcmp(pi.command, myName)) {\n            otherInstanceID = pi.id;\n            break;\n        }\n    }\n    \n    return otherInstanceID;\n}\n\n\n///\n/// Determines if the current process is visible.\n///\n/// @return\n///  true if the current process is visible, otherwise false.\n/// \nbool CBOINCGUIApp::IsApplicationVisible() {\n#ifdef __WXMAC__\n    if (IsProcessVisible(\u0026m_psnCurrentProcess)) {\n        return true;\n    }\n#endif\n    return false;\n}\n\n///\n/// Shows or hides the current process.\n///\n/// @param bShow\n///   true will show the process, false will hide the process.\n///\n#ifdef __WXMAC__\nvoid CBOINCGUIApp::ShowApplication(bool bShow) {\n    if (bShow) {\n        SetFrontProcess(\u0026m_psnCurrentProcess);\n    } else {\n        ShowHideProcess(\u0026m_psnCurrentProcess, false);\n    }\n}\n#else\nvoid CBOINCGUIApp::ShowApplication(bool) {\n}\n#endif\n\n\nbool CBOINCGUIApp::ShowInterface() {\n    return SetActiveGUI(m_iGUISelected, true);\n}\n\n\nbool CBOINCGUIApp::ShowNotifications() {\n    bool retval = false;\n\n    retval = SetActiveGUI(m_iGUISelected, true);\n    if (retval) {\n        GetFrame()-\u003eFireNotification();\n        GetDocument()-\u003eUpdateUnreadNoticeState();\n    }\n\n    return retval;\n}\n\n\nbool CBOINCGUIApp::IsModalDialogDisplayed() {\n    if (m_bSafeMessageBoxDisplayed) return true;\n    \n    // Search for the dialog by ID since all of BOINC Manager's \n    // dialog IDs are 10000.\n    if (wxDynamicCast(wxWindow::FindWindowById(ID_ANYDIALOG), wxDialog)) {\n        return true;\n    }\n    \n    if (m_pDocument) {\n        if (m_pDocument-\u003eWaitingForRPC()) {\n            return true;\n        }\n    }\n    return false;\n}\n\nvoid CBOINCGUIApp::DeleteTaskBarIcon() {\n    if (m_pTaskBarIcon) {\n        delete m_pTaskBarIcon;\n    }\n    m_pTaskBarIcon = NULL;\n}\n\n#ifdef __WXMAC__\nvoid CBOINCGUIApp::DeleteMacSystemMenu() {\n    if (m_pMacSystemMenu) {\n        delete m_pMacSystemMenu;\n    }\n    m_pMacSystemMenu = NULL;\n}\n#endif\n\n\n// Prevent recursive entry of CMainDocument::RequestRPC()\nint CBOINCGUIApp::FilterEvent(wxEvent \u0026event) {\n    int theEventType;\n    wxDialog* theRPCWaitDialog;\n    wxObject* theObject;\n\n    if (!m_pDocument) return -1;\n\n    theEventType = event.GetEventType();\n\n    if (m_pDocument-\u003eWaitingForRPC()) {\n        // If in RPC Please Wait dialog, reject all command \n        // and timer events except: \n        //  - RPC Finished\n        //  - those for that dialog or its children\n        //  - Open Manager menu item from system tray icon\n\n        if ((theEventType == wxEVT_COMMAND_MENU_SELECTED) \u0026\u0026 (event.GetId() == wxID_OPEN)) {\n            return -1;        \n        }\n\n        theRPCWaitDialog = m_pDocument-\u003eGetRPCWaitDialog();\n        theObject = event.GetEventObject();\n        while (theObject) {\n            if (!theObject-\u003eIsKindOf(CLASSINFO(wxWindow))) break;\n            if (theObject == theRPCWaitDialog) return -1;\n            theObject = ((wxWindow*)theObject)-\u003eGetParent();\n        }\n        // Continue with rest of filtering below\n    } else {\n        // Do limited filtering if shutting down to allow RPC \n        // completion events but not events which start new RPCs\n        if (!m_bFilterEvents) return -1;\n    }\n\n    // Allow all except Command, Timer and Mouse Moved events\n    if (event.IsCommandEvent()) {\n        return false;\n    }\n    \n    if (theEventType == wxEVT_TIMER) {\n        return false;\n    }\n    \n#ifdef __WXMSW__\n    if (theEventType == wxEVT_TASKBAR_MOVE) {\n        return false;\n    }\n#endif\n   \n    return -1;\n}\n\n"}
{"repo_name":"fahhem/mbed-os","ref":"refs/heads/master","path":"targets/TARGET_NUVOTON/TARGET_M451/device/TOOLCHAIN_ARM_STD/sys.cpp","copies":"126","language":"C++","content":"/* mbed Microcontroller Library - stackheap\n * Copyright (C) 2009-2011 ARM Limited. All rights reserved.\n *\n * Setup a fixed single stack/heap memory model,\n *  between the top of the RW/ZI region and the stackpointer\n */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include \u003crt_misc.h\u003e\n#include \u003cstdint.h\u003e\n\nextern char Image$$ARM_LIB_STACK$$ZI$$Limit[];\nextern char Image$$ARM_LIB_HEAP$$Base[];\nextern char Image$$ARM_LIB_HEAP$$ZI$$Limit[];\nextern __value_in_regs struct __initial_stackheap __user_setup_stackheap(uint32_t R0, uint32_t R1, uint32_t R2, uint32_t R3) {\n\n    struct __initial_stackheap r;\n    r.heap_base = (uint32_t)Image$$ARM_LIB_HEAP$$Base;\n    r.heap_limit = (uint32_t)Image$$ARM_LIB_HEAP$$ZI$$Limit;\n    return r;\n}\n\n#ifdef __cplusplus\n}\n#endif\n"}
{"repo_name":"NickelMedia/phantomjs","ref":"refs/heads/master","path":"src/qt/qtbase/config.tests/unix/evdev/evdev.cpp","copies":"85","language":"C++","content":"/****************************************************************************\n**\n** Copyright (C) 2014 Digia Plc and/or its subsidiary(-ies).\n** Contact: http://www.qt-project.org/legal\n**\n** This file is part of the config.tests of the Qt Toolkit.\n**\n** $QT_BEGIN_LICENSE:LGPL21$\n** Commercial License Usage\n** Licensees holding valid commercial Qt licenses may use this file in\n** accordance with the commercial license agreement provided with the\n** Software or, alternatively, in accordance with the terms contained in\n** a written agreement between you and Digia. For licensing terms and\n** conditions see http://qt.digia.com/licensing. For further information\n** use the contact form at http://qt.digia.com/contact-us.\n**\n** GNU Lesser General Public License Usage\n** Alternatively, this file may be used under the terms of the GNU Lesser\n** General Public License version 2.1 or version 3 as published by the Free\n** Software Foundation and appearing in the file LICENSE.LGPLv21 and\n** LICENSE.LGPLv3 included in the packaging of this file. Please review the\n** following information to ensure the GNU Lesser General Public License\n** requirements will be met: https://www.gnu.org/licenses/lgpl.html and\n** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.\n**\n** In addition, as a special exception, Digia gives you certain additional\n** rights. These rights are described in the Digia Qt LGPL Exception\n** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.\n**\n** $QT_END_LICENSE$\n**\n****************************************************************************/\n\n#include \u003clinux/input.h\u003e\n#include \u003clinux/kd.h\u003e\n\nenum {\n    e1 = ABS_PRESSURE,\n    e2 = ABS_X,\n    e3 = REL_X,\n    e4 = SYN_REPORT,\n};\n\nint main()\n{\n    ::input_event buf[32];\n    (void) buf;\n    return 0;\n}\n"}
{"repo_name":"uwafsl/ardupilot","ref":"refs/heads/master","path":"libraries/AP_HAL_Linux/Util.cpp","copies":"8","language":"C++","content":"#include \u003cAP_HAL/AP_HAL.h\u003e\n\n#if CONFIG_HAL_BOARD == HAL_BOARD_LINUX\n#include \u003cstdio.h\u003e\n#include \u003cstdarg.h\u003e\n#include \u003csys/stat.h\u003e\n#include \u003cunistd.h\u003e\n#include \u003cstdlib.h\u003e\n#include \u003cerrno.h\u003e\n#include \u003ctime.h\u003e\n#include \u003cfcntl.h\u003e\n\nextern const AP_HAL::HAL\u0026 hal;\n\n#include \"ToneAlarm_Raspilot.h\"\n#include \"Util.h\"\n#include \"Heat_Pwm.h\"\n\nusing namespace Linux;\n\n\nstatic int state;\n#if CONFIG_HAL_BOARD_SUBTYPE == HAL_BOARD_SUBTYPE_LINUX_RASPILOT\nToneAlarm_Raspilot Util::_toneAlarm;\n#else\nToneAlarm Util::_toneAlarm;\n#endif\n\nvoid Util::init(int argc, char * const *argv) {\n    saved_argc = argc;\n    saved_argv = argv;\n\n#ifdef HAL_UTILS_HEAT\n#if HAL_UTILS_HEAT == HAL_LINUX_HEAT_PWM\n    _heat = new Linux::HeatPwm(HAL_LINUX_HEAT_PWM_NUM,\n                            HAL_LINUX_HEAT_KP,\n                            HAL_LINUX_HEAT_KI,\n                            HAL_LINUX_HEAT_PERIOD_NS,\n                            HAL_LINUX_HEAT_TARGET_TEMP);\n#else\n    #error Unrecognized Heat\n#endif // #if\n#else\n    _heat = new Linux::Heat();\n#endif // #ifdef\n}\n\nvoid Util::set_imu_temp(float current)\n{\n    _heat-\u003eset_imu_temp(current);\n}\n\n/**\n   return commandline arguments, if available\n*/\nvoid Util::commandline_arguments(uint8_t \u0026argc, char * const *\u0026argv)\n{\n    argc = saved_argc;\n    argv = saved_argv;\n}\n\nbool Util::toneAlarm_init()\n{\n    return _toneAlarm.init();\n}\n\nvoid Util::toneAlarm_set_tune(uint8_t tone)\n{\n    _toneAlarm.set_tune(tone);\n}\n\nvoid Util::_toneAlarm_timer_tick(){\n    if(state == 0){\n        state = state + _toneAlarm.init_tune();\n    }else if(state == 1){\n        state = state + _toneAlarm.set_note();\n    }\n    if(state == 2){\n        state = state + _toneAlarm.play();\n    }else if(state == 3){\n        state = 1;\n    }\n    \n    if(_toneAlarm.is_tune_comp()){\n        state = 0;\n    }\n    \n}\n\nvoid Util::set_system_clock(uint64_t time_utc_usec)\n{\n#if CONFIG_HAL_BOARD_SUBTYPE != HAL_BOARD_SUBTYPE_LINUX_NONE\n    timespec ts;\n    ts.tv_sec = time_utc_usec/1.0e6;\n    ts.tv_nsec = (time_utc_usec % 1000000) * 1000;\n    clock_settime(CLOCK_REALTIME, \u0026ts);    \n#endif    \n}\n\nbool Util::is_chardev_node(const char *path)\n{\n    struct stat st;\n\n    if (!path || lstat(path, \u0026st) \u003c 0)\n        return false;\n\n    return S_ISCHR(st.st_mode);\n}\n\n/*\n  always report 256k of free memory. Using mallinfo() isn't useful as\n  it only reported the current heap, which auto-expands. What we're\n  trying to do here is ensure that code which checks for free memory\n  before allocating objects does allow the allocation\n */\nuint32_t Util::available_memory(void)\n{\n    return 256*1024;\n}\n\nint Util::write_file(const char *path, const char *fmt, ...)\n{\n    errno = 0;\n\n    int fd = ::open(path, O_WRONLY | O_CLOEXEC);\n    if (fd == -1) {\n        return -errno;\n    }\n\n    va_list args;\n    va_start(args, fmt);\n\n    int ret = ::vdprintf(fd, fmt, args);\n    int errno_bkp = errno;\n    ::close(fd);\n\n    va_end(args);\n\n    if (ret \u003c 1) {\n        return -errno_bkp;\n    }\n\n    return ret;\n}\n\nint Util::read_file(const char *path, const char *fmt, ...)\n{\n    errno = 0;\n\n    FILE *file = ::fopen(path, \"re\");\n    if (!file)\n        return -errno;\n\n    va_list args;\n    va_start(args, fmt);\n\n    int ret = ::vfscanf(file, fmt, args);\n    int errno_bkp = errno;\n    ::fclose(file);\n\n    va_end(args);\n\n    if (ret \u003c 1)\n        return -errno_bkp;\n\n    return ret;\n}\n\nconst char *Linux::Util::_hw_names[UTIL_NUM_HARDWARES] = {\n    [UTIL_HARDWARE_RPI1]   = \"BCM2708\",\n    [UTIL_HARDWARE_RPI2]   = \"BCM2709\",\n    [UTIL_HARDWARE_BEBOP]  = \"Mykonos3 board\",\n    [UTIL_HARDWARE_BEBOP2] = \"Milos board\",\n};\n\n#define MAX_SIZE_LINE 50\nint Util::get_hw_arm32()\n{\n    int ret = -ENOENT;\n    char buffer[MAX_SIZE_LINE];\n    const char* hardware_description_entry = \"Hardware\";\n    char* flag;\n    FILE* f;\n\n    f = fopen(\"/proc/cpuinfo\", \"r\");\n\n    if (f == NULL) {\n        ret = -errno;\n        goto end;\n    }\n\n    while (fgets(buffer, MAX_SIZE_LINE, f) != NULL) {\n        flag = strstr(buffer, hardware_description_entry);\n        if (flag != NULL) {\n            for (uint8_t i = 0; i \u003c UTIL_NUM_HARDWARES; i++) {\n                if (strstr(buffer, _hw_names[i]) != 0) {\n                     ret = i;\n                     goto close_end;\n                }\n            }\n        }\n    }\n\nclose_end:\n    fclose(f);\nend:\n    return ret;\n}\n\n#endif // CONFIG_HAL_BOARD == HAL_BOARD_LINUX\n"}
{"repo_name":"liuchuo/LeetCode-practice","ref":"refs/heads/master","path":"C++/079. Word Search.cpp","copies":"1","language":"C++","content":"79. Word Search\nGiven a 2D board and a word, find if the word exists in the grid.\n\nThe word can be constructed from letters of sequentially adjacent cell, where \"adjacent\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.\n\nFor example,\nGiven board =\n\n[\n  ['A','B','C','E'],\n  ['S','F','C','S'],\n  ['A','D','E','E']\n]\nword = \"ABCCED\", -\u003e returns true,\nword = \"SEE\", -\u003e returns true,\nword = \"ABCB\", -\u003e returns false.\n\n题目大意：给一个char型二维数组和一个word字符串，寻找网格中是否含有word字符串，只能通过相邻（垂直或者水平）的格子连接～\n分析：对于二维数组中的每一个点都开始遍历，如果当前点的字母正好等于word[0]就进入dfs，设立flag标记是否找到，设立visit标记是否访问：\n首先令起始节点visit[j][k]标记为已经访问过，接着dfs，如果flag为true直接return，如果当前index正好为word的最后一个字符下标就标记flag为true，return。\n从四个方向开始对结点进行深度优先搜索，首先要保证搜索的结点满足：1.是合法的在网格之内的 2.未被访问过 3.当前字符与要找的word[index+1]相同。满足则标记visit[tx][ty] = true,且dfs tx和ty以及index+1，两个dfs后要把他重新置为false～\n这样最后返回flag的值即为是否能找到的结果～\n\nclass Solution {\nprivate:\n    bool flag = false;\n    vector\u003cvector\u003cbool\u003e\u003e visit;\n    vector\u003cvector\u003cchar\u003e\u003e board;\n    string word = \"\";\n    int dir[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    int m, n;\npublic:\n    bool exist(vector\u003cvector\u003cchar\u003e\u003e\u0026 board, string word) {\n        if (board.size() == 0) return word == \"\";\n        m = board.size(), n = board[0].size();\n        this-\u003eword = word;\n        this-\u003eboard = board;\n        visit.resize(m, vector\u003cbool\u003e(n));\n        for (int j = 0; j \u003c m; j++) {\n            for (int k = 0; k \u003c n; k++) {\n                if (board[j][k] == word[0]) {\n                    visit[j][k] = true;\n                    dfs(j, k, 0);\n                    visit[j][k] = false;\n                }\n            }\n        }\n        return flag;\n    }\n    \n    void dfs(int x, int y, int index) {\n        if (flag == true) return ;\n        if (index == word.length() - 1) {\n            flag = true;\n            return ;\n        }\n        for (int i = 0; i \u003c 4; i++) {\n            int tx = x + dir[i][0], ty = y + dir[i][1];\n            if (tx \u003e= 0 \u0026\u0026 tx \u003c m \u0026\u0026 ty \u003e= 0 \u0026\u0026 ty \u003c n \u0026\u0026 board[tx][ty] == word[index + 1] \u0026\u0026 visit[tx][ty] == false) {\n                visit[tx][ty] = true;\n                dfs(tx, ty, index + 1);\n                visit[tx][ty] = false;\n            }\n        }\n    }\n};"}
{"repo_name":"didoutheone/MangosOneDidou","ref":"refs/heads/master","path":"dep/recastnavigation/RecastDemo/Source/CrowdManager.cpp","copies":"66","language":"C++","content":"//\n// Copyright (c) 2009-2010 Mikko Mononen memon@inside.org\n//\n// This software is provided 'as-is', without any express or implied\n// warranty.  In no event will the authors be held liable for any damages\n// arising from the use of this software.\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n// 1. The origin of this software must not be misrepresented; you must not\n//    claim that you wrote the original software. If you use this software\n//    in a product, an acknowledgment in the product documentation would be\n//    appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//    misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n//\n\n#define _USE_MATH_DEFINES\n#include \u003cmath.h\u003e\n#include \u003cstdio.h\u003e\n#include \u003cstdlib.h\u003e\n#include \u003cstring.h\u003e\n#include \u003cfloat.h\u003e\n#include \"DetourNavMesh.h\"\n#include \"DetourNavMeshQuery.h\"\n#include \"DetourObstacleAvoidance.h\"\n#include \"DetourCommon.h\"\n#include \"CrowdManager.h\"\n#include \"SampleInterfaces.h\" // For timer\n#include \"DetourAssert.h\"\n#include \"DetourAlloc.h\"\n\nstatic const int VO_ADAPTIVE_DIVS = 7;\nstatic const int VO_ADAPTIVE_RINGS = 2;\nstatic const int VO_ADAPTIVE_DEPTH = 5;\n\nstatic const int VO_GRID_SIZE = 33;\n\n\ninline int hashPos2(int x, int y, int n)\n{\n\treturn ((x*73856093) ^ (y*19349663)) \u0026 (n-1);\n}\n\nProximityGrid::ProximityGrid() :\n\tm_maxItems(0),\n\tm_cellSize(0),\n\tm_pool(0),\n\tm_poolHead(0),\n\tm_poolSize(0),\n\tm_buckets(0),\n\tm_bucketsSize(0)\n{\n}\n\t\nProximityGrid::~ProximityGrid()\n{\n\tdtFree(m_buckets);\n\tdtFree(m_pool);\n}\n\t\nbool ProximityGrid::init(const int maxItems, const float cellSize)\n{\n\tdtAssert(maxItems \u003e 0);\n\tdtAssert(cellSize \u003e 0.0f);\n\t\n\tm_cellSize = cellSize;\n\tm_invCellSize = 1.0f / m_cellSize;\n\t\n\t// Allocate hashs buckets\n\tm_bucketsSize = dtNextPow2(maxItems);\n\tm_buckets = (unsigned short*)dtAlloc(sizeof(unsigned short)*m_bucketsSize, DT_ALLOC_PERM);\n\tif (!m_buckets)\n\t\treturn false;\n\n\t// Allocate pool of items.\n\tm_poolSize = maxItems*4;\n\tm_poolHead = 0;\n\tm_pool = (Item*)dtAlloc(sizeof(Item)*m_poolSize, DT_ALLOC_PERM);\n\tif (!m_pool)\n\t\treturn false;\n\t\n\tclear();\n\t\n\treturn true;\n}\n\nvoid ProximityGrid::clear()\n{\n\tmemset(m_buckets, 0xff, sizeof(unsigned short)*m_bucketsSize);\n\tm_poolHead = 0;\n\tm_bounds[0] = 0xffff;\n\tm_bounds[1] = 0xffff;\n\tm_bounds[2] = -0xffff;\n\tm_bounds[3] = -0xffff;\n}\n\nvoid ProximityGrid::addItem(const unsigned short id,\n\t\t\t\t\t\t\tconst float minx, const float miny,\n\t\t\t\t\t\t\tconst float maxx, const float maxy)\n{\n\tconst int iminx = (int)floorf(minx * m_invCellSize);\n\tconst int iminy = (int)floorf(miny * m_invCellSize);\n\tconst int imaxx = (int)floorf(maxx * m_invCellSize);\n\tconst int imaxy = (int)floorf(maxy * m_invCellSize);\n\t\n\tm_bounds[0] = dtMin(m_bounds[0], iminx);\n\tm_bounds[1] = dtMin(m_bounds[1], iminy);\n\tm_bounds[2] = dtMax(m_bounds[2], imaxx);\n\tm_bounds[3] = dtMax(m_bounds[3], imaxy);\n\t\n\tfor (int y = iminy; y \u003c= imaxy; ++y)\n\t{\n\t\tfor (int x = iminx; x \u003c= imaxx; ++x)\n\t\t{\n\t\t\tif (m_poolHead \u003c m_poolSize)\n\t\t\t{\n\t\t\t\tconst int h = hashPos2(x, y, m_bucketsSize);\n\t\t\t\tconst unsigned short idx = (unsigned short)m_poolHead;\n\t\t\t\tm_poolHead++;\n\t\t\t\tItem\u0026 item = m_pool[idx];\n\t\t\t\titem.x = (short)x;\n\t\t\t\titem.y = (short)y;\n\t\t\t\titem.id = id;\n\t\t\t\titem.next = m_buckets[h];\n\t\t\t\tm_buckets[h] = idx;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint ProximityGrid::queryItems(const float minx, const float miny,\n\t\t\t\t\t\t\t  const float maxx, const float maxy,\n\t\t\t\t\t\t\t  unsigned short* ids, const int maxIds) const\n{\n\tconst int iminx = (int)floorf(minx * m_invCellSize);\n\tconst int iminy = (int)floorf(miny * m_invCellSize);\n\tconst int imaxx = (int)floorf(maxx * m_invCellSize);\n\tconst int imaxy = (int)floorf(maxy * m_invCellSize);\n\t\n\tint n = 0;\n\t\n\tfor (int y = iminy; y \u003c= imaxy; ++y)\n\t{\n\t\tfor (int x = iminx; x \u003c= imaxx; ++x)\n\t\t{\n\t\t\tconst int h = hashPos2(x, y, m_bucketsSize);\n\t\t\tunsigned short idx = m_buckets[h];\n\t\t\twhile (idx != 0xffff)\n\t\t\t{\n\t\t\t\tItem\u0026 item = m_pool[idx];\n\t\t\t\tif ((int)item.x == x \u0026\u0026 (int)item.y == y)\n\t\t\t\t{\n\t\t\t\t\t// Check if the id exists already.\n\t\t\t\t\tconst unsigned short* end = ids + n;\n\t\t\t\t\tunsigned short* i = ids;\n\t\t\t\t\twhile (i != end \u0026\u0026 *i != item.id)\n\t\t\t\t\t\t++i;\n\t\t\t\t\t// Item not found, add it.\n\t\t\t\t\tif (i == end)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (n \u003e= maxIds)\n\t\t\t\t\t\t\treturn n;\n\t\t\t\t\t\tids[n++] = item.id;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tidx = item.next;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn n;\n}\n\nint ProximityGrid::getItemCountAt(const int x, const int y) const\n{\n\tint n = 0;\n\t\n\tconst int h = hashPos2(x, y, m_bucketsSize);\n\tunsigned short idx = m_buckets[h];\n\twhile (idx != 0xffff)\n\t{\n\t\tItem\u0026 item = m_pool[idx];\n\t\tif ((int)item.x == x \u0026\u0026 (int)item.y == y)\n\t\t\tn++;\n\t\tidx = item.next;\n\t}\n\n\treturn n;\n}\n\nPathQueue::PathQueue() :\n\tm_nextHandle(1),\n\tm_delay(0)\n{\n\tfor (int i = 0; i \u003c MAX_QUEUE; ++i)\n\t\tm_queue[i].ref = PATHQ_INVALID;\n}\n\nPathQueue::~PathQueue()\n{\n}\n\nvoid PathQueue::update(dtNavMeshQuery* navquery)\n{\n\t// Artificial delay to test the code better,\n\t// update only one request too.\n\t\n\t// TODO: Use sliced pathfinder.\n\tm_delay++;\n\tif ((m_delay % 4) == 0)\n\t{\n\t\tfor (int i = 0; i \u003c MAX_QUEUE; ++i)\n\t\t{\n\t\t\tPathQuery\u0026 q = m_queue[i];\n\t\t\tif (q.ref == PATHQ_INVALID)\n\t\t\t\tcontinue;\n\t\t\tnavquery-\u003efindPath(q.startRef, q.endRef, q.startPos, q.endPos,\n\t\t\t\t\t\t\t   q.filter, q.path, \u0026q.npath, PQ_MAX_PATH);\n\t\t\tq.ready = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Kill forgotten request.\n\tfor (int i = 0; i \u003c MAX_QUEUE; ++i)\n\t{\n\t\tPathQuery\u0026 q = m_queue[i];\n\t\tif (q.ref != PATHQ_INVALID \u0026\u0026 q.ready)\n\t\t{\n\t\t\tq.keepalive++;\n\t\t\tif (q.keepalive \u003e 2)\n\t\t\t\tq.ref = PATHQ_INVALID;\n\t\t}\n\t}\n}\n\nPathQueueRef PathQueue::request(dtPolyRef startRef, dtPolyRef endRef,\n\t\t\t\t\t\t\t\tconst float* startPos, const float* endPos,\n\t\t\t\t\t\t\t\tconst dtQueryFilter* filter)\n{\n\t// Find empty slot\n\tint slot = -1;\n\tfor (int i = 0; i \u003c MAX_QUEUE; ++i)\n\t{\n\t\tif (m_queue[i].ref == PATHQ_INVALID)\n\t\t{\n\t\t\tslot = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\t// Could not find slot.\n\tif (slot == -1)\n\t\treturn PATHQ_INVALID;\n\t\n\tPathQueueRef ref = m_nextHandle++;\n\tif (m_nextHandle == PATHQ_INVALID) m_nextHandle++;\n\t\n\tPathQuery\u0026 q = m_queue[slot];\n\tq.ref = ref;\n\tdtVcopy(q.startPos, startPos);\n\tq.startRef = startRef;\n\tdtVcopy(q.endPos, endPos);\n\tq.endRef = endRef;\n\tq.ready = false;\n\tq.npath = 0;\n\tq.filter = filter; // TODO: This is potentially dangerous!\n\tq.keepalive = 0;\n\t\n\treturn ref;\n}\n\nint PathQueue::getRequestState(PathQueueRef ref)\n{\n\tfor (int i = 0; i \u003c MAX_QUEUE; ++i)\n\t{\n\t\tif (m_queue[i].ref == ref)\n\t\t\treturn m_queue[i].ready ? PATHQ_STATE_READY : PATHQ_STATE_WORKING;\n\t}\n\t\n\treturn PATHQ_STATE_INVALID;\n}\n\nint PathQueue::getPathResult(PathQueueRef ref, dtPolyRef* path, const int maxPath)\n{\n\tfor (int i = 0; i \u003c MAX_QUEUE; ++i)\n\t{\n\t\tif (m_queue[i].ref == ref)\n\t\t{\n\t\t\tPathQuery\u0026 q = m_queue[i];\n\t\t\t// Allow to reuse the request.\n\t\t\tq.ref = PATHQ_INVALID;\n\t\t\tint n = 0;\n\t\t\tfor (int j = 0; j \u003c q.npath \u0026\u0026 j \u003c maxPath; ++j)\n\t\t\t\tpath[n++] = q.path[j];\n\t\t\treturn n;\n\t\t}\n\t}\n\treturn 0;\t\n}\n\n\nstatic int fixupCorridor(dtPolyRef* path, const int npath, const int maxPath,\n\t\t\t\t\t\t const dtPolyRef* visited, const int nvisited)\n{\n\tint furthestPath = -1;\n\tint furthestVisited = -1;\n\t\n\t// Find furthest common polygon.\n\tfor (int i = npath-1; i \u003e= 0; --i)\n\t{\n\t\tbool found = false;\n\t\tfor (int j = nvisited-1; j \u003e= 0; --j)\n\t\t{\n\t\t\tif (path[i] == visited[j])\n\t\t\t{\n\t\t\t\tfurthestPath = i;\n\t\t\t\tfurthestVisited = j;\n\t\t\t\tfound = true;\n\t\t\t}\n\t\t}\n\t\tif (found)\n\t\t\tbreak;\n\t}\n\t\n\t// If no intersection found just return current path. \n\tif (furthestPath == -1 || furthestVisited == -1)\n\t\treturn npath;\n\t\n\t// Concatenate paths.\t\n\t\n\t// Adjust beginning of the buffer to include the visited.\n\tconst int req = nvisited - furthestVisited;\n\tconst int orig = dtMin(furthestPath+1, npath);\n\tint size = dtMax(0, npath-orig);\n\tif (req+size \u003e maxPath)\n\t\tsize = maxPath-req;\n\tif (size)\n\t\tmemmove(path+req, path+orig, size*sizeof(dtPolyRef));\n\t\n\t// Store visited\n\tfor (int i = 0; i \u003c req; ++i)\n\t\tpath[i] = visited[(nvisited-1)-i];\t\t\t\t\n\t\n\treturn req+size;\n}\n\nstatic int fixupCorridorEnd(dtPolyRef* path, const int npath, const int maxPath,\n\t\t\t\t\t\t\tconst dtPolyRef* visited, const int nvisited)\n{\n\tint furthestPath = -1;\n\tint furthestVisited = -1;\n\t\n\t// Find furthest common polygon.\n\tfor (int i = 0; i \u003c npath; ++i)\n\t{\n\t\tbool found = false;\n\t\tfor (int j = nvisited-1; j \u003e= 0; --j)\n\t\t{\n\t\t\tif (path[i] == visited[j])\n\t\t\t{\n\t\t\t\tfurthestPath = i;\n\t\t\t\tfurthestVisited = j;\n\t\t\t\tfound = true;\n\t\t\t}\n\t\t}\n\t\tif (found)\n\t\t\tbreak;\n\t}\n\t\n\t// If no intersection found just return current path. \n\tif (furthestPath == -1 || furthestVisited == -1)\n\t\treturn npath;\n\t\n\t// Concatenate paths.\n\tconst int ppos = furthestPath+1;\n\tconst int vpos = furthestVisited+1;\n\tconst int count = dtMin(nvisited-vpos, maxPath-ppos);\n\tdtAssert(ppos+count \u003c= maxPath);\n\tif (count)\n\t\tmemcpy(path+ppos, visited+vpos, sizeof(dtPolyRef)*count);\n\n\treturn ppos+count;\n}\n\nstatic int mergeCorridor(dtPolyRef* path, const int npath, const int maxPath,\n\t\t\t\t\t\t const dtPolyRef* visited, const int nvisited)\n{\n\tint furthestPath = -1;\n\tint furthestVisited = -1;\n\t\n\t// Find furthest common polygon.\n\tfor (int i = npath-1; i \u003e= 0; --i)\n\t{\n\t\tbool found = false;\n\t\tfor (int j = nvisited-1; j \u003e= 0; --j)\n\t\t{\n\t\t\tif (path[i] == visited[j])\n\t\t\t{\n\t\t\t\tfurthestPath = i;\n\t\t\t\tfurthestVisited = j;\n\t\t\t\tfound = true;\n\t\t\t}\n\t\t}\n\t\tif (found)\n\t\t\tbreak;\n\t}\n\t\n\t// If no intersection found just return current path. \n\tif (furthestPath == -1 || furthestVisited == -1)\n\t\treturn npath;\n\t\n\t// Concatenate paths.\t\n\t\n\t// Adjust beginning of the buffer to include the visited.\n\tconst int req = furthestVisited;\n\tif (req \u003c= 0)\n\t\treturn npath;\n\t\n\tconst int orig = furthestPath;\n\tint size = dtMax(0, npath-orig);\n\tif (req+size \u003e maxPath)\n\t\tsize = maxPath-req;\n\tif (size)\n\t\tmemmove(path+req, path+orig, size*sizeof(dtPolyRef));\n\t\n\t// Store visited\n\tfor (int i = 0; i \u003c req; ++i)\n\t\tpath[i] = visited[i];\n\t\n\treturn req+size;\n}\n\nPathCorridor::PathCorridor() :\n\tm_path(0),\n\tm_npath(0),\n\tm_maxPath(0)\n{\n\t\n}\n\nPathCorridor::~PathCorridor()\n{\n\tdtFree(m_path);\n}\n\nbool PathCorridor::init(const int maxPath)\n{\n\tdtAssert(!m_path);\n\tm_path = (dtPolyRef*)dtAlloc(sizeof(dtPolyRef)*maxPath, DT_ALLOC_PERM);\n\tif (!m_path)\n\t\treturn false;\n\tm_npath = 0;\n\tm_maxPath = maxPath;\n\treturn true;\n}\n\nvoid PathCorridor::reset(dtPolyRef ref, const float* pos)\n{\n\tdtAssert(m_path);\n\tdtVcopy(m_pos, pos);\n\tdtVcopy(m_target, pos);\n\tm_path[0] = ref;\n\tm_npath = 1;\n}\n\nint PathCorridor::findCorners(float* cornerVerts, unsigned char* cornerFlags,\n\t\t\t\t\t\t\t  dtPolyRef* cornerPolys, const int maxCorners,\n\t\t\t\t\t\t\t  dtNavMeshQuery* navquery, const dtQueryFilter* filter)\n{\n\tdtAssert(m_path);\n\tdtAssert(m_npath);\n\t\n\tstatic const float MIN_TARGET_DIST = 0.01f;\n\t\n\tint ncorners = 0;\n\tnavquery-\u003efindStraightPath(m_pos, m_target, m_path, m_npath,\n\t\t\t\t\t\t\t   cornerVerts, cornerFlags, cornerPolys, \u0026ncorners, maxCorners);\n\t\n\t// Prune points in the beginning of the path which are too close.\n\twhile (ncorners)\n\t{\n\t\tif ((cornerFlags[0] \u0026 DT_STRAIGHTPATH_OFFMESH_CONNECTION) ||\n\t\t\tdtVdist2DSqr(\u0026cornerVerts[0], m_pos) \u003e dtSqr(MIN_TARGET_DIST))\n\t\t\tbreak;\n\t\tncorners--;\n\t\tif (ncorners)\n\t\t{\n\t\t\tmemmove(cornerFlags, cornerFlags+1, sizeof(unsigned char)*ncorners);\n\t\t\tmemmove(cornerPolys, cornerPolys+1, sizeof(dtPolyRef)*ncorners);\n\t\t\tmemmove(cornerVerts, cornerVerts+3, sizeof(float)*3*ncorners);\n\t\t}\n\t}\n\t\n\t// Prune points after an off-mesh connection.\n\tfor (int i = 0; i \u003c ncorners; ++i)\n\t{\n\t\tif (cornerFlags[i] \u0026 DT_STRAIGHTPATH_OFFMESH_CONNECTION)\n\t\t{\n\t\t\tncorners = i+1;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\treturn ncorners;\n}\n\nvoid PathCorridor::optimizePathVisibility(const float* next, const float pathOptimizationRange,\n\t\t\t\t\t\t\t\t\t\t  dtNavMeshQuery* navquery, const dtQueryFilter* filter)\n{\n\tdtAssert(m_path);\n\t\n\t// Clamp the ray to max distance.\n\tfloat goal[3];\n\tdtVcopy(goal, next);\n\tfloat dist = dtVdist2D(m_pos, goal);\n\t\n\t// If too close to the goal, do not try to optimize.\n\tif (dist \u003c 0.01f)\n\t\treturn;\n\n\t// Overshoot a little. This helps to optimize open fields in tiled meshes.\n\tdist = dtMin(dist+0.01f, pathOptimizationRange);\n\t\n\t// Adjust ray length.\n\tfloat delta[3];\n\tdtVsub(delta, goal, m_pos);\n\tdtVmad(goal, m_pos, delta, pathOptimizationRange/dist);\n\t\n\tstatic const int MAX_RES = 32;\n\tdtPolyRef res[MAX_RES];\n\tfloat t, norm[3];\n\tint nres = 0;\n\tnavquery-\u003eraycast(m_path[0], m_pos, goal, filter, \u0026t, norm, res, \u0026nres, MAX_RES);\n\tif (nres \u003e 1 \u0026\u0026 t \u003e 0.99f)\n\t{\n\t\tm_npath = mergeCorridor(m_path, m_npath, m_maxPath, res, nres);\n\t}\n}\n\nbool PathCorridor::optimizePathTopology(dtNavMeshQuery* navquery, const dtQueryFilter* filter)\n{\n\tdtAssert(m_path);\n\n\tif (m_npath \u003c 3)\n\t\treturn false;\n\t\n\tstatic const int MAX_ITER = 32;\n\tstatic const int MAX_RES = 32;\n\n\tdtPolyRef res[MAX_RES];\n\tint nres = 0;\n\tnavquery-\u003einitSlicedFindPath(m_path[0], m_path[m_npath-1], m_pos, m_target, filter);\n\tnavquery-\u003eupdateSlicedFindPath(MAX_ITER);\n\tdtStatus status = navquery-\u003efinalizeSlicedFindPathPartial(m_path, m_npath, res, \u0026nres, MAX_RES);\n\n\tif (status == DT_SUCCESS \u0026\u0026 nres \u003e 0)\n\t{\n\t\tm_npath = mergeCorridor(m_path, m_npath, m_maxPath, res, nres);\n\t\treturn true;\n\t}\n\t\n\treturn false;\n}\n\nvoid PathCorridor::movePosition(const float* npos, dtNavMeshQuery* navquery, const dtQueryFilter* filter)\n{\n\tdtAssert(m_path);\n\tdtAssert(m_npath);\n\t\n\t// Move along navmesh and update new position.\n\tfloat result[3];\n\tstatic const int MAX_VISITED = 16;\n\tdtPolyRef visited[MAX_VISITED];\n\tint nvisited = 0;\n\tnavquery-\u003emoveAlongSurface(m_path[0], m_pos, npos, filter,\n\t\t\t\t\t\t\t   result, visited, \u0026nvisited, MAX_VISITED);\n\tm_npath = fixupCorridor(m_path, m_npath, m_maxPath, visited, nvisited);\n\t\n\t// Adjust the position to stay on top of the navmesh.\n\tfloat h = m_pos[1];\n\tnavquery-\u003egetPolyHeight(m_path[0], result, \u0026h);\n\tresult[1] = h;\n\tdtVcopy(m_pos, result);\n}\n\nvoid PathCorridor::moveTargetPosition(const float* npos, dtNavMeshQuery* navquery, const dtQueryFilter* filter)\n{\n\tdtAssert(m_path);\n\tdtAssert(m_npath);\n\t\n\t// Move along navmesh and update new position.\n\tfloat result[3];\n\tstatic const int MAX_VISITED = 16;\n\tdtPolyRef visited[MAX_VISITED];\n\tint nvisited = 0;\n\tnavquery-\u003emoveAlongSurface(m_path[m_npath-1], m_target, npos, filter,\n\t\t\t\t\t\t\t   result, visited, \u0026nvisited, MAX_VISITED);\n\tm_npath = fixupCorridorEnd(m_path, m_npath, m_maxPath, visited, nvisited);\n\t\n\t// TODO: should we do that?\n\t// Adjust the position to stay on top of the navmesh.\n/*\tfloat h = m_target[1];\n\tnavquery-\u003egetPolyHeight(m_path[m_npath-1], result, \u0026h);\n\tresult[1] = h;*/\n\t\n\tdtVcopy(m_target, result);\n}\n\nvoid PathCorridor::setCorridor(const float* target, const dtPolyRef* path, const int npath)\n{\n\tdtAssert(m_path);\n\tdtAssert(npath \u003e 0);\n\tdtAssert(npath \u003c m_maxPath);\n\t\n\tdtVcopy(m_target, target);\n\tmemcpy(m_path, path, sizeof(dtPolyRef)*npath);\n\tm_npath = npath;\n}\n\n\n\n\nvoid Agent::integrate(const float maxAcc, const float dt)\n{\n\t// Fake dynamic constraint.\n\tconst float maxDelta = maxAcc * dt;\n\tfloat dv[3];\n\tdtVsub(dv, nvel, vel);\n\tfloat ds = dtVlen(dv);\n\tif (ds \u003e maxDelta)\n\t\tdtVscale(dv, dv, maxDelta/ds);\n\tdtVadd(vel, vel, dv);\n\t\n\t// Integrate\n\tif (dtVlen(vel) \u003e 0.0001f)\n\t\tdtVmad(npos, npos, vel, dt);\n\telse\n\t\tdtVset(vel,0,0,0);\n}\n\nfloat Agent::getDistanceToGoal(const float range) const\n{\n\tif (!ncorners)\n\t\treturn range;\n\t\n\tconst bool endOfPath = (cornerFlags[ncorners-1] \u0026 DT_STRAIGHTPATH_END) ? true : false;\n\tconst bool offMeshConnection = (cornerFlags[ncorners-1] \u0026 DT_STRAIGHTPATH_OFFMESH_CONNECTION) ? true : false;\n\tif (endOfPath || offMeshConnection)\n\t\treturn dtMin(dtVdist2D(npos, \u0026cornerVerts[(ncorners-1)*3]), range);\n\t\n\treturn range;\n}\n\nvoid Agent::calcSmoothSteerDirection(float* dir)\n{\n\tif (!ncorners)\n\t{\n\t\tdtVset(dir, 0,0,0);\n\t\treturn;\n\t}\n\t\n\tconst int ip0 = 0;\n\tconst int ip1 = dtMin(1, ncorners-1);\n\tconst float* p0 = \u0026cornerVerts[ip0*3];\n\tconst float* p1 = \u0026cornerVerts[ip1*3];\n\t\n\tfloat dir0[3], dir1[3];\n\tdtVsub(dir0, p0, npos);\n\tdtVsub(dir1, p1, npos);\n\tdir0[1] = 0;\n\tdir1[1] = 0;\n\t\n\tfloat len0 = dtVlen(dir0);\n\tfloat len1 = dtVlen(dir1);\n\tif (len1 \u003e 0.001f)\n\t\tdtVscale(dir1,dir1,1.0f/len1);\n\t\n\tdir[0] = dir0[0] - dir1[0]*len0*0.5f;\n\tdir[1] = 0;\n\tdir[2] = dir0[2] - dir1[2]*len0*0.5f;\n\t\n\tdtVnormalize(dir);\n}\n\nvoid Agent::calcStraightSteerDirection(float* dir)\n{\n\tif (!ncorners)\n\t{\n\t\tdtVset(dir, 0,0,0);\n\t\treturn;\n\t}\n\tdtVsub(dir, \u0026cornerVerts[0], npos);\n\tdir[1] = 0;\n\tdtVnormalize(dir);\n}\n\n\n\nLocalBoundary::LocalBoundary() :\n\tm_nsegs(0)\n{\n\tdtVset(m_center, FLT_MAX,FLT_MAX,FLT_MAX);\n}\n\nLocalBoundary::~LocalBoundary()\n{\n}\n\t\nvoid LocalBoundary::reset()\n{\n\tdtVset(m_center, FLT_MAX,FLT_MAX,FLT_MAX);\n\tm_nsegs = 0;\n}\n\nvoid LocalBoundary::addSegment(const float dist, const float* s)\n{\n\t// Insert neighbour based on the distance.\n\tSegment* seg = 0;\n\tif (!m_nsegs)\n\t{\n\t\t// First, trivial accept.\n\t\tseg = \u0026m_segs[0];\n\t}\n\telse if (dist \u003e= m_segs[m_nsegs-1].d)\n\t{\n\t\t// Further than the last segment, skip.\n\t\tif (m_nsegs \u003e= MAX_SEGS)\n\t\t\treturn;\n\t\t// Last, trivial accept.\n\t\tseg = \u0026m_segs[m_nsegs];\n\t}\n\telse\n\t{\n\t\t// Insert inbetween.\n\t\tint i;\n\t\tfor (i = 0; i \u003c m_nsegs; ++i)\n\t\t\tif (dist \u003c= m_segs[i].d)\n\t\t\t\tbreak;\n\t\tconst int tgt = i+1;\n\t\tconst int n = dtMin(m_nsegs-i, MAX_SEGS-tgt);\n\t\tdtAssert(tgt+n \u003c= MAX_SEGS);\n\t\tif (n \u003e 0)\n\t\t\tmemmove(\u0026m_segs[tgt], \u0026m_segs[i], sizeof(Segment)*n);\n\t\tseg = \u0026m_segs[i];\n\t}\n\t\n\tseg-\u003ed = dist;\n\tmemcpy(seg-\u003es, s, sizeof(float)*6);\n\t\n\tif (m_nsegs \u003c MAX_SEGS)\n\t\tm_nsegs++;\n}\n\nvoid LocalBoundary::update(dtPolyRef ref, const float* pos, const float collisionQueryRange,\n\t\t\t\t\t\t   dtNavMeshQuery* navquery, const dtQueryFilter* filter)\n{\n\tstatic const int MAX_LOCAL_POLYS = 16;\n\tstatic const int MAX_SEGS_PER_POLY = DT_VERTS_PER_POLYGON*2;\n\t\n\tif (!ref)\n\t{\n\t\tdtVset(m_center, FLT_MAX,FLT_MAX,FLT_MAX);\n\t\tm_nsegs = 0;\n\t\treturn;\n\t}\n\t\n\tdtVcopy(m_center, pos);\n\t\n\t// First query non-overlapping polygons.\n\tdtPolyRef locals[MAX_LOCAL_POLYS];\n\tint nlocals = 0;\n\tnavquery-\u003efindLocalNeighbourhood(ref, pos, collisionQueryRange,\n\t\t\t\t\t\t\t\t\t filter, locals, 0, \u0026nlocals, MAX_LOCAL_POLYS);\n\t\n\t// Secondly, store all polygon edges.\n\tm_nsegs = 0;\n\tfloat segs[MAX_SEGS_PER_POLY*6];\n\tint nsegs = 0;\n\tfor (int j = 0; j \u003c nlocals; ++j)\n\t{\n\t\tnavquery-\u003egetPolyWallSegments(locals[j], filter, segs, \u0026nsegs, MAX_SEGS_PER_POLY);\n\t\tfor (int k = 0; k \u003c nsegs; ++k)\n\t\t{\n\t\t\tconst float* s = \u0026segs[k*6];\n\t\t\t// Skip too distant segments.\n\t\t\tfloat tseg;\n\t\t\tconst float distSqr = dtDistancePtSegSqr2D(pos, s, s+3, tseg);\n\t\t\tif (distSqr \u003e dtSqr(collisionQueryRange))\n\t\t\t\tcontinue;\n\t\t\taddSegment(distSqr, s);\n\t\t}\n\t}\n}\n\n\nCrowdManager::CrowdManager() :\n\tm_obstacleQuery(0),\n\tm_pathResult(0),\n\tm_maxPathResult(0),\n\tm_totalTime(0),\n\tm_rvoTime(0),\n\tm_sampleCount(0),\n\tm_moveRequestCount(0)\n{\n\tdtVset(m_ext, 2,4,2);\n\t\n\tm_obstacleQuery = dtAllocObstacleAvoidanceQuery();\n\tm_obstacleQuery-\u003einit(6, 8);\n\t\n\tm_obstacleQuery-\u003esetDesiredVelocityWeight(2.0f);\n\tm_obstacleQuery-\u003esetCurrentVelocityWeight(0.75f);\n\tm_obstacleQuery-\u003esetPreferredSideWeight(0.75f);\n\tm_obstacleQuery-\u003esetCollisionTimeWeight(2.5f);\n\tm_obstacleQuery-\u003esetTimeHorizon(2.5f);\n\tm_obstacleQuery-\u003esetVelocitySelectionBias(0.4f);\n\t\n\tmemset(m_vodebug, 0, sizeof(m_vodebug));\n\tconst int maxAdaptiveSamples = (VO_ADAPTIVE_DIVS*VO_ADAPTIVE_RINGS+1)*VO_ADAPTIVE_DEPTH;\n\tconst int maxGridSamples = VO_GRID_SIZE*VO_GRID_SIZE;\n\tconst int sampleCount = dtMax(maxAdaptiveSamples, maxGridSamples);\n\tfor (int i = 0; i \u003c MAX_AGENTS; ++i)\n\t{\n\t\tm_vodebug[i] = dtAllocObstacleAvoidanceDebugData();\n\t\tm_vodebug[i]-\u003einit(sampleCount);\n\t}\n\t\n\t// Allocate temp buffer for merging paths.\n\tm_maxPathResult = 256;\n\tm_pathResult = (dtPolyRef*)dtAlloc(sizeof(dtPolyRef)*m_maxPathResult, DT_ALLOC_PERM);\n\n\t// Alloca corridors.\n\tfor (int i = 0; i \u003c MAX_AGENTS; ++i)\n\t{\n\t\tm_agents[i].corridor.init(m_maxPathResult);\n\t}\n\n\t// TODO: the radius should be related to the agent radius used to create the navmesh!\n\tm_grid.init(100, 1.0f);\n\t\n\treset();\n}\n\nCrowdManager::~CrowdManager()\n{\n\tdelete [] m_pathResult;\n\t\n\tfor (int i = 0; i \u003c MAX_AGENTS; ++i)\n\t\tdtFreeObstacleAvoidanceDebugData(m_vodebug[i]);\n\tdtFreeObstacleAvoidanceQuery(m_obstacleQuery);\n}\n\nvoid CrowdManager::reset()\n{\n\tfor (int i = 0; i \u003c MAX_AGENTS; ++i)\n\t\tm_agents[i].active = 0;\n}\n\nconst int CrowdManager::getAgentCount() const\n{\n\treturn MAX_AGENTS;\n}\n\nconst Agent* CrowdManager::getAgent(const int idx)\n{\n\treturn \u0026m_agents[idx];\n}\n\nint CrowdManager::addAgent(const float* pos, const float radius, const float height, dtNavMeshQuery* navquery)\n{\n\t// Find empty slot.\n\tint idx = -1;\n\tfor (int i = 0; i \u003c MAX_AGENTS; ++i)\n\t{\n\t\tif (!m_agents[i].active)\n\t\t{\n\t\t\tidx = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (idx == -1)\n\t\treturn -1;\n\t\n\tAgent* ag = \u0026m_agents[idx];\n\n\t// Find nearest position on navmesh and place the agent there.\n\tfloat nearest[3];\n\tdtPolyRef ref;\n\tnavquery-\u003efindNearestPoly(pos, m_ext, \u0026m_filter, \u0026ref, nearest);\n\tif (!ref)\n\t{\n\t\t// Could not find a location on navmesh.\n\t\treturn -1;\n\t}\n\t\n\tag-\u003ecorridor.reset(ref, nearest);\n\tag-\u003eboundary.reset();\n\n\tag-\u003eradius = radius;\n\tag-\u003eheight = height;\n\tag-\u003ecollisionQueryRange = radius * 8;\n\tag-\u003epathOptimizationRange = radius * 30;\n\tag-\u003etopologyOptTime = 0;\n\tag-\u003enneis = 0;\n\t\n\tdtVset(ag-\u003edvel, 0,0,0);\n\tdtVset(ag-\u003envel, 0,0,0);\n\tdtVset(ag-\u003evel, 0,0,0);\n\tdtVcopy(ag-\u003enpos, nearest);\n\t\n\tag-\u003emaxspeed = 0;\n\tag-\u003et = 0;\n\tdtVset(ag-\u003eopts, 0,0,0);\n\tdtVset(ag-\u003eopte, 0,0,0);\n\tag-\u003eactive = 1;\n\tag-\u003evar = (rand() % 10) / 9.0f;\n\t\n\t// Init trail\n\tfor (int i = 0; i \u003c AGENT_MAX_TRAIL; ++i)\n\t\tdtVcopy(\u0026ag-\u003etrail[i*3], ag-\u003ecorridor.getPos());\n\tag-\u003ehtrail = 0;\n\t\n\treturn idx;\n}\n\nvoid CrowdManager::removeAgent(const int idx)\n{\n\tif (idx \u003e= 0 \u0026\u0026 idx \u003c MAX_AGENTS)\n\t{\n\t\tm_agents[idx].active = 0;\n\t}\n}\n\nbool CrowdManager::requestMoveTarget(const int idx, dtPolyRef ref, const float* pos)\n{\n\tif (idx \u003c 0 || idx \u003e MAX_AGENTS)\n\t\treturn false;\n\tif (!ref)\n\t\treturn false;\n\t\n\tMoveRequest* req = 0;\n\t// Check if there is existing request and update that instead.\n\tfor (int i = 0; i \u003c m_moveRequestCount; ++i)\n\t{\n\t\tif (m_moveRequests[i].idx == idx)\n\t\t{\n\t\t\treq = \u0026m_moveRequests[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!req)\n\t{\n\t\tif (m_moveRequestCount \u003e= MAX_AGENTS)\n\t\t\treturn false;\n\t\treq = \u0026m_moveRequests[m_moveRequestCount++];\n\t\tmemset(req, 0, sizeof(MoveRequest));\n\t}\n\t\n\t// Initialize request.\n\treq-\u003eidx = idx;\n\treq-\u003eref = ref;\n\tdtVcopy(req-\u003epos, pos);\n\treq-\u003epathqRef = PATHQ_INVALID;\n\treq-\u003estate = MR_TARGET_REQUESTING;\n\n\treq-\u003etemp[0] = ref;\n\treq-\u003entemp = 1;\n\n\treturn true;\n}\n\nbool CrowdManager::adjustMoveTarget(const int idx, dtPolyRef ref, const float* pos)\n{\n\tif (idx \u003c 0 || idx \u003e MAX_AGENTS)\n\t\treturn false;\n\tif (!ref)\n\t\treturn false;\n\t\n\tMoveRequest* req = 0;\n\t// Check if there is existing request and update that instead.\n\tfor (int i = 0; i \u003c m_moveRequestCount; ++i)\n\t{\n\t\tif (m_moveRequests[i].idx == idx)\n\t\t{\n\t\t\treq = \u0026m_moveRequests[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!req)\n\t{\n\t\tif (m_moveRequestCount \u003e= MAX_AGENTS)\n\t\t\treturn false;\n\t\treq = \u0026m_moveRequests[m_moveRequestCount++];\n\t\tmemset(req, 0, sizeof(MoveRequest));\n\n\t\t// New adjust request\n\t\treq-\u003estate = MR_TARGET_ADJUST;\n\t\treq-\u003eidx = idx;\n\t}\n\n\t// Set adjustment request.\n\treq-\u003earef = ref;\n\tdtVcopy(req-\u003eapos, pos);\n\n\treturn true;\n}\n\nint CrowdManager::getActiveAgents(Agent** agents, const int maxAgents)\n{\n\tint n = 0;\n\tfor (int i = 0; i \u003c MAX_AGENTS; ++i)\n\t{\n\t\tif (!m_agents[i].active) continue;\n\t\tif (n \u003c maxAgents)\n\t\t\tagents[n++] = \u0026m_agents[i];\n\t}\n\treturn n;\n}\n\n\nstatic int addNeighbour(const int idx, const float dist,\n\t\t\t\t\t\tNeighbour* neis, const int nneis, const int maxNeis)\n{\n\t// Insert neighbour based on the distance.\n\tNeighbour* nei = 0;\n\tif (!nneis)\n\t{\n\t\tnei = \u0026neis[nneis];\n\t}\n\telse if (dist \u003e= neis[nneis-1].dist)\n\t{\n\t\tif (nneis \u003e= maxNeis)\n\t\t\treturn nneis;\n\t\tnei = \u0026neis[nneis];\n\t}\n\telse\n\t{\n\t\tint i;\n\t\tfor (i = 0; i \u003c nneis; ++i)\n\t\t\tif (dist \u003c= neis[i].dist)\n\t\t\t\tbreak;\n\t\t\n\t\tconst int tgt = i+1;\n\t\tconst int n = dtMin(nneis-i, maxNeis-tgt);\n\t\t\n\t\tdtAssert(tgt+n \u003c= maxNeis);\n\t\t\n\t\tif (n \u003e 0)\n\t\t\tmemmove(\u0026neis[tgt], \u0026neis[i], sizeof(Neighbour)*n);\n\t\tnei = \u0026neis[i];\n\t}\n\t\n\tmemset(nei, 0, sizeof(Neighbour));\n\n\tnei-\u003eidx = idx;\n\tnei-\u003edist = dist;\n\t\n\treturn dtMin(nneis+1, maxNeis);\n}\n\nint CrowdManager::getNeighbours(const float* pos, const float height, const float range,\n\t\t\t\t\t\t\t\tconst Agent* skip, Neighbour* result, const int maxResult)\n{\n\tint n = 0;\n\t\n\tunsigned short ids[MAX_AGENTS];\n\tint nids = m_grid.queryItems(pos[0]-range, pos[2]-range,\n\t\t\t\t\t\t\t\t pos[0]+range, pos[2]+range,\n\t\t\t\t\t\t\t\t ids, MAX_AGENTS);\n\t\n\tfor (int i = 0; i \u003c nids; ++i)\n\t{\n\t\tAgent* ag = \u0026m_agents[ids[i]];\n\n\t\tif (ag == skip) continue;\n\n\t\t// Check for overlap.\n\t\tfloat diff[3];\n\t\tdtVsub(diff, pos, ag-\u003enpos);\n\t\tif (fabsf(diff[1]) \u003e= (height+ag-\u003eheight)/2.0f)\n\t\t\tcontinue;\n\t\tdiff[1] = 0;\n\t\tconst float distSqr = dtVlenSqr(diff);\n\t\tif (distSqr \u003e dtSqr(range))\n\t\t\tcontinue;\n\t\t\n\t\tn = addNeighbour(ids[i], distSqr, result, n, maxResult);\n\t}\n\treturn n;\n}\n\nvoid CrowdManager::updateMoveRequest(const float dt, dtNavMeshQuery* navquery, const dtQueryFilter* filter)\n{\n\t// Fire off new requests.\n\tfor (int i = 0; i \u003c m_moveRequestCount; ++i)\n\t{\n\t\tMoveRequest* req = \u0026m_moveRequests[i];\n\t\tAgent* ag = \u0026m_agents[req-\u003eidx];\n\t\t\n\t\t// Agent not active anymore, kill request.\n\t\tif (!ag-\u003eactive)\n\t\t\treq-\u003estate = MR_TARGET_FAILED;\n\t\t\n\t\t// Adjust target\n\t\tif (req-\u003earef)\n\t\t{\n\t\t\tif (req-\u003estate == MR_TARGET_ADJUST)\n\t\t\t{\n\t\t\t\t// Adjust existing path.\n\t\t\t\tag-\u003ecorridor.moveTargetPosition(req-\u003eapos, navquery, filter);\n\t\t\t\treq-\u003estate = MR_TARGET_VALID;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Adjust on the flight request.\n\t\t\t\tfloat result[3];\n\t\t\t\tstatic const int MAX_VISITED = 16;\n\t\t\t\tdtPolyRef visited[MAX_VISITED];\n\t\t\t\tint nvisited = 0;\n\t\t\t\tnavquery-\u003emoveAlongSurface(req-\u003etemp[req-\u003entemp-1], req-\u003epos, req-\u003eapos, filter,\n\t\t\t\t\t\t\t\t\t\t   result, visited, \u0026nvisited, MAX_VISITED);\n\t\t\t\treq-\u003entemp = fixupCorridorEnd(req-\u003etemp, req-\u003entemp, MAX_TEMP_PATH, visited, nvisited);\n\t\t\t\tdtVcopy(req-\u003epos, result);\n\t\t\t\t\n\t\t\t\t// Reset adjustment.\n\t\t\t\tdtVset(req-\u003eapos, 0,0,0);\n\t\t\t\treq-\u003earef = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tif (req-\u003estate == MR_TARGET_REQUESTING)\n\t\t{\n\t\t\t// Calculate request position.\n\t\t\t// If there is a lot of latency between requests, it is possible to\n\t\t\t// project the current position ahead and use raycast to find the actual\n\t\t\t// location and path.\n\t\t\tconst dtPolyRef* path = ag-\u003ecorridor.getPath();\n\t\t\tconst int npath = ag-\u003ecorridor.getPathCount();\n\t\t\tdtAssert(npath);\n\t\t\t\n\t\t\t// Here we take the simple approach and set the path to be just the current location.\n\t\t\tfloat reqPos[3];\n\t\t\tdtVcopy(reqPos, ag-\u003ecorridor.getPos());\t// The location of the request\n\t\t\tdtPolyRef reqPath[8];\t\t\t\t\t// The path to the request location\n\t\t\treqPath[0] = path[0];\n\t\t\tint reqPathCount = 1;\n\t\t\t\n\t\t\treq-\u003epathqRef = m_pathq.request(reqPath[reqPathCount-1], req-\u003eref, reqPos, req-\u003epos, \u0026m_filter);\n\t\t\tif (req-\u003epathqRef != PATHQ_INVALID)\n\t\t\t{\n\t\t\t\tag-\u003ecorridor.setCorridor(reqPos, reqPath, reqPathCount);\n\t\t\t\treq-\u003estate = MR_TARGET_WAITING_FOR_PATH;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// Update requests.\n\tm_pathq.update(navquery);\n\t\n\n\t// Process path results.\n\tfor (int i = 0; i \u003c m_moveRequestCount; ++i)\n\t{\n\t\tMoveRequest* req = \u0026m_moveRequests[i];\n\t\tAgent* ag = \u0026m_agents[req-\u003eidx];\n\t\t\n\t\tif (req-\u003estate == MR_TARGET_WAITING_FOR_PATH)\n\t\t{\n\t\t\t// Poll path queue.\n\t\t\tint state = m_pathq.getRequestState(req-\u003epathqRef);\n\t\t\tif (state == PATHQ_STATE_INVALID)\n\t\t\t{\n\t\t\t\treq-\u003epathqRef = PATHQ_INVALID;\n\t\t\t\treq-\u003estate = MR_TARGET_FAILED;\n\t\t\t}\n\t\t\telse if (state == PATHQ_STATE_READY)\n\t\t\t{\n\t\t\t\tconst dtPolyRef* path = ag-\u003ecorridor.getPath();\n\t\t\t\tconst int npath = ag-\u003ecorridor.getPathCount();\n\t\t\t\tdtAssert(npath);\n\t\t\t\t\n\t\t\t\t// Apply results.\n\t\t\t\tfloat targetPos[3];\n\t\t\t\tdtVcopy(targetPos, req-\u003epos);\n\t\t\t\t\n\t\t\t\tdtPolyRef* res = m_pathResult;\n\t\t\t\tbool valid = true;\n\t\t\t\tint nres = m_pathq.getPathResult(req-\u003epathqRef, res, m_maxPathResult);\n\t\t\t\tif (!nres)\n\t\t\t\t\tvalid = false;\n\t\t\t\t\n\t\t\t\t// Merge with any target adjustment that happened during the search.\n\t\t\t\tif (req-\u003entemp \u003e 1)\n\t\t\t\t{\n\t\t\t\t\tnres = fixupCorridorEnd(res, nres, m_maxPathResult, req-\u003etemp, req-\u003entemp);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Merge result and existing path.\n\t\t\t\t// The agent might have moved whilst the request is\n\t\t\t\t// being processed, so the path may have changed.\n\t\t\t\t// We assume that the end of the path is at the same location\n\t\t\t\t// where the request was issued.\n\t\t\t\t\n\t\t\t\t// The last ref in the old path should be the same as\n\t\t\t\t// the location where the request was issued..\n\t\t\t\tif (valid \u0026\u0026 path[npath-1] != res[0])\n\t\t\t\t\tvalid = false;\n\t\t\t\t\n\t\t\t\tif (valid)\n\t\t\t\t{\n\t\t\t\t\t// Put the old path infront of the old path.\n\t\t\t\t\tif (npath \u003e 1)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Make space for the old path.\n\t\t\t\t\t\tif ((npath-1)+nres \u003e m_maxPathResult)\n\t\t\t\t\t\t\tnres = m_maxPathResult - (npath-1);\n\t\t\t\t\t\tmemmove(res+npath-1, res, sizeof(dtPolyRef)*nres);\n\t\t\t\t\t\t// Copy old path in the beginning.\n\t\t\t\t\t\tmemcpy(res, path, sizeof(dtPolyRef)*(npath-1));\n\t\t\t\t\t\tnres += npath-1;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// Check for partial path.\n\t\t\t\t\tif (res[nres-1] != req-\u003eref)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Partial path, constrain target position inside the last polygon.\n\t\t\t\t\t\tfloat nearest[3];\n\t\t\t\t\t\tif (navquery-\u003eclosestPointOnPoly(res[nres-1], targetPos, nearest) == DT_SUCCESS)\n\t\t\t\t\t\t\tdtVcopy(targetPos, nearest);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tvalid = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (valid)\n\t\t\t\t{\n\t\t\t\t\tag-\u003ecorridor.setCorridor(targetPos, res, nres);\n\t\t\t\t\treq-\u003estate = MR_TARGET_VALID;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// Something went wrong.\n\t\t\t\t\treq-\u003estate = MR_TARGET_FAILED;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Remove request when done with it.\n\t\tif (req-\u003estate == MR_TARGET_VALID || req-\u003estate == MR_TARGET_FAILED)\n\t\t{\n\t\t\tm_moveRequestCount--;\n\t\t\tif (i != m_moveRequestCount)\n\t\t\t\tmemcpy(\u0026m_moveRequests[i], \u0026m_moveRequests[m_moveRequestCount], sizeof(MoveRequest));\n\t\t\t--i;\n\t\t}\n\t}\n\t\n}\n\n\n\nstatic int addToOptQueue(Agent* newag, Agent** agents, const int nagents, const int maxAgents)\n{\n\t// Insert neighbour based on greatest time.\n\tint slot = 0;\n\tif (!nagents)\n\t{\n\t\tslot = nagents;\n\t}\n\telse if (newag-\u003etopologyOptTime \u003c= agents[nagents-1]-\u003etopologyOptTime)\n\t{\n\t\tif (nagents \u003e= maxAgents)\n\t\t\treturn nagents;\n\t\tslot = nagents;\n\t}\n\telse\n\t{\n\t\tint i;\n\t\tfor (i = 0; i \u003c nagents; ++i)\n\t\t\tif (newag-\u003etopologyOptTime \u003e= agents[i]-\u003etopologyOptTime)\n\t\t\t\tbreak;\n\t\t\n\t\tconst int tgt = i+1;\n\t\tconst int n = dtMin(nagents-i, maxAgents-tgt);\n\t\t\n\t\tdtAssert(tgt+n \u003c= maxAgents);\n\t\t\n\t\tif (n \u003e 0)\n\t\t\tmemmove(\u0026agents[tgt], \u0026agents[i], sizeof(Agent*)*n);\n\t\tslot = i;\n\t}\n\n\tagents[slot] = newag;\n\t\n\treturn dtMin(nagents+1, maxAgents);\n}\n\nvoid CrowdManager::updateTopologyOptimization(const float dt, dtNavMeshQuery* navquery, const dtQueryFilter* filter)\n{\n\tAgent* agents[MAX_AGENTS];\n\tint nagents = getActiveAgents(agents, MAX_AGENTS);\n\tif (!nagents)\n\t\treturn;\n\t\n\tconst float OPT_TIME_THR = 0.5f; // seconds\n\tconst int OPT_MAX_AGENTS = 1;\n\t\n\tAgent* queue[OPT_MAX_AGENTS];\n\tint nqueue = 0;\n\t\n\tfor (int i = 0; i \u003c nagents; ++i)\n\t{\n\t\tAgent* ag = agents[i];\n\t\tag-\u003etopologyOptTime += dt;\n\t\tif (ag-\u003etopologyOptTime \u003e= OPT_TIME_THR)\n\t\t{\n\t\t\tnqueue = addToOptQueue(ag, queue, nqueue, OPT_MAX_AGENTS);\n\t\t}\n\t}\n\n\tfor (int i = 0; i \u003c nqueue; ++i)\n\t{\n\t\tAgent* ag = queue[i];\n\t\tag-\u003ecorridor.optimizePathTopology(navquery, filter);\n\t\tag-\u003etopologyOptTime = 0;\n\t}\n\n}\n\nvoid CrowdManager::update(const float dt, unsigned int flags, dtNavMeshQuery* navquery)\n{\n\tm_sampleCount = 0;\n\tm_totalTime = 0;\n\tm_rvoTime = 0;\n\t\n\tif (!navquery)\n\t\treturn;\n\t\n\tTimeVal startTime = getPerfTime();\n\t\n\tAgent* agents[MAX_AGENTS];\n\tint nagents = getActiveAgents(agents, MAX_AGENTS);\n\t\n\tstatic const float MAX_ACC = 8.0f;\n\tstatic const float MAX_SPEED = 3.5f;\n\n\t// Update async move request and path finder.\n\tupdateMoveRequest(dt, navquery, \u0026m_filter);\n\n\t// Optimize path topology.\n\tif (flags \u0026 CROWDMAN_OPTIMIZE_TOPO)\n\t\tupdateTopologyOptimization(dt, navquery, \u0026m_filter);\n\t\n\t// Register agents to proximity grid.\n\tm_grid.clear();\n\tfor (int i = 0; i \u003c nagents; ++i)\n\t{\n\t\tAgent* ag = agents[i];\n\t\tconst float* p = ag-\u003enpos;\n\t\tconst float r = ag-\u003eradius;\n\t\tm_grid.addItem((unsigned short)i, p[0]-r, p[2]-r, p[0]+r, p[2]+r);\n\t}\n\t\n\t// Get nearby navmesh segments and agents to collide with.\n\tfor (int i = 0; i \u003c nagents; ++i)\n\t{\n\t\tAgent* ag = agents[i];\n\t\t// Only update the collision boundary after certain distance has been passed.\n\t\tif (dtVdist2DSqr(ag-\u003enpos, ag-\u003eboundary.getCenter()) \u003e dtSqr(ag-\u003ecollisionQueryRange*0.25f))\n\t\t\tag-\u003eboundary.update(ag-\u003ecorridor.getFirstPoly(), ag-\u003enpos, ag-\u003ecollisionQueryRange, navquery, \u0026m_filter);\n\t\t// Query neighbour agents\n\t\tag-\u003enneis = getNeighbours(ag-\u003enpos, ag-\u003eheight, ag-\u003ecollisionQueryRange, ag, ag-\u003eneis, AGENT_MAX_NEIGHBOURS);\n\t}\n\t\n\t// Find next corner to steer to.\n\tfor (int i = 0; i \u003c nagents; ++i)\n\t{\n\t\tAgent* ag = agents[i];\n\t\t\n\t\t// Find corners for steering\n\t\tag-\u003encorners = ag-\u003ecorridor.findCorners(ag-\u003ecornerVerts, ag-\u003ecornerFlags, ag-\u003ecornerPolys,\n\t\t\t\t\t\t\t\t\t\t\t\tAGENT_MAX_CORNERS, navquery, \u0026m_filter);\n\t\t\n\t\t// Check to see if the corner after the next corner is directly visible,\n\t\t// and short cut to there.\n\t\tif ((flags \u0026 CROWDMAN_OPTIMIZE_VIS) \u0026\u0026 ag-\u003encorners \u003e 0)\n\t\t{\n\t\t\tconst float* target = \u0026ag-\u003ecornerVerts[dtMin(1,ag-\u003encorners-1)*3];\n\t\t\tdtVcopy(ag-\u003eopts, ag-\u003ecorridor.getPos());\n\t\t\tdtVcopy(ag-\u003eopte, target);\n\t\t\tag-\u003ecorridor.optimizePathVisibility(target, ag-\u003epathOptimizationRange, navquery, \u0026m_filter);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdtVset(ag-\u003eopts, 0,0,0);\n\t\t\tdtVset(ag-\u003eopte, 0,0,0);\n\t\t}\n\t\t\n\t\t// Copy data for debug purposes.\n\t}\n\t\n\t// Calculate steering.\n\tfor (int i = 0; i \u003c nagents; ++i)\n\t{\n\t\tAgent* ag = agents[i];\n\t\t\n\t\tfloat dvel[3] = {0,0,0};\n\t\t\n\t\t// Calculate steering direction.\n\t\tif (flags \u0026 CROWDMAN_ANTICIPATE_TURNS)\n\t\t\tag-\u003ecalcSmoothSteerDirection(dvel);\n\t\telse\n\t\t\tag-\u003ecalcStraightSteerDirection(dvel);\n\t\t\n\t\t// Calculate speed scale, which tells the agent to slowdown at the end of the path.\n\t\tconst float slowDownRadius = ag-\u003eradius*2;\t// TODO: make less hacky.\n\t\tconst float speedScale = ag-\u003egetDistanceToGoal(slowDownRadius) / slowDownRadius;\n\t\t\n\t\t// Apply style.\n\t\tif (flags \u0026 CROWDMAN_DRUNK)\n\t\t{\n\t\t\t// Drunken steering\n\t\t\t\n\t\t\t// Pulsating speed.\n\t\t\tag-\u003et += dt * (1.0f - ag-\u003evar*0.25f);\n\t\t\tag-\u003emaxspeed = MAX_SPEED*(1 + dtSqr(cosf(ag-\u003et*2.0f))*0.3f);\n\t\t\t\n\t\t\tdtVscale(dvel, dvel, ag-\u003emaxspeed * speedScale);\n\t\t\t\n\t\t\t// Slightly wandering steering.\n\t\t\tconst float amp = cosf(ag-\u003evar*13.69f+ag-\u003et*3.123f) * 0.2f;\n\t\t\tconst float nx = -dvel[2];\n\t\t\tconst float nz = dvel[0];\n\t\t\tdvel[0] += nx*amp;\n\t\t\tdvel[2] += nz*amp;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Normal steering.\n\t\t\tag-\u003emaxspeed = MAX_SPEED;\n\t\t\tdtVscale(dvel, dvel, ag-\u003emaxspeed * speedScale);\n\t\t}\n\t\t\n\t\t// Set the desired velocity.\n\t\tdtVcopy(ag-\u003edvel, dvel);\n\t}\n\t\n\t// Velocity planning.\n\tTimeVal rvoStartTime = getPerfTime();\n\t\n\tfor (int i = 0; i \u003c nagents; ++i)\n\t{\n\t\tAgent* ag = agents[i];\n\t\t\n\t\tif (flags \u0026 CROWDMAN_USE_VO)\n\t\t{\n\t\t\tm_obstacleQuery-\u003ereset();\n\t\t\t\n\t\t\t// Add neighbours as obstacles.\n\t\t\tfor (int j = 0; j \u003c ag-\u003enneis; ++j)\n\t\t\t{\n\t\t\t\tconst Agent* nei = \u0026m_agents[ag-\u003eneis[j].idx];\n\t\t\t\tm_obstacleQuery-\u003eaddCircle(nei-\u003enpos, nei-\u003eradius, nei-\u003evel, nei-\u003edvel);\n\t\t\t}\n\n\t\t\t// Append neighbour segments as obstacles.\n\t\t\tfor (int j = 0; j \u003c ag-\u003eboundary.getSegmentCount(); ++j)\n\t\t\t{\n\t\t\t\tconst float* s = ag-\u003eboundary.getSegment(j);\n\t\t\t\tif (dtTriArea2D(ag-\u003enpos, s, s+3) \u003c 0.0f)\n\t\t\t\t\tcontinue;\n\t\t\t\tm_obstacleQuery-\u003eaddSegment(s, s+3);\n\t\t\t}\n\n\t\t\t// Sample new safe velocity.\n\t\t\tbool adaptive = true;\n\n\t\t\tif (adaptive)\n\t\t\t{\n\t\t\t\tm_obstacleQuery-\u003esampleVelocityAdaptive(ag-\u003enpos, ag-\u003eradius, ag-\u003emaxspeed,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tag-\u003evel, ag-\u003edvel, ag-\u003envel,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tVO_ADAPTIVE_DIVS, VO_ADAPTIVE_RINGS, VO_ADAPTIVE_DEPTH,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tm_vodebug[i]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tm_obstacleQuery-\u003esampleVelocityGrid(ag-\u003enpos, ag-\u003eradius, ag-\u003emaxspeed,\n\t\t\t\t\t\t\t\t\t\t\t\t\tag-\u003evel, ag-\u003edvel, ag-\u003envel,\n\t\t\t\t\t\t\t\t\t\t\t\t\tVO_GRID_SIZE, m_vodebug[i]);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// If not using velocity planning, new velocity is directly the desired velocity.\n\t\t\tdtVcopy(ag-\u003envel, ag-\u003edvel);\n\t\t}\n\t}\n\tTimeVal rvoEndTime = getPerfTime();\n\t\n\t// Integrate.\n\tfor (int i = 0; i \u003c nagents; ++i)\n\t{\n\t\tAgent* ag = agents[i];\n\t\tag-\u003eintegrate(MAX_ACC, dt);\n\t}\n\t\n\t// Handle collisions.\n\tfor (int iter = 0; iter \u003c 4; ++iter)\n\t{\n\t\tfor (int i = 0; i \u003c nagents; ++i)\n\t\t{\n\t\t\tAgent* ag = agents[i];\n\t\t\t\n\t\t\tdtVset(ag-\u003edisp, 0,0,0);\n\t\t\t\n\t\t\tfloat w = 0;\n\n\t\t\tfor (int j = 0; j \u003c ag-\u003enneis; ++j)\n\t\t\t{\n\t\t\t\tconst Agent* nei = \u0026m_agents[ag-\u003eneis[j].idx];\n\t\t\t\t\n\t\t\t\tfloat diff[3];\n\t\t\t\tdtVsub(diff, ag-\u003enpos, nei-\u003enpos);\n\t\t\t\t\n\t\t\t\tif (fabsf(diff[1]) \u003e= (ag-\u003eheight+  nei-\u003eheight)/2.0f)\n\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\tdiff[1] = 0;\n\t\t\t\t\n\t\t\t\tfloat dist = dtVlenSqr(diff);\n\t\t\t\tif (dist \u003e dtSqr(ag-\u003eradius + nei-\u003eradius))\n\t\t\t\t\tcontinue;\n\t\t\t\tdist = sqrtf(dist);\n\t\t\t\tfloat pen = (ag-\u003eradius + nei-\u003eradius) - dist;\n\t\t\t\tif (dist \u003e 0.0001f)\n\t\t\t\t\tpen = (1.0f/dist) * (pen*0.5f) * 0.7f;\n\t\t\t\t\n\t\t\t\tdtVmad(ag-\u003edisp, ag-\u003edisp, diff, pen);\t\t\t\n\t\t\t\t\n\t\t\t\tw += 1.0f;\n\t\t\t}\n\t\t\t\n\t\t\tif (w \u003e 0.0001f)\n\t\t\t{\n\t\t\t\tconst float iw = 1.0f / w;\n\t\t\t\tdtVscale(ag-\u003edisp, ag-\u003edisp, iw);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i \u003c nagents; ++i)\n\t\t{\n\t\t\tAgent* ag = agents[i];\n\t\t\tdtVadd(ag-\u003enpos, ag-\u003enpos, ag-\u003edisp);\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i \u003c nagents; ++i)\n\t{\n\t\tAgent* ag = agents[i];\n\t\t// Move along navmesh.\n\t\tag-\u003ecorridor.movePosition(ag-\u003enpos, navquery, \u0026m_filter);\n\t\t// Get valid constrained position back.\n\t\tdtVcopy(ag-\u003enpos, ag-\u003ecorridor.getPos());\n\t}\n\t\n\tTimeVal endTime = getPerfTime();\n\n\t// Debug/demo book keeping\n\tint ns = 0;\n\tfor (int i = 0; i \u003c nagents; ++i)\n\t{\n\t\tAgent* ag = agents[i];\n\t\t\n\t\tif (flags \u0026 CROWDMAN_USE_VO)\n\t\t{\n\t\t\t// Normalize samples for debug draw\n\t\t\tm_vodebug[i]-\u003enormalizeSamples();\n\t\t\tns += m_vodebug[i]-\u003egetSampleCount();\n\t\t}\n\t\t\n\t\t// Update agent movement trail.\n\t\tag-\u003ehtrail = (ag-\u003ehtrail + 1) % AGENT_MAX_TRAIL;\n\t\tdtVcopy(\u0026ag-\u003etrail[ag-\u003ehtrail*3], ag-\u003enpos);\n\t}\n\n\tm_sampleCount = ns;\n\tm_rvoTime = getPerfDeltaTimeUsec(rvoStartTime, rvoEndTime);\n\tm_totalTime = getPerfDeltaTimeUsec(startTime, endTime);\n}\n\n\n"}
{"repo_name":"JIghtuse/functional-cpp","ref":"refs/heads/master","path":"src/functional_objects/company.cpp","copies":"1","language":"C++","content":"#include \u003ccompany.h\u003e\n#include \u003calgorithm\u003e\n\n// possible implementation for lambda in countTeamMembers\nclass lambda_implementation {\npublic:\n    lambda_implementation(const Company* _this,\n                          const std::string\u0026 teamName)\n        : m_this{_this}\n        , m_teamName{teamName}\n    {\n    }\n\n    bool operator() (const Person\u0026 employee) const\n    {\n        return m_this-\u003eteamNameFor(employee) == m_teamName;\n    }\nprivate:\n    const Company* m_this;\n    const std::string\u0026 m_teamName;\n};\n\nint Company::countTeamMembers(const std::string\u0026 teamName) const\n{\n    return std::count_if(\n            m_employees.cbegin(), m_employees.cend(),\n            [this, \u0026teamName](const Person\u0026 p) {\n                return teamNameFor(p) == teamName;\n            });\n}\n\nstd::string Company::teamNameFor(const Person\u0026) const\n{\n    return \"some\";\n}\n"}
{"repo_name":"peak3d/inputstream.adaptive","ref":"refs/heads/master","path":"lib/libbento4/Core/Ap4.cpp","copies":"4","language":"C++","content":"/*****************************************************************\n|\n|    AP4 - Main Header\n|\n|    Copyright 2002-2008 Axiomatic Systems, LLC\n|\n|\n|    This file is part of Bento4/AP4 (MP4 Atom Processing Library).\n|\n|    Unless you have obtained Bento4 under a difference license,\n|    this version of Bento4 is Bento4|GPL.\n|    Bento4|GPL is free software; you can redistribute it and/or modify\n|    it under the terms of the GNU General Public License as published by\n|    the Free Software Foundation; either version 2, or (at your option)\n|    any later version.\n|\n|    Bento4|GPL is distributed in the hope that it will be useful,\n|    but WITHOUT ANY WARRANTY; without even the implied warranty of\n|    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n|    GNU General Public License for more details.\n|\n|    You should have received a copy of the GNU General Public License\n|    along with Bento4|GPL; see the file COPYING.  If not, write to the\n|    Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n|    02111-1307, USA.\n|\n ****************************************************************/\n\n/*----------------------------------------------------------------------\n|   includes\n+---------------------------------------------------------------------*/\n#include \"Ap4.h\"\n\n/*----------------------------------------------------------------------\n|   AP4::AP4\n+---------------------------------------------------------------------*/\n// this constructor can be used to detect if the platform's loader\n// correctly constructs static C++ objects\nstatic AP4 AP4_LoaderCheck;\nAP4::AP4() : m_ConstructedByLoader(true)\n{\n}\n\n/*----------------------------------------------------------------------\n|   AP4::Initialize\n+---------------------------------------------------------------------*/\nAP4_Result\nAP4::Initialize()\n{\n    AP4_Result result = AP4_SUCCESS;\n#if defined(AP4_CONFIG_CONSTRUCT_STATICS_ON_INITIALIZE)\n    if (!AP4_DefaultAtomFactory::Instance.m_Initialized) {\n        result = AP4_DefaultAtomFactory::Instance.Initialize();\n        if (AP4_FAILED(result)) return result;\n    }\n    if (!AP4_DefaultBlockCipherFactory::Instance.m_Initialized) {\n        result = AP4_DefaultBlockCipherFactory::Instance.Initialize();\n        if (AP4_FAILED(result)) return result;\n    }\n    if (!AP4_MetaData::Initialized()) {\n        AP4_MetaData::Initialize();\n    }\n#endif\n    \n    return result;\n}\n\n/*----------------------------------------------------------------------\n|   AP4_Terminate\n+---------------------------------------------------------------------*/\nAP4_Result\nAP4::Terminate()\n{\n#if defined(AP4_CONFIG_DESTRUCT_STATICS_ON_TERMINATE)\n    if (!AP4_LoaderCheck.m_ConstructedByLoader) {\n        if (AP4_DefaultAtomFactory::Instance.m_Initialized) {\n            AP4_DefaultAtomFactory::Instance.~AP4_DefaultAtomFactory();\n        }\n        if (AP4_DefaultBlockCipherFactory::Instance.m_Initialized) {\n            AP4_DefaultBlockCipherFactory::Instance.~AP4_DefaultBlockCipherFactory();\n        }\n        if (AP4_MetaData::Initialized()) {\n            AP4_MetaData::UnInitialize();\n        }\n    }\n#endif\n\n    return AP4_SUCCESS;\n} \n"}
{"repo_name":"keichan100yen/ode-ext","ref":"refs/heads/master","path":"boost/libs/config/test/no_std_allocator_fail.cpp","copies":"71","language":"C++","content":"//  This file was automatically generated on Fri Dec 03 18:04:02 2004\n//  by libs/config/tools/generate.cpp\n//  Copyright John Maddock 2002-4.\n//  Use, modification and distribution are subject to the \n//  Boost Software License, Version 1.0. (See accompanying file \n//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n\n//  See http://www.boost.org/libs/config for the most recent version.\n\n// Test file for macro BOOST_NO_STD_ALLOCATOR\n// This file should not compile, if it does then\n// BOOST_NO_STD_ALLOCATOR should not be defined.\n// See file boost_no_std_allocator.ipp for details\n\n// Must not have BOOST_ASSERT_CONFIG set; it defeats\n// the objective of this file:\n#ifdef BOOST_ASSERT_CONFIG\n#  undef BOOST_ASSERT_CONFIG\n#endif\n\n#include \u003cboost/config.hpp\u003e\n#include \"test.hpp\"\n\n#ifdef BOOST_NO_STD_ALLOCATOR\n#include \"boost_no_std_allocator.ipp\"\n#else\n#error \"this file should not compile\"\n#endif\n\nint main( int, char *[] )\n{\n   return boost_no_std_allocator::test();\n}\n\n"}
{"repo_name":"Deepakpatle/phantomjs","ref":"refs/heads/master","path":"src/qt/qtwebkit/Source/JavaScriptCore/dfg/DFGAbstractState.cpp","copies":"104","language":"C++","content":"/*\n * Copyright (C) 2011, 2012, 2013 Apple Inc. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. \n */\n\n#include \"config.h\"\n#include \"DFGAbstractState.h\"\n\n#if ENABLE(DFG_JIT)\n\n#include \"CodeBlock.h\"\n#include \"DFGBasicBlock.h\"\n#include \"GetByIdStatus.h\"\n#include \"Operations.h\"\n#include \"PutByIdStatus.h\"\n#include \"StringObject.h\"\n\nnamespace JSC { namespace DFG {\n\nAbstractState::AbstractState(Graph\u0026 graph)\n    : m_codeBlock(graph.m_codeBlock)\n    , m_graph(graph)\n    , m_variables(m_codeBlock-\u003enumParameters(), graph.m_localVars)\n    , m_block(0)\n{\n}\n\nAbstractState::~AbstractState() { }\n\nvoid AbstractState::beginBasicBlock(BasicBlock* basicBlock)\n{\n    ASSERT(!m_block);\n    \n    ASSERT(basicBlock-\u003evariablesAtHead.numberOfLocals() == basicBlock-\u003evaluesAtHead.numberOfLocals());\n    ASSERT(basicBlock-\u003evariablesAtTail.numberOfLocals() == basicBlock-\u003evaluesAtTail.numberOfLocals());\n    ASSERT(basicBlock-\u003evariablesAtHead.numberOfLocals() == basicBlock-\u003evariablesAtTail.numberOfLocals());\n    \n    for (size_t i = 0; i \u003c basicBlock-\u003esize(); i++)\n        forNode(basicBlock-\u003eat(i)).clear();\n\n    m_variables = basicBlock-\u003evaluesAtHead;\n    m_haveStructures = false;\n    for (size_t i = 0; i \u003c m_variables.numberOfArguments(); ++i) {\n        if (m_variables.argument(i).m_currentKnownStructure.isNeitherClearNorTop()) {\n            m_haveStructures = true;\n            break;\n        }\n    }\n    for (size_t i = 0; i \u003c m_variables.numberOfLocals(); ++i) {\n        if (m_variables.local(i).m_currentKnownStructure.isNeitherClearNorTop()) {\n            m_haveStructures = true;\n            break;\n        }\n    }\n    \n    basicBlock-\u003ecfaShouldRevisit = false;\n    basicBlock-\u003ecfaHasVisited = true;\n    m_block = basicBlock;\n    m_isValid = true;\n    m_foundConstants = false;\n    m_branchDirection = InvalidBranchDirection;\n}\n\nvoid AbstractState::initialize(Graph\u0026 graph)\n{\n    BasicBlock* root = graph.m_blocks[0].get();\n    root-\u003ecfaShouldRevisit = true;\n    root-\u003ecfaHasVisited = false;\n    root-\u003ecfaFoundConstants = false;\n    for (size_t i = 0; i \u003c root-\u003evaluesAtHead.numberOfArguments(); ++i) {\n        Node* node = root-\u003evariablesAtHead.argument(i);\n        ASSERT(node-\u003eop() == SetArgument);\n        if (!node-\u003evariableAccessData()-\u003eshouldUnboxIfPossible()) {\n            root-\u003evaluesAtHead.argument(i).makeTop();\n            continue;\n        }\n        \n        SpeculatedType prediction = node-\u003evariableAccessData()-\u003eprediction();\n        if (isInt32Speculation(prediction))\n            root-\u003evaluesAtHead.argument(i).set(SpecInt32);\n        else if (isBooleanSpeculation(prediction))\n            root-\u003evaluesAtHead.argument(i).set(SpecBoolean);\n        else if (isCellSpeculation(prediction))\n            root-\u003evaluesAtHead.argument(i).set(SpecCell);\n        else\n            root-\u003evaluesAtHead.argument(i).makeTop();\n        \n        root-\u003evaluesAtTail.argument(i).clear();\n    }\n    for (size_t i = 0; i \u003c root-\u003evaluesAtHead.numberOfLocals(); ++i) {\n        Node* node = root-\u003evariablesAtHead.local(i);\n        if (node \u0026\u0026 node-\u003evariableAccessData()-\u003eisCaptured())\n            root-\u003evaluesAtHead.local(i).makeTop();\n        else\n            root-\u003evaluesAtHead.local(i).clear();\n        root-\u003evaluesAtTail.local(i).clear();\n    }\n    for (BlockIndex blockIndex = 1 ; blockIndex \u003c graph.m_blocks.size(); ++blockIndex) {\n        BasicBlock* block = graph.m_blocks[blockIndex].get();\n        if (!block)\n            continue;\n        if (!block-\u003eisReachable)\n            continue;\n        block-\u003ecfaShouldRevisit = false;\n        block-\u003ecfaHasVisited = false;\n        block-\u003ecfaFoundConstants = false;\n        for (size_t i = 0; i \u003c block-\u003evaluesAtHead.numberOfArguments(); ++i) {\n            block-\u003evaluesAtHead.argument(i).clear();\n            block-\u003evaluesAtTail.argument(i).clear();\n        }\n        for (size_t i = 0; i \u003c block-\u003evaluesAtHead.numberOfLocals(); ++i) {\n            block-\u003evaluesAtHead.local(i).clear();\n            block-\u003evaluesAtTail.local(i).clear();\n        }\n        if (!block-\u003eisOSRTarget)\n            continue;\n        if (block-\u003ebytecodeBegin != graph.m_osrEntryBytecodeIndex)\n            continue;\n        for (size_t i = 0; i \u003c graph.m_mustHandleValues.size(); ++i) {\n            AbstractValue value;\n            value.setMostSpecific(graph.m_mustHandleValues[i]);\n            int operand = graph.m_mustHandleValues.operandForIndex(i);\n            block-\u003evaluesAtHead.operand(operand).merge(value);\n#if DFG_ENABLE(DEBUG_PROPAGATION_VERBOSE)\n            dataLogF(\"    Initializing Block #%u, operand r%d, to \", blockIndex, operand);\n            block-\u003evaluesAtHead.operand(operand).dump(WTF::dataFile());\n            dataLogF(\"\\n\");\n#endif\n        }\n        block-\u003ecfaShouldRevisit = true;\n    }\n}\n\nbool AbstractState::endBasicBlock(MergeMode mergeMode)\n{\n    ASSERT(m_block);\n    \n    BasicBlock* block = m_block; // Save the block for successor merging.\n    \n    block-\u003ecfaFoundConstants = m_foundConstants;\n    block-\u003ecfaDidFinish = m_isValid;\n    block-\u003ecfaBranchDirection = m_branchDirection;\n    \n    if (!m_isValid) {\n        reset();\n        return false;\n    }\n    \n    bool changed = false;\n    \n    if (mergeMode != DontMerge || !ASSERT_DISABLED) {\n        for (size_t argument = 0; argument \u003c block-\u003evariablesAtTail.numberOfArguments(); ++argument) {\n#if DFG_ENABLE(DEBUG_PROPAGATION_VERBOSE)\n            dataLogF(\"        Merging state for argument %zu.\\n\", argument);\n#endif\n            AbstractValue\u0026 destination = block-\u003evaluesAtTail.argument(argument);\n            changed |= mergeStateAtTail(destination, m_variables.argument(argument), block-\u003evariablesAtTail.argument(argument));\n        }\n        \n        for (size_t local = 0; local \u003c block-\u003evariablesAtTail.numberOfLocals(); ++local) {\n#if DFG_ENABLE(DEBUG_PROPAGATION_VERBOSE)\n            dataLogF(\"        Merging state for local %zu.\\n\", local);\n#endif\n            AbstractValue\u0026 destination = block-\u003evaluesAtTail.local(local);\n            changed |= mergeStateAtTail(destination, m_variables.local(local), block-\u003evariablesAtTail.local(local));\n        }\n    }\n    \n    ASSERT(mergeMode != DontMerge || !changed);\n    \n#if DFG_ENABLE(DEBUG_PROPAGATION_VERBOSE)\n    dataLogF(\"        Branch direction = %s\\n\", branchDirectionToString(m_branchDirection));\n#endif\n    \n    reset();\n    \n    if (mergeMode != MergeToSuccessors)\n        return changed;\n    \n    return mergeToSuccessors(m_graph, block);\n}\n\nvoid AbstractState::reset()\n{\n    m_block = 0;\n    m_isValid = false;\n    m_branchDirection = InvalidBranchDirection;\n}\n\nAbstractState::BooleanResult AbstractState::booleanResult(Node* node, AbstractValue\u0026 value)\n{\n    JSValue childConst = value.value();\n    if (childConst) {\n        if (childConst.toBoolean(m_codeBlock-\u003eglobalObjectFor(node-\u003ecodeOrigin)-\u003eglobalExec()))\n            return DefinitelyTrue;\n        return DefinitelyFalse;\n    }\n\n    // Next check if we can fold because we know that the source is an object or string and does not equal undefined.\n    if (isCellSpeculation(value.m_type)\n        \u0026\u0026 value.m_currentKnownStructure.hasSingleton()) {\n        Structure* structure = value.m_currentKnownStructure.singleton();\n        if (!structure-\u003emasqueradesAsUndefined(m_codeBlock-\u003eglobalObjectFor(node-\u003ecodeOrigin))\n            \u0026\u0026 structure-\u003etypeInfo().type() != StringType)\n            return DefinitelyTrue;\n    }\n    \n    return UnknownBooleanResult;\n}\n\nbool AbstractState::startExecuting(Node* node)\n{\n    ASSERT(m_block);\n    ASSERT(m_isValid);\n    \n    m_didClobber = false;\n    \n    node-\u003esetCanExit(false);\n    \n    if (!node-\u003eshouldGenerate())\n        return false;\n    \n    return true;\n}\n\nbool AbstractState::startExecuting(unsigned indexInBlock)\n{\n    return startExecuting(m_block-\u003eat(indexInBlock));\n}\n\nvoid AbstractState::executeEdges(Node* node)\n{\n    DFG_NODE_DO_TO_CHILDREN(m_graph, node, filterEdgeByUse);\n}\n\nvoid AbstractState::executeEdges(unsigned indexInBlock)\n{\n    executeEdges(m_block-\u003eat(indexInBlock));\n}\n\nvoid AbstractState::verifyEdge(Node*, Edge edge)\n{\n    RELEASE_ASSERT(!(forNode(edge).m_type \u0026 ~typeFilterFor(edge.useKind())));\n}\n\nvoid AbstractState::verifyEdges(Node* node)\n{\n    DFG_NODE_DO_TO_CHILDREN(m_graph, node, verifyEdge);\n}\n\nbool AbstractState::executeEffects(unsigned indexInBlock, Node* node)\n{\n    if (!ASSERT_DISABLED)\n        verifyEdges(node);\n    \n    switch (node-\u003eop()) {\n    case JSConstant:\n    case WeakJSConstant:\n    case PhantomArguments: {\n        forNode(node).set(m_graph.valueOfJSConstant(node));\n        break;\n    }\n        \n    case Identity: {\n        forNode(node) = forNode(node-\u003echild1());\n        break;\n    }\n            \n    case GetLocal: {\n        VariableAccessData* variableAccessData = node-\u003evariableAccessData();\n        if (variableAccessData-\u003eprediction() == SpecNone) {\n            m_isValid = false;\n            break;\n        }\n        AbstractValue value = m_variables.operand(variableAccessData-\u003elocal());\n        if (!variableAccessData-\u003eisCaptured()) {\n            if (value.isClear())\n                node-\u003esetCanExit(true);\n        }\n        if (value.value())\n            m_foundConstants = true;\n        forNode(node) = value;\n        break;\n    }\n        \n    case GetLocalUnlinked: {\n        AbstractValue value = m_variables.operand(node-\u003eunlinkedLocal());\n        if (value.value())\n            m_foundConstants = true;\n        forNode(node) = value;\n        break;\n    }\n        \n    case SetLocal: {\n        m_variables.operand(node-\u003elocal()) = forNode(node-\u003echild1());\n        break;\n    }\n        \n    case MovHintAndCheck: {\n        // Don't need to do anything. A MovHint is effectively a promise that the SetLocal\n        // was dead.\n        break;\n    }\n        \n    case MovHint:\n    case ZombieHint: {\n        RELEASE_ASSERT_NOT_REACHED();\n        break;\n    }\n            \n    case SetArgument:\n        // Assert that the state of arguments has been set.\n        ASSERT(!m_block-\u003evaluesAtHead.operand(node-\u003elocal()).isClear());\n        break;\n            \n    case BitAnd:\n    case BitOr:\n    case BitXor:\n    case BitRShift:\n    case BitLShift:\n    case BitURShift: {\n        JSValue left = forNode(node-\u003echild1()).value();\n        JSValue right = forNode(node-\u003echild2()).value();\n        if (left \u0026\u0026 right \u0026\u0026 left.isInt32() \u0026\u0026 right.isInt32()) {\n            int32_t a = left.asInt32();\n            int32_t b = right.asInt32();\n            bool constantWasSet;\n            switch (node-\u003eop()) {\n            case BitAnd:\n                constantWasSet = trySetConstant(node, JSValue(a \u0026 b));\n                break;\n            case BitOr:\n                constantWasSet = trySetConstant(node, JSValue(a | b));\n                break;\n            case BitXor:\n                constantWasSet = trySetConstant(node, JSValue(a ^ b));\n                break;\n            case BitRShift:\n                constantWasSet = trySetConstant(node, JSValue(a \u003e\u003e static_cast\u003cuint32_t\u003e(b)));\n                break;\n            case BitLShift:\n                constantWasSet = trySetConstant(node, JSValue(a \u003c\u003c static_cast\u003cuint32_t\u003e(b)));\n                break;\n            case BitURShift:\n                constantWasSet = trySetConstant(node, JSValue(static_cast\u003cuint32_t\u003e(a) \u003e\u003e static_cast\u003cuint32_t\u003e(b)));\n                break;\n            default:\n                RELEASE_ASSERT_NOT_REACHED();\n                constantWasSet = false;\n            }\n            if (constantWasSet) {\n                m_foundConstants = true;\n                break;\n            }\n        }\n        forNode(node).set(SpecInt32);\n        break;\n    }\n        \n    case UInt32ToNumber: {\n        JSValue child = forNode(node-\u003echild1()).value();\n        if (child \u0026\u0026 child.isNumber()) {\n            ASSERT(child.isInt32());\n            if (trySetConstant(node, JSValue(child.asUInt32()))) {\n                m_foundConstants = true;\n                break;\n            }\n        }\n        if (!node-\u003ecanSpeculateInteger())\n            forNode(node).set(SpecDouble);\n        else {\n            forNode(node).set(SpecInt32);\n            node-\u003esetCanExit(true);\n        }\n        break;\n    }\n            \n    case DoubleAsInt32: {\n        JSValue child = forNode(node-\u003echild1()).value();\n        if (child \u0026\u0026 child.isNumber()) {\n            double asDouble = child.asNumber();\n            int32_t asInt = JSC::toInt32(asDouble);\n            if (bitwise_cast\u003cint64_t\u003e(static_cast\u003cdouble\u003e(asInt)) == bitwise_cast\u003cint64_t\u003e(asDouble)\n                \u0026\u0026 trySetConstant(node, JSValue(asInt))) {\n                m_foundConstants = true;\n                break;\n            }\n        }\n        node-\u003esetCanExit(true);\n        forNode(node).set(SpecInt32);\n        break;\n    }\n            \n    case ValueToInt32: {\n        JSValue child = forNode(node-\u003echild1()).value();\n        if (child \u0026\u0026 child.isNumber()) {\n            bool constantWasSet;\n            if (child.isInt32())\n                constantWasSet = trySetConstant(node, child);\n            else\n                constantWasSet = trySetConstant(node, JSValue(JSC::toInt32(child.asDouble())));\n            if (constantWasSet) {\n                m_foundConstants = true;\n                break;\n            }\n        }\n        \n        forNode(node).set(SpecInt32);\n        break;\n    }\n\n    case Int32ToDouble:\n    case ForwardInt32ToDouble: {\n        JSValue child = forNode(node-\u003echild1()).value();\n        if (child \u0026\u0026 child.isNumber()\n            \u0026\u0026 trySetConstant(node, JSValue(JSValue::EncodeAsDouble, child.asNumber()))) {\n            m_foundConstants = true;\n            break;\n        }\n        if (isInt32Speculation(forNode(node-\u003echild1()).m_type))\n            forNode(node).set(SpecDoubleReal);\n        else\n            forNode(node).set(SpecDouble);\n        break;\n    }\n        \n    case ValueAdd:\n    case ArithAdd: {\n        JSValue left = forNode(node-\u003echild1()).value();\n        JSValue right = forNode(node-\u003echild2()).value();\n        if (left \u0026\u0026 right \u0026\u0026 left.isNumber() \u0026\u0026 right.isNumber()\n            \u0026\u0026 trySetConstant(node, JSValue(left.asNumber() + right.asNumber()))) {\n            m_foundConstants = true;\n            break;\n        }\n        switch (node-\u003ebinaryUseKind()) {\n        case Int32Use:\n            forNode(node).set(SpecInt32);\n            if (!nodeCanTruncateInteger(node-\u003earithNodeFlags()))\n                node-\u003esetCanExit(true);\n            break;\n        case NumberUse:\n            if (isRealNumberSpeculation(forNode(node-\u003echild1()).m_type)\n                \u0026\u0026 isRealNumberSpeculation(forNode(node-\u003echild2()).m_type))\n                forNode(node).set(SpecDoubleReal);\n            else\n                forNode(node).set(SpecDouble);\n            break;\n        default:\n            RELEASE_ASSERT(node-\u003eop() == ValueAdd);\n            clobberWorld(node-\u003ecodeOrigin, indexInBlock);\n            forNode(node).set(SpecString | SpecInt32 | SpecNumber);\n            break;\n        }\n        break;\n    }\n        \n    case MakeRope: {\n        forNode(node).set(m_graph.m_vm.stringStructure.get());\n        break;\n    }\n            \n    case ArithSub: {\n        JSValue left = forNode(node-\u003echild1()).value();\n        JSValue right = forNode(node-\u003echild2()).value();\n        if (left \u0026\u0026 right \u0026\u0026 left.isNumber() \u0026\u0026 right.isNumber()\n            \u0026\u0026 trySetConstant(node, JSValue(left.asNumber() - right.asNumber()))) {\n            m_foundConstants = true;\n            break;\n        }\n        switch (node-\u003ebinaryUseKind()) {\n        case Int32Use:\n            forNode(node).set(SpecInt32);\n            if (!nodeCanTruncateInteger(node-\u003earithNodeFlags()))\n                node-\u003esetCanExit(true);\n            break;\n        case NumberUse:\n            forNode(node).set(SpecDouble);\n            break;\n        default:\n            RELEASE_ASSERT_NOT_REACHED();\n            break;\n        }\n        break;\n    }\n        \n    case ArithNegate: {\n        JSValue child = forNode(node-\u003echild1()).value();\n        if (child \u0026\u0026 child.isNumber()\n            \u0026\u0026 trySetConstant(node, JSValue(-child.asNumber()))) {\n            m_foundConstants = true;\n            break;\n        }\n        switch (node-\u003echild1().useKind()) {\n        case Int32Use:\n            forNode(node).set(SpecInt32);\n            if (!nodeCanTruncateInteger(node-\u003earithNodeFlags()))\n                node-\u003esetCanExit(true);\n            break;\n        case NumberUse:\n            forNode(node).set(SpecDouble);\n            break;\n        default:\n            RELEASE_ASSERT_NOT_REACHED();\n            break;\n        }\n        break;\n    }\n        \n    case ArithMul: {\n        JSValue left = forNode(node-\u003echild1()).value();\n        JSValue right = forNode(node-\u003echild2()).value();\n        if (left \u0026\u0026 right \u0026\u0026 left.isNumber() \u0026\u0026 right.isNumber()\n            \u0026\u0026 trySetConstant(node, JSValue(left.asNumber() * right.asNumber()))) {\n            m_foundConstants = true;\n            break;\n        }\n        switch (node-\u003ebinaryUseKind()) {\n        case Int32Use:\n            forNode(node).set(SpecInt32);\n            if (!nodeCanTruncateInteger(node-\u003earithNodeFlags())\n                || !nodeCanIgnoreNegativeZero(node-\u003earithNodeFlags()))\n                node-\u003esetCanExit(true);\n            break;\n        case NumberUse:\n            if (isRealNumberSpeculation(forNode(node-\u003echild1()).m_type)\n                || isRealNumberSpeculation(forNode(node-\u003echild2()).m_type))\n                forNode(node).set(SpecDoubleReal);\n            else\n                forNode(node).set(SpecDouble);\n            break;\n        default:\n            RELEASE_ASSERT_NOT_REACHED();\n            break;\n        }\n        break;\n    }\n\n    case ArithIMul: {\n        forNode(node).set(SpecInt32);\n        break;\n    }\n        \n    case ArithDiv:\n    case ArithMin:\n    case ArithMax:\n    case ArithMod: {\n        JSValue left = forNode(node-\u003echild1()).value();\n        JSValue right = forNode(node-\u003echild2()).value();\n        if (left \u0026\u0026 right \u0026\u0026 left.isNumber() \u0026\u0026 right.isNumber()) {\n            double a = left.asNumber();\n            double b = right.asNumber();\n            bool constantWasSet;\n            switch (node-\u003eop()) {\n            case ArithDiv:\n                constantWasSet = trySetConstant(node, JSValue(a / b));\n                break;\n            case ArithMin:\n                constantWasSet = trySetConstant(node, JSValue(a \u003c b ? a : (b \u003c= a ? b : a + b)));\n                break;\n            case ArithMax:\n                constantWasSet = trySetConstant(node, JSValue(a \u003e b ? a : (b \u003e= a ? b : a + b)));\n                break;\n            case ArithMod:\n                constantWasSet = trySetConstant(node, JSValue(fmod(a, b)));\n                break;\n            default:\n                RELEASE_ASSERT_NOT_REACHED();\n                constantWasSet = false;\n                break;\n            }\n            if (constantWasSet) {\n                m_foundConstants = true;\n                break;\n            }\n        }\n        switch (node-\u003ebinaryUseKind()) {\n        case Int32Use:\n            forNode(node).set(SpecInt32);\n            node-\u003esetCanExit(true);\n            break;\n        case NumberUse:\n            forNode(node).set(SpecDouble);\n            break;\n        default:\n            RELEASE_ASSERT_NOT_REACHED();\n            break;\n        }\n        break;\n    }\n            \n    case ArithAbs: {\n        JSValue child = forNode(node-\u003echild1()).value();\n        if (child \u0026\u0026 child.isNumber()\n            \u0026\u0026 trySetConstant(node, JSValue(fabs(child.asNumber())))) {\n            m_foundConstants = true;\n            break;\n        }\n        switch (node-\u003echild1().useKind()) {\n        case Int32Use:\n            forNode(node).set(SpecInt32);\n            node-\u003esetCanExit(true);\n            break;\n        case NumberUse:\n            forNode(node).set(SpecDouble);\n            break;\n        default:\n            RELEASE_ASSERT_NOT_REACHED();\n            break;\n        }\n        break;\n    }\n            \n    case ArithSqrt: {\n        JSValue child = forNode(node-\u003echild1()).value();\n        if (child \u0026\u0026 child.isNumber()\n            \u0026\u0026 trySetConstant(node, JSValue(sqrt(child.asNumber())))) {\n            m_foundConstants = true;\n            break;\n        }\n        forNode(node).set(SpecDouble);\n        break;\n    }\n            \n    case LogicalNot: {\n        bool didSetConstant = false;\n        switch (booleanResult(node, forNode(node-\u003echild1()))) {\n        case DefinitelyTrue:\n            didSetConstant = trySetConstant(node, jsBoolean(false));\n            break;\n        case DefinitelyFalse:\n            didSetConstant = trySetConstant(node, jsBoolean(true));\n            break;\n        default:\n            break;\n        }\n        if (didSetConstant) {\n            m_foundConstants = true;\n            break;\n        }\n        switch (node-\u003echild1().useKind()) {\n        case BooleanUse:\n        case Int32Use:\n        case NumberUse:\n        case UntypedUse:\n            break;\n        case ObjectOrOtherUse:\n            node-\u003esetCanExit(true);\n            break;\n        default:\n            RELEASE_ASSERT_NOT_REACHED();\n            break;\n        }\n        forNode(node).set(SpecBoolean);\n        break;\n    }\n        \n    case IsUndefined:\n    case IsBoolean:\n    case IsNumber:\n    case IsString:\n    case IsObject:\n    case IsFunction: {\n        node-\u003esetCanExit(node-\u003eop() == IsUndefined \u0026\u0026 m_codeBlock-\u003eglobalObjectFor(node-\u003ecodeOrigin)-\u003emasqueradesAsUndefinedWatchpoint()-\u003eisStillValid());\n        JSValue child = forNode(node-\u003echild1()).value();\n        if (child) {\n            bool constantWasSet;\n            switch (node-\u003eop()) {\n            case IsUndefined:\n                if (m_codeBlock-\u003eglobalObjectFor(node-\u003ecodeOrigin)-\u003emasqueradesAsUndefinedWatchpoint()-\u003eisStillValid()) {\n                    constantWasSet = trySetConstant(node, jsBoolean(\n                        child.isCell()\n                        ? false \n                        : child.isUndefined()));\n                } else {\n                    constantWasSet = trySetConstant(node, jsBoolean(\n                        child.isCell()\n                        ? child.asCell()-\u003estructure()-\u003emasqueradesAsUndefined(m_codeBlock-\u003eglobalObjectFor(node-\u003ecodeOrigin))\n                        : child.isUndefined()));\n                }\n                break;\n            case IsBoolean:\n                constantWasSet = trySetConstant(node, jsBoolean(child.isBoolean()));\n                break;\n            case IsNumber:\n                constantWasSet = trySetConstant(node, jsBoolean(child.isNumber()));\n                break;\n            case IsString:\n                constantWasSet = trySetConstant(node, jsBoolean(isJSString(child)));\n                break;\n            case IsObject:\n                if (child.isNull() || !child.isObject()) {\n                    constantWasSet = trySetConstant(node, jsBoolean(child.isNull()));\n                    break;\n                }\n            default:\n                constantWasSet = false;\n                break;\n            }\n            if (constantWasSet) {\n                m_foundConstants = true;\n                break;\n            }\n        }\n\n        forNode(node).set(SpecBoolean);\n        break;\n    }\n\n    case TypeOf: {\n        VM* vm = m_codeBlock-\u003evm();\n        JSValue child = forNode(node-\u003echild1()).value();\n        AbstractValue\u0026 abstractChild = forNode(node-\u003echild1());\n        if (child) {\n            JSValue typeString = jsTypeStringForValue(*vm, m_codeBlock-\u003eglobalObjectFor(node-\u003ecodeOrigin), child);\n            if (trySetConstant(node, typeString)) {\n                m_foundConstants = true;\n                break;\n            }\n        } else if (isNumberSpeculation(abstractChild.m_type)) {\n            if (trySetConstant(node, vm-\u003esmallStrings.numberString())) {\n                forNode(node-\u003echild1()).filter(SpecNumber);\n                m_foundConstants = true;\n                break;\n            }\n        } else if (isStringSpeculation(abstractChild.m_type)) {\n            if (trySetConstant(node, vm-\u003esmallStrings.stringString())) {\n                forNode(node-\u003echild1()).filter(SpecString);\n                m_foundConstants = true;\n                break;\n            }\n        } else if (isFinalObjectSpeculation(abstractChild.m_type) || isArraySpeculation(abstractChild.m_type) || isArgumentsSpeculation(abstractChild.m_type)) {\n            if (trySetConstant(node, vm-\u003esmallStrings.objectString())) {\n                forNode(node-\u003echild1()).filter(SpecFinalObject | SpecArray | SpecArguments);\n                m_foundConstants = true;\n                break;\n            }\n        } else if (isFunctionSpeculation(abstractChild.m_type)) {\n            if (trySetConstant(node, vm-\u003esmallStrings.functionString())) {\n                forNode(node-\u003echild1()).filter(SpecFunction);\n                m_foundConstants = true;\n                break;\n            }\n        } else if (isBooleanSpeculation(abstractChild.m_type)) {\n            if (trySetConstant(node, vm-\u003esmallStrings.booleanString())) {\n                forNode(node-\u003echild1()).filter(SpecBoolean);\n                m_foundConstants = true;\n                break;\n            }\n        }\n\n        switch (node-\u003echild1().useKind()) {\n        case StringUse:\n        case CellUse:\n            node-\u003esetCanExit(true);\n            break;\n        case UntypedUse:\n            break;\n        default:\n            RELEASE_ASSERT_NOT_REACHED();\n            break;\n        }\n        forNode(node).set(m_graph.m_vm.stringStructure.get());\n        break;\n    }\n            \n    case CompareLess:\n    case CompareLessEq:\n    case CompareGreater:\n    case CompareGreaterEq:\n    case CompareEq:\n    case CompareEqConstant: {\n        bool constantWasSet = false;\n\n        JSValue leftConst = forNode(node-\u003echild1()).value();\n        JSValue rightConst = forNode(node-\u003echild2()).value();\n        if (leftConst \u0026\u0026 rightConst \u0026\u0026 leftConst.isNumber() \u0026\u0026 rightConst.isNumber()) {\n            double a = leftConst.asNumber();\n            double b = rightConst.asNumber();\n            switch (node-\u003eop()) {\n            case CompareLess:\n                constantWasSet = trySetConstant(node, jsBoolean(a \u003c b));\n                break;\n            case CompareLessEq:\n                constantWasSet = trySetConstant(node, jsBoolean(a \u003c= b));\n                break;\n            case CompareGreater:\n                constantWasSet = trySetConstant(node, jsBoolean(a \u003e b));\n                break;\n            case CompareGreaterEq:\n                constantWasSet = trySetConstant(node, jsBoolean(a \u003e= b));\n                break;\n            case CompareEq:\n                constantWasSet = trySetConstant(node, jsBoolean(a == b));\n                break;\n            default:\n                RELEASE_ASSERT_NOT_REACHED();\n                constantWasSet = false;\n                break;\n            }\n        }\n        \n        if (!constantWasSet \u0026\u0026 (node-\u003eop() == CompareEqConstant || node-\u003eop() == CompareEq)) {\n            SpeculatedType leftType = forNode(node-\u003echild1()).m_type;\n            SpeculatedType rightType = forNode(node-\u003echild2()).m_type;\n            if ((isInt32Speculation(leftType) \u0026\u0026 isOtherSpeculation(rightType))\n                || (isOtherSpeculation(leftType) \u0026\u0026 isInt32Speculation(rightType)))\n                constantWasSet = trySetConstant(node, jsBoolean(false));\n        }\n        \n        if (constantWasSet) {\n            m_foundConstants = true;\n            break;\n        }\n        \n        forNode(node).set(SpecBoolean);\n        \n        // This is overly conservative. But the only thing this prevents is store elimination,\n        // and how likely is it, really, that you'll have redundant stores across a comparison\n        // operation? Comparison operations are typically at the end of basic blocks, so\n        // unless we have global store elimination (super unlikely given how unprofitable that\n        // optimization is to begin with), you aren't going to be wanting to store eliminate\n        // across an equality op.\n        node-\u003esetCanExit(true);\n        break;\n    }\n            \n    case CompareStrictEq:\n    case CompareStrictEqConstant: {\n        Node* leftNode = node-\u003echild1().node();\n        Node* rightNode = node-\u003echild2().node();\n        JSValue left = forNode(leftNode).value();\n        JSValue right = forNode(rightNode).value();\n        if (left \u0026\u0026 right \u0026\u0026 left.isNumber() \u0026\u0026 right.isNumber()\n            \u0026\u0026 trySetConstant(node, jsBoolean(left.asNumber() == right.asNumber()))) {\n            m_foundConstants = true;\n            break;\n        }\n        forNode(node).set(SpecBoolean);\n        node-\u003esetCanExit(true); // This is overly conservative.\n        break;\n    }\n        \n    case StringCharCodeAt:\n        node-\u003esetCanExit(true);\n        forNode(node).set(SpecInt32);\n        break;\n        \n    case StringFromCharCode:\n        forNode(node).set(SpecString);\n        break;\n\n    case StringCharAt:\n        node-\u003esetCanExit(true);\n        forNode(node).set(m_graph.m_vm.stringStructure.get());\n        break;\n            \n    case GetByVal: {\n        node-\u003esetCanExit(true);\n        switch (node-\u003earrayMode().type()) {\n        case Array::SelectUsingPredictions:\n        case Array::Unprofiled:\n        case Array::Undecided:\n            RELEASE_ASSERT_NOT_REACHED();\n            break;\n        case Array::ForceExit:\n            m_isValid = false;\n            break;\n        case Array::Generic:\n            clobberWorld(node-\u003ecodeOrigin, indexInBlock);\n            forNode(node).makeTop();\n            break;\n        case Array::String:\n            forNode(node).set(m_graph.m_vm.stringStructure.get());\n            break;\n        case Array::Arguments:\n            forNode(node).makeTop();\n            break;\n        case Array::Int32:\n            if (node-\u003earrayMode().isOutOfBounds()) {\n                clobberWorld(node-\u003ecodeOrigin, indexInBlock);\n                forNode(node).makeTop();\n            } else\n                forNode(node).set(SpecInt32);\n            break;\n        case Array::Double:\n            if (node-\u003earrayMode().isOutOfBounds()) {\n                clobberWorld(node-\u003ecodeOrigin, indexInBlock);\n                forNode(node).makeTop();\n            } else if (node-\u003earrayMode().isSaneChain())\n                forNode(node).set(SpecDouble);\n            else\n                forNode(node).set(SpecDoubleReal);\n            break;\n        case Array::Contiguous:\n        case Array::ArrayStorage:\n        case Array::SlowPutArrayStorage:\n            if (node-\u003earrayMode().isOutOfBounds())\n                clobberWorld(node-\u003ecodeOrigin, indexInBlock);\n            forNode(node).makeTop();\n            break;\n        case Array::Int8Array:\n            forNode(node).set(SpecInt32);\n            break;\n        case Array::Int16Array:\n            forNode(node).set(SpecInt32);\n            break;\n        case Array::Int32Array:\n            forNode(node).set(SpecInt32);\n            break;\n        case Array::Uint8Array:\n            forNode(node).set(SpecInt32);\n            break;\n        case Array::Uint8ClampedArray:\n            forNode(node).set(SpecInt32);\n            break;\n        case Array::Uint16Array:\n            forNode(node).set(SpecInt32);\n            break;\n        case Array::Uint32Array:\n            if (node-\u003eshouldSpeculateInteger())\n                forNode(node).set(SpecInt32);\n            else\n                forNode(node).set(SpecDouble);\n            break;\n        case Array::Float32Array:\n            forNode(node).set(SpecDouble);\n            break;\n        case Array::Float64Array:\n            forNode(node).set(SpecDouble);\n            break;\n        default:\n            RELEASE_ASSERT_NOT_REACHED();\n            break;\n        }\n        break;\n    }\n            \n    case PutByVal:\n    case PutByValAlias: {\n        node-\u003esetCanExit(true);\n        switch (node-\u003earrayMode().modeForPut().type()) {\n        case Array::ForceExit:\n            m_isValid = false;\n            break;\n        case Array::Generic:\n            clobberWorld(node-\u003ecodeOrigin, indexInBlock);\n            break;\n        case Array::Int32:\n            if (node-\u003earrayMode().isOutOfBounds())\n                clobberWorld(node-\u003ecodeOrigin, indexInBlock);\n            break;\n        case Array::Double:\n            if (node-\u003earrayMode().isOutOfBounds())\n                clobberWorld(node-\u003ecodeOrigin, indexInBlock);\n            break;\n        case Array::Contiguous:\n        case Array::ArrayStorage:\n            if (node-\u003earrayMode().isOutOfBounds())\n                clobberWorld(node-\u003ecodeOrigin, indexInBlock);\n            break;\n        case Array::SlowPutArrayStorage:\n            if (node-\u003earrayMode().mayStoreToHole())\n                clobberWorld(node-\u003ecodeOrigin, indexInBlock);\n            break;\n        default:\n            break;\n        }\n        break;\n    }\n            \n    case ArrayPush:\n        node-\u003esetCanExit(true);\n        clobberWorld(node-\u003ecodeOrigin, indexInBlock);\n        forNode(node).set(SpecNumber);\n        break;\n            \n    case ArrayPop:\n        node-\u003esetCanExit(true);\n        clobberWorld(node-\u003ecodeOrigin, indexInBlock);\n        forNode(node).makeTop();\n        break;\n            \n    case RegExpExec:\n        forNode(node).makeTop();\n        break;\n\n    case RegExpTest:\n        forNode(node).set(SpecBoolean);\n        break;\n            \n    case Jump:\n        break;\n            \n    case Branch: {\n        Node* child = node-\u003echild1().node();\n        BooleanResult result = booleanResult(node, forNode(child));\n        if (result == DefinitelyTrue) {\n            m_branchDirection = TakeTrue;\n            break;\n        }\n        if (result == DefinitelyFalse) {\n            m_branchDirection = TakeFalse;\n            break;\n        }\n        // FIXME: The above handles the trivial cases of sparse conditional\n        // constant propagation, but we can do better:\n        // We can specialize the source variable's value on each direction of\n        // the branch.\n        node-\u003esetCanExit(true); // This is overly conservative.\n        m_branchDirection = TakeBoth;\n        break;\n    }\n            \n    case Return:\n        m_isValid = false;\n        break;\n        \n    case Throw:\n    case ThrowReferenceError:\n        m_isValid = false;\n        node-\u003esetCanExit(true);\n        break;\n            \n    case ToPrimitive: {\n        JSValue childConst = forNode(node-\u003echild1()).value();\n        if (childConst \u0026\u0026 childConst.isNumber() \u0026\u0026 trySetConstant(node, childConst)) {\n            m_foundConstants = true;\n            break;\n        }\n        \n        ASSERT(node-\u003echild1().useKind() == UntypedUse);\n        \n        AbstractValue\u0026 source = forNode(node-\u003echild1());\n        AbstractValue\u0026 destination = forNode(node);\n        \n        // NB. The more canonical way of writing this would have been:\n        //\n        // destination = source;\n        // if (destination.m_type \u0026 !(SpecNumber | SpecString | SpecBoolean)) {\n        //     destination.filter(SpecNumber | SpecString | SpecBoolean);\n        //     AbstractValue string;\n        //     string.set(vm-\u003estringStructure);\n        //     destination.merge(string);\n        // }\n        //\n        // The reason why this would, in most other cases, have been better is that\n        // then destination would preserve any non-SpeculatedType knowledge of source.\n        // As it stands, the code below forgets any non-SpeculatedType knowledge that\n        // source would have had. Fortunately, though, for things like strings and\n        // numbers and booleans, we don't care about the non-SpeculatedType knowedge:\n        // the structure won't tell us anything we don't already know, and neither\n        // will ArrayModes. And if the source was a meaningful constant then we\n        // would have handled that above. Unfortunately, this does mean that\n        // ToPrimitive will currently forget string constants. But that's not a big\n        // deal since we don't do any optimization on those currently.\n        \n        clobberWorld(node-\u003ecodeOrigin, indexInBlock);\n        \n        SpeculatedType type = source.m_type;\n        if (type \u0026 ~(SpecNumber | SpecString | SpecBoolean)) {\n            type \u0026= (SpecNumber | SpecString | SpecBoolean);\n            type |= SpecString;\n        }\n        destination.set(type);\n        break;\n    }\n        \n    case ToString: {\n        switch (node-\u003echild1().useKind()) {\n        case StringObjectUse:\n            // This also filters that the StringObject has the primordial StringObject\n            // structure.\n            forNode(node-\u003echild1()).filter(m_graph.globalObjectFor(node-\u003ecodeOrigin)-\u003estringObjectStructure());\n            node-\u003esetCanExit(true); // We could be more precise but it's likely not worth it.\n            break;\n        case StringOrStringObjectUse:\n            node-\u003esetCanExit(true); // We could be more precise but it's likely not worth it.\n            break;\n        case CellUse:\n        case UntypedUse:\n            clobberWorld(node-\u003ecodeOrigin, indexInBlock);\n            break;\n        default:\n            RELEASE_ASSERT_NOT_REACHED();\n            break;\n        }\n        forNode(node).set(m_graph.m_vm.stringStructure.get());\n        break;\n    }\n        \n    case NewStringObject: {\n        ASSERT(node-\u003estructure()-\u003eclassInfo() == \u0026StringObject::s_info);\n        forNode(node).set(node-\u003estructure());\n        break;\n    }\n            \n    case NewArray:\n        node-\u003esetCanExit(true);\n        forNode(node).set(m_graph.globalObjectFor(node-\u003ecodeOrigin)-\u003earrayStructureForIndexingTypeDuringAllocation(node-\u003eindexingType()));\n        m_haveStructures = true;\n        break;\n        \n    case NewArrayBuffer:\n        node-\u003esetCanExit(true);\n        forNode(node).set(m_graph.globalObjectFor(node-\u003ecodeOrigin)-\u003earrayStructureForIndexingTypeDuringAllocation(node-\u003eindexingType()));\n        m_haveStructures = true;\n        break;\n\n    case NewArrayWithSize:\n        node-\u003esetCanExit(true);\n        forNode(node).set(SpecArray);\n        m_haveStructures = true;\n        break;\n            \n    case NewRegexp:\n        forNode(node).set(m_graph.globalObjectFor(node-\u003ecodeOrigin)-\u003eregExpStructure());\n        m_haveStructures = true;\n        break;\n            \n    case ConvertThis: {\n        AbstractValue\u0026 source = forNode(node-\u003echild1());\n        AbstractValue\u0026 destination = forNode(node);\n            \n        destination = source;\n        destination.merge(SpecObjectOther);\n        break;\n    }\n\n    case CreateThis: {\n        forNode(node).set(SpecFinalObject);\n        break;\n    }\n        \n    case AllocationProfileWatchpoint:\n        node-\u003esetCanExit(true);\n        break;\n\n    case NewObject:\n        forNode(node).set(node-\u003estructure());\n        m_haveStructures = true;\n        break;\n        \n    case CreateActivation:\n        forNode(node).set(m_codeBlock-\u003eglobalObjectFor(node-\u003ecodeOrigin)-\u003eactivationStructure());\n        m_haveStructures = true;\n        break;\n        \n    case CreateArguments:\n        forNode(node).set(m_codeBlock-\u003eglobalObjectFor(node-\u003ecodeOrigin)-\u003eargumentsStructure());\n        m_haveStructures = true;\n        break;\n        \n    case TearOffActivation:\n    case TearOffArguments:\n        // Does nothing that is user-visible.\n        break;\n\n    case CheckArgumentsNotCreated:\n        if (isEmptySpeculation(\n                m_variables.operand(\n                    m_graph.argumentsRegisterFor(node-\u003ecodeOrigin)).m_type))\n            m_foundConstants = true;\n        else\n            node-\u003esetCanExit(true);\n        break;\n        \n    case GetMyArgumentsLength:\n        // We know that this executable does not escape its arguments, so we can optimize\n        // the arguments a bit. Note that this is not sufficient to force constant folding\n        // of GetMyArgumentsLength, because GetMyArgumentsLength is a clobbering operation.\n        // We perform further optimizations on this later on.\n        if (node-\u003ecodeOrigin.inlineCallFrame)\n            forNode(node).set(jsNumber(node-\u003ecodeOrigin.inlineCallFrame-\u003earguments.size() - 1));\n        else\n            forNode(node).set(SpecInt32);\n        node-\u003esetCanExit(\n            !isEmptySpeculation(\n                m_variables.operand(\n                    m_graph.argumentsRegisterFor(node-\u003ecodeOrigin)).m_type));\n        break;\n        \n    case GetMyArgumentsLengthSafe:\n        // This potentially clobbers all structures if the arguments object had a getter\n        // installed on the length property.\n        clobberWorld(node-\u003ecodeOrigin, indexInBlock);\n        // We currently make no guarantee about what this returns because it does not\n        // speculate that the length property is actually a length.\n        forNode(node).makeTop();\n        break;\n        \n    case GetMyArgumentByVal:\n        node-\u003esetCanExit(true);\n        // We know that this executable does not escape its arguments, so we can optimize\n        // the arguments a bit. Note that this ends up being further optimized by the\n        // ArgumentsSimplificationPhase.\n        forNode(node).makeTop();\n        break;\n        \n    case GetMyArgumentByValSafe:\n        node-\u003esetCanExit(true);\n        // This potentially clobbers all structures if the property we're accessing has\n        // a getter. We don't speculate against this.\n        clobberWorld(node-\u003ecodeOrigin, indexInBlock);\n        // And the result is unknown.\n        forNode(node).makeTop();\n        break;\n        \n    case NewFunction: {\n        AbstractValue\u0026 value = forNode(node);\n        value = forNode(node-\u003echild1());\n        \n        if (!(value.m_type \u0026 SpecEmpty)) {\n            m_foundConstants = true;\n            break;\n        }\n\n        value.set((value.m_type \u0026 ~SpecEmpty) | SpecFunction);\n        break;\n    }\n\n    case NewFunctionExpression:\n    case NewFunctionNoCheck:\n        forNode(node).set(m_codeBlock-\u003eglobalObjectFor(node-\u003ecodeOrigin)-\u003efunctionStructure());\n        break;\n        \n    case GetCallee:\n        forNode(node).set(SpecFunction);\n        break;\n        \n    case SetCallee:\n    case SetMyScope:\n        break;\n            \n    case GetScope: // FIXME: We could get rid of these if we know that the JSFunction is a constant. https://bugs.webkit.org/show_bug.cgi?id=106202\n    case GetMyScope:\n    case SkipTopScope:\n        forNode(node).set(SpecCellOther);\n        break;\n\n    case SkipScope: {\n        JSValue child = forNode(node-\u003echild1()).value();\n        if (child \u0026\u0026 trySetConstant(node, JSValue(jsCast\u003cJSScope*\u003e(child.asCell())-\u003enext()))) {\n            m_foundConstants = true;\n            break;\n        }\n        forNode(node).set(SpecCellOther);\n        break;\n    }\n\n    case GetScopeRegisters:\n        forNode(node).clear(); // The result is not a JS value.\n        break;\n\n    case GetScopedVar:\n        forNode(node).makeTop();\n        break;\n            \n    case PutScopedVar:\n        clobberCapturedVars(node-\u003ecodeOrigin);\n        break;\n            \n    case GetById:\n    case GetByIdFlush:\n        node-\u003esetCanExit(true);\n        if (!node-\u003eprediction()) {\n            m_isValid = false;\n            break;\n        }\n        if (isCellSpeculation(node-\u003echild1()-\u003eprediction())) {\n            if (Structure* structure = forNode(node-\u003echild1()).bestProvenStructure()) {\n                GetByIdStatus status = GetByIdStatus::computeFor(\n                    m_graph.m_vm, structure,\n                    m_graph.m_codeBlock-\u003eidentifier(node-\u003eidentifierNumber()));\n                if (status.isSimple()) {\n                    // Assert things that we can't handle and that the computeFor() method\n                    // above won't be able to return.\n                    ASSERT(status.structureSet().size() == 1);\n                    ASSERT(status.chain().isEmpty());\n                    \n                    if (status.specificValue())\n                        forNode(node).set(status.specificValue());\n                    else\n                        forNode(node).makeTop();\n                    forNode(node-\u003echild1()).filter(status.structureSet());\n                    \n                    m_foundConstants = true;\n                    break;\n                }\n            }\n        }\n        clobberWorld(node-\u003ecodeOrigin, indexInBlock);\n        forNode(node).makeTop();\n        break;\n            \n    case GetArrayLength:\n        node-\u003esetCanExit(true); // Lies, but it's true for the common case of JSArray, so it's good enough.\n        forNode(node).set(SpecInt32);\n        break;\n        \n    case CheckExecutable: {\n        // FIXME: We could track executables in AbstractValue, which would allow us to get rid of these checks\n        // more thoroughly. https://bugs.webkit.org/show_bug.cgi?id=106200\n        // FIXME: We could eliminate these entirely if we know the exact value that flows into this.\n        // https://bugs.webkit.org/show_bug.cgi?id=106201\n        node-\u003esetCanExit(true);\n        break;\n    }\n\n    case CheckStructure:\n    case ForwardCheckStructure: {\n        // FIXME: We should be able to propagate the structure sets of constants (i.e. prototypes).\n        AbstractValue\u0026 value = forNode(node-\u003echild1());\n        ASSERT(!(value.m_type \u0026 ~SpecCell)); // Edge filtering should have already ensured this.\n        // If this structure check is attempting to prove knowledge already held in\n        // the futurePossibleStructure set then the constant folding phase should\n        // turn this into a watchpoint instead.\n        StructureSet\u0026 set = node-\u003estructureSet();\n        if (value.m_futurePossibleStructure.isSubsetOf(set)\n            || value.m_currentKnownStructure.isSubsetOf(set))\n            m_foundConstants = true;\n        if (!value.m_currentKnownStructure.isSubsetOf(set))\n            node-\u003esetCanExit(true);\n        value.filter(set);\n        m_haveStructures = true;\n        break;\n    }\n        \n    case StructureTransitionWatchpoint:\n    case ForwardStructureTransitionWatchpoint: {\n        AbstractValue\u0026 value = forNode(node-\u003echild1());\n\n        // It's only valid to issue a structure transition watchpoint if we already\n        // know that the watchpoint covers a superset of the structures known to\n        // belong to the set of future structures that this value may have.\n        // Currently, we only issue singleton watchpoints (that check one structure)\n        // and our futurePossibleStructure set can only contain zero, one, or an\n        // infinity of structures.\n        ASSERT(value.m_futurePossibleStructure.isSubsetOf(StructureSet(node-\u003estructure())));\n        \n        value.filter(node-\u003estructure());\n        m_haveStructures = true;\n        node-\u003esetCanExit(true);\n        break;\n    }\n            \n    case PutStructure:\n    case PhantomPutStructure:\n        if (!forNode(node-\u003echild1()).m_currentKnownStructure.isClear()) {\n            clobberStructures(indexInBlock);\n            forNode(node-\u003echild1()).set(node-\u003estructureTransitionData().newStructure);\n            m_haveStructures = true;\n        }\n        break;\n    case GetButterfly:\n    case AllocatePropertyStorage:\n    case ReallocatePropertyStorage:\n        forNode(node).clear(); // The result is not a JS value.\n        break;\n    case CheckArray: {\n        if (node-\u003earrayMode().alreadyChecked(m_graph, node, forNode(node-\u003echild1()))) {\n            m_foundConstants = true;\n            break;\n        }\n        node-\u003esetCanExit(true); // Lies, but this is followed by operations (like GetByVal) that always exit, so there is no point in us trying to be clever here.\n        switch (node-\u003earrayMode().type()) {\n        case Array::String:\n            forNode(node-\u003echild1()).filter(SpecString);\n            break;\n        case Array::Int32:\n        case Array::Double:\n        case Array::Contiguous:\n        case Array::ArrayStorage:\n        case Array::SlowPutArrayStorage:\n            break;\n        case Array::Arguments:\n            forNode(node-\u003echild1()).filter(SpecArguments);\n            break;\n        case Array::Int8Array:\n            forNode(node-\u003echild1()).filter(SpecInt8Array);\n            break;\n        case Array::Int16Array:\n            forNode(node-\u003echild1()).filter(SpecInt16Array);\n            break;\n        case Array::Int32Array:\n            forNode(node-\u003echild1()).filter(SpecInt32Array);\n            break;\n        case Array::Uint8Array:\n            forNode(node-\u003echild1()).filter(SpecUint8Array);\n            break;\n        case Array::Uint8ClampedArray:\n            forNode(node-\u003echild1()).filter(SpecUint8ClampedArray);\n            break;\n        case Array::Uint16Array:\n            forNode(node-\u003echild1()).filter(SpecUint16Array);\n            break;\n        case Array::Uint32Array:\n            forNode(node-\u003echild1()).filter(SpecUint32Array);\n            break;\n        case Array::Float32Array:\n            forNode(node-\u003echild1()).filter(SpecFloat32Array);\n            break;\n        case Array::Float64Array:\n            forNode(node-\u003echild1()).filter(SpecFloat64Array);\n            break;\n        default:\n            RELEASE_ASSERT_NOT_REACHED();\n            break;\n        }\n        forNode(node-\u003echild1()).filterArrayModes(node-\u003earrayMode().arrayModesThatPassFiltering());\n        m_haveStructures = true;\n        break;\n    }\n    case Arrayify: {\n        if (node-\u003earrayMode().alreadyChecked(m_graph, node, forNode(node-\u003echild1()))) {\n            m_foundConstants = true;\n            break;\n        }\n        ASSERT(node-\u003earrayMode().conversion() == Array::Convert\n            || node-\u003earrayMode().conversion() == Array::RageConvert);\n        node-\u003esetCanExit(true);\n        clobberStructures(indexInBlock);\n        forNode(node-\u003echild1()).filterArrayModes(node-\u003earrayMode().arrayModesThatPassFiltering());\n        m_haveStructures = true;\n        break;\n    }\n    case ArrayifyToStructure: {\n        AbstractValue\u0026 value = forNode(node-\u003echild1());\n        StructureSet set = node-\u003estructure();\n        if (value.m_futurePossibleStructure.isSubsetOf(set)\n            || value.m_currentKnownStructure.isSubsetOf(set))\n            m_foundConstants = true;\n        node-\u003esetCanExit(true);\n        clobberStructures(indexInBlock);\n        value.filter(set);\n        m_haveStructures = true;\n        break;\n    }\n    case GetIndexedPropertyStorage: {\n        forNode(node).clear();\n        break; \n    }\n    case GetByOffset: {\n        forNode(node).makeTop();\n        break;\n    }\n            \n    case PutByOffset: {\n        break;\n    }\n            \n    case CheckFunction: {\n        JSValue value = forNode(node-\u003echild1()).value();\n        if (value == node-\u003efunction()) {\n            m_foundConstants = true;\n            ASSERT(value);\n            break;\n        }\n        \n        node-\u003esetCanExit(true); // Lies! We can do better.\n        forNode(node-\u003echild1()).filterByValue(node-\u003efunction());\n        break;\n    }\n        \n    case PutById:\n    case PutByIdDirect:\n        node-\u003esetCanExit(true);\n        if (Structure* structure = forNode(node-\u003echild1()).bestProvenStructure()) {\n            PutByIdStatus status = PutByIdStatus::computeFor(\n                m_graph.m_vm,\n                m_graph.globalObjectFor(node-\u003ecodeOrigin),\n                structure,\n                m_graph.m_codeBlock-\u003eidentifier(node-\u003eidentifierNumber()),\n                node-\u003eop() == PutByIdDirect);\n            if (status.isSimpleReplace()) {\n                forNode(node-\u003echild1()).filter(structure);\n                m_foundConstants = true;\n                break;\n            }\n            if (status.isSimpleTransition()) {\n                clobberStructures(indexInBlock);\n                forNode(node-\u003echild1()).set(status.newStructure());\n                m_haveStructures = true;\n                m_foundConstants = true;\n                break;\n            }\n        }\n        clobberWorld(node-\u003ecodeOrigin, indexInBlock);\n        break;\n            \n    case GetGlobalVar:\n        forNode(node).makeTop();\n        break;\n        \n    case GlobalVarWatchpoint:\n        node-\u003esetCanExit(true);\n        break;\n            \n    case PutGlobalVar:\n    case PutGlobalVarCheck:\n        break;\n            \n    case CheckHasInstance:\n        node-\u003esetCanExit(true);\n        // Sadly, we don't propagate the fact that we've done CheckHasInstance\n        break;\n            \n    case InstanceOf:\n        node-\u003esetCanExit(true);\n        // Again, sadly, we don't propagate the fact that we've done InstanceOf\n        forNode(node).set(SpecBoolean);\n        break;\n            \n    case Phi:\n    case Flush:\n    case PhantomLocal:\n    case Breakpoint:\n        break;\n            \n    case Call:\n    case Construct:\n    case Resolve:\n    case ResolveBase:\n    case ResolveBaseStrictPut:\n    case ResolveGlobal:\n        node-\u003esetCanExit(true);\n        clobberWorld(node-\u003ecodeOrigin, indexInBlock);\n        forNode(node).makeTop();\n        break;\n\n    case GarbageValue:\n        clobberWorld(node-\u003ecodeOrigin, indexInBlock);\n        forNode(node).makeTop();\n        break;\n\n    case ForceOSRExit:\n        node-\u003esetCanExit(true);\n        m_isValid = false;\n        break;\n            \n    case CheckWatchdogTimer:\n        node-\u003esetCanExit(true);\n        break;\n            \n    case Phantom:\n    case InlineStart:\n    case Nop:\n    case CountExecution:\n        break;\n        \n    case LastNodeType:\n        RELEASE_ASSERT_NOT_REACHED();\n        break;\n    }\n    \n    return m_isValid;\n}\n\nbool AbstractState::executeEffects(unsigned indexInBlock)\n{\n    return executeEffects(indexInBlock, m_block-\u003eat(indexInBlock));\n}\n\nbool AbstractState::execute(unsigned indexInBlock)\n{\n    Node* node = m_block-\u003eat(indexInBlock);\n    if (!startExecuting(node))\n        return true;\n    \n    executeEdges(node);\n    return executeEffects(indexInBlock, node);\n}\n\ninline void AbstractState::clobberWorld(const CodeOrigin\u0026 codeOrigin, unsigned indexInBlock)\n{\n    clobberCapturedVars(codeOrigin);\n    clobberStructures(indexInBlock);\n}\n\ninline void AbstractState::clobberCapturedVars(const CodeOrigin\u0026 codeOrigin)\n{\n    if (codeOrigin.inlineCallFrame) {\n        const BitVector\u0026 capturedVars = codeOrigin.inlineCallFrame-\u003ecapturedVars;\n        for (size_t i = capturedVars.size(); i--;) {\n            if (!capturedVars.quickGet(i))\n                continue;\n            m_variables.local(i).makeTop();\n        }\n    } else {\n        for (size_t i = m_codeBlock-\u003em_numVars; i--;) {\n            if (m_codeBlock-\u003eisCaptured(i))\n                m_variables.local(i).makeTop();\n        }\n    }\n\n    for (size_t i = m_variables.numberOfArguments(); i--;) {\n        if (m_codeBlock-\u003eisCaptured(argumentToOperand(i)))\n            m_variables.argument(i).makeTop();\n    }\n}\n\ninline void AbstractState::clobberStructures(unsigned indexInBlock)\n{\n    if (!m_haveStructures)\n        return;\n    for (size_t i = indexInBlock + 1; i--;)\n        forNode(m_block-\u003eat(i)).clobberStructures();\n    for (size_t i = m_variables.numberOfArguments(); i--;)\n        m_variables.argument(i).clobberStructures();\n    for (size_t i = m_variables.numberOfLocals(); i--;)\n        m_variables.local(i).clobberStructures();\n    m_haveStructures = false;\n    m_didClobber = true;\n}\n\ninline bool AbstractState::mergeStateAtTail(AbstractValue\u0026 destination, AbstractValue\u0026 inVariable, Node* node)\n{\n    if (!node)\n        return false;\n        \n    AbstractValue source;\n    \n    if (node-\u003evariableAccessData()-\u003eisCaptured()) {\n        // If it's captured then we know that whatever value was stored into the variable last is the\n        // one we care about. This is true even if the variable at tail is dead, which might happen if\n        // the last thing we did to the variable was a GetLocal and then ended up now using the\n        // GetLocal's result.\n        \n        source = inVariable;\n#if DFG_ENABLE(DEBUG_PROPAGATION_VERBOSE)\n        dataLogF(\"          Transfering \");\n        source.dump(WTF::dataFile());\n        dataLogF(\" from last access due to captured variable.\\n\");\n#endif\n    } else {\n#if DFG_ENABLE(DEBUG_PROPAGATION_VERBOSE)\n        dataLogF(\"          It's live, node @%u.\\n\", node-\u003eindex());\n#endif\n    \n        switch (node-\u003eop()) {\n        case Phi:\n        case SetArgument:\n        case PhantomLocal:\n        case Flush:\n            // The block transfers the value from head to tail.\n            source = inVariable;\n#if DFG_ENABLE(DEBUG_PROPAGATION_VERBOSE)\n            dataLogF(\"          Transfering \");\n            source.dump(WTF::dataFile());\n            dataLogF(\" from head to tail.\\n\");\n#endif\n            break;\n            \n        case GetLocal:\n            // The block refines the value with additional speculations.\n            source = forNode(node);\n#if DFG_ENABLE(DEBUG_PROPAGATION_VERBOSE)\n            dataLogF(\"          Refining to \");\n            source.dump(WTF::dataFile());\n            dataLogF(\"\\n\");\n#endif\n            break;\n            \n        case SetLocal:\n            // The block sets the variable, and potentially refines it, both\n            // before and after setting it.\n            if (node-\u003evariableAccessData()-\u003eshouldUseDoubleFormat()) {\n                // FIXME: This unnecessarily loses precision.\n                source.set(SpecDouble);\n            } else\n                source = forNode(node-\u003echild1());\n#if DFG_ENABLE(DEBUG_PROPAGATION_VERBOSE)\n            dataLogF(\"          Setting to \");\n            source.dump(WTF::dataFile());\n            dataLogF(\"\\n\");\n#endif\n            break;\n        \n        default:\n            RELEASE_ASSERT_NOT_REACHED();\n            break;\n        }\n    }\n    \n    if (destination == source) {\n        // Abstract execution did not change the output value of the variable, for this\n        // basic block, on this iteration.\n#if DFG_ENABLE(DEBUG_PROPAGATION_VERBOSE)\n        dataLogF(\"          Not changed!\\n\");\n#endif\n        return false;\n    }\n    \n    // Abstract execution reached a new conclusion about the speculations reached about\n    // this variable after execution of this basic block. Update the state, and return\n    // true to indicate that the fixpoint must go on!\n    destination = source;\n#if DFG_ENABLE(DEBUG_PROPAGATION_VERBOSE)\n    dataLogF(\"          Changed!\\n\");\n#endif\n    return true;\n}\n\ninline bool AbstractState::merge(BasicBlock* from, BasicBlock* to)\n{\n    ASSERT(from-\u003evariablesAtTail.numberOfArguments() == to-\u003evariablesAtHead.numberOfArguments());\n    ASSERT(from-\u003evariablesAtTail.numberOfLocals() == to-\u003evariablesAtHead.numberOfLocals());\n    \n    bool changed = false;\n    \n    for (size_t argument = 0; argument \u003c from-\u003evariablesAtTail.numberOfArguments(); ++argument) {\n        AbstractValue\u0026 destination = to-\u003evaluesAtHead.argument(argument);\n        changed |= mergeVariableBetweenBlocks(destination, from-\u003evaluesAtTail.argument(argument), to-\u003evariablesAtHead.argument(argument), from-\u003evariablesAtTail.argument(argument));\n    }\n    \n    for (size_t local = 0; local \u003c from-\u003evariablesAtTail.numberOfLocals(); ++local) {\n        AbstractValue\u0026 destination = to-\u003evaluesAtHead.local(local);\n        changed |= mergeVariableBetweenBlocks(destination, from-\u003evaluesAtTail.local(local), to-\u003evariablesAtHead.local(local), from-\u003evariablesAtTail.local(local));\n    }\n\n    if (!to-\u003ecfaHasVisited)\n        changed = true;\n    \n    to-\u003ecfaShouldRevisit |= changed;\n    \n    return changed;\n}\n\ninline bool AbstractState::mergeToSuccessors(Graph\u0026 graph, BasicBlock* basicBlock)\n{\n    Node* terminal = basicBlock-\u003elast();\n    \n    ASSERT(terminal-\u003eisTerminal());\n    \n    switch (terminal-\u003eop()) {\n    case Jump: {\n        ASSERT(basicBlock-\u003ecfaBranchDirection == InvalidBranchDirection);\n#if DFG_ENABLE(DEBUG_PROPAGATION_VERBOSE)\n        dataLogF(\"        Merging to block #%u.\\n\", terminal-\u003etakenBlockIndex());\n#endif\n        return merge(basicBlock, graph.m_blocks[terminal-\u003etakenBlockIndex()].get());\n    }\n        \n    case Branch: {\n        ASSERT(basicBlock-\u003ecfaBranchDirection != InvalidBranchDirection);\n        bool changed = false;\n#if DFG_ENABLE(DEBUG_PROPAGATION_VERBOSE)\n        dataLogF(\"        Merging to block #%u.\\n\", terminal-\u003etakenBlockIndex());\n#endif\n        if (basicBlock-\u003ecfaBranchDirection != TakeFalse)\n            changed |= merge(basicBlock, graph.m_blocks[terminal-\u003etakenBlockIndex()].get());\n#if DFG_ENABLE(DEBUG_PROPAGATION_VERBOSE)\n        dataLogF(\"        Merging to block #%u.\\n\", terminal-\u003enotTakenBlockIndex());\n#endif\n        if (basicBlock-\u003ecfaBranchDirection != TakeTrue)\n            changed |= merge(basicBlock, graph.m_blocks[terminal-\u003enotTakenBlockIndex()].get());\n        return changed;\n    }\n        \n    case Return:\n    case Throw:\n    case ThrowReferenceError:\n        ASSERT(basicBlock-\u003ecfaBranchDirection == InvalidBranchDirection);\n        return false;\n        \n    default:\n        RELEASE_ASSERT_NOT_REACHED();\n        return false;\n    }\n}\n\ninline bool AbstractState::mergeVariableBetweenBlocks(AbstractValue\u0026 destination, AbstractValue\u0026 source, Node* destinationNode, Node* sourceNode)\n{\n    if (!destinationNode)\n        return false;\n    \n    ASSERT_UNUSED(sourceNode, sourceNode);\n    \n    // FIXME: We could do some sparse conditional propagation here!\n    \n    return destination.merge(source);\n}\n\nvoid AbstractState::dump(PrintStream\u0026 out)\n{\n    bool first = true;\n    for (size_t i = 0; i \u003c m_block-\u003esize(); ++i) {\n        Node* node = m_block-\u003eat(i);\n        AbstractValue\u0026 value = forNode(node);\n        if (value.isClear())\n            continue;\n        if (first)\n            first = false;\n        else\n            out.printf(\" \");\n        out.printf(\"@%lu:\", static_cast\u003cunsigned long\u003e(node-\u003eindex()));\n        value.dump(out);\n    }\n}\n\n} } // namespace JSC::DFG\n\n#endif // ENABLE(DFG_JIT)\n\n"}
{"repo_name":"Eagle-X/folly","ref":"refs/heads/master","path":"folly/test/IPAddressBenchmark.cpp","copies":"54","language":"C++","content":"/*\n * Copyright 2015 Facebook, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include \u003cfolly/IPAddress.h\u003e\n\n#include \u003cglog/logging.h\u003e\n\n#include \u003cfolly/Benchmark.h\u003e\n\nusing namespace folly;\nusing std::string;\n\nBENCHMARK(ipv4_to_string_inet_ntop, iters) {\n  folly::IPAddressV4 ipv4Addr(\"127.0.0.1\");\n  in_addr ip = ipv4Addr.toAddr();\n  char outputString[INET_ADDRSTRLEN] = {0};\n\n  while (iters--) {\n    const char* val = inet_ntop(\n      AF_INET,\n      \u0026ip,\n      outputString,\n      sizeof(outputString));\n  }\n}\n\nBENCHMARK_RELATIVE(ipv4_to_fully_qualified, iters) {\n  IPAddressV4 ip(\"127.0.0.1\");\n  while (iters--) {\n    string outputString = ip.toFullyQualified();\n  }\n}\n\nBENCHMARK_DRAW_LINE()\n\nBENCHMARK(ipv6_to_string_inet_ntop, iters) {\n  IPAddressV6 ipv6Addr(\"F1E0:0ACE:FB94:7ADF:22E8:6DE6:9672:3725\");\n  in6_addr ip = ipv6Addr.toAddr();\n  char outputString[INET6_ADDRSTRLEN] = {0};\n  bool checkResult = (iters == 1);\n\n  while (iters--) {\n    const char* val = inet_ntop(\n      AF_INET6,\n      \u0026ip,\n      outputString,\n      sizeof(outputString));\n  }\n}\n\nBENCHMARK_RELATIVE(ipv6_to_fully_qualified, iters) {\n  IPAddressV6 ip(\"F1E0:0ACE:FB94:7ADF:22E8:6DE6:9672:3725\");\n  string outputString;\n  while (iters--) {\n    outputString = ip.toFullyQualified();\n  }\n}\n\n// Benchmark results on Intel Xeon CPU E5-2660 @ 2.20GHz\n// ============================================================================\n// folly/test/IPAddressBenchmark.cpp               relative  time/iter  iters/s\n// ============================================================================\n// ipv4_to_string_inet_ntop                                   237.87ns    4.20M\n// ipv4_to_fully_qualified                          362.31%    65.65ns   15.23M\n// ----------------------------------------------------------------------------\n// ipv6_to_string_inet_ntop                                   768.60ns    1.30M\n// ipv6_to_fully_qualified                          821.81%    93.53ns   10.69M\n// ============================================================================\n\nint main(int argc, char *argv[]) {\n  gflags::ParseCommandLineFlags(\u0026argc, \u0026argv, true);\n  runBenchmarks();\n  return 0;\n}\n"}
{"repo_name":"kstripp/LittleBudget","ref":"refs/heads/master","path":"src/core/main.cpp","copies":"1","language":"C++","content":"/***************************************************************************\n *                                                                         *\n *   LB - The Little Budget Utility for GnuCash                            *\n *                                                                         *\n *   Copyright (C) 2004,2005 by Gabriel M. Beddingfield                    *\n *   gabriel@teuton.org                                                    *\n *                                                                         *\n *   This program is free software; you can redistribute it and/or modify  *\n *   it under the terms of the GNU General Public License as published by  *\n *   the Free Software Foundation; either version 2 of the License, or     *\n *   (at your option) any later version.                                   *\n *                                                                         *\n *   This program is distributed in the hope that it will be useful,       *\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *\n *   GNU General Public License for more details.                          *\n *                                                                         *\n *   You should have received a copy of the GNU General Public License     *\n *   along with this program; if not, write to the                         *\n *   Free Software Foundation, Inc.,                                       *\n *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *\n ***************************************************************************/\n\n\n/* main.cpp\n   Gabriel M. Beddingfield\n   02OCT2004\n\n   For merging a gnucash report\n   with a published budget.\n*/\n\n#include \u003ciostream\u003e\n#include \"lb.h\"\n\nusing std::cout;\nusing std::endl;\nusing std::cerr;\n\n#ifndef VERSION\n#define VERSION \"1.0.1\"\n#endif\n\n\nint main( int argc, const char* argv[] )\n{\n\ttry {\n\t\tlb app(argc,argv);\n\n\t\treturn app.run();\n\t} catch (lb_error e) {\n\t\tcerr \u003c\u003c e.what() \u003c\u003c endl;\n\t\treturn EXIT_FAILURE;\n\t} catch (runtime_error e) {\n\t\tcerr \u003c\u003c e.what() \u003c\u003c endl;\n\t\treturn EXIT_FAILURE;\n\t} catch (...) {\n\t\tcerr \u003c\u003c \"Unhandled exception in lb.\" \u003c\u003c endl;\n\t\treturn EXIT_FAILURE;\n\t}\n}\n"}
{"repo_name":"imAArtist/simIr","ref":"refs/heads/master","path":"Data/singleFile/code_721.cpp","copies":"1","language":"C++","content":"  int candy(vector\u003cint\u003e \u0026ratings)\n {\n     int size=ratings.size();\n     if(size\u003c=1)\n         return size;\n     vector\u003cint\u003e num(size,1);\n     for (int i = 1; i \u003c size; i++)\n     {\n         if(ratings[i]\u003eratings[i-1])\n             num[i]=num[i-1]+1;\n     }\n     for (int i= size-1; i\u003e0 ; i--)\n     {\n         if(ratings[i-1]\u003eratings[i])\n             num[i-1]=max(num[i]+1,num[i-1]);\n     }\n     int result=0;\n     for (int i = 0; i \u003c size; i++)\n     {\n         result+=num[i];\n        // cout\u003c\u003cnum[i]\u003c\u003c\" \";\n     }\n     return result;\n }\n1,3,3,3,21,2,1,2,1public int candy(int[] ratings) {\n\n    int len = ratings.length;\n    int[] candy = new int[len];\n\n    candy[0] =1;\n    for (int i = 1; i \u003c len; ++i) {\n        if (ratings[i] \u003e ratings[i-1]) {\n            candy[i] = candy[i-1] + 1;\n        } else {\n            candy[i] = 1;\n        }\n    }\n\n    int total = candy[len-1];\n    for (int i = len - 2; i \u003e= 0; --i) {\n        if (ratings[i] \u003e ratings[i+1] \u0026\u0026 candy[i] \u003c= candy[i+1]) {\n            candy[i] = candy[i+1] + 1;\n        }\n        total += candy[i];    \n    }\n    return total;\n}\n"}
{"repo_name":"jamesfowkes/DataLogger","ref":"refs/heads/master","path":"libraries/DLDataField/DLDataField.Manager.cpp","copies":"2","language":"C++","content":"/*\n * DLDataField.Manager.cpp\n *\n * Provides management of datafields for applications\n *\n * Author: James Fowkes\n *\n * www.re-innovation.co.uk\n */\n\n/*\n * Arduino/C++ Library Includes\n */\n\n#ifdef ARDUINO\n#include \u003cArduino.h\u003e\n#else\n#include \u003cstdint.h\u003e\n#include \u003cstdio.h\u003e\n#include \u003cstring.h\u003e\n#endif\n\n#ifdef TEST\n#include \u003ciostream\u003e\n#endif\n\n/*\n * Datalogger Library Includes\n */\n\n#include \"DLUtility.Averager.h\"\n#include \"DLDataField.Types.h\"\n#include \"DLDataField.h\"\n#include \"DLDataField.Manager.h\"\n#include \"DLSettings.Reader.Errors.h\"\n#include \"DLSettings.DataChannels.h\"\n#include \"DLUtility.h\"\n#include \"DLUtility.ArrayFunctions.h\"\n#include \"DLPlatform.h\"\n\nDataFieldManager::DataFieldManager(uint32_t dataSize, uint32_t averagerSize)\n{\n    m_dataSize = dataSize;\n    m_averagerSize = averagerSize;\n    m_fieldCount = 0;\n    m_dataCount = 0;\n\n    uint8_t i = 0;\n    for (i = 0; i \u003c MAX_FIELDS; i++)\n    {\n        m_fields[i] = NULL;\n    }\n}\n\nuint8_t DataFieldManager::fieldCount()\n{\n    return m_fieldCount;\n}\n\n/*\n * addField\n *\n * Add a field to the manager.\n * Stores field pointer in next free location in m_fields.\n * Channel number is stored in m_channelNumbers.\n */\nbool DataFieldManager::addField(NumericDataField * field)\n{\n    if (!field) { return false; }\n\n    if (m_fieldCount == MAX_FIELDS) { return false; }\n\n    // The field might need extra setup based on the datatype/sensor and platform.\n    // The platform interface takes care of that.\n    PLATFORM_specialFieldSetup(field);\n\n    field-\u003esetDataSizes(m_dataSize, m_averagerSize);\n\n    m_fields[m_fieldCount] = field;\n    m_channelNumbers[m_fieldCount] = field-\u003egetChannelNumber();\n    m_fieldCount++;\n\n    return true;\n}\n\nbool DataFieldManager::addField(StringDataField * field)\n{\n    if (!field) { return false; }\n\n    if (m_fieldCount == MAX_FIELDS) { return false; }\n\n    m_fields[m_fieldCount] = field;\n    m_channelNumbers[m_fieldCount] = field-\u003egetChannelNumber();\n\n    m_fieldCount++;\n    return true;\n}\n\nvoid DataFieldManager::storeDataArray(int32_t * data)\n{\n    uint16_t field = 0;\n\n    // The data manager stores only the fields of interest, but \n    // the incoming data array is for ALL channels for the platform\n    // dataIndex is the correct index for the raw data array\n    uint16_t dataIndex;\n\n    bool newAverageStored = false;\n    for (field = 0; field \u003c m_fieldCount; field++)\n    {\n        NumericDataField* pField = (NumericDataField*)m_fields[field];\n        if (pField)\n        {\n            dataIndex = m_channelNumbers[field] - 1;\n            newAverageStored |= pField-\u003estoreData( data[dataIndex] );\n        }\n    }\n\n    if (newAverageStored) { m_dataCount++; }\n}\n\nvoid DataFieldManager::getDataArray(float * buffer, bool converted, bool alsoRemove)\n{\n    uint16_t field;\n    for(field = 0; field \u003c m_fieldCount; ++field)\n    {\n        if (converted)\n        {\n            buffer[field] = ((NumericDataField*)m_fields[field])-\u003egetConvData(alsoRemove);\n        }\n        else\n        {\n            buffer[field] = ((NumericDataField*)m_fields[field])-\u003egetRawData(alsoRemove);\n        }\n    }\n    if (alsoRemove) { m_dataCount--; }\n}\n\nDataField * DataFieldManager::getChannel(uint8_t channel)\n{\n    int32_t actualIndex = indexOf(m_channelNumbers, (uint32_t)channel, m_fieldCount);\n    return actualIndex \u003e= 0 ? m_fields[actualIndex] : NULL;\n}\n\nDataField * DataFieldManager::getField(uint8_t index)\n{\n    return m_fields[index];\n}\n\nDataField ** DataFieldManager::getFields(void)\n{\n    return m_fields;\n}\n\nuint32_t DataFieldManager::writeHeadersToBuffer(char * buffer, uint8_t bufferLength)\n{\n    if (!buffer) { return 0; }\n\n    uint8_t i;\n\n    FixedLengthAccumulator headerAccumulator(buffer, bufferLength);\n\n    for (i = 0; i \u003c m_fieldCount; ++i)\n    {\n        headerAccumulator.writeString(m_fields[i]-\u003egetTypeString());\n        if (!lastinloop(i, m_fieldCount))\n        {\n            headerAccumulator.writeString(\", \");\n        }\n    }\n\n    headerAccumulator.writeString(\"\\r\\n\");\n\n    return headerAccumulator.length();\n}\n\nvoid DataFieldManager::setupAllValidChannels(void)\n{\n    uint8_t ch;\n    NumericDataField * field;\n    FIELD_TYPE type;\n    void * data;\n\n    uint32_t maxChannels = Settings_GetMaxChannels();\n    for (ch = 1; ch \u003c maxChannels; ch++)\n    {\n        if (Settings_ChannelSettingIsValid(ch))\n        {\n            type = Settings_GetChannelType(ch);\n            data = Settings_GetData(ch);\n\n            switch(type)\n            {\n            case VOLTAGE:\n            case CURRENT:\n            case TEMPERATURE_C:\n            case TEMPERATURE_K:\n            case TEMPERATURE_F:\n                field = new NumericDataField(type, data, ch);\n                #ifdef TEST\n                std::cout \u003c\u003c \"Adding channel \" \u003c\u003c (int)ch \u003c\u003c \", type \" \u003c\u003c field-\u003egetTypeString() \u003c\u003c std::endl;\n                #endif\n                addField(field);\n                break;\n            default:\n                break;\n            }\n        }\n    }\n}\n\nbool DataFieldManager::hasData(void)\n{\n    uint8_t i = 0;\n    bool atLeastOneFieldHasData = false;\n    for (i = 0; i \u003c m_fieldCount; i++)\n    {\n        atLeastOneFieldHasData |= m_fields[i]-\u003ehasData();\n    }\n    return atLeastOneFieldHasData;\n}\n\nuint32_t DataFieldManager::count(void)\n{\n    return m_dataCount;\n}\n\nuint32_t * DataFieldManager::getChannelNumbers(void)\n{\n    return m_channelNumbers;\n}"}
{"repo_name":"m039/Void","ref":"refs/heads/master","path":"third-party/void-boost/libs/config/test/has_part_alloc_fail.cpp","copies":"71","language":"C++","content":"//  This file was automatically generated on Fri Dec 03 18:04:00 2004\n//  by libs/config/tools/generate.cpp\n//  Copyright John Maddock 2002-4.\n//  Use, modification and distribution are subject to the \n//  Boost Software License, Version 1.0. (See accompanying file \n//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n\n//  See http://www.boost.org/libs/config for the most recent version.\n\n// Test file for macro BOOST_HAS_PARTIAL_STD_ALLOCATOR\n// This file should not compile, if it does then\n// BOOST_HAS_PARTIAL_STD_ALLOCATOR should be defined.\n// See file boost_has_part_alloc.ipp for details\n\n// Must not have BOOST_ASSERT_CONFIG set; it defeats\n// the objective of this file:\n#ifdef BOOST_ASSERT_CONFIG\n#  undef BOOST_ASSERT_CONFIG\n#endif\n\n#include \u003cboost/config.hpp\u003e\n#include \"test.hpp\"\n\n#ifndef BOOST_HAS_PARTIAL_STD_ALLOCATOR\n#include \"boost_has_part_alloc.ipp\"\n#else\n#error \"this file should not compile\"\n#endif\n\nint main( int, char *[] )\n{\n   return boost_has_partial_std_allocator::test();\n}\n\n"}
{"repo_name":"CodeDJ/qt5-hidpi","ref":"refs/heads/master","path":"qt/qtdeclarative/src/quick/util/qquickanimatorcontroller.cpp","copies":"3","language":"C++","content":"/****************************************************************************\n**\n** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies).\n** Contact: http://www.qt-project.org/legal\n**\n** This file is part of the QtQuick module of the Qt Toolkit.\n**\n** $QT_BEGIN_LICENSE:LGPL$\n** Commercial License Usage\n** Licensees holding valid commercial Qt licenses may use this file in\n** accordance with the commercial license agreement provided with the\n** Software or, alternatively, in accordance with the terms contained in\n** a written agreement between you and Digia.  For licensing terms and\n** conditions see http://qt.digia.com/licensing.  For further information\n** use the contact form at http://qt.digia.com/contact-us.\n**\n** GNU Lesser General Public License Usage\n** Alternatively, this file may be used under the terms of the GNU Lesser\n** General Public License version 2.1 as published by the Free Software\n** Foundation and appearing in the file LICENSE.LGPL included in the\n** packaging of this file.  Please review the following information to\n** ensure the GNU Lesser General Public License version 2.1 requirements\n** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.\n**\n** In addition, as a special exception, Digia gives you certain additional\n** rights.  These rights are described in the Digia Qt LGPL Exception\n** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.\n**\n** GNU General Public License Usage\n** Alternatively, this file may be used under the terms of the GNU\n** General Public License version 3.0 as published by the Free Software\n** Foundation and appearing in the file LICENSE.GPL included in the\n** packaging of this file.  Please review the following information to\n** ensure the GNU General Public License version 3.0 requirements will be\n** met: http://www.gnu.org/copyleft/gpl.html.\n**\n**\n** $QT_END_LICENSE$\n**\n****************************************************************************/\n\n#include \"qquickanimatorcontroller_p.h\"\n\n#include \u003cprivate/qquickwindow_p.h\u003e\n#include \u003cprivate/qsgrenderloop_p.h\u003e\n\n#include \u003cprivate/qanimationgroupjob_p.h\u003e\n\n#include \u003cQtGui/qscreen.h\u003e\n\n#include \u003cQtCore/qcoreapplication.h\u003e\n\nQT_BEGIN_NAMESPACE\n\nQQuickAnimatorController::QQuickAnimatorController()\n    : m_window(0)\n{\n}\n\nQQuickAnimatorController::~QQuickAnimatorController()\n{\n    // The proxy job might already have been deleted, in which case we\n    // need to avoid calling functions on them. Then delete the job.\n    foreach (QAbstractAnimationJob *job, m_deleting) {\n        m_starting.take(job);\n        m_stopping.take(job);\n        m_animatorRoots.take(job);\n        delete job;\n    }\n\n    foreach (QQuickAnimatorProxyJob *proxy, m_animatorRoots)\n        proxy-\u003econtrollerWasDeleted();\n    qDeleteAll(m_animatorRoots.keys());\n\n    // Delete those who have been started, stopped and are now still\n    // pending for restart.\n    foreach (QAbstractAnimationJob *job, m_starting.keys()) {\n        if (!m_animatorRoots.contains(job))\n            delete job;\n    }\n}\n\nvoid QQuickAnimatorController::itemDestroyed(QObject *o)\n{\n    m_deletedSinceLastFrame \u003c\u003c (QQuickItem *) o;\n}\n\nvoid QQuickAnimatorController::advance()\n{\n    bool running = false;\n    for (QHash\u003cQAbstractAnimationJob *, QQuickAnimatorProxyJob *\u003e::const_iterator it = m_animatorRoots.constBegin();\n         !running \u0026\u0026 it != m_animatorRoots.constEnd(); ++it) {\n        if (it.key()-\u003eisRunning())\n            running = true;\n    }\n\n    // It was tempting to only run over the active animations, but we need to push\n    // the values for the transforms that finished in the last frame and those will\n    // have been removed already...\n    lock();\n    for (QHash\u003cQQuickItem *, QQuickTransformAnimatorJob::Helper *\u003e::const_iterator it = m_transforms.constBegin();\n         it != m_transforms.constEnd(); ++it) {\n        QQuickTransformAnimatorJob::Helper *xform = *it;\n        // Set to zero when the item was deleted in beforeNodeSync().\n        if (!xform-\u003eitem)\n            continue;\n        (*it)-\u003eapply();\n    }\n    unlock();\n\n    if (running)\n        m_window-\u003eupdate();\n}\n\nstatic void qquick_initialize_helper(QAbstractAnimationJob *job, QQuickAnimatorController *c)\n{\n    if (job-\u003eisRenderThreadJob()) {\n        QQuickAnimatorJob *j = static_cast\u003cQQuickAnimatorJob *\u003e(job);\n        if (!j-\u003etarget()) {\n            return;\n        } else if (c-\u003em_deletedSinceLastFrame.contains(j-\u003etarget())) {\n            j-\u003etargetWasDeleted();\n        } else {\n            j-\u003eaddAnimationChangeListener(c, QAbstractAnimationJob::StateChange);\n            j-\u003einitialize(c);\n        }\n    } else if (job-\u003eisGroup()) {\n        QAnimationGroupJob *g = static_cast\u003cQAnimationGroupJob *\u003e(job);\n        for (QAbstractAnimationJob *a = g-\u003efirstChild(); a; a = a-\u003enextSibling())\n            qquick_initialize_helper(a, c);\n    }\n}\n\nvoid QQuickAnimatorController::beforeNodeSync()\n{\n    foreach (QAbstractAnimationJob *job, m_deleting) {\n        m_starting.take(job);\n        m_stopping.take(job);\n        m_animatorRoots.take(job);\n        job-\u003estop();\n        delete job;\n    }\n    m_deleting.clear();\n\n    if (m_starting.size())\n        m_window-\u003eupdate();\n    foreach (QQuickAnimatorProxyJob *proxy, m_starting) {\n        QAbstractAnimationJob *job = proxy-\u003ejob();\n        job-\u003eaddAnimationChangeListener(this, QAbstractAnimationJob::Completion);\n        qquick_initialize_helper(job, this);\n        m_animatorRoots[job] = proxy;\n        job-\u003estart();\n        proxy-\u003estartedByController();\n    }\n    m_starting.clear();\n\n    foreach (QQuickAnimatorProxyJob *proxy, m_stopping) {\n        QAbstractAnimationJob *job = proxy-\u003ejob();\n        job-\u003estop();\n    }\n    m_stopping.clear();\n\n    foreach (QQuickAnimatorJob *job, m_activeLeafAnimations) {\n        if (!job-\u003etarget())\n            continue;\n        else if (m_deletedSinceLastFrame.contains(job-\u003etarget()))\n            job-\u003etargetWasDeleted();\n        else if (job-\u003eisTransform()) {\n            QQuickTransformAnimatorJob *xform = static_cast\u003cQQuickTransformAnimatorJob *\u003e(job);\n            xform-\u003etransformHelper()-\u003esync();\n        }\n    }\n    foreach (QQuickItem *wiped, m_deletedSinceLastFrame) {\n        QQuickTransformAnimatorJob::Helper *helper = m_transforms.value(wiped);\n        if (helper)\n            helper-\u003eitem = 0;\n    }\n\n    m_deletedSinceLastFrame.clear();\n}\n\nvoid QQuickAnimatorController::afterNodeSync()\n{\n    foreach (QQuickAnimatorJob *job, m_activeLeafAnimations) {\n        if (job-\u003eisUniform() \u0026\u0026 job-\u003etarget())\n            static_cast\u003cQQuickUniformAnimatorJob *\u003e(job)-\u003eafterNodeSync();\n    }\n}\n\nvoid QQuickAnimatorController::animationFinished(QAbstractAnimationJob *job)\n{\n    /* We are currently on the render thread and m_deleting is primarily\n     * being written on the GUI Thread and read during sync. However, we don't\n     * need to lock here as this is a direct result of animationDriver-\u003eadvance()\n     * which is already locked. For non-threaded render loops no locking is\n     * needed in any case.\n     */\n    if (!m_deleting.contains(job)) {\n        QQuickAnimatorProxyJob *proxy = m_animatorRoots[job];\n        if (proxy)\n            QCoreApplication::postEvent(proxy, new QEvent(QEvent::User));\n        // else already gone...\n    }\n}\n\nvoid QQuickAnimatorController::animationStateChanged(QAbstractAnimationJob *job,\n                                                     QAbstractAnimationJob::State newState,\n                                                     QAbstractAnimationJob::State oldState)\n{\n    Q_ASSERT(job-\u003eisRenderThreadJob());\n    QQuickAnimatorJob *animator = static_cast\u003cQQuickAnimatorJob *\u003e(job);\n    if (newState == QAbstractAnimationJob::Running) {\n        m_activeLeafAnimations \u003c\u003c animator;\n        animator-\u003esetHasBeenRunning(true);\n    } else if (oldState == QAbstractAnimationJob::Running) {\n        m_activeLeafAnimations.remove(animator);\n    }\n}\n\n\n\nvoid QQuickAnimatorController::requestSync()\n{\n    // Force a \"sync\" pass as the newly started animation needs to sync properties from GUI.\n    m_window-\u003emaybeUpdate();\n}\n\n// These functions are called on the GUI thread.\nvoid QQuickAnimatorController::startJob(QQuickAnimatorProxyJob *proxy, QAbstractAnimationJob *job)\n{\n    m_starting[job] = proxy;\n    requestSync();\n}\n\nvoid QQuickAnimatorController::stopJob(QQuickAnimatorProxyJob *proxy, QAbstractAnimationJob *job)\n{\n    m_stopping[job] = proxy;\n    requestSync();\n}\n\nvoid QQuickAnimatorController::deleteJob(QAbstractAnimationJob *job)\n{\n    lock();\n    m_deleting \u003c\u003c job;\n    requestSync();\n    unlock();\n}\n\nQT_END_NAMESPACE\n"}
{"repo_name":"plexinc/plex-home-theater-public","ref":"refs/heads/pht-frodo","path":"plex/Update-Installer/external/win32cpp/tutorials/Tutorial8/View.cpp","copies":"7","language":"C++","content":"//////////////////////////////////////////////\n// View.cpp\n//  Definitions for the CView class\n\n#include \"view.h\"\n#include \"GDI.h\"\n#include \"file.h\"\n#include \"resource.h\"\n\nusing namespace std;\n\nCView::CView() : m_PenColor(RGB(0,0,0))\n{\n\tm_Brush.CreateSolidBrush(RGB(255,255,230));\n}\n\nCView::~CView()\n{\n}\n\nvoid CView::ClearPoints()\n{\n\tm_points.clear();\n\tInvalidate();\n}\n\nvoid CView::DrawLine(int x, int y)\n{\n\tCClientDC dcClient(this);\n\tdcClient.CreatePen(PS_SOLID, 1, m_points.back().color);\n\tdcClient.MoveTo(m_points.back().x, m_points.back().y);\n\tdcClient.LineTo(x, y);\n}\n\nvoid CView::OnDraw(CDC* pDC)\n{\n\tif (m_points.size() \u003e 0)\n\t{\n\t\tbool bDraw = false;  //Start with the pen up\n\t\tfor (unsigned int i = 0 ; i \u003c m_points.size(); i++)\n\t\t{\n\t\t\tpDC-\u003eCreatePen(PS_SOLID, 1, m_points[i].color);\n\t\t\tif (bDraw)\n\t\t\t\tpDC-\u003eLineTo(m_points[i].x, m_points[i].y);\n\t\t\telse\n\t\t\t\tpDC-\u003eMoveTo(m_points[i].x, m_points[i].y);\n\t\t\t\n\t\t\tbDraw = m_points[i].PenDown;\n\t\t}\n\t}\n}\n\nvoid CView::PreCreate(CREATESTRUCT \u0026cs)\n{\n\t// Set the extra style to provide a sunken effect\n\tcs.dwExStyle = WS_EX_CLIENTEDGE;\n}\n\nvoid CView::PreRegisterClass(WNDCLASS \u0026wc)\n{\n\t// Set the background brush, class name and cursor\n\twc.hbrBackground = m_Brush;\n\twc.lpszClassName = _T(\"Scribble Window\");\n\twc.hCursor = ::LoadCursor(GetApp()-\u003eGetInstanceHandle(), MAKEINTRESOURCE(IDC_CURSOR1));\n}\n\nBOOL CView::FileOpen(LPCTSTR szFilename)\n{\n\t// empty the PlotPoint vector\n\tm_points.clear();\n\tDWORD nBytesRead;\n\tBOOL bResult = FALSE;\n\n\t// Create a handle to the file\n\tCFile File;\n\tif (File.Open(szFilename, OPEN_EXISTING))\n\t{\n\t\tdo\n\t\t{\n\t\t\tPlotPoint pp;\n\t\t\tnBytesRead = File.Read(\u0026pp, sizeof(PlotPoint));\n\t\t\tif (nBytesRead == sizeof(PlotPoint))\n\t\t\t\tm_points.push_back(pp);\t\n\n\t\t} while (nBytesRead == sizeof(PlotPoint));\n\n\t\tif ((0 != nBytesRead) || (m_points.empty()))\n\t\t{\n\t\t\t// Failed to read all of the file\n\t\t\tm_points.clear();\n\t\t\t::MessageBox (0, _T(\"Invalid data in file\"), _T(\"Error\"), MB_ICONEXCLAMATION | MB_OK);\n\t\t}\n\t\telse\n\t\t\tbResult = TRUE;\n\n\t}\n\telse\n\t{\n\t\ttString tsErrMsg = _T(\"Failed to open file \");\n\t\ttsErrMsg += szFilename;\n\t\t::MessageBox (0, tsErrMsg.c_str(), _T(\"Error\"), MB_ICONEXCLAMATION | MB_OK);\n\t}\n\n\tInvalidate();\n\treturn bResult;\n}\n\nBOOL CView::FileSave(LPCTSTR szFilename)\n{\n\tBOOL bResult = TRUE;\n\tCFile hFile;\n\tif (!hFile.Open(szFilename, CREATE_ALWAYS))\n\t{\n\t\t::MessageBox (0, _T(\"Failed to open file for writing\"), _T(\"Error\"), MB_ICONEXCLAMATION | MB_OK);\n\t\tbResult = FALSE;\n\t}\n\t\n\tif (bResult)\n\t{\n\t\t// Write the file\n\t\tfor (size_t i = 0; i \u003c m_points.size(); ++i)\n\t\t{\n\t\t\tif (!hFile.Write(\u0026m_points[i], sizeof(PlotPoint)))\n\t\t\t{\n\t\t\t\t::MessageBox (0, _T(\"Error while writing to file\"), _T(\"Error\"), MB_ICONEXCLAMATION | MB_OK);\n\t\t\t\tbResult = FALSE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// Verify file length\n\t\tif (hFile.GetLength() != m_points.size() * sizeof(PlotPoint))\n\t\t{\n\t\t\t::MessageBox (0, _T(\"Error while writing to file\"), _T(\"Error\"), MB_ICONEXCLAMATION | MB_OK);\n\t\t\tbResult = FALSE;\n\t\t}\n\t}\n\n\treturn bResult;\n}\n\nvoid CView::SetPen(COLORREF color)\n{\n\tm_PenColor = color;\n}\n\nvoid CView::StorePoint(int x, int y, bool PenDown)\n{\n\tPlotPoint P1;\n\tP1.x = x;\n\tP1.y = y;\n\tP1.PenDown = PenDown;\n\tP1.color = m_PenColor;\n\n\tm_points.push_back(P1); //Add the point to the vector\n}\n\nvoid CView::OnLButtonDown(LPARAM lParam)\n{\n \t// Capture mouse input.\n \tSetCapture();\n\n\tStorePoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam), true);\n}\n\nvoid CView::OnLButtonUp(LPARAM lParam)\n{\n\t{\n\t\t//Release the capture on the mouse\n\t\tReleaseCapture();\n\n\t\tStorePoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam), false);\n\t}\n}\n\nvoid CView::OnMouseMove(WPARAM wParam, LPARAM lParam)\n{\n\t// hold down the left mouse button and move mouse to draw lines.\n\tif ( (wParam \u0026 MK_LBUTTON) \u0026\u0026 (GetCapture() == this) )\n\t{\n\t\tDrawLine(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));\n\t\tStorePoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam), true);\n\t}\n}\n\nLRESULT CView::WndProc(UINT uMsg, WPARAM wParam, LPARAM lParam)\n{\n\tswitch (uMsg)\n\t{\n\tcase WM_LBUTTONDOWN:\n\t\tOnLButtonDown(lParam);\n\t\tbreak;\n\n\tcase WM_MOUSEMOVE:\n\t\tOnMouseMove(wParam, lParam);\n        break;\n\n    case WM_LBUTTONUP:\n\t\tOnLButtonUp(lParam);\n\t\tbreak;\n\t}\n\n\t//Use the default message handling for remaining messages\n\treturn WndProcDefault(uMsg, wParam, lParam);\n}\n\n\n"}
{"repo_name":"grokys/coreclr","ref":"refs/heads/master","path":"src/vm/common.cpp","copies":"62","language":"C++","content":"//\n// Copyright (c) Microsoft. All rights reserved.\n// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n//\n\n\n#include \"common.h\"\n\n"}
{"repo_name":"Maximus-/WinObjC","ref":"refs/heads/master","path":"deps/3rdparty/icu/icu/source/layout/TibetanReordering.cpp","copies":"361","language":"C++","content":"/*\n *\n * (C) Copyright IBM Corp. 1998-2007 - All Rights Reserved \n *\n * Developed at DIT - Government of Bhutan\n *\n * Contact person: Pema Geyleg - \u003cpema_geyleg@druknet.bt\u003e \n *\n * This file is a modification of the ICU file KhmerReordering.cpp\n * by Jens Herden and Javier Sola who have given all their possible rights to IBM and the Governement of Bhutan\n * A first module for Dzongkha was developed by Karunakar under Panlocalisation funding.\n * Assistance for this module has been received from Namgay Thinley, Christopher Fynn and Javier Sola\n *\n */\n\n//#include \u003cstdio.h\u003e\n#include \"LETypes.h\"\n#include \"OpenTypeTables.h\"\n#include \"TibetanReordering.h\"\n#include \"LEGlyphStorage.h\"\n\n\nU_NAMESPACE_BEGIN\n\n// Characters that get refered to by name...\nenum\n{\n    C_DOTTED_CIRCLE = 0x25CC,\n    C_PRE_NUMBER_MARK = 0x0F3F\n };\n\n\nenum\n{\n    // simple classes, they are used in the statetable (in this file) to control the length of a syllable\n    // they are also used to know where a character should be placed (location in reference to the base character)\n    // and also to know if a character, when independtly displayed, should be displayed with a dotted-circle to\n    // indicate error in syllable construction \n    _xx = TibetanClassTable::CC_RESERVED,\n    _ba = TibetanClassTable::CC_BASE,\n    _sj = TibetanClassTable::CC_SUBJOINED | TibetanClassTable::CF_DOTTED_CIRCLE | TibetanClassTable::CF_POS_BELOW, \n    _tp = TibetanClassTable::CC_TSA_PHRU  | TibetanClassTable::CF_DOTTED_CIRCLE | TibetanClassTable::CF_POS_ABOVE,\n    _ac = TibetanClassTable::CC_A_CHUNG |  TibetanClassTable::CF_DOTTED_CIRCLE | TibetanClassTable::CF_POS_BELOW,\n    _cs = TibetanClassTable::CC_COMP_SANSKRIT | TibetanClassTable::CF_DOTTED_CIRCLE | TibetanClassTable::CF_POS_BELOW,\n    _ha = TibetanClassTable::CC_HALANTA | TibetanClassTable::CF_DOTTED_CIRCLE | TibetanClassTable::CF_POS_BELOW, \n    _bv = TibetanClassTable::CC_BELOW_VOWEL | TibetanClassTable::CF_DOTTED_CIRCLE | TibetanClassTable::CF_POS_BELOW,\n    _av = TibetanClassTable::CC_ABOVE_VOWEL | TibetanClassTable::CF_DOTTED_CIRCLE | TibetanClassTable::CF_POS_ABOVE,\n    _an = TibetanClassTable::CC_ANUSVARA | TibetanClassTable::CF_DOTTED_CIRCLE | TibetanClassTable::CF_POS_ABOVE,\n    _cb = TibetanClassTable::CC_CANDRABINDU | TibetanClassTable::CF_DOTTED_CIRCLE | TibetanClassTable::CF_POS_ABOVE,\n    _vs = TibetanClassTable::CC_VISARGA | TibetanClassTable::CF_DOTTED_CIRCLE| TibetanClassTable::CF_POS_AFTER,\n    _as = TibetanClassTable::CC_ABOVE_S_MARK | TibetanClassTable::CF_DOTTED_CIRCLE | TibetanClassTable::CF_POS_ABOVE,\n    _bs = TibetanClassTable::CC_BELOW_S_MARK | TibetanClassTable::CF_DOTTED_CIRCLE | TibetanClassTable::CF_POS_BELOW,\n    _di = TibetanClassTable::CC_DIGIT | TibetanClassTable::CF_DIGIT,\n    _pd = TibetanClassTable::CC_PRE_DIGIT_MARK | TibetanClassTable::CF_DOTTED_CIRCLE | TibetanClassTable::CF_PREDIGIT | TibetanClassTable::CF_POS_BEFORE ,\n    _bd = TibetanClassTable::CC_POST_BELOW_DIGIT_M | TibetanClassTable::CF_DOTTED_CIRCLE | TibetanClassTable::CF_POS_AFTER\n};\n\n\n// Character class tables \n//_xx Non Combining characters\n//_ba Base Consonants\n//_sj Subjoined consonants\n//_tp Tsa - phru\n//_ac A-chung, Vowel Lengthening mark\n//_cs Precomposed Sanskrit vowel + subjoined consonants\n//_ha Halanta/Virama\n//_bv Below vowel\n//_av above vowel\n//_an Anusvara\n//_cb Candrabindu\n//_vs Visaraga/Post mark\n//_as Upper Stress marks\n//_bs Lower Stress marks\n//_di Digit\n//_pd Number pre combining, Needs reordering\n//_bd Other number combining marks\n\nstatic const TibetanClassTable::CharClass tibetanCharClasses[] =\n{\n   // 0    1    2    3    4    5    6    7    8    9   a     b   c    d     e   f\n    _xx, _ba, _xx, _xx, _ba, _ba, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, // 0F00 - 0F0F 0\n    _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _bd, _bd, _xx, _xx, _xx, _xx, _xx, _xx, // 0F10 - 0F1F 1\n    _di, _di, _di, _di, _di, _di, _di, _di, _di, _di, _xx, _xx, _xx, _xx, _xx, _xx, // 0F20 - 0F2F 2 \n    _xx, _xx, _xx, _xx, _xx, _bs, _xx, _bs, _xx, _tp, _xx, _xx, _xx, _xx, _bd, _pd, // 0F30 - 0F3F 3 \n    _ba, _ba, _ba, _ba, _ba, _ba, _ba, _ba, _xx, _ba, _ba, _ba, _ba, _ba, _ba, _ba, // 0F40 - 0F4F 4\n    _ba, _ba, _ba, _ba, _ba, _ba, _ba, _ba, _ba, _ba, _ba, _ba, _ba, _ba, _ba, _ba, // 0F50 - 0F5F 5\n    _ba, _ba, _ba, _ba, _ba, _ba, _ba, _ba, _ba, _ba, _ba, _xx, _xx, _xx, _xx, _xx, // 0F60 - 0F6F 6\n    _xx, _ac, _av, _cs, _bv, _bv, _cs, _cs, _cs, _cs, _av, _av, _av, _av, _an, _vs, // 0F70 - 0F7F 7\n    _av, _cs, _cb, _cb, _ha, _xx, _as, _as, _ba, _ba, _ba, _ba, _xx, _xx, _xx, _xx, // 0F80 - 0F8F 8\n    _sj, _sj, _sj, _sj, _sj, _sj, _sj, _sj, _xx, _sj, _sj, _sj, _sj, _sj, _sj, _sj, // 0F90 - 0F9F 9\n    _sj, _sj, _sj, _sj, _sj, _sj, _sj, _sj, _sj, _sj, _sj, _sj, _sj, _sj, _sj, _sj, // 0FA0 - 0FAF a\n    _sj, _sj, _sj, _sj, _sj, _sj, _sj, _sj, _sj, _sj, _sj, _sj, _sj, _xx, _sj, _sj, // 0FB0 - 0FBF b\n    _xx, _xx, _xx, _xx, _xx, _xx, _bs, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, // 0FC0 - 0FCF c\n    _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx,// 0FD0 - 0FDF  d\n    _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, // 0FE0 - 0FEF e\n    _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, _xx, // 0FF0 - 0FFF f \n};                                                                                  \n\n\n//\n// Tibetan Class Tables\n//                   \n\n//\n// The range of characters defined in the above table is defined here. For Tibetan 0F00 to 0FFF\n// Even if the Tibetan range is bigger, most of the characters are not combinable, and therefore treated\n// as _xx\nstatic const TibetanClassTable tibetanClassTable = {0x0F00, 0x0FFF, tibetanCharClasses};\n\n\n// Below we define how a character in the input string is either in the tibetanCharClasses table\n// (in which case we get its type back), or an unknown object in which case we get _xx (CC_RESERVED) back\nTibetanClassTable::CharClass TibetanClassTable::getCharClass(LEUnicode ch) const\n{\n    if (ch \u003c firstChar || ch \u003e lastChar) {\n        return CC_RESERVED;\n    }\n    \n    return classTable[ch - firstChar];\n}\n\nconst TibetanClassTable *TibetanClassTable::getTibetanClassTable()\n{\n    return \u0026tibetanClassTable;\n}\n\n\n\nclass TibetanReorderingOutput : public UMemory {\nprivate:\n    le_int32 fSyllableCount;\n    le_int32 fOutIndex;\n    LEUnicode *fOutChars;\n\n    LEGlyphStorage \u0026fGlyphStorage;\n\n\npublic:\n    TibetanReorderingOutput(LEUnicode *outChars, LEGlyphStorage \u0026glyphStorage)\n        : fSyllableCount(0), fOutIndex(0), fOutChars(outChars), fGlyphStorage(glyphStorage)\n    {\n        // nothing else to do...\n    }\n\n    ~TibetanReorderingOutput()\n    {\n        // nothing to do here...\n    }\n\n    void reset()\n    {\n        fSyllableCount += 1;\n    }\n\n    void writeChar(LEUnicode ch, le_uint32 charIndex, FeatureMask featureMask)\n    {\n        LEErrorCode success = LE_NO_ERROR;\n\n        fOutChars[fOutIndex] = ch;\n\n        fGlyphStorage.setCharIndex(fOutIndex, charIndex, success);\n        fGlyphStorage.setAuxData(fOutIndex, featureMask, success);\n\n        fOutIndex += 1;\n    }\n\n    le_int32 getOutputIndex()\n    {\n        return fOutIndex;\n    }\n};\n\n\n//TODO remove unused flags\n#define ccmpFeatureTag LE_CCMP_FEATURE_TAG\n#define blwfFeatureTag LE_BLWF_FEATURE_TAG\n#define pstfFeatureTag LE_PSTF_FEATURE_TAG\n#define presFeatureTag LE_PRES_FEATURE_TAG\n#define blwsFeatureTag LE_BLWS_FEATURE_TAG\n#define abvsFeatureTag LE_ABVS_FEATURE_TAG\n#define pstsFeatureTag LE_PSTS_FEATURE_TAG\n\n#define blwmFeatureTag LE_BLWM_FEATURE_TAG\n#define abvmFeatureTag LE_ABVM_FEATURE_TAG\n#define distFeatureTag LE_DIST_FEATURE_TAG\n\n#define prefFeatureTag LE_PREF_FEATURE_TAG\n#define abvfFeatureTag LE_ABVF_FEATURE_TAG\n#define cligFeatureTag LE_CLIG_FEATURE_TAG\n#define mkmkFeatureTag LE_MKMK_FEATURE_TAG\n\n// Shaping features\n#define prefFeatureMask 0x80000000UL\n#define blwfFeatureMask 0x40000000UL\n#define abvfFeatureMask 0x20000000UL\n#define pstfFeatureMask 0x10000000UL \n#define presFeatureMask 0x08000000UL\n#define blwsFeatureMask 0x04000000UL\n#define abvsFeatureMask 0x02000000UL\n#define pstsFeatureMask 0x01000000UL\n#define cligFeatureMask 0x00800000UL \n#define ccmpFeatureMask 0x00040000UL\n\n// Positioning features\n#define distFeatureMask 0x00400000UL\n#define blwmFeatureMask 0x00200000UL\n#define abvmFeatureMask 0x00100000UL\n#define mkmkFeatureMask 0x00080000UL\n\n#define tagPref    (ccmpFeatureMask | prefFeatureMask | presFeatureMask | cligFeatureMask | distFeatureMask)\n#define tagAbvf    (ccmpFeatureMask | abvfFeatureMask | abvsFeatureMask | cligFeatureMask | distFeatureMask | abvmFeatureMask | mkmkFeatureMask)\n#define tagPstf    (ccmpFeatureMask | blwfFeatureMask | blwsFeatureMask | prefFeatureMask | presFeatureMask | pstfFeatureMask | pstsFeatureMask | cligFeatureMask | distFeatureMask | blwmFeatureMask)\n#define tagBlwf    (ccmpFeatureMask | blwfFeatureMask | blwsFeatureMask | cligFeatureMask | distFeatureMask | blwmFeatureMask | mkmkFeatureMask)\n#define tagDefault (ccmpFeatureMask | prefFeatureMask | blwfFeatureMask | presFeatureMask | blwsFeatureMask | cligFeatureMask | distFeatureMask | abvmFeatureMask | blwmFeatureMask | mkmkFeatureMask)\n\n\n\n// These are in the order in which the features need to be applied\n// for correct processing\nstatic const FeatureMap featureMap[] =\n{\n    // Shaping features\n    {ccmpFeatureTag, ccmpFeatureMask},\n    {prefFeatureTag, prefFeatureMask},\n    {blwfFeatureTag, blwfFeatureMask},\n    {abvfFeatureTag, abvfFeatureMask},\n    {pstfFeatureTag, pstfFeatureMask}, \n    {presFeatureTag, presFeatureMask},\n    {blwsFeatureTag, blwsFeatureMask},\n    {abvsFeatureTag, abvsFeatureMask},\n    {pstsFeatureTag, pstsFeatureMask},\n    {cligFeatureTag, cligFeatureMask},\n    \n    // Positioning features\n    {distFeatureTag, distFeatureMask},\n    {blwmFeatureTag, blwmFeatureMask},\n    {abvmFeatureTag, abvmFeatureMask},\n    {mkmkFeatureTag, mkmkFeatureMask},\n};\n\nstatic const le_int32 featureMapCount = LE_ARRAY_SIZE(featureMap);\n\n// The stateTable is used to calculate the end (the length) of a well\n// formed Tibetan Syllable. \n//\n// Each horizontal line is ordered exactly the same way as the values in TibetanClassTable\n// CharClassValues in TibetanReordering.h This coincidence of values allows the\n// follow up of the table.\n//\n// Each line corresponds to a state, which does not necessarily need to be a type\n// of component... for example, state 2 is a base, with is always a first character\n// in the syllable, but the state could be produced a consonant of any type when\n// it is the first character that is analysed (in ground state).\n//\nstatic const le_int8 tibetanStateTable[][TibetanClassTable::CC_COUNT] =\n{\n\n     \n    //Dzongkha state table\n    //xx  ba  sj  tp  ac  cs  ha  bv  av  an  cb  vs  as  bs  di  pd  bd\n    { 1,  2,  4,  3,  8,  7,  9, 10, 14, 13, 17, 18, 19, 19, 20, 21, 21,}, //  0 - ground state\n    {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,}, //  1 - exit state (or sign to the right of the syllable)\n    {-1, -1,  4,  3,  8,  7,  9, 10, 14, 13, 17, 18, 19, 19, -1, -1, -1,}, //  2 - Base consonant    \n    {-1, -1,  5, -1,  8,  7, -1, 10, 14, 13, 17, 18, 19, 19, -1, -1, -1,}, //  3 - Tsa phru after base\n    {-1, -1,  4,  6,  8,  7,  9, 10, 14, 13, 17, 18, 19, 19, -1, -1, -1,}, //  4 - Subjoined consonant after base             \n    {-1, -1,  5, -1,  8,  7, -1, 10, 14, 13, 17, 18, 19, 19, -1, -1, -1,}, //  5 - Subjoined consonant after tsa phru\n    {-1, -1, -1, -1,  8,  7, -1, 10, 14, 13, 17, 18, 19, 19, -1, -1, -1,}, //  6 - Tsa phru after subjoined consonant\n    {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 19, 19, -1, -1, -1,}, //  7 - Pre Composed Sanskrit\n    {-1, -1, -1, -1, -1, -1, -1, 10, 14, 13, 17, 18, 19, 19, -1, -1, -1,}, //  8 - A-chung\n    {-1, -1, -1, -1, -1, -1, -1, -1, 14, 13, 17, -1, 19, 19, -1, -1, -1,}, //  9 - Halanta\n    {-1, -1, -1, -1, -1, -1, -1, 11, 14, 13, 17, 18, 19, 19, -1, -1, -1,}, // 10 - below vowel 1\n    {-1, -1, -1, -1, -1, -1, -1, 12, 14, 13, 17, 18, 19, 19, -1, -1, -1,}, // 11 - below vowel 2\n    {-1, -1, -1, -1, -1, -1, -1, -1, 14, 13, 17, 18, 19, 19, -1, -1, -1,}, // 12 - below vowel 3   \n    {-1, -1, -1, -1, -1, -1, -1, -1, 14, 17, 17, 18, 19, 19, -1, -1, -1,}, // 13 - Anusvara before vowel\n    {-1, -1, -1, -1, -1, -1, -1, -1, 15, 17, 17, 18, 19, 19, -1, -1, -1,}, // 14 - above vowel 1\n    {-1, -1, -1, -1, -1, -1, -1, -1, 16, 17, 17, 18, 19, 19, -1, -1, -1,}, // 15 - above vowel 2\n    {-1, -1, -1, -1, -1, -1, -1, -1, -1, 17, 17, 18, 19, 19, -1, -1, -1,}, // 16 - above vowel 3\n    {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 18, 19, 19, -1, -1, -1,}, // 17 - Anusvara or Candrabindu after vowel \n    {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 19, 19, -1, -1, -1,}, // 18 - Visarga    \n    {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,}, // 19 - strss mark\n    {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 21, 21,}, // 20 - digit \n    {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,}, // 21 - digit mark\n    \n\n};         \n\n\nconst FeatureMap *TibetanReordering::getFeatureMap(le_int32 \u0026count)\n{\n    count = featureMapCount;\n\n    return featureMap;\n}\n\n\n// Given an input string of characters and a location in which to start looking\n// calculate, using the state table, which one is the last character of the syllable\n// that starts in the starting position.\nle_int32 TibetanReordering::findSyllable(const TibetanClassTable *classTable, const LEUnicode *chars, le_int32 prev, le_int32 charCount)\n{\n    le_int32 cursor = prev;\n    le_int8 state = 0;\n\n    while (cursor \u003c charCount) {\n        TibetanClassTable::CharClass charClass = (classTable-\u003egetCharClass(chars[cursor]) \u0026 TibetanClassTable::CF_CLASS_MASK);\n\n        state = tibetanStateTable[state][charClass];\n\n        if (state \u003c 0) {\n            break;\n        }\n\n        cursor += 1;\n    }\n\n    return cursor;\n}\n\n\n// This is the real reordering function as applied to the Tibetan language\n\nle_int32 TibetanReordering::reorder(const LEUnicode *chars, le_int32 charCount, le_int32,\n                                  LEUnicode *outChars, LEGlyphStorage \u0026glyphStorage)\n{\n    const TibetanClassTable *classTable = TibetanClassTable::getTibetanClassTable();\n\n    TibetanReorderingOutput output(outChars, glyphStorage);\n    TibetanClassTable::CharClass charClass;\n    le_int32 i, prev = 0;\n\n    // This loop only exits when we reach the end of a run, which may contain \n    // several syllables.\n    while (prev \u003c charCount) {\n        le_int32 syllable = findSyllable(classTable, chars, prev, charCount);  \n\n        output.reset();\n       \n        // shall we add a dotted circle?\n        // If in the position in which the base should be (first char in the string) there is\n        // a character that has the Dotted circle flag (a character that cannot be a base)\n        // then write a dotted circle\n        if (classTable-\u003egetCharClass(chars[prev]) \u0026 TibetanClassTable::CF_DOTTED_CIRCLE) {\n            output.writeChar(C_DOTTED_CIRCLE, prev, tagDefault);        \n        }        \n\n        // copy the rest to output, inverting the pre-number mark if present after a digit.\n        for (i = prev; i \u003c syllable; i += 1) {\n            charClass = classTable-\u003egetCharClass(chars[i]);\n           \n           if ((TibetanClassTable::CF_DIGIT \u0026 charClass) \n              \u0026\u0026 ( classTable-\u003egetCharClass(chars[i+1]) \u0026 TibetanClassTable::CF_PREDIGIT))\n           {\n         \t\t output.writeChar(C_PRE_NUMBER_MARK, i, tagPref);\n                         output.writeChar(chars[i], i+1 , tagPref);\n\t\t\ti += 1;\n          } else {\n            switch (charClass \u0026 TibetanClassTable::CF_POS_MASK) {\n            \t\n            \t// If the present character is a number, and the next character is a pre-number combining mark\n            // then the two characters are reordered\n          \t           \t\n                case TibetanClassTable::CF_POS_ABOVE :\n                    output.writeChar(chars[i], i, tagAbvf);\n                    break;\n                \n                case TibetanClassTable::CF_POS_AFTER :\n                    output.writeChar(chars[i], i, tagPstf);\n                    break;\n                \n                case TibetanClassTable::CF_POS_BELOW :\n                    output.writeChar(chars[i], i, tagBlwf);\n                    break;\n                \n                default:                                       \n                    // default - any other characters\n                   output.writeChar(chars[i], i, tagDefault);\n                    break;\n            } // switch\n          } // if\n        } // for\n\n        prev = syllable; // move the pointer to the start of next syllable\n    }\n\n    return output.getOutputIndex();\n}\n\n\nU_NAMESPACE_END\n"}
{"repo_name":"punker76/Windows-universal-samples","ref":"refs/heads/master","path":"Samples/XamlCloudFontIntegration/cpp/Scenario_Document1.xaml.cpp","copies":"112","language":"C++","content":"//*********************************************************\n//\n// Copyright (c) Microsoft. All rights reserved.\n// This code is licensed under the MIT License (MIT).\n// THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF\n// ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY\n// IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR\n// PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.\n//\n//*********************************************************\n\n#include \"pch.h\"\n#include \"Scenario_Document1.xaml.h\"\n\nusing namespace SDKTemplate;\n\nusing namespace Platform;\nusing namespace Windows::Foundation;\nusing namespace Windows::Foundation::Collections;\nusing namespace Windows::UI::Xaml;\nusing namespace Windows::UI::Xaml::Controls;\nusing namespace Windows::UI::Xaml::Controls::Primitives;\nusing namespace Windows::UI::Xaml::Data;\nusing namespace Windows::UI::Xaml::Input;\nusing namespace Windows::UI::Xaml::Media;\nusing namespace Windows::UI::Xaml::Navigation;\n\n\nScenario_Document1::Scenario_Document1()\n{\n    InitializeComponent();\n}\n\n\nvoid Scenario_Document1::Page_Loaded(Platform::Object^ sender, Windows::UI::Xaml::RoutedEventArgs^ e)\n{\n    // Font formatting is being applied on page load rather than in XAML markup\n    // so that the on-demand cloud font behavior can be experienced when the\n    // app runs rather than when the XAML file is viewed in Visual Studio.\n\n    // Formatting will be applied to all content elements in the page that don't \n    // already have FontFamily set.\n    this-\u003eFontFamily = ref new Windows::UI::Xaml::Media::FontFamily(\"Neue Haas Grotesk Text Pro\");\n}\n"}
{"repo_name":"nextgis/NextGIS_QGIS_open","ref":"refs/heads/ngq-15_0","path":"src/gui/qgsfieldvalidator.cpp","copies":"13","language":"C++","content":"/***************************************************************************\n                         qgsfieldvalidator.cpp  -  description\n                             -------------------\n    begin                : March 2011\n    copyright            : (C) 2011 by SunilRajKiran-kCube\n    email                : sunilraj.kiran@kcubeconsulting.com\n\n  adapted version of QValidator for QgsField\n ***************************************************************************/\n\n/***************************************************************************\n *                                                                         *\n *   This program is free software; you can redistribute it and/or modify  *\n *   it under the terms of the GNU General Public License as published by  *\n *   the Free Software Foundation; either version 2 of the License, or     *\n *   (at your option) any later version.                                   *\n *                                                                         *\n ***************************************************************************/\n\n#include \"qgsfieldvalidator.h\"\n\n#include \u003cQValidator\u003e\n#include \u003cQRegExpValidator\u003e\n#include \u003cQDate\u003e\n#include \u003cQVariant\u003e\n#include \u003cQSettings\u003e\n\n#include \"qgslogger.h\"\n#include \"qgslonglongvalidator.h\"\n#include \"qgsfield.h\"\n\nQgsFieldValidator::QgsFieldValidator( QObject *parent, const QgsField \u0026field, QString dateFormat )\n    : QValidator( parent )\n    , mField( field )\n    , mDateFormat( dateFormat )\n{\n  switch ( mField.type() )\n  {\n    case QVariant::Int:\n    {\n      if ( mField.length() \u003e 0 )\n      {\n        QString re = QString( \"-?\\\\d{0,%1}\" ).arg( mField.length() );\n        mValidator = new QRegExpValidator( QRegExp( re ), parent );\n      }\n      else\n      {\n        mValidator = new QIntValidator( parent );\n      }\n    }\n    break;\n\n    case QVariant::Double:\n    {\n      if ( mField.length() \u003e 0 \u0026\u0026 mField.precision() \u003e 0 )\n      {\n        QString re = QString( \"-?\\\\d{0,%1}(\\\\.\\\\d{0,%2})?\" ).arg( mField.length() - mField.precision() ).arg( mField.precision() );\n        mValidator = new QRegExpValidator( QRegExp( re ), parent );\n      }\n      else if ( mField.length() \u003e 0 \u0026\u0026 mField.precision() == 0 )\n      {\n        QString re = QString( \"-?\\\\d{0,%1}\" ).arg( mField.length() );\n        mValidator = new QRegExpValidator( QRegExp( re ), parent );\n      }\n      else if ( mField.precision() \u003e 0 )\n      {\n        QString re = QString( \"-?\\\\d*(\\\\.\\\\d{0,%1})?\" ).arg( mField.precision() );\n        mValidator = new QRegExpValidator( QRegExp( re ), parent );\n      }\n      else\n      {\n        mValidator = new QDoubleValidator( parent );\n      }\n    }\n    break;\n\n    case QVariant::LongLong :\n      mValidator = new QgsLongLongValidator( parent );\n      break;\n\n    default:\n      mValidator = 0;\n  }\n\n  QSettings settings;\n  mNullValue = settings.value( \"qgis/nullValue\", \"NULL\" ).toString();\n}\n\nQgsFieldValidator::~QgsFieldValidator()\n{\n  delete mValidator;\n}\n\nQValidator::State QgsFieldValidator::validate( QString \u0026s, int \u0026i ) const\n{\n  // empty values are considered NULL for numbers and dates and are acceptable\n  if ( s.isEmpty() \u0026\u0026\n       ( mField.type() == QVariant::Double\n         || mField.type() == QVariant::Int\n         || mField.type() == QVariant::LongLong\n         || mField.type() == QVariant::Date\n       )\n     )\n  {\n    return Acceptable;\n  }\n\n  // delegate to the child validator if any\n  if ( mValidator )\n  {\n    QValidator::State result = mValidator-\u003evalidate( s, i );\n    return result;\n  }\n  else if ( mField.type() == QVariant::String )\n  {\n    // allow to enter the NULL representation, which might be\n    // longer than the actual field\n    if ( mNullValue.size() \u003e 0 \u0026\u0026\n         s.size() \u003e 0 \u0026\u0026\n         s.size() \u003c mNullValue.size() \u0026\u0026\n         s == mNullValue.left( s.size() ) )\n      return Intermediate;\n\n    if ( s == mNullValue )\n      return Acceptable;\n\n    if ( mField.length() \u003e 0 \u0026\u0026 s.size() \u003e mField.length() )\n      return Invalid;\n  }\n  else if ( mField.type() == QVariant::Date )\n  {\n    return QDate::fromString( s, mDateFormat ).isValid() ? Acceptable : Intermediate;\n  }\n  else\n  {\n    QgsDebugMsg( QString( \"unsupported type %1 for validation\" ).arg( mField.type() ) );\n    return Invalid;\n  }\n\n  return Acceptable;\n}\n\nvoid QgsFieldValidator::fixup( QString \u0026s ) const\n{\n  if ( mValidator )\n  {\n    mValidator-\u003efixup( s );\n  }\n  else if ( mField.type() == QVariant::String \u0026\u0026 mField.length() \u003e 0 \u0026\u0026 s.size() \u003e mField.length() )\n  {\n    // if the value is longer, this must be a partial NULL representation\n    s = mNullValue;\n  }\n  else if ( mField.type() == QVariant::Date )\n  {\n    // invalid dates will also translate to NULL\n    s = \"\";\n  }\n}\n"}
{"repo_name":"geofl/JK2_1.02Source","ref":"refs/heads/master","path":"CODE-mp/server/sv_world.cpp","copies":"12","language":"C++","content":"// world.c -- world query functions\r\n\r\n#include \"server.h\"\r\n\r\n/*\r\n================\r\nSV_ClipHandleForEntity\r\n\r\nReturns a headnode that can be used for testing or clipping to a\r\ngiven entity.  If the entity is a bsp model, the headnode will\r\nbe returned, otherwise a custom box tree will be constructed.\r\n================\r\n*/\r\nclipHandle_t SV_ClipHandleForEntity( const sharedEntity_t *ent ) {\r\n\tif ( ent-\u003er.bmodel ) {\r\n\t\t// explicit hulls in the BSP model\r\n\t\treturn CM_InlineModel( ent-\u003es.modelindex );\r\n\t}\r\n\tif ( ent-\u003er.svFlags \u0026 SVF_CAPSULE ) {\r\n\t\t// create a temp capsule from bounding box sizes\r\n\t\treturn CM_TempBoxModel( ent-\u003er.mins, ent-\u003er.maxs, qtrue );\r\n\t}\r\n\r\n\t// create a temp tree from bounding box sizes\r\n\treturn CM_TempBoxModel( ent-\u003er.mins, ent-\u003er.maxs, qfalse );\r\n}\r\n\r\n\r\n\r\n/*\r\n===============================================================================\r\n\r\nENTITY CHECKING\r\n\r\nTo avoid linearly searching through lists of entities during environment testing,\r\nthe world is carved up with an evenly spaced, axially aligned bsp tree.  Entities\r\nare kept in chains either at the final leafs, or at the first node that splits\r\nthem, which prevents having to deal with multiple fragments of a single entity.\r\n\r\n===============================================================================\r\n*/\r\n\r\ntypedef struct worldSector_s {\r\n\tint\t\taxis;\t\t// -1 = leaf node\r\n\tfloat\tdist;\r\n\tstruct worldSector_s\t*children[2];\r\n\tsvEntity_t\t*entities;\r\n} worldSector_t;\r\n\r\n#define\tAREA_DEPTH\t4\r\n#define\tAREA_NODES\t64\r\n\r\nworldSector_t\tsv_worldSectors[AREA_NODES];\r\nint\t\t\tsv_numworldSectors;\r\n\r\n\r\n/*\r\n===============\r\nSV_SectorList_f\r\n===============\r\n*/\r\nvoid SV_SectorList_f( void ) {\r\n\tint\t\t\t\ti, c;\r\n\tworldSector_t\t*sec;\r\n\tsvEntity_t\t\t*ent;\r\n\r\n\tfor ( i = 0 ; i \u003c AREA_NODES ; i++ ) {\r\n\t\tsec = \u0026sv_worldSectors[i];\r\n\r\n\t\tc = 0;\r\n\t\tfor ( ent = sec-\u003eentities ; ent ; ent = ent-\u003enextEntityInWorldSector ) {\r\n\t\t\tc++;\r\n\t\t}\r\n\t\tCom_Printf( \"sector %i: %i entities\\n\", i, c );\r\n\t}\r\n}\r\n\r\n/*\r\n===============\r\nSV_CreateworldSector\r\n\r\nBuilds a uniformly subdivided tree for the given world size\r\n===============\r\n*/\r\nworldSector_t *SV_CreateworldSector( int depth, vec3_t mins, vec3_t maxs ) {\r\n\tworldSector_t\t*anode;\r\n\tvec3_t\t\tsize;\r\n\tvec3_t\t\tmins1, maxs1, mins2, maxs2;\r\n\r\n\tanode = \u0026sv_worldSectors[sv_numworldSectors];\r\n\tsv_numworldSectors++;\r\n\r\n\tif (depth == AREA_DEPTH) {\r\n\t\tanode-\u003eaxis = -1;\r\n\t\tanode-\u003echildren[0] = anode-\u003echildren[1] = NULL;\r\n\t\treturn anode;\r\n\t}\r\n\t\r\n\tVectorSubtract (maxs, mins, size);\r\n\tif (size[0] \u003e size[1]) {\r\n\t\tanode-\u003eaxis = 0;\r\n\t} else {\r\n\t\tanode-\u003eaxis = 1;\r\n\t}\r\n\r\n\tanode-\u003edist = 0.5 * (maxs[anode-\u003eaxis] + mins[anode-\u003eaxis]);\r\n\tVectorCopy (mins, mins1);\t\r\n\tVectorCopy (mins, mins2);\t\r\n\tVectorCopy (maxs, maxs1);\t\r\n\tVectorCopy (maxs, maxs2);\t\r\n\t\r\n\tmaxs1[anode-\u003eaxis] = mins2[anode-\u003eaxis] = anode-\u003edist;\r\n\t\r\n\tanode-\u003echildren[0] = SV_CreateworldSector (depth+1, mins2, maxs2);\r\n\tanode-\u003echildren[1] = SV_CreateworldSector (depth+1, mins1, maxs1);\r\n\r\n\treturn anode;\r\n}\r\n\r\n/*\r\n===============\r\nSV_ClearWorld\r\n\r\n===============\r\n*/\r\nvoid SV_ClearWorld( void ) {\r\n\tclipHandle_t\th;\r\n\tvec3_t\t\t\tmins, maxs;\r\n\r\n\tCom_Memset( sv_worldSectors, 0, sizeof(sv_worldSectors) );\r\n\tsv_numworldSectors = 0;\r\n\r\n\t// get world map bounds\r\n\th = CM_InlineModel( 0 );\r\n\tCM_ModelBounds( h, mins, maxs );\r\n\tSV_CreateworldSector( 0, mins, maxs );\r\n}\r\n\r\n\r\n/*\r\n===============\r\nSV_UnlinkEntity\r\n\r\n===============\r\n*/\r\nvoid SV_UnlinkEntity( sharedEntity_t *gEnt ) {\r\n\tsvEntity_t\t\t*ent;\r\n\tsvEntity_t\t\t*scan;\r\n\tworldSector_t\t*ws;\r\n\r\n\tent = SV_SvEntityForGentity( gEnt );\r\n\r\n\tgEnt-\u003er.linked = qfalse;\r\n\r\n\tws = ent-\u003eworldSector;\r\n\tif ( !ws ) {\r\n\t\treturn;\t\t// not linked in anywhere\r\n\t}\r\n\tent-\u003eworldSector = NULL;\r\n\r\n\tif ( ws-\u003eentities == ent ) {\r\n\t\tws-\u003eentities = ent-\u003enextEntityInWorldSector;\r\n\t\treturn;\r\n\t}\r\n\r\n\tfor ( scan = ws-\u003eentities ; scan ; scan = scan-\u003enextEntityInWorldSector ) {\r\n\t\tif ( scan-\u003enextEntityInWorldSector == ent ) {\r\n\t\t\tscan-\u003enextEntityInWorldSector = ent-\u003enextEntityInWorldSector;\r\n\t\t\treturn;\r\n\t\t}\r\n\t}\r\n\r\n\tCom_Printf( \"WARNING: SV_UnlinkEntity: not found in worldSector\\n\" );\r\n}\r\n\r\n\r\n/*\r\n===============\r\nSV_LinkEntity\r\n\r\n===============\r\n*/\r\n#define MAX_TOTAL_ENT_LEAFS\t\t128\r\nvoid SV_LinkEntity( sharedEntity_t *gEnt ) {\r\n\tworldSector_t\t*node;\r\n\tint\t\t\tleafs[MAX_TOTAL_ENT_LEAFS];\r\n\tint\t\t\tcluster;\r\n\tint\t\t\tnum_leafs;\r\n\tint\t\t\ti, j, k;\r\n\tint\t\t\tarea;\r\n\tint\t\t\tlastLeaf;\r\n\tfloat\t\t*origin, *angles;\r\n\tsvEntity_t\t*ent;\r\n\r\n\tent = SV_SvEntityForGentity( gEnt );\r\n\r\n\tif ( ent-\u003eworldSector ) {\r\n\t\tSV_UnlinkEntity( gEnt );\t// unlink from old position\r\n\t}\r\n\r\n\t// encode the size into the entityState_t for client prediction\r\n\tif ( gEnt-\u003er.bmodel ) {\r\n\t\tgEnt-\u003es.solid = SOLID_BMODEL;\t\t// a solid_box will never create this value\r\n\t} else if ( gEnt-\u003er.contents \u0026 ( CONTENTS_SOLID | CONTENTS_BODY ) ) {\r\n\t\t// assume that x/y are equal and symetric\r\n\t\ti = gEnt-\u003er.maxs[0];\r\n\t\tif (i\u003c1)\r\n\t\t\ti = 1;\r\n\t\tif (i\u003e255)\r\n\t\t\ti = 255;\r\n\r\n\t\t// z is not symetric\r\n\t\tj = (-gEnt-\u003er.mins[2]);\r\n\t\tif (j\u003c1)\r\n\t\t\tj = 1;\r\n\t\tif (j\u003e255)\r\n\t\t\tj = 255;\r\n\r\n\t\t// and z maxs can be negative...\r\n\t\tk = (gEnt-\u003er.maxs[2]+32);\r\n\t\tif (k\u003c1)\r\n\t\t\tk = 1;\r\n\t\tif (k\u003e255)\r\n\t\t\tk = 255;\r\n\r\n\t\tgEnt-\u003es.solid = (k\u003c\u003c16) | (j\u003c\u003c8) | i;\r\n\t} else {\r\n\t\tgEnt-\u003es.solid = 0;\r\n\t}\r\n\r\n\t// get the position\r\n\torigin = gEnt-\u003er.currentOrigin;\r\n\tangles = gEnt-\u003er.currentAngles;\r\n\r\n\t// set the abs box\r\n\tif ( gEnt-\u003er.bmodel \u0026\u0026 (angles[0] || angles[1] || angles[2]) ) {\r\n\t\t// expand for rotation\r\n\t\tfloat\t\tmax;\r\n\t\tint\t\t\ti;\r\n\r\n\t\tmax = RadiusFromBounds( gEnt-\u003er.mins, gEnt-\u003er.maxs );\r\n\t\tfor (i=0 ; i\u003c3 ; i++) {\r\n\t\t\tgEnt-\u003er.absmin[i] = origin[i] - max;\r\n\t\t\tgEnt-\u003er.absmax[i] = origin[i] + max;\r\n\t\t}\r\n\t} else {\r\n\t\t// normal\r\n\t\tVectorAdd (origin, gEnt-\u003er.mins, gEnt-\u003er.absmin);\t\r\n\t\tVectorAdd (origin, gEnt-\u003er.maxs, gEnt-\u003er.absmax);\r\n\t}\r\n\r\n\t// because movement is clipped an epsilon away from an actual edge,\r\n\t// we must fully check even when bounding boxes don't quite touch\r\n\tgEnt-\u003er.absmin[0] -= 1;\r\n\tgEnt-\u003er.absmin[1] -= 1;\r\n\tgEnt-\u003er.absmin[2] -= 1;\r\n\tgEnt-\u003er.absmax[0] += 1;\r\n\tgEnt-\u003er.absmax[1] += 1;\r\n\tgEnt-\u003er.absmax[2] += 1;\r\n\r\n\t// link to PVS leafs\r\n\tent-\u003enumClusters = 0;\r\n\tent-\u003elastCluster = 0;\r\n\tent-\u003eareanum = -1;\r\n\tent-\u003eareanum2 = -1;\r\n\r\n\t//get all leafs, including solids\r\n\tnum_leafs = CM_BoxLeafnums( gEnt-\u003er.absmin, gEnt-\u003er.absmax,\r\n\t\tleafs, MAX_TOTAL_ENT_LEAFS, \u0026lastLeaf );\r\n\r\n\t// if none of the leafs were inside the map, the\r\n\t// entity is outside the world and can be considered unlinked\r\n\tif ( !num_leafs ) {\r\n\t\treturn;\r\n\t}\r\n\r\n\t// set areas, even from clusters that don't fit in the entity array\r\n\tfor (i=0 ; i\u003cnum_leafs ; i++) {\r\n\t\tarea = CM_LeafArea (leafs[i]);\r\n\t\tif (area != -1) {\r\n\t\t\t// doors may legally straggle two areas,\r\n\t\t\t// but nothing should evern need more than that\r\n\t\t\tif (ent-\u003eareanum != -1 \u0026\u0026 ent-\u003eareanum != area) {\r\n\t\t\t\tif (ent-\u003eareanum2 != -1 \u0026\u0026 ent-\u003eareanum2 != area \u0026\u0026 sv.state == SS_LOADING) {\r\n\t\t\t\t\tCom_DPrintf (\"Object %i touching 3 areas at %f %f %f\\n\",\r\n\t\t\t\t\tgEnt-\u003es.number,\r\n\t\t\t\t\tgEnt-\u003er.absmin[0], gEnt-\u003er.absmin[1], gEnt-\u003er.absmin[2]);\r\n\t\t\t\t}\r\n\t\t\t\tent-\u003eareanum2 = area;\r\n\t\t\t} else {\r\n\t\t\t\tent-\u003eareanum = area;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// store as many explicit clusters as we can\r\n\tent-\u003enumClusters = 0;\r\n\tfor (i=0 ; i \u003c num_leafs ; i++) {\r\n\t\tcluster = CM_LeafCluster( leafs[i] );\r\n\t\tif ( cluster != -1 ) {\r\n\t\t\tent-\u003eclusternums[ent-\u003enumClusters++] = cluster;\r\n\t\t\tif ( ent-\u003enumClusters == MAX_ENT_CLUSTERS ) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// store off a last cluster if we need to\r\n\tif ( i != num_leafs ) {\r\n\t\tent-\u003elastCluster = CM_LeafCluster( lastLeaf );\r\n\t}\r\n\r\n\tgEnt-\u003er.linkcount++;\r\n\r\n\t// find the first world sector node that the ent's box crosses\r\n\tnode = sv_worldSectors;\r\n\twhile (1)\r\n\t{\r\n\t\tif (node-\u003eaxis == -1)\r\n\t\t\tbreak;\r\n\t\tif ( gEnt-\u003er.absmin[node-\u003eaxis] \u003e node-\u003edist)\r\n\t\t\tnode = node-\u003echildren[0];\r\n\t\telse if ( gEnt-\u003er.absmax[node-\u003eaxis] \u003c node-\u003edist)\r\n\t\t\tnode = node-\u003echildren[1];\r\n\t\telse\r\n\t\t\tbreak;\t\t// crosses the node\r\n\t}\r\n\t\r\n\t// link it in\r\n\tent-\u003eworldSector = node;\r\n\tent-\u003enextEntityInWorldSector = node-\u003eentities;\r\n\tnode-\u003eentities = ent;\r\n\r\n\tgEnt-\u003er.linked = qtrue;\r\n}\r\n\r\n/*\r\n============================================================================\r\n\r\nAREA QUERY\r\n\r\nFills in a list of all entities who's absmin / absmax intersects the given\r\nbounds.  This does NOT mean that they actually touch in the case of bmodels.\r\n============================================================================\r\n*/\r\n\r\ntypedef struct {\r\n\tconst float\t*mins;\r\n\tconst float\t*maxs;\r\n\tint\t\t\t*list;\r\n\tint\t\t\tcount, maxcount;\r\n} areaParms_t;\r\n\r\n\r\n/*\r\n====================\r\nSV_AreaEntities_r\r\n\r\n====================\r\n*/\r\nvoid SV_AreaEntities_r( worldSector_t *node, areaParms_t *ap ) {\r\n\tsvEntity_t\t*check, *next;\r\n\tsharedEntity_t *gcheck;\r\n\tint\t\t\tcount;\r\n\r\n\tcount = 0;\r\n\r\n\tfor ( check = node-\u003eentities  ; check ; check = next ) {\r\n\t\tnext = check-\u003enextEntityInWorldSector;\r\n\r\n\t\tgcheck = SV_GEntityForSvEntity( check );\r\n\r\n\t\tif ( gcheck-\u003er.absmin[0] \u003e ap-\u003emaxs[0]\r\n\t\t|| gcheck-\u003er.absmin[1] \u003e ap-\u003emaxs[1]\r\n\t\t|| gcheck-\u003er.absmin[2] \u003e ap-\u003emaxs[2]\r\n\t\t|| gcheck-\u003er.absmax[0] \u003c ap-\u003emins[0]\r\n\t\t|| gcheck-\u003er.absmax[1] \u003c ap-\u003emins[1]\r\n\t\t|| gcheck-\u003er.absmax[2] \u003c ap-\u003emins[2]) {\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tif ( ap-\u003ecount == ap-\u003emaxcount ) {\r\n\t\t\tCom_Printf (\"SV_AreaEntities: MAXCOUNT\\n\");\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tap-\u003elist[ap-\u003ecount] = check - sv.svEntities;\r\n\t\tap-\u003ecount++;\r\n\t}\r\n\t\r\n\tif (node-\u003eaxis == -1) {\r\n\t\treturn;\t\t// terminal node\r\n\t}\r\n\r\n\t// recurse down both sides\r\n\tif ( ap-\u003emaxs[node-\u003eaxis] \u003e node-\u003edist ) {\r\n\t\tSV_AreaEntities_r ( node-\u003echildren[0], ap );\r\n\t}\r\n\tif ( ap-\u003emins[node-\u003eaxis] \u003c node-\u003edist ) {\r\n\t\tSV_AreaEntities_r ( node-\u003echildren[1], ap );\r\n\t}\r\n}\r\n\r\n/*\r\n================\r\nSV_AreaEntities\r\n================\r\n*/\r\nint SV_AreaEntities( const vec3_t mins, const vec3_t maxs, int *entityList, int maxcount ) {\r\n\tareaParms_t\t\tap;\r\n\r\n\tap.mins = mins;\r\n\tap.maxs = maxs;\r\n\tap.list = entityList;\r\n\tap.count = 0;\r\n\tap.maxcount = maxcount;\r\n\r\n\tSV_AreaEntities_r( sv_worldSectors, \u0026ap );\r\n\r\n\treturn ap.count;\r\n}\r\n\r\n\r\n\r\n//===========================================================================\r\n\r\n\r\ntypedef struct {\r\n\tvec3_t\t\tboxmins, boxmaxs;// enclose the test object along entire move\r\n\tconst float\t*mins;\r\n\tconst float *maxs;\t// size of the moving object\r\n/*\r\nGhoul2 Insert Start\r\n*/\r\n\tvec3_t\t\tstart;\r\n\r\n\tvec3_t\t\tend;\r\n\r\n\tint\t\t\tpassEntityNum;\r\n\tint\t\t\tcontentmask;\r\n\tint\t\t\tcapsule;\r\n\r\n\tint\t\t\ttraceFlags;\r\n\tint\t\t\tuseLod;\r\n\ttrace_t\t\ttrace;\t\t\t// make sure nothing goes under here for Ghoul2 collision purposes\r\n/*\r\nGhoul2 Insert End\r\n*/\r\n} moveclip_t;\r\n\r\n\r\n/*\r\n====================\r\nSV_ClipToEntity\r\n\r\n====================\r\n*/\r\nvoid SV_ClipToEntity( trace_t *trace, const vec3_t start, const vec3_t mins, const vec3_t maxs, const vec3_t end, int entityNum, int contentmask, int capsule ) {\r\n\tsharedEntity_t\t*touch;\r\n\tclipHandle_t\tclipHandle;\r\n\tfloat\t\t\t*origin, *angles;\r\n\r\n\ttouch = SV_GentityNum( entityNum );\r\n\r\n\tCom_Memset(trace, 0, sizeof(trace_t));\r\n\r\n\t// if it doesn't have any brushes of a type we\r\n\t// are looking for, ignore it\r\n\tif ( ! ( contentmask \u0026 touch-\u003er.contents ) ) {\r\n\t\ttrace-\u003efraction = 1.0;\r\n\t\treturn;\r\n\t}\r\n\r\n\t// might intersect, so do an exact clip\r\n\tclipHandle = SV_ClipHandleForEntity (touch);\r\n\r\n\torigin = touch-\u003er.currentOrigin;\r\n\tangles = touch-\u003er.currentAngles;\r\n\r\n\tif ( !touch-\u003er.bmodel ) {\r\n\t\tangles = vec3_origin;\t// boxes don't rotate\r\n\t}\r\n\r\n\tCM_TransformedBoxTrace ( trace, (float *)start, (float *)end,\r\n\t\t(float *)mins, (float *)maxs, clipHandle,  contentmask,\r\n\t\torigin, angles, capsule);\r\n\r\n\tif ( trace-\u003efraction \u003c 1 ) {\r\n\t\ttrace-\u003eentityNum = touch-\u003es.number;\r\n\t}\r\n}\r\n\r\n\r\n/*\r\n====================\r\nSV_ClipMoveToEntities\r\n\r\n====================\r\n*/\r\nvoid SV_ClipMoveToEntities( moveclip_t *clip ) {\r\n\tint\t\t\ti, num;\r\n\tint\t\t\ttouchlist[MAX_GENTITIES];\r\n\tsharedEntity_t *touch;\r\n\tint\t\t\tpassOwnerNum;\r\n\ttrace_t\t\ttrace, oldTrace;\r\n\tclipHandle_t\tclipHandle;\r\n\tfloat\t\t*origin, *angles;\r\n\tint\t\t\tthisOwnerShared = 1;\r\n\r\n\tnum = SV_AreaEntities( clip-\u003eboxmins, clip-\u003eboxmaxs, touchlist, MAX_GENTITIES);\r\n\r\n\tif ( clip-\u003epassEntityNum != ENTITYNUM_NONE ) {\r\n\t\tpassOwnerNum = ( SV_GentityNum( clip-\u003epassEntityNum ) )-\u003er.ownerNum;\r\n\t\tif ( passOwnerNum == ENTITYNUM_NONE ) {\r\n\t\t\tpassOwnerNum = -1;\r\n\t\t}\r\n\t} else {\r\n\t\tpassOwnerNum = -1;\r\n\t}\r\n\r\n\tif ( SV_GentityNum(clip-\u003epassEntityNum)-\u003er.svFlags \u0026 SVF_OWNERNOTSHARED )\r\n\t{\r\n\t\tthisOwnerShared = 0;\r\n\t}\r\n\r\n\tfor ( i=0 ; i\u003cnum ; i++ ) {\r\n\t\tif ( clip-\u003etrace.allsolid ) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\ttouch = SV_GentityNum( touchlist[i] );\r\n\r\n\t\t// see if we should ignore this entity\r\n\t\tif ( clip-\u003epassEntityNum != ENTITYNUM_NONE ) {\r\n\t\t\tif ( touchlist[i] == clip-\u003epassEntityNum ) {\r\n\t\t\t\tcontinue;\t// don't clip against the pass entity\r\n\t\t\t}\r\n\t\t\tif ( touch-\u003er.ownerNum == clip-\u003epassEntityNum) {\r\n\t\t\t\tif (touch-\u003er.svFlags \u0026 SVF_OWNERNOTSHARED)\r\n\t\t\t\t{\r\n\t\t\t\t\tif ( clip-\u003econtentmask != (MASK_SHOT | CONTENTS_LIGHTSABER) \u0026\u0026\r\n\t\t\t\t\t\tclip-\u003econtentmask != (MASK_SHOT))\r\n\t\t\t\t\t{ //it's not a laser hitting the other \"missile\", don't care then\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tcontinue;\t// don't clip against own missiles\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif ( touch-\u003er.ownerNum == passOwnerNum \u0026\u0026\r\n\t\t\t\t!(touch-\u003er.svFlags \u0026 SVF_OWNERNOTSHARED) \u0026\u0026\r\n\t\t\t\t!thisOwnerShared ) {\r\n\t\t\t\tcontinue;\t// don't clip against other missiles from our owner\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// if it doesn't have any brushes of a type we\r\n\t\t// are looking for, ignore it\r\n\t\tif ( ! ( clip-\u003econtentmask \u0026 touch-\u003er.contents ) ) {\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tif ((clip-\u003econtentmask == (MASK_SHOT|CONTENTS_LIGHTSABER) || clip-\u003econtentmask == MASK_SHOT) \u0026\u0026 (touch-\u003er.contents \u003e 0 \u0026\u0026 (touch-\u003er.contents \u0026 CONTENTS_NOSHOT)))\r\n\t\t{\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\t// might intersect, so do an exact clip\r\n\t\tclipHandle = SV_ClipHandleForEntity (touch);\r\n\r\n\t\torigin = touch-\u003er.currentOrigin;\r\n\t\tangles = touch-\u003er.currentAngles;\r\n\r\n\r\n\t\tif ( !touch-\u003er.bmodel ) {\r\n\t\t\tangles = vec3_origin;\t// boxes don't rotate\r\n\t\t}\r\n\r\n\t\tCM_TransformedBoxTrace ( \u0026trace, (float *)clip-\u003estart, (float *)clip-\u003eend,\r\n\t\t\t(float *)clip-\u003emins, (float *)clip-\u003emaxs, clipHandle,  clip-\u003econtentmask,\r\n\t\t\torigin, angles, clip-\u003ecapsule);\r\n\r\n/*\r\nGhoul2 Insert Start\r\n*/\r\n\r\n\t\t// keep these older variables around for a bit, incase we need to replace them in the Ghoul2 Collision check\r\n\t\toldTrace = clip-\u003etrace;\r\n/*\r\nGhoul2 Insert End\r\n*/\r\n\r\n\t\tif ( trace.allsolid ) {\r\n\t\t\tclip-\u003etrace.allsolid = qtrue;\r\n\t\t\ttrace.entityNum = touch-\u003es.number;\r\n\t\t} else if ( trace.startsolid ) {\r\n\t\t\tclip-\u003etrace.startsolid = qtrue;\r\n\t\t\ttrace.entityNum = touch-\u003es.number;\r\n\t\t}\r\n\r\n\t\tif ( trace.fraction \u003c clip-\u003etrace.fraction ) {\r\n\t\t\tqboolean\toldStart;\r\n\r\n\t\t\t// make sure we keep a startsolid from a previous trace\r\n\t\t\toldStart = clip-\u003etrace.startsolid;\r\n\r\n\t\t\ttrace.entityNum = touch-\u003es.number;\r\n\t\t\tclip-\u003etrace = trace;\r\n\t\t\tclip-\u003etrace.startsolid = (qboolean)((unsigned)clip-\u003etrace.startsolid | (unsigned)oldStart);\r\n\t\t}\r\n/*\r\nGhoul2 Insert Start\r\n*/\r\n#if 0\r\n\t\t// decide if we should do the ghoul2 collision detection right here\r\n\t\tif ((trace.entityNum == touch-\u003es.number) \u0026\u0026 (clip-\u003etraceFlags))\r\n\t\t{\r\n\t\t\t// do we actually have a ghoul2 model here?\r\n\t\t\tif (touch-\u003es.ghoul2)\r\n\t\t\t{\r\n\t\t\t\tint\t\t\toldTraceRecSize = 0;\r\n\t\t\t\tint\t\t\tnewTraceRecSize = 0;\r\n\t\t\t\tint\t\t\tz;\r\n\r\n\t\t\t\t// we have to do this because sometimes you may hit a model's bounding box, but not actually penetrate the Ghoul2 Models polygons\r\n\t\t\t\t// this is, needless to say, not good. So we must check to see if we did actually hit the model, and if not, reset the trace stuff\r\n\t\t\t\t// to what it was to begin with\r\n\r\n\t\t\t\t// set our trace record size\r\n\t\t\t\tfor (z=0;z\u003cMAX_G2_COLLISIONS;z++)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (clip-\u003etrace.G2CollisionMap[z].mEntityNum != -1)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\toldTraceRecSize++;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tG2API_CollisionDetect(\u0026clip-\u003etrace.G2CollisionMap[0], *((CGhoul2Info_v *)touch-\u003es.ghoul2),\r\n\t\t\t\t\ttouch-\u003es.angles, touch-\u003es.origin, svs.time, touch-\u003es.number, clip-\u003estart, clip-\u003eend, touch-\u003es.modelScale, G2VertSpaceServer, clip-\u003etraceFlags, clip-\u003euseLod);\r\n\r\n\t\t\t\t// set our new trace record size\r\n \r\n\t\t\t\tfor (z=0;z\u003cMAX_G2_COLLISIONS;z++)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (clip-\u003etrace.G2CollisionMap[z].mEntityNum != -1)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tnewTraceRecSize++;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// did we actually touch this model? If not, lets reset this ent as being hit..\r\n\t\t\t\tif (newTraceRecSize == oldTraceRecSize)\r\n\t\t\t\t{\r\n\t\t\t\t\tclip-\u003etrace = oldTrace;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n#endif\r\n/*\r\nGhoul2 Insert End\r\n*/\r\n\t}\r\n}\r\n\r\n\r\n/*\r\n==================\r\nSV_Trace\r\n\r\nMoves the given mins/maxs volume through the world from start to end.\r\npassEntityNum and entities owned by passEntityNum are explicitly not checked.\r\n==================\r\n*/\r\n/*\r\nGhoul2 Insert Start\r\n*/\r\nvoid SV_Trace( trace_t *results, const vec3_t start, const vec3_t mins, const vec3_t maxs, const vec3_t end, int passEntityNum, int contentmask, int capsule, int traceFlags, int useLod ) {\r\n/*\r\nGhoul2 Insert End\r\n*/\r\n\tmoveclip_t\tclip;\r\n\tint\t\t\ti;\r\n\r\n\tif ( !mins ) {\r\n\t\tmins = vec3_origin;\r\n\t}\r\n\tif ( !maxs ) {\r\n\t\tmaxs = vec3_origin;\r\n\t}\r\n\r\n\tCom_Memset ( \u0026clip, 0, sizeof ( moveclip_t ) );\r\n\r\n\t// clip to world\r\n\tCM_BoxTrace( \u0026clip.trace, start, end, mins, maxs, 0, contentmask, capsule );\r\n\tclip.trace.entityNum = clip.trace.fraction != 1.0 ? ENTITYNUM_WORLD : ENTITYNUM_NONE;\r\n\tif ( clip.trace.fraction == 0 ) {\r\n\t\t*results = clip.trace;\r\n\t\treturn;\t\t// blocked immediately by the world\r\n\t}\r\n\r\n\tclip.contentmask = contentmask;\r\n/*\r\nGhoul2 Insert Start\r\n*/\t\r\n\tVectorCopy( start, clip.start );\r\n\tclip.traceFlags = traceFlags;\r\n\tclip.useLod = useLod;\r\n/*\r\nGhoul2 Insert End\r\n*/\r\n//\tVectorCopy( clip.trace.endpos, clip.end );\r\n\tVectorCopy( end, clip.end );\r\n\tclip.mins = mins;\r\n\tclip.maxs = maxs;\r\n\tclip.passEntityNum = passEntityNum;\r\n\tclip.capsule = capsule;\r\n\r\n\t// create the bounding box of the entire move\r\n\t// we can limit it to the part of the move not\r\n\t// already clipped off by the world, which can be\r\n\t// a significant savings for line of sight and shot traces\r\n\tfor ( i=0 ; i\u003c3 ; i++ ) {\r\n\t\tif ( end[i] \u003e start[i] ) {\r\n\t\t\tclip.boxmins[i] = clip.start[i] + clip.mins[i] - 1;\r\n\t\t\tclip.boxmaxs[i] = clip.end[i] + clip.maxs[i] + 1;\r\n\t\t} else {\r\n\t\t\tclip.boxmins[i] = clip.end[i] + clip.mins[i] - 1;\r\n\t\t\tclip.boxmaxs[i] = clip.start[i] + clip.maxs[i] + 1;\r\n\t\t}\r\n\t}\r\n\r\n\t// clip to other solid entities\r\n\tSV_ClipMoveToEntities ( \u0026clip );\r\n\r\n\t*results = clip.trace;\r\n}\r\n\r\n\r\n\r\n/*\r\n=============\r\nSV_PointContents\r\n=============\r\n*/\r\nint SV_PointContents( const vec3_t p, int passEntityNum ) {\r\n\tint\t\t\ttouch[MAX_GENTITIES];\r\n\tsharedEntity_t *hit;\r\n\tint\t\t\ti, num;\r\n\tint\t\t\tcontents, c2;\r\n\tclipHandle_t\tclipHandle;\r\n\tfloat\t\t*angles;\r\n\r\n\t// get base contents from world\r\n\tcontents = CM_PointContents( p, 0 );\r\n\r\n\t// or in contents from all the other entities\r\n\tnum = SV_AreaEntities( p, p, touch, MAX_GENTITIES );\r\n\r\n\tfor ( i=0 ; i\u003cnum ; i++ ) {\r\n\t\tif ( touch[i] == passEntityNum ) {\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\thit = SV_GentityNum( touch[i] );\r\n\t\t// might intersect, so do an exact clip\r\n\t\tclipHandle = SV_ClipHandleForEntity( hit );\r\n\t\tangles = hit-\u003es.angles;\r\n\t\tif ( !hit-\u003er.bmodel ) {\r\n\t\t\tangles = vec3_origin;\t// boxes don't rotate\r\n\t\t}\r\n\r\n\t\tc2 = CM_TransformedPointContents (p, clipHandle, hit-\u003es.origin, hit-\u003es.angles);\r\n\r\n\t\tcontents |= c2;\r\n\t}\r\n\r\n\treturn contents;\r\n}\r\n\r\n\r\n"}
{"repo_name":"Poxleit/s-core","ref":"refs/heads/master","path":"src/scriptdev2/scripts/eastern_kingdoms/shadowfang_keep/instance_shadowfang_keep.cpp","copies":"27","language":"C++","content":"/* This file is part of the ScriptDev2 Project. See AUTHORS file for Copyright information\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n/* ScriptData\nSDName: Instance_Shadowfang_Keep\nSD%Complete: 90\nSDComment:\nSDCategory: Shadowfang Keep\nEndScriptData */\n\n#include \"precompiled.h\"\n#include \"shadowfang_keep.h\"\n\ninstance_shadowfang_keep::instance_shadowfang_keep(Map* pMap) : ScriptedInstance(pMap)\n{\n    Initialize();\n}\n\nvoid instance_shadowfang_keep::Initialize()\n{\n    memset(\u0026m_auiEncounter, 0, sizeof(m_auiEncounter));\n}\n\nvoid instance_shadowfang_keep::OnCreatureCreate(Creature* pCreature)\n{\n    switch (pCreature-\u003eGetEntry())\n    {\n        case NPC_ASH:\n        case NPC_ADA:\n        case NPC_FENRUS:\n            break;\n        case NPC_VINCENT:\n            // If Arugal has done the intro, make Vincent dead!\n            if (m_auiEncounter[4] == DONE)\n                pCreature-\u003eSetStandState(UNIT_STAND_STATE_DEAD);\n            break;\n\n        default:\n            return;\n    }\n    m_mNpcEntryGuidStore[pCreature-\u003eGetEntry()] = pCreature-\u003eGetObjectGuid();\n}\n\nvoid instance_shadowfang_keep::OnObjectCreate(GameObject* pGo)\n{\n    switch (pGo-\u003eGetEntry())\n    {\n        case GO_COURTYARD_DOOR:\n            if (m_auiEncounter[0] == DONE)\n                pGo-\u003eSetGoState(GO_STATE_ACTIVE);\n            break;\n            // For this we ignore voidwalkers, because if the server restarts\n            // They won't be there, but Fenrus is dead so the door can't be opened!\n        case GO_SORCERER_DOOR:\n            if (m_auiEncounter[2] == DONE)\n                pGo-\u003eSetGoState(GO_STATE_ACTIVE);\n            break;\n        case GO_ARUGAL_DOOR:\n            if (m_auiEncounter[3] == DONE)\n                pGo-\u003eSetGoState(GO_STATE_ACTIVE);\n            break;\n        case GO_ARUGAL_FOCUS:\n            break;\n\n        default:\n            return;\n    }\n    m_mGoEntryGuidStore[pGo-\u003eGetEntry()] = pGo-\u003eGetObjectGuid();\n}\n\nvoid instance_shadowfang_keep::DoSpeech()\n{\n    Creature* pAda = GetSingleCreatureFromStorage(NPC_ADA);\n    Creature* pAsh = GetSingleCreatureFromStorage(NPC_ASH);\n\n    if (pAda \u0026\u0026 pAda-\u003eisAlive() \u0026\u0026 pAsh \u0026\u0026 pAsh-\u003eisAlive())\n    {\n        DoScriptText(SAY_BOSS_DIE_AD, pAda);\n        DoScriptText(SAY_BOSS_DIE_AS, pAsh);\n    }\n}\n\nvoid instance_shadowfang_keep::SetData(uint32 uiType, uint32 uiData)\n{\n    switch (uiType)\n    {\n        case TYPE_FREE_NPC:\n            if (uiData == DONE)\n                DoUseDoorOrButton(GO_COURTYARD_DOOR);\n            m_auiEncounter[0] = uiData;\n            break;\n        case TYPE_RETHILGORE:\n            if (uiData == DONE)\n                DoSpeech();\n            m_auiEncounter[1] = uiData;\n            break;\n        case TYPE_FENRUS:\n            if (uiData == DONE)\n            {\n                if (Creature* pFenrus = GetSingleCreatureFromStorage(NPC_FENRUS))\n                    pFenrus-\u003eSummonCreature(NPC_ARCHMAGE_ARUGAL, -136.89f, 2169.17f, 136.58f, 2.794f, TEMPSUMMON_TIMED_DESPAWN, 30000);\n            }\n            m_auiEncounter[2] = uiData;\n            break;\n        case TYPE_NANDOS:\n            if (uiData == DONE)\n                DoUseDoorOrButton(GO_ARUGAL_DOOR);\n            m_auiEncounter[3] = uiData;\n            break;\n        case TYPE_INTRO:\n            m_auiEncounter[4] = uiData;\n            break;\n        case TYPE_VOIDWALKER:\n            if (uiData == DONE)\n            {\n                m_auiEncounter[5]++;\n                if (m_auiEncounter[5] \u003e 3)\n                    DoUseDoorOrButton(GO_SORCERER_DOOR);\n            }\n            break;\n    }\n\n    if (uiData == DONE)\n    {\n        OUT_SAVE_INST_DATA;\n\n        std::ostringstream saveStream;\n        saveStream \u003c\u003c m_auiEncounter[0] \u003c\u003c \" \" \u003c\u003c m_auiEncounter[1] \u003c\u003c \" \" \u003c\u003c m_auiEncounter[2] \u003c\u003c \" \" \u003c\u003c m_auiEncounter[3]\n                   \u003c\u003c \" \" \u003c\u003c m_auiEncounter[4] \u003c\u003c \" \" \u003c\u003c m_auiEncounter[5];\n\n        m_strInstData = saveStream.str();\n\n        SaveToDB();\n        OUT_SAVE_INST_DATA_COMPLETE;\n    }\n}\n\nuint32 instance_shadowfang_keep::GetData(uint32 uiType) const\n{\n    switch (uiType)\n    {\n        case TYPE_FREE_NPC:   return m_auiEncounter[0];\n        case TYPE_RETHILGORE: return m_auiEncounter[1];\n        case TYPE_FENRUS:     return m_auiEncounter[2];\n        case TYPE_NANDOS:     return m_auiEncounter[3];\n        case TYPE_INTRO:      return m_auiEncounter[4];\n\n        default:\n            return 0;\n    }\n}\n\nvoid instance_shadowfang_keep::Load(const char* chrIn)\n{\n    if (!chrIn)\n    {\n        OUT_LOAD_INST_DATA_FAIL;\n        return;\n    }\n\n    OUT_LOAD_INST_DATA(chrIn);\n\n    std::istringstream loadStream(chrIn);\n    loadStream \u003e\u003e m_auiEncounter[0] \u003e\u003e m_auiEncounter[1] \u003e\u003e m_auiEncounter[2] \u003e\u003e m_auiEncounter[3]\n               \u003e\u003e m_auiEncounter[4] \u003e\u003e m_auiEncounter[5];\n\n    for (uint8 i = 0; i \u003c MAX_ENCOUNTER; ++i)\n    {\n        if (m_auiEncounter[i] == IN_PROGRESS)\n            m_auiEncounter[i] = NOT_STARTED;\n    }\n\n    OUT_LOAD_INST_DATA_COMPLETE;\n}\n\nInstanceData* GetInstanceData_instance_shadowfang_keep(Map* pMap)\n{\n    return new instance_shadowfang_keep(pMap);\n}\n\nvoid AddSC_instance_shadowfang_keep()\n{\n    Script* pNewScript;\n\n    pNewScript = new Script;\n    pNewScript-\u003eName = \"instance_shadowfang_keep\";\n    pNewScript-\u003eGetInstanceData = \u0026GetInstanceData_instance_shadowfang_keep;\n    pNewScript-\u003eRegisterSelf();\n}\n"}
{"repo_name":"slitvinov/lammps-sph-multiphase","ref":"refs/heads/surface_tension_clean","path":"src/ASPHERE/compute_temp_asphere.cpp","copies":"8","language":"C++","content":"/* ----------------------------------------------------------------------\n   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator\n   http://lammps.sandia.gov, Sandia National Laboratories\n   Steve Plimpton, sjplimp@sandia.gov\n\n   Copyright (2003) Sandia Corporation.  Under the terms of Contract\n   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains\n   certain rights in this software.  This software is distributed under\n   the GNU General Public License.\n\n   See the README file in the top-level LAMMPS directory.\n------------------------------------------------------------------------- */\n\n/* ----------------------------------------------------------------------\n   Contributing author: Mike Brown (SNL)\n------------------------------------------------------------------------- */\n\n#include \"mpi.h\"\n#include \"string.h\"\n#include \"compute_temp_asphere.h\"\n#include \"math_extra.h\"\n#include \"atom.h\"\n#include \"atom_vec_ellipsoid.h\"\n#include \"update.h\"\n#include \"force.h\"\n#include \"domain.h\"\n#include \"modify.h\"\n#include \"group.h\"\n#include \"memory.h\"\n#include \"error.h\"\n\nusing namespace LAMMPS_NS;\n\nenum{ROTATE,ALL};\n\n#define INERTIA 0.2          // moment of inertia prefactor for ellipsoid\n\n/* ---------------------------------------------------------------------- */\n\nComputeTempAsphere::ComputeTempAsphere(LAMMPS *lmp, int narg, char **arg) :\n  Compute(lmp, narg, arg)\n{\n  if (narg \u003c 3) error-\u003eall(FLERR,\"Illegal compute temp/asphere command\");\n\n  scalar_flag = vector_flag = 1;\n  size_vector = 6;\n  extscalar = 0;\n  extvector = 1;\n  tempflag = 1;\n\n  tempbias = 0;\n  id_bias = NULL;\n  mode = ALL;\n\n  int iarg = 3;\n  while (iarg \u003c narg) {\n    if (strcmp(arg[iarg],\"bias\") == 0) {\n      if (iarg+2 \u003e narg) \n        error-\u003eall(FLERR,\"Illegal compute temp/asphere command\");\n      tempbias = 1;\n      int n = strlen(arg[iarg+1]) + 1;\n      id_bias = new char[n];\n      strcpy(id_bias,arg[iarg+1]);\n      iarg += 2;\n    } else if (strcmp(arg[iarg],\"dof\") == 0) {\n      if (iarg+2 \u003e narg) \n        error-\u003eall(FLERR,\"Illegal compute temp/asphere command\");\n      if (strcmp(arg[iarg+1],\"rotate\") == 0) mode = ROTATE;\n      else if (strcmp(arg[iarg+1],\"all\") == 0) mode = ALL;\n      else error-\u003eall(FLERR,\"Illegal compute temp/asphere command\");\n      iarg += 2;\n    } else error-\u003eall(FLERR,\"Illegal compute temp/asphere command\");\n  }\n\n  vector = new double[6];\n\n}\n\n/* ---------------------------------------------------------------------- */\n\nComputeTempAsphere::~ComputeTempAsphere()\n{\n  delete [] id_bias;\n  delete [] vector;\n}\n\n/* ---------------------------------------------------------------------- */\n\nvoid ComputeTempAsphere::init()\n{\n  // error check\n\n  avec = (AtomVecEllipsoid *) atom-\u003estyle_match(\"ellipsoid\");\n  if (!avec)\n    error-\u003eall(FLERR,\"Compute temp/asphere requires atom style ellipsoid\");\n\n  // check that all particles are finite-size, no point particles allowed\n\n  int *ellipsoid = atom-\u003eellipsoid;\n  int *mask = atom-\u003emask;\n  int nlocal = atom-\u003enlocal;\n\n  for (int i = 0; i \u003c nlocal; i++)\n    if (mask[i] \u0026 groupbit)\n      if (ellipsoid[i] \u003c 0)\n        error-\u003eone(FLERR,\"Compute temp/asphere requires extended particles\");\n\n  if (tempbias) {\n    int i = modify-\u003efind_compute(id_bias);\n    if (i \u003c 0) \n      error-\u003eall(FLERR,\"Could not find compute ID for temperature bias\");\n    tbias = modify-\u003ecompute[i];\n    if (tbias-\u003etempflag == 0)\n      error-\u003eall(FLERR,\"Bias compute does not calculate temperature\");\n    if (tbias-\u003etempbias == 0)\n      error-\u003eall(FLERR,\"Bias compute does not calculate a velocity bias\");\n    if (tbias-\u003eigroup != igroup)\n      error-\u003eall(FLERR,\"Bias compute group does not match compute group\");\n    tbias-\u003einit();\n    tbias-\u003esetup();\n    if (strcmp(tbias-\u003estyle,\"temp/region\") == 0) tempbias = 2;\n    else tempbias = 1;\n  }\n}\n\n/* ---------------------------------------------------------------------- */\n\nvoid ComputeTempAsphere::setup()\n{\n  fix_dof = -1;\n  dof_compute();\n}\n\n/* ---------------------------------------------------------------------- */\n\nvoid ComputeTempAsphere::dof_compute()\n{\n  if (fix_dof) adjust_dof_fix();\n\n  // 6 dof for 3d, 3 dof for 2d\n  // which dof are included also depends on mode\n  // assume full rotation of extended particles\n  // user should correct this via compute_modify if needed\n\n  double natoms = group-\u003ecount(igroup);\n  int nper;\n  if (domain-\u003edimension == 3) {\n    if (mode == ALL) nper = 6;\n    else nper = 3;\n  } else {\n    if (mode == ALL) nper = 3;\n    else nper = 1;\n  }\n  dof = nper*natoms;\n\n  // additional adjustments to dof\n\n  if (tempbias == 1) {\n    if (mode == ALL) dof -= tbias-\u003edof_remove(-1) * natoms;\n\n  } else if (tempbias == 2) {\n    int *mask = atom-\u003emask;\n    int nlocal = atom-\u003enlocal;\n\n    tbias-\u003edof_remove_pre();\n\n    int count = 0;\n    for (int i = 0; i \u003c nlocal; i++)\n      if (mask[i] \u0026 groupbit)\n        if (tbias-\u003edof_remove(i)) count++;\n    int count_all;\n    MPI_Allreduce(\u0026count,\u0026count_all,1,MPI_INT,MPI_SUM,world);\n    dof -= nper*count_all;\n  }\n\n  dof -= extra_dof + fix_dof;\n  if (dof \u003e 0) tfactor = force-\u003emvv2e / (dof * force-\u003eboltz);\n  else tfactor = 0.0;\n}\n\n/* ---------------------------------------------------------------------- */\n\ndouble ComputeTempAsphere::compute_scalar()\n{\n  invoked_scalar = update-\u003entimestep;\n\n  if (tempbias) {\n    if (tbias-\u003einvoked_scalar != update-\u003entimestep) tbias-\u003ecompute_scalar();\n    tbias-\u003eremove_bias_all();\n  }\n\n  AtomVecEllipsoid::Bonus *bonus = avec-\u003ebonus;\n  double **v = atom-\u003ev;\n  double **angmom = atom-\u003eangmom;\n  double *rmass = atom-\u003ermass;\n  int *ellipsoid = atom-\u003eellipsoid;\n  int *mask = atom-\u003emask;\n  int nlocal = atom-\u003enlocal;\n\n  double *shape,*quat;\n  double wbody[3],inertia[3];\n  double rot[3][3];\n\n  // sum translational and rotational energy for each particle\n  // no point particles since divide by inertia\n\n  double t = 0.0;\n\n  if (mode == ALL) {\n    for (int i = 0; i \u003c nlocal; i++)\n      if (mask[i] \u0026 groupbit) {\n        t += (v[i][0]*v[i][0] + v[i][1]*v[i][1] + v[i][2]*v[i][2]) * rmass[i];\n\n        // principal moments of inertia\n\n        shape = bonus[ellipsoid[i]].shape;\n        quat = bonus[ellipsoid[i]].quat;\n\n        inertia[0] = INERTIA*rmass[i] * (shape[1]*shape[1]+shape[2]*shape[2]);\n        inertia[1] = INERTIA*rmass[i] * (shape[0]*shape[0]+shape[2]*shape[2]);\n        inertia[2] = INERTIA*rmass[i] * (shape[0]*shape[0]+shape[1]*shape[1]);\n\n        // wbody = angular velocity in body frame\n\n        MathExtra::quat_to_mat(quat,rot);\n        MathExtra::transpose_matvec(rot,angmom[i],wbody);\n        wbody[0] /= inertia[0];\n        wbody[1] /= inertia[1];\n        wbody[2] /= inertia[2];\n\n        t += inertia[0]*wbody[0]*wbody[0] +\n          inertia[1]*wbody[1]*wbody[1] + inertia[2]*wbody[2]*wbody[2];\n      }\n\n  } else {\n    for (int i = 0; i \u003c nlocal; i++)\n      if (mask[i] \u0026 groupbit) {\n\n        // principal moments of inertia\n\n        shape = bonus[ellipsoid[i]].shape;\n        quat = bonus[ellipsoid[i]].quat;\n\n        inertia[0] = INERTIA*rmass[i] * (shape[1]*shape[1]+shape[2]*shape[2]);\n        inertia[1] = INERTIA*rmass[i] * (shape[0]*shape[0]+shape[2]*shape[2]);\n        inertia[2] = INERTIA*rmass[i] * (shape[0]*shape[0]+shape[1]*shape[1]);\n\n        // wbody = angular velocity in body frame\n\n        MathExtra::quat_to_mat(quat,rot);\n        MathExtra::transpose_matvec(rot,angmom[i],wbody);\n        wbody[0] /= inertia[0];\n        wbody[1] /= inertia[1];\n        wbody[2] /= inertia[2];\n\n        t += inertia[0]*wbody[0]*wbody[0] +\n          inertia[1]*wbody[1]*wbody[1] + inertia[2]*wbody[2]*wbody[2];\n      }\n  }\n\n  if (tempbias) tbias-\u003erestore_bias_all();\n\n  MPI_Allreduce(\u0026t,\u0026scalar,1,MPI_DOUBLE,MPI_SUM,world);\n  if (dynamic || tempbias == 2) dof_compute();\n  scalar *= tfactor;\n  return scalar;\n}\n\n/* ---------------------------------------------------------------------- */\n\nvoid ComputeTempAsphere::compute_vector()\n{\n  int i;\n\n  invoked_vector = update-\u003entimestep;\n\n  if (tempbias) {\n    if (tbias-\u003einvoked_vector != update-\u003entimestep) tbias-\u003ecompute_vector();\n    tbias-\u003eremove_bias_all();\n  }\n\n  AtomVecEllipsoid::Bonus *bonus = avec-\u003ebonus;\n  double **v = atom-\u003ev;\n  double **angmom = atom-\u003eangmom;\n  double *rmass = atom-\u003ermass;\n  int *ellipsoid = atom-\u003eellipsoid;\n  int *mask = atom-\u003emask;\n  int nlocal = atom-\u003enlocal;\n\n  double *shape,*quat;\n  double wbody[3],inertia[3],t[6];\n  double rot[3][3];\n  double massone;\n\n  // sum translational and rotational energy for each particle\n  // no point particles since divide by inertia\n\n  for (i = 0; i \u003c 6; i++) t[i] = 0.0;\n\n  if (mode == ALL) {\n    for (i = 0; i \u003c nlocal; i++)\n      if (mask[i] \u0026 groupbit) {\n        massone = rmass[i];\n        t[0] += massone * v[i][0]*v[i][0];\n        t[1] += massone * v[i][1]*v[i][1];\n        t[2] += massone * v[i][2]*v[i][2];\n        t[3] += massone * v[i][0]*v[i][1];\n        t[4] += massone * v[i][0]*v[i][2];\n        t[5] += massone * v[i][1]*v[i][2];\n\n        // principal moments of inertia\n\n        shape = bonus[ellipsoid[i]].shape;\n        quat = bonus[ellipsoid[i]].quat;\n\n        inertia[0] = INERTIA*massone * (shape[1]*shape[1]+shape[2]*shape[2]);\n        inertia[1] = INERTIA*massone * (shape[0]*shape[0]+shape[2]*shape[2]);\n        inertia[2] = INERTIA*massone * (shape[0]*shape[0]+shape[1]*shape[1]);\n\n        // wbody = angular velocity in body frame\n\n        MathExtra::quat_to_mat(quat,rot);\n        MathExtra::transpose_matvec(rot,angmom[i],wbody);\n        wbody[0] /= inertia[0];\n        wbody[1] /= inertia[1];\n        wbody[2] /= inertia[2];\n\n        // rotational kinetic energy\n\n        t[0] += inertia[0]*wbody[0]*wbody[0];\n        t[1] += inertia[1]*wbody[1]*wbody[1];\n        t[2] += inertia[2]*wbody[2]*wbody[2];\n        t[3] += inertia[0]*wbody[0]*wbody[1];\n        t[4] += inertia[1]*wbody[0]*wbody[2];\n        t[5] += inertia[2]*wbody[1]*wbody[2];\n      }\n\n  } else {\n    for (i = 0; i \u003c nlocal; i++)\n      if (mask[i] \u0026 groupbit) {\n\n        // principal moments of inertia\n\n        shape = bonus[ellipsoid[i]].shape;\n        quat = bonus[ellipsoid[i]].quat;\n        massone = rmass[i];\n\n        inertia[0] = INERTIA*massone * (shape[1]*shape[1]+shape[2]*shape[2]);\n        inertia[1] = INERTIA*massone * (shape[0]*shape[0]+shape[2]*shape[2]);\n        inertia[2] = INERTIA*massone * (shape[0]*shape[0]+shape[1]*shape[1]);\n\n        // wbody = angular velocity in body frame\n\n        MathExtra::quat_to_mat(quat,rot);\n        MathExtra::transpose_matvec(rot,angmom[i],wbody);\n        wbody[0] /= inertia[0];\n        wbody[1] /= inertia[1];\n        wbody[2] /= inertia[2];\n\n        // rotational kinetic energy\n\n        t[0] += inertia[0]*wbody[0]*wbody[0];\n        t[1] += inertia[1]*wbody[1]*wbody[1];\n        t[2] += inertia[2]*wbody[2]*wbody[2];\n        t[3] += inertia[0]*wbody[0]*wbody[1];\n        t[4] += inertia[1]*wbody[0]*wbody[2];\n        t[5] += inertia[2]*wbody[1]*wbody[2];\n      }\n  }\n\n  if (tempbias) tbias-\u003erestore_bias_all();\n\n  MPI_Allreduce(t,vector,6,MPI_DOUBLE,MPI_SUM,world);\n  for (i = 0; i \u003c 6; i++) vector[i] *= force-\u003emvv2e;\n}\n\n/* ----------------------------------------------------------------------\n   remove velocity bias from atom I to leave thermal velocity\n------------------------------------------------------------------------- */\n\nvoid ComputeTempAsphere::remove_bias(int i, double *v)\n{\n  if (tbias) tbias-\u003eremove_bias(i,v);\n}\n\n/* ----------------------------------------------------------------------\n   add back in velocity bias to atom I removed by remove_bias()\n   assume remove_bias() was previously called\n------------------------------------------------------------------------- */\n\nvoid ComputeTempAsphere::restore_bias(int i, double *v)\n{\n  if (tbias) tbias-\u003erestore_bias(i,v);\n}\n"}
{"repo_name":"biojppm/c4stl","ref":"refs/heads/master","path":"bm/list/push_back/flat_fwd_list__paged__NumBytes_64___int32_t.cpp","copies":"1","language":"C++","content":"#include \"benchmark/benchmark.h\"\n\n#include \"c4/log.hpp\"\n#include \"c4/allocator.hpp\"\n#include \"../list_types.hpp\"\n\nnamespace bm = benchmark;\n\nnamespace c4 {\n\ntemplate\u003c class List \u003e\nvoid BM_ListPushBack(bm::State\u0026 st)\n{\n    List li;\n    using T = typename List::value_type;\n    T v{};\n    size_t count = 0;\n    while(st.KeepRunning())\n    {\n        for(int i = 0, e = st.range(0); i \u003c e; ++i)\n        {\n            if(li.size() == li.max_size()) li.clear();\n            li.push_back(v);\n            ++count;\n        }\n        li.clear();\n    }\n    st.SetComplexityN(st.range(0));\n    st.SetItemsProcessed(count);\n    st.SetBytesProcessed(count * sizeof(T));\n}\n\nBENCHMARK_TEMPLATE(BM_ListPushBack, flat_fwd_list__paged\u003c NumBytes\u003c64\u003e C4_COMMA  int32_t \u003e)\n    -\u003eRangeMultiplier(2)\n    -\u003eRange(4, 1\u003c\u003c19)\n    -\u003eComplexity();\n\n} // end namespace c4\n\nBENCHMARK_MAIN()"}
{"repo_name":"einon/affymetrix-power-tools","ref":"refs/heads/master","path":"sdk/calvin_files/parameter/test/ParameterFileDataTest.cpp","copies":"1","language":"C++","content":"////////////////////////////////////////////////////////////////\n//\n// Copyright (C) 2005 Affymetrix, Inc.\n//\n// This library is free software; you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License \n// (version 2.1) as published by the Free Software Foundation.\n// \n// This library is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n// or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License\n// for more details.\n// \n// You should have received a copy of the GNU Lesser General Public License\n// along with this library; if not, write to the Free Software Foundation, Inc.,\n// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA \n//\n////////////////////////////////////////////////////////////////\n#include \"calvin_files/parameter/src/ParameterFileData.h\"\n//\n#include \u003ccppunit/extensions/HelperMacros.h\u003e\n//\n\nusing namespace affymetrix_calvin_parameter;\n\nclass ParameterFileDataTest : public CPPUNIT_NS::TestFixture  \n{\n\tCPPUNIT_TEST_SUITE (ParameterFileDataTest);\n\n\tCPPUNIT_TEST (testAccess);\n\n\tCPPUNIT_TEST_SUITE_END();\npublic:\n\tvoid setUp();\n\tvoid tearDown();\n\n    void testAccess();\n};\n\n\nCPPUNIT_TEST_SUITE_REGISTRATION( ParameterFileDataTest );\n\nvoid ParameterFileDataTest::setUp()\n{\n}\n\nvoid ParameterFileDataTest::tearDown()\n{\n}\n\nvoid ParameterFileDataTest::testAccess()\n{\n\tParameterFileData d;\n\n    d.ImplementationAttributes().description = L\"d\";\n    d.ImplementationAttributes().executableFileName = L\"e\";\n    d.ImplementationAttributes().name = L\"n\";\n    d.ImplementationAttributes().version = L\"v\";\n\n    CPPUNIT_ASSERT(d.ImplementationAttributes().description == L\"d\");\n    CPPUNIT_ASSERT(d.ImplementationAttributes().executableFileName == L\"e\");\n    CPPUNIT_ASSERT(d.ImplementationAttributes().name == L\"n\");\n    CPPUNIT_ASSERT(d.ImplementationAttributes().version == L\"v\");\n\n    d.ParameterFileAttributes().company = L\"c\";\n    d.ParameterFileAttributes().userName = L\"u\";\n    d.ParameterFileAttributes().contentVersion = L\"cv\";\n\n    CPPUNIT_ASSERT(d.ParameterFileAttributes().company == L\"c\");\n    CPPUNIT_ASSERT(d.ParameterFileAttributes().userName == L\"u\");\n    CPPUNIT_ASSERT(d.ParameterFileAttributes().contentVersion == L\"cv\");\n\n    ParameterType p;\n\n    p.name = L\"n\";\n    p.index = L\"i\";\n    p.displayName = L\"d\";\n    p.category = L\"c\";\n    p.isEditable = L\"is\";\n    p.type = L\"t\";\n    p.currentValue = L\"cv\";\n    p.minValue = L\"mv\";\n    p.maxValue = L\"xv\";\n    p.defaultValue = L\"dv\";\n    p.precision = L\"p\";\n    p.maxLength = L\"l\";\n    p.description = L\"de\";\n\n    CPPUNIT_ASSERT(p.name == L\"n\");\n    CPPUNIT_ASSERT(p.index == L\"i\");\n    CPPUNIT_ASSERT(p.displayName == L\"d\");\n    CPPUNIT_ASSERT(p.category == L\"c\");\n    CPPUNIT_ASSERT(p.isEditable == L\"is\");\n    CPPUNIT_ASSERT(p.type == L\"t\");\n    CPPUNIT_ASSERT(p.currentValue == L\"cv\");\n    CPPUNIT_ASSERT(p.minValue == L\"mv\");\n    CPPUNIT_ASSERT(p.maxValue == L\"xv\");\n    CPPUNIT_ASSERT(p.defaultValue == L\"dv\");\n    CPPUNIT_ASSERT(p.precision == L\"p\");\n    CPPUNIT_ASSERT(p.maxLength == L\"l\");\n    CPPUNIT_ASSERT(p.description == L\"de\");\n\n    d.Parameters().push_back(p);\n\n    p.name.clear();\n    p.index.clear();\n\n    CPPUNIT_ASSERT(d.Parameters().size() == 1);\n\n    d.Clear();\n\n    CPPUNIT_ASSERT(d.ImplementationAttributes().description == L\"\");\n    CPPUNIT_ASSERT(d.ImplementationAttributes().executableFileName == L\"\");\n    CPPUNIT_ASSERT(d.ImplementationAttributes().name == L\"\");\n    CPPUNIT_ASSERT(d.ImplementationAttributes().version == L\"\");\n\n    CPPUNIT_ASSERT(d.ParameterFileAttributes().company == L\"\");\n    CPPUNIT_ASSERT(d.ParameterFileAttributes().userName == L\"\");\n    CPPUNIT_ASSERT(d.ParameterFileAttributes().contentVersion == L\"\");\n\n    CPPUNIT_ASSERT(d.Parameters().size() == 0);\n\n}\n"}
{"repo_name":"kyroskoh/phantomjs","ref":"refs/heads/master","path":"src/qt/qtwebkit/Source/WebCore/platform/network/soup/SoupURIUtils.cpp","copies":"128","language":"C++","content":"/*\n *  Copyright (C) 20010 Igalia S.L.\n *\n *  This library is free software; you can redistribute it and/or\n *  modify it under the terms of the GNU Lesser General Public\n *  License as published by the Free Software Foundation; either\n *  version 2 of the License, or (at your option) any later version.\n *\n *  This library is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n *  Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; if not, write to the Free Software\n *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\n\n#include \"config.h\"\n#include \"SoupURIUtils.h\"\n\n#include \u003cwtf/gobject/GOwnPtr.h\u003e\n#include \u003clibsoup/soup.h\u003e\n\nnamespace WebCore {\n\n// Motivated by https://bugs.webkit.org/show_bug.cgi?id=38956. libsoup\n// does not add the password to the URL when calling\n// soup_uri_to_string, and thus the requests are not properly\n// built. Fixing soup_uri_to_string is a no-no as the maintainer does\n// not want to break compatibility with previous implementations\nKURL soupURIToKURL(SoupURI* soupURI)\n{\n    GOwnPtr\u003cgchar\u003e urlString(soup_uri_to_string(soupURI, FALSE));\n    KURL url(KURL(), String::fromUTF8(urlString.get()));\n\n    if (!soupURI-\u003epassword)\n        return url;\n\n    url.setPass(String::fromUTF8(soupURI-\u003epassword));\n    return url;\n}\n\n}\n"}
{"repo_name":"miniwebkit/src","ref":"refs/heads/master","path":"WebCore/xml/XMLSerializer.cpp","copies":"79","language":"C++","content":"/*\n *  Copyright (C) 2003, 2006 Apple Inc. All rights reserved.\n *  Copyright (C) 2006 Samuel Weinig (sam@webkit.org)\n *\n *  This library is free software; you can redistribute it and/or\n *  modify it under the terms of the GNU Lesser General Public\n *  License as published by the Free Software Foundation; either\n *  version 2 of the License, or (at your option) any later version.\n *\n *  This library is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n *  Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; if not, write to the Free Software\n *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\n\n#include \"config.h\"\n#include \"XMLSerializer.h\"\n\n#include \"Document.h\"\n#include \"ExceptionCode.h\"\n#include \"markup.h\"\n\nnamespace WebCore {\n\nString XMLSerializer::serializeToString(Node* node, ExceptionCode\u0026 ec)\n{\n    if (!node)\n        return String();\n\n    if (!node-\u003edocument()) {\n        // Due to the fact that DocumentType nodes are created by the DOMImplementation\n        // and not the Document, it is possible for it to not have a Document associated\n        // with it.  It should be the only type of node where this is possible.\n        ASSERT(node-\u003enodeType() == Node::DOCUMENT_TYPE_NODE);\n\n        ec = INVALID_ACCESS_ERR;\n        return String();\n    }\n\n    return createMarkup(node);\n}\n\n} // namespace WebCore\n"}
{"repo_name":"domin1101/malmo-challenge","ref":"refs/heads/master","path":"cpp/src/main.cpp","copies":"1","language":"C++","content":"#include \"LightBulbApp/App.hpp\"\n#include \u003cwx/wxprec.h\u003e\n#include \"PigChase/PigChaseEvolution.hpp\"\n#include \"PigChase/TensorflowExporter.hpp\"\n\nint main(int argc, char** argv)\n{\n\t// Setup the main app\n\tLightBulb::App* app = new LightBulb::App();\n\tapp-\u003eaddTrainingPlan(new PigChaseEvolution());\n\tapp-\u003eaddExporter(new TensorflowExporter());\n\n\twxApp::SetInstance(app);\n\twxEntry(argc, argv);\n\n\treturn 0;\n}\n"}
{"repo_name":"Sija/swift","ref":"refs/heads/master","path":"Tests/Source/TestValueBool.cpp","copies":"1","language":"C++","content":"#include \"stdafx.h\"\r\n#include \u003ccppunit/extensions/HelperMacros.h\u003e\r\n\r\n#include \"../../Source/stdafx.h\"\r\n#include \"../../Source/values/Bool.h\"\r\n\r\nusing namespace Swift;\r\n\r\nclass TestValueBool : public CPPUNIT_NS::TestFixture {\r\npublic:\r\n  CPPUNIT_TEST_SUITE(TestValueBool);\r\n\r\n  CPPUNIT_TEST(testInit);\r\n  CPPUNIT_TEST(testAssign);\r\n  CPPUNIT_TEST(testGet);\r\n  CPPUNIT_TEST(testSetClear);\r\n  CPPUNIT_TEST(testOperators);\r\n\r\n  CPPUNIT_TEST_SUITE_END();\r\n\r\npublic:\r\n  void setUp() { }\r\n  void tearDown() { }\r\n\r\nprotected:\r\n  void testInit() {\r\n    CPPUNIT_ASSERT(iValue::hasTypeString(Values::Bool::id));\r\n  }\r\n\r\n  void testAssign() {\r\n    oValue b(true);\r\n\r\n    CPPUNIT_ASSERT(b-\u003egetID() == Values::Bool::id);\r\n  }\r\n\r\n  void testGet() {\r\n    CPPUNIT_ASSERT(oValue(true) \u003e\u003e bool());\r\n    CPPUNIT_ASSERT(!((Values::Bool*) oValue(false).get())-\u003eoutput());\r\n  }\r\n\r\n  void testSetClear() {\r\n    oValue v(true);\r\n    v-\u003eclear();\r\n\r\n    CPPUNIT_ASSERT(!(v \u003e\u003e bool()));\r\n\r\n    Values::Bool* b = (Values::Bool*) v.get();\r\n    b-\u003eset(true);\r\n\r\n    CPPUNIT_ASSERT(v \u003e\u003e bool());\r\n  }\r\n\r\n  void testOperators() {\r\n    CPPUNIT_ASSERT((oValue(true) == oValue(true)) \u003e\u003e bool());\r\n    CPPUNIT_ASSERT((oValue(true) != oValue(false)) \u003e\u003e bool());\r\n    CPPUNIT_ASSERT((oValue(true) \u0026\u0026 oValue(true)) \u003e\u003e bool());\r\n    CPPUNIT_ASSERT((oValue(false) || oValue(true)) \u003e\u003e bool());\r\n    CPPUNIT_ASSERT((!oValue(true) == oValue(false)) \u003e\u003e bool());\r\n\r\n    CPPUNIT_ASSERT((oValue() \u003c\u003c true)-\u003egetID() == Values::Bool::id);\r\n    CPPUNIT_ASSERT((oValue(false) \u003e\u003e bool()) == false);\r\n  }\r\n};\r\n\r\nCPPUNIT_TEST_SUITE_REGISTRATION(TestValueBool);"}
{"repo_name":"renatofilho/QtCreator","ref":"refs/heads/master","path":"src/plugins/texteditor/codeassist/functionhintproposalwidget.cpp","copies":"2","language":"C++","content":"/**************************************************************************\n**\n** This file is part of Qt Creator\n**\n** Copyright (c) 2011 Nokia Corporation and/or its subsidiary(-ies).\n**\n** Contact: Nokia Corporation (info@qt.nokia.com)\n**\n**\n** GNU Lesser General Public License Usage\n**\n** This file may be used under the terms of the GNU Lesser General Public\n** License version 2.1 as published by the Free Software Foundation and\n** appearing in the file LICENSE.LGPL included in the packaging of this file.\n** Please review the following information to ensure the GNU Lesser General\n** Public License version 2.1 requirements will be met:\n** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.\n**\n** In addition, as a special exception, Nokia gives you certain additional\n** rights. These rights are described in the Nokia Qt LGPL Exception\n** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.\n**\n** Other Usage\n**\n** Alternatively, this file may be used in accordance with the terms and\n** conditions contained in a signed written agreement between you and Nokia.\n**\n** If you have questions regarding the use of this file, please contact\n** Nokia at info@qt.nokia.com.\n**\n**************************************************************************/\n\n#include \"functionhintproposalwidget.h\"\n#include \"ifunctionhintproposalmodel.h\"\n#include \"codeassistant.h\"\n\n#include \u003cutils/faketooltip.h\u003e\n\n#include \u003cQtCore/QDebug\u003e\n#include \u003cQtGui/QApplication\u003e\n#include \u003cQtGui/QLabel\u003e\n#include \u003cQtGui/QToolButton\u003e\n#include \u003cQtGui/QHBoxLayout\u003e\n#include \u003cQtGui/QVBoxLayout\u003e\n#include \u003cQtGui/QDesktopWidget\u003e\n#include \u003cQtGui/QKeyEvent\u003e\n#include \u003cQtGui/QShortcutEvent\u003e\n\nnamespace TextEditor {\n\n// -------------------------\n// HintProposalWidgetPrivate\n// -------------------------\nstruct FunctionHintProposalWidgetPrivate\n{\n    FunctionHintProposalWidgetPrivate();\n\n    const QWidget *m_underlyingWidget;\n    CodeAssistant *m_assistant;\n    IFunctionHintProposalModel *m_model;\n    Utils::FakeToolTip *m_popupFrame;\n    QLabel *m_numberLabel;\n    QLabel *m_hintLabel;\n    QWidget *m_pager;\n    QRect m_displayRect;\n    int m_currentHint;\n    int m_totalHints;\n    int m_currentArgument;\n    bool m_escapePressed;\n};\n\nFunctionHintProposalWidgetPrivate::FunctionHintProposalWidgetPrivate()\n    : m_underlyingWidget(0)\n    , m_assistant(0)\n    , m_model(0)\n    , m_popupFrame(new Utils::FakeToolTip)\n    , m_numberLabel(new QLabel)\n    , m_hintLabel(new QLabel)\n    , m_pager(new QWidget)\n    , m_currentHint(-1)\n    , m_totalHints(0)\n    , m_currentArgument(-1)\n    , m_escapePressed(false)\n{\n    m_hintLabel-\u003esetTextFormat(Qt::RichText);\n}\n\n// ------------------\n// HintProposalWidget\n// ------------------\nFunctionHintProposalWidget::FunctionHintProposalWidget()\n    : m_d(new FunctionHintProposalWidgetPrivate)\n{\n    QToolButton *downArrow = new QToolButton;\n    downArrow-\u003esetArrowType(Qt::DownArrow);\n    downArrow-\u003esetFixedSize(16, 16);\n    downArrow-\u003esetAutoRaise(true);\n\n    QToolButton *upArrow = new QToolButton;\n    upArrow-\u003esetArrowType(Qt::UpArrow);\n    upArrow-\u003esetFixedSize(16, 16);\n    upArrow-\u003esetAutoRaise(true);\n\n    QHBoxLayout *pagerLayout = new QHBoxLayout(m_d-\u003em_pager);\n    pagerLayout-\u003esetMargin(0);\n    pagerLayout-\u003esetSpacing(0);\n    pagerLayout-\u003eaddWidget(upArrow);\n    pagerLayout-\u003eaddWidget(m_d-\u003em_numberLabel);\n    pagerLayout-\u003eaddWidget(downArrow);\n\n    QHBoxLayout *popupLayout = new QHBoxLayout(m_d-\u003em_popupFrame);\n    popupLayout-\u003esetMargin(0);\n    popupLayout-\u003esetSpacing(0);\n    popupLayout-\u003eaddWidget(m_d-\u003em_pager);\n    popupLayout-\u003eaddWidget(m_d-\u003em_hintLabel);\n\n    connect(upArrow, SIGNAL(clicked()), SLOT(previousPage()));\n    connect(downArrow, SIGNAL(clicked()), SLOT(nextPage()));\n\n    qApp-\u003einstallEventFilter(this);\n\n    setFocusPolicy(Qt::NoFocus);\n}\n\nFunctionHintProposalWidget::~FunctionHintProposalWidget()\n{\n    delete m_d-\u003em_model;\n}\n\nvoid FunctionHintProposalWidget::setAssistant(CodeAssistant *assistant)\n{\n    m_d-\u003em_assistant = assistant;\n}\n\nvoid FunctionHintProposalWidget::setReason(AssistReason reason)\n{\n    Q_UNUSED(reason);\n}\n\nvoid FunctionHintProposalWidget::setUnderlyingWidget(const QWidget *underlyingWidget)\n{\n    m_d-\u003em_underlyingWidget = underlyingWidget;\n}\n\nvoid FunctionHintProposalWidget::setModel(IAssistProposalModel *model)\n{\n    m_d-\u003em_model = static_cast\u003cIFunctionHintProposalModel *\u003e(model);\n}\n\nvoid FunctionHintProposalWidget::setDisplayRect(const QRect \u0026rect)\n{\n    m_d-\u003em_displayRect = rect;\n}\n\nvoid FunctionHintProposalWidget::setIsSynchronized(bool)\n{}\n\nvoid FunctionHintProposalWidget::showProposal(const QString \u0026prefix)\n{\n    m_d-\u003em_totalHints = m_d-\u003em_model-\u003esize();\n    if (m_d-\u003em_totalHints == 0) {\n        abort();\n        return;\n    }\n    m_d-\u003em_pager-\u003esetVisible(m_d-\u003em_totalHints \u003e 1);\n    m_d-\u003em_currentHint = 0;\n    if (!updateAndCheck(prefix)) {\n        abort();\n        return;\n    }\n    m_d-\u003em_popupFrame-\u003eshow();\n}\n\nvoid FunctionHintProposalWidget::updateProposal(const QString \u0026prefix)\n{\n    updateAndCheck(prefix);\n}\n\nvoid FunctionHintProposalWidget::closeProposal()\n{\n    abort();\n}\n\nvoid FunctionHintProposalWidget::abort()\n{\n    if (m_d-\u003em_popupFrame-\u003eisVisible())\n        m_d-\u003em_popupFrame-\u003eclose();\n    deleteLater();\n}\n\nbool FunctionHintProposalWidget::eventFilter(QObject *obj, QEvent *e)\n{\n    switch (e-\u003etype()) {\n    case QEvent::ShortcutOverride:\n        if (static_cast\u003cQKeyEvent*\u003e(e)-\u003ekey() == Qt::Key_Escape) {\n            m_d-\u003em_escapePressed = true;\n        }\n        break;\n    case QEvent::KeyPress:\n        if (static_cast\u003cQKeyEvent*\u003e(e)-\u003ekey() == Qt::Key_Escape) {\n            m_d-\u003em_escapePressed = true;\n        }\n        if (m_d-\u003em_model-\u003esize() \u003e 1) {\n            QKeyEvent *ke = static_cast\u003cQKeyEvent*\u003e(e);\n            if (ke-\u003ekey() == Qt::Key_Up) {\n                previousPage();\n                return true;\n            } else if (ke-\u003ekey() == Qt::Key_Down) {\n                nextPage();\n                return true;\n            }\n            return false;\n        }\n        break;\n    case QEvent::KeyRelease:\n        if (static_cast\u003cQKeyEvent*\u003e(e)-\u003ekey() == Qt::Key_Escape \u0026\u0026 m_d-\u003em_escapePressed) {\n            abort();\n            return false;\n        }\n        m_d-\u003em_assistant-\u003enotifyChange();\n        break;\n    case QEvent::WindowDeactivate:\n    case QEvent::FocusOut:\n        if (obj != m_d-\u003em_underlyingWidget) {\n            break;\n        }\n        abort();\n        break;\n    case QEvent::MouseButtonPress:\n    case QEvent::MouseButtonRelease:\n    case QEvent::MouseButtonDblClick:\n    case QEvent::Wheel: {\n            QWidget *widget = qobject_cast\u003cQWidget *\u003e(obj);\n            if (! (widget == this || isAncestorOf(widget))) {\n                abort();\n            }\n        }\n        break;\n    default:\n        break;\n    }\n    return false;\n}\n\nvoid FunctionHintProposalWidget::nextPage()\n{\n    m_d-\u003em_currentHint = (m_d-\u003em_currentHint + 1) % m_d-\u003em_totalHints;\n    updateContent();\n}\n\nvoid FunctionHintProposalWidget::previousPage()\n{\n    if (m_d-\u003em_currentHint == 0)\n        m_d-\u003em_currentHint = m_d-\u003em_totalHints - 1;\n    else\n        --m_d-\u003em_currentHint;\n    updateContent();\n}\n\nbool FunctionHintProposalWidget::updateAndCheck(const QString \u0026prefix)\n{\n    const int activeArgument = m_d-\u003em_model-\u003eactiveArgument(prefix);\n    if (activeArgument == -1) {\n        abort();\n        return false;\n    } else if (activeArgument != m_d-\u003em_currentArgument) {\n        m_d-\u003em_currentArgument = activeArgument;\n        updateContent();\n    }\n\n    return true;\n}\n\nvoid FunctionHintProposalWidget::updateContent()\n{\n    m_d-\u003em_hintLabel-\u003esetText(m_d-\u003em_model-\u003etext(m_d-\u003em_currentHint));\n    m_d-\u003em_numberLabel-\u003esetText(tr(\"%1 of %2\").arg(m_d-\u003em_currentHint + 1).arg(m_d-\u003em_totalHints));\n    updatePosition();\n}\n\nvoid FunctionHintProposalWidget::updatePosition()\n{\n    const QDesktopWidget *desktop = QApplication::desktop();\n#ifdef Q_WS_MAC\n    const QRect \u0026screen = desktop-\u003eavailableGeometry(desktop-\u003escreenNumber(m_d-\u003em_underlyingWidget));\n#else\n    const QRect \u0026screen = desktop-\u003escreenGeometry(desktop-\u003escreenNumber(m_d-\u003em_underlyingWidget));\n#endif\n\n    m_d-\u003em_pager-\u003esetFixedWidth(m_d-\u003em_pager-\u003eminimumSizeHint().width());\n\n    m_d-\u003em_hintLabel-\u003esetWordWrap(false);\n    const int maxDesiredWidth = screen.width() - 10;\n    const QSize \u0026minHint = m_d-\u003em_popupFrame-\u003eminimumSizeHint();\n    if (minHint.width() \u003e maxDesiredWidth) {\n        m_d-\u003em_hintLabel-\u003esetWordWrap(true);\n        m_d-\u003em_popupFrame-\u003esetFixedWidth(maxDesiredWidth);\n        const int extra = m_d-\u003em_popupFrame-\u003econtentsMargins().bottom() +\n            m_d-\u003em_popupFrame-\u003econtentsMargins().top();\n        m_d-\u003em_popupFrame-\u003esetFixedHeight(\n            m_d-\u003em_hintLabel-\u003eheightForWidth(maxDesiredWidth - m_d-\u003em_pager-\u003ewidth()) + extra);\n    } else {\n        m_d-\u003em_popupFrame-\u003esetFixedSize(minHint);\n    }\n\n    const QSize \u0026sz = m_d-\u003em_popupFrame-\u003esize();\n    QPoint pos = m_d-\u003em_displayRect.topLeft();\n    pos.setY(pos.y() - sz.height() - 1);\n    if (pos.x() + sz.width() \u003e screen.right())\n        pos.setX(screen.right() - sz.width());\n    m_d-\u003em_popupFrame-\u003emove(pos);\n}\n\n} // TextEditor\n"}
{"repo_name":"SuslikV/obs-studio","ref":"refs/heads/SuslikV-fix-1","path":"plugins/win-capture/graphics-hook/d3d9-capture.cpp","copies":"1","language":"C++","content":"#define _CRT_SECURE_NO_WARNINGS\n#include \u003cd3d9.h\u003e\n#include \u003cd3d11.h\u003e\n#include \u003cdxgi.h\u003e\n\n#include \"graphics-hook.h\"\n#include \"../funchook.h\"\n#include \"d3d9-patches.hpp\"\n\ntypedef HRESULT (STDMETHODCALLTYPE *present_t)(IDirect3DDevice9*,\n\t\tCONST RECT*, CONST RECT*, HWND, CONST RGNDATA*);\ntypedef HRESULT (STDMETHODCALLTYPE *present_ex_t)(IDirect3DDevice9*,\n\t\tCONST RECT*, CONST RECT*, HWND, CONST RGNDATA*, DWORD);\ntypedef HRESULT (STDMETHODCALLTYPE *present_swap_t)(IDirect3DSwapChain9*,\n\t\tCONST RECT*, CONST RECT*, HWND, CONST RGNDATA*, DWORD);\ntypedef HRESULT (STDMETHODCALLTYPE *reset_t)(IDirect3DDevice9*,\n\t\tD3DPRESENT_PARAMETERS*);\ntypedef HRESULT (STDMETHODCALLTYPE *reset_ex_t)(IDirect3DDevice9*,\n\t\tD3DPRESENT_PARAMETERS*, D3DDISPLAYMODEEX*);\n\ntypedef HRESULT (WINAPI *createfactory1_t)(REFIID, void **);\n\nstatic struct func_hook present;\nstatic struct func_hook present_ex;\nstatic struct func_hook present_swap;\nstatic struct func_hook reset;\nstatic struct func_hook reset_ex;\n\nstruct d3d9_data {\n\tHMODULE                d3d9;\n\tIDirect3DDevice9       *device; /* do not release */\n\tuint32_t               cx;\n\tuint32_t               cy;\n\tD3DFORMAT              d3d9_format;\n\tDXGI_FORMAT            dxgi_format;\n\tbool                   using_shtex : 1;\n\tbool                   using_scale : 1;\n\n\tvolatile bool          issued_queries[NUM_BUFFERS];\n\n\tunion {\n\t\t/* shared texture */\n\t\tstruct {\n\t\t\tIDirect3DSurface9      *d3d9_copytex;\n\t\t\tID3D11Device           *d3d11_device;\n\t\t\tID3D11DeviceContext    *d3d11_context;\n\t\t\tID3D11Resource         *d3d11_tex;\n\t\t\tstruct shtex_data      *shtex_info;\n\t\t\tHANDLE                 handle;\n\t\t\tint                    patch;\n\t\t};\n\t\t/* shared memory */\n\t\tstruct {\n\t\t\tIDirect3DSurface9      *copy_surfaces[NUM_BUFFERS];\n\t\t\tIDirect3DSurface9      *render_targets[NUM_BUFFERS];\n\t\t\tIDirect3DQuery9        *queries[NUM_BUFFERS];\n\t\t\tstruct shmem_data      *shmem_info;\n\t\t\tbool                   texture_mapped[NUM_BUFFERS];\n\t\t\tuint32_t               pitch;\n\t\t\tint                    cur_tex;\n\t\t\tint                    copy_wait;\n\t\t};\n\t};\n};\n\nstatic struct d3d9_data data = {};\n\nstatic void d3d9_free()\n{\n\tcapture_free();\n\n\tif (data.using_shtex) {\n\t\tif (data.d3d11_tex)\n\t\t\tdata.d3d11_tex-\u003eRelease();\n\t\tif (data.d3d11_context)\n\t\t\tdata.d3d11_context-\u003eRelease();\n\t\tif (data.d3d11_device)\n\t\t\tdata.d3d11_device-\u003eRelease();\n\t\tif (data.d3d9_copytex)\n\t\t\tdata.d3d9_copytex-\u003eRelease();\n\t} else {\n\t\tfor (size_t i = 0; i \u003c NUM_BUFFERS; i++) {\n\t\t\tif (data.copy_surfaces[i]) {\n\t\t\t\tif (data.texture_mapped[i])\n\t\t\t\t\tdata.copy_surfaces[i]-\u003eUnlockRect();\n\t\t\t\tdata.copy_surfaces[i]-\u003eRelease();\n\t\t\t}\n\t\t\tif (data.render_targets[i])\n\t\t\t\tdata.render_targets[i]-\u003eRelease();\n\t\t\tif (data.queries[i])\n\t\t\t\tdata.queries[i]-\u003eRelease();\n\t\t}\n\t}\n\n\tmemset(\u0026data, 0, sizeof(data));\n\n\thlog(\"----------------- d3d9 capture freed -----------------\");\n}\n\nstatic DXGI_FORMAT d3d9_to_dxgi_format(D3DFORMAT format)\n{\n\tswitch ((unsigned long)format) {\n\tcase D3DFMT_A2B10G10R10: return DXGI_FORMAT_R10G10B10A2_UNORM;\n\tcase D3DFMT_A8R8G8B8:    return DXGI_FORMAT_B8G8R8A8_UNORM;\n\tcase D3DFMT_X8R8G8B8:    return DXGI_FORMAT_B8G8R8X8_UNORM;\n\t}\n\n\treturn DXGI_FORMAT_UNKNOWN;\n}\n\nconst static D3D_FEATURE_LEVEL feature_levels[] =\n{\n\tD3D_FEATURE_LEVEL_11_0,\n\tD3D_FEATURE_LEVEL_10_1,\n\tD3D_FEATURE_LEVEL_10_0,\n\tD3D_FEATURE_LEVEL_9_3,\n};\n\nstatic inline bool shex_init_d3d11()\n{\n\tPFN_D3D11_CREATE_DEVICE create_device;\n\tcreatefactory1_t create_factory;\n\tD3D_FEATURE_LEVEL level_used;\n\tIDXGIFactory *factory;\n\tIDXGIAdapter *adapter;\n\tHMODULE d3d11;\n\tHMODULE dxgi;\n\tHRESULT hr;\n\n\td3d11 = load_system_library(\"d3d11.dll\");\n\tif (!d3d11) {\n\t\thlog(\"d3d9_init: Failed to load D3D11\");\n\t\treturn false;\n\t}\n\n\tdxgi = load_system_library(\"dxgi.dll\");\n\tif (!dxgi) {\n\t\thlog(\"d3d9_init: Failed to load DXGI\");\n\t\treturn false;\n\t}\n\n\tcreate_factory = (createfactory1_t)GetProcAddress(dxgi,\n\t\t\t\"CreateDXGIFactory1\");\n\tif (!create_factory) {\n\t\thlog(\"d3d9_init: Failed to get CreateDXGIFactory1 address\");\n\t\treturn false;\n\t}\n\n\tcreate_device = (PFN_D3D11_CREATE_DEVICE)GetProcAddress(d3d11,\n\t\t\t\"D3D11CreateDevice\");\n\tif (!create_device) {\n\t\thlog(\"d3d9_init: Failed to get D3D11CreateDevice address\");\n\t\treturn false;\n\t}\n\n\thr = create_factory(__uuidof(IDXGIFactory1), (void**)\u0026factory);\n\tif (FAILED(hr)) {\n\t\thlog_hr(\"d3d9_init: Failed to create factory object\", hr);\n\t\treturn false;\n\t}\n\n\thr = factory-\u003eEnumAdapters(0, \u0026adapter);\n\tfactory-\u003eRelease();\n\n\tif (FAILED(hr)) {\n\t\thlog_hr(\"d3d9_init: Failed to get adapter\", hr);\n\t\treturn false;\n\t}\n\n\thr = create_device(adapter, D3D_DRIVER_TYPE_UNKNOWN, nullptr,\n\t\t\t0, feature_levels,\n\t\t\tsizeof(feature_levels) / sizeof(D3D_FEATURE_LEVEL),\n\t\t\tD3D11_SDK_VERSION, \u0026data.d3d11_device, \u0026level_used,\n\t\t\t\u0026data.d3d11_context);\n\tadapter-\u003eRelease();\n\n\tif (FAILED(hr)) {\n\t\thlog_hr(\"d3d9_init: Failed to create D3D11 device\", hr);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic inline bool d3d9_shtex_init_shtex()\n{\n\tIDXGIResource *res;\n\tHRESULT hr;\n\n\tD3D11_TEXTURE2D_DESC desc = {};\n\tdesc.Width                = data.cx;\n\tdesc.Height               = data.cy;\n\tdesc.Format               = data.dxgi_format;\n\tdesc.MipLevels            = 1;\n\tdesc.ArraySize            = 1;\n\tdesc.SampleDesc.Count     = 1;\n\tdesc.Usage                = D3D11_USAGE_DEFAULT;\n\tdesc.MiscFlags            = D3D11_RESOURCE_MISC_SHARED;\n\tdesc.BindFlags            = D3D11_BIND_RENDER_TARGET |\n\t                            D3D11_BIND_SHADER_RESOURCE;\n\n\thr = data.d3d11_device-\u003eCreateTexture2D(\u0026desc, nullptr,\n\t\t\t(ID3D11Texture2D**)\u0026data.d3d11_tex);\n\tif (FAILED(hr)) {\n\t\thlog_hr(\"d3d9_shtex_init_shtex: Failed to create D3D11 texture\",\n\t\t\t\thr);\n\t\treturn false;\n\t}\n\n\thr = data.d3d11_tex-\u003eQueryInterface(__uuidof(IDXGIResource),\n\t\t\t(void**)\u0026res);\n\tif (FAILED(hr)) {\n\t\thlog_hr(\"d3d9_shtex_init_shtex: Failed to query IDXGIResource\",\n\t\t\t\thr);\n\t\treturn false;\n\t}\n\n\thr = res-\u003eGetSharedHandle(\u0026data.handle);\n\tres-\u003eRelease();\n\n\tif (FAILED(hr)) {\n\t\thlog_hr(\"d3d9_shtex_init_shtex: Failed to get shared handle\",\n\t\t\t\thr);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic inline bool d3d9_shtex_init_copytex()\n{\n\tuint8_t *patch_addr = get_d3d9_patch_addr(data.d3d9, data.patch);\n\tuint8_t saved_data[MAX_PATCH_SIZE];\n\tsize_t patch_size = 0;\n\tIDirect3DTexture9 *tex;\n\tDWORD protect_val;\n\tHRESULT hr;\n\n\tif (patch_addr) {\n\t\tpatch_size = patch[data.patch].size;\n\t\tVirtualProtect(patch_addr, patch_size, PAGE_EXECUTE_READWRITE,\n\t\t\t\t\u0026protect_val);\n\t\tmemcpy(saved_data, patch_addr, patch_size);\n\t\tmemcpy(patch_addr, patch[data.patch].data, patch_size);\n\t}\n\n\thr = data.device-\u003eCreateTexture(data.cx, data.cy, 1,\n\t\t\tD3DUSAGE_RENDERTARGET, data.d3d9_format,\n\t\t\tD3DPOOL_DEFAULT, \u0026tex, \u0026data.handle);\n\n\tif (patch_addr \u0026\u0026 patch_size) {\n\t\tmemcpy(patch_addr, saved_data, patch_size);\n\t\tVirtualProtect(patch_addr, patch_size, protect_val,\n\t\t\t\t\u0026protect_val);\n\t}\n\n\tif (FAILED(hr)) {\n\t\thlog_hr(\"d3d9_shtex_init_copytex: Failed to create shared texture\",\n\t\t\t\thr);\n\t\treturn false;\n\t}\n\n\thr = tex-\u003eGetSurfaceLevel(0, \u0026data.d3d9_copytex);\n\ttex-\u003eRelease();\n\n\tif (FAILED(hr)) {\n\t\thlog_hr(\"d3d9_shtex_init_copytex: Failed to get surface level\", hr);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic bool d3d9_shtex_init(uint32_t cx, uint32_t cy, HWND window)\n{\n\tdata.using_shtex = true;\n\n\tif (!shex_init_d3d11()) {\n\t\treturn false;\n\t}\n\tif (!d3d9_shtex_init_shtex()) {\n\t\treturn false;\n\t}\n\tif (!d3d9_shtex_init_copytex()) {\n\t\treturn false;\n\t}\n\tif (!capture_init_shtex(\u0026data.shtex_info, window, cx, cy,\n\t\t\t\tdata.cx, data.cy, data.dxgi_format, false,\n\t\t\t\t(uintptr_t)data.handle)) {\n\t\treturn false;\n\t}\n\n\thlog(\"d3d9 shared texture capture successful\");\n\treturn true;\n}\n\nstatic bool d3d9_shmem_init_buffers(size_t buffer)\n{\n\tHRESULT hr;\n\n\thr = data.device-\u003eCreateOffscreenPlainSurface(data.cx, data.cy,\n\t\t\tdata.d3d9_format, D3DPOOL_SYSTEMMEM,\n\t\t\t\u0026data.copy_surfaces[buffer], nullptr);\n\tif (FAILED(hr)) {\n\t\thlog_hr(\"d3d9_shmem_init_buffers: Failed to create surface\",\n\t\t\t\thr);\n\t\treturn false;\n\t}\n\n\tif (buffer == 0) {\n\t\tD3DLOCKED_RECT rect;\n\t\thr = data.copy_surfaces[buffer]-\u003eLockRect(\u0026rect, nullptr,\n\t\t\t\tD3DLOCK_READONLY);\n\t\tif (FAILED(hr)) {\n\t\t\thlog_hr(\"d3d9_shmem_init_buffers: Failed to lock \"\n\t\t\t        \"buffer\", hr);\n\t\t\treturn false;\n\t\t}\n\n\t\tdata.pitch = rect.Pitch;\n\t\tdata.copy_surfaces[buffer]-\u003eUnlockRect();\n\t}\t\n\n\thr = data.device-\u003eCreateRenderTarget(data.cx, data.cy,\n\t\t\tdata.d3d9_format, D3DMULTISAMPLE_NONE, 0, false,\n\t\t\t\u0026data.render_targets[buffer], nullptr);\n\tif (FAILED(hr)) {\n\t\thlog_hr(\"d3d9_shmem_init_buffers: Failed to create render \"\n\t\t        \"target\", hr);\n\t\treturn false;\n\t}\n\n\thr = data.device-\u003eCreateQuery(D3DQUERYTYPE_EVENT,\n\t\t\t\u0026data.queries[buffer]);\n\tif (FAILED(hr)) {\n\t\thlog_hr(\"d3d9_shmem_init_buffers: Failed to create query\", hr);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic bool d3d9_shmem_init(uint32_t cx, uint32_t cy, HWND window)\n{\n\tdata.using_shtex = false;\n\n\tfor (size_t i = 0; i \u003c NUM_BUFFERS; i++) {\n\t\tif (!d3d9_shmem_init_buffers(i)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tif (!capture_init_shmem(\u0026data.shmem_info, window, cx, cy,\n\t\t\t\tdata.cx, data.cy, data.pitch, data.dxgi_format,\n\t\t\t\tfalse)) {\n\t\treturn false;\n\t}\n\n\thlog(\"d3d9 memory capture successful\");\n\treturn true;\n}\n\nstatic bool d3d9_get_swap_desc(D3DPRESENT_PARAMETERS \u0026pp)\n{\n\tIDirect3DSwapChain9 *swap = nullptr;\n\tHRESULT hr;\n\n\thr = data.device-\u003eGetSwapChain(0, \u0026swap);\n\tif (FAILED(hr)) {\n\t\thlog_hr(\"d3d9_get_swap_desc: Failed to get swap chain\", hr);\n\t\treturn false;\n\t}\n\n\thr = swap-\u003eGetPresentParameters(\u0026pp);\n\tswap-\u003eRelease();\n\n\tif (FAILED(hr)) {\n\t\thlog_hr(\"d3d9_get_swap_desc: Failed to get \"\n\t\t        \"presentation parameters\", hr);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic bool d3d9_init_format_backbuffer(uint32_t \u0026cx, uint32_t \u0026cy,\n\t\tHWND \u0026window)\n{\n\tIDirect3DSurface9 *back_buffer = nullptr;\n\tD3DPRESENT_PARAMETERS pp;\n\tD3DSURFACE_DESC desc;\n\tHRESULT hr;\n\n\tif (!d3d9_get_swap_desc(pp)) {\n\t\treturn false;\n\t}\n\n\thr = data.device-\u003eGetRenderTarget(0, \u0026back_buffer);\n\tif (FAILED(hr)) {\n\t\treturn false;\n\t}\n\n\thr = back_buffer-\u003eGetDesc(\u0026desc);\n\tback_buffer-\u003eRelease();\n\n\tif (FAILED(hr)) {\n\t\thlog_hr(\"d3d9_init_format_backbuffer: Failed to get \"\n\t\t        \"backbuffer descriptor\", hr);\n\t\treturn false;\n\t}\n\n\tdata.d3d9_format = desc.Format;\n\tdata.dxgi_format = d3d9_to_dxgi_format(desc.Format);\n\tdata.using_scale = global_hook_info-\u003euse_scale;\n\twindow = pp.hDeviceWindow;\n\tcx = desc.Width;\n\tcy = desc.Height;\n\n\tif (data.using_scale) {\n\t\tdata.cx = global_hook_info-\u003ecx;\n\t\tdata.cy = global_hook_info-\u003ecy;\n\t} else {\n\t\tdata.cx = desc.Width;\n\t\tdata.cy = desc.Height;\n\t}\n\n\treturn true;\n}\n\nstatic bool d3d9_init_format_swapchain(uint32_t \u0026cx, uint32_t \u0026cy, HWND \u0026window)\n{\n\tD3DPRESENT_PARAMETERS pp;\n\n\tif (!d3d9_get_swap_desc(pp)) {\n\t\treturn false;\n\t}\n\n\tdata.dxgi_format = d3d9_to_dxgi_format(pp.BackBufferFormat);\n\tdata.d3d9_format = pp.BackBufferFormat;\n\tdata.using_scale = global_hook_info-\u003euse_scale;\n\twindow = pp.hDeviceWindow;\n\tcx = pp.BackBufferWidth;\n\tcy = pp.BackBufferHeight;\n\n\tif (data.using_scale) {\n\t\tdata.cx = global_hook_info-\u003ecx;\n\t\tdata.cy = global_hook_info-\u003ecy;\n\t} else {\n\t\tdata.cx = pp.BackBufferWidth;\n\t\tdata.cy = pp.BackBufferHeight;\n\t}\n\n\treturn true;\n}\n\nstatic void d3d9_init(IDirect3DDevice9 *device)\n{\n\tIDirect3DDevice9Ex *d3d9ex = nullptr;\n\tbool success;\n\tuint32_t cx = 0;\n\tuint32_t cy = 0;\n\tHWND window = nullptr;\n\tHRESULT hr;\n\n\tdata.d3d9 = get_system_module(\"d3d9.dll\");\n\tdata.device = device;\n\n\thr = device-\u003eQueryInterface(__uuidof(IDirect3DDevice9Ex),\n\t\t\t(void**)\u0026d3d9ex);\n\tif (SUCCEEDED(hr)) {\n\t\td3d9ex-\u003eRelease();\n\t\tdata.patch = -1;\n\t} else {\n\t\tdata.patch = get_d3d9_patch(data.d3d9);\n\t}\n\n\tif (!d3d9_init_format_backbuffer(cx, cy, window)) {\n\t\tif (!d3d9_init_format_swapchain(cx, cy, window)) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (global_hook_info-\u003eforce_shmem || (!d3d9ex \u0026\u0026 data.patch == -1)) {\n\t\tsuccess = d3d9_shmem_init(cx, cy, window);\n\t} else {\n\t\tsuccess = d3d9_shtex_init(cx, cy, window);\n\t}\n\n\tif (!success)\n\t\td3d9_free();\n}\n\nstatic inline HRESULT get_backbuffer(IDirect3DDevice9 *device,\n\t\tIDirect3DSurface9 **surface)\n{\n\tstatic bool use_backbuffer = false;\n\tstatic bool checked_exceptions = false;\n\n\tif (!checked_exceptions) {\n\t\tif (_strcmpi(get_process_name(), \"hotd_ng.exe\") == 0)\n\t\t\tuse_backbuffer = true;\n\t\tchecked_exceptions = true;\n\t}\n\n\tif (use_backbuffer) {\n\t\treturn device-\u003eGetBackBuffer(0, 0, D3DBACKBUFFER_TYPE_MONO,\n\t\t\t\tsurface);\n\t} else {\n\t\treturn device-\u003eGetRenderTarget(0, surface);\n\t}\n}\n\nstatic inline void d3d9_shtex_capture(IDirect3DSurface9 *backbuffer)\n{\n\tD3DTEXTUREFILTERTYPE filter;\n\tHRESULT hr;\n\n\tfilter = data.using_scale ? D3DTEXF_LINEAR : D3DTEXF_NONE;\n\n\thr = data.device-\u003eStretchRect(backbuffer, nullptr, data.d3d9_copytex,\n\t\t\tnullptr, filter);\n\tif (FAILED(hr))\n\t\thlog_hr(\"d3d9_shtex_capture: StretchRect failed\", hr);\n}\n\nstatic inline void d3d9_shmem_capture_queue_copy()\n{\n\tfor (int i = 0; i \u003c NUM_BUFFERS; i++) {\n\t\tIDirect3DSurface9 *target = data.copy_surfaces[i];\n\t\tD3DLOCKED_RECT rect;\n\t\tHRESULT hr;\n\n\t\tif (!data.issued_queries[i]) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (data.queries[i]-\u003eGetData(0, 0, 0) != S_OK) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tdata.issued_queries[i] = false;\n\n\t\thr = target-\u003eLockRect(\u0026rect, nullptr, D3DLOCK_READONLY);\n\t\tif (SUCCEEDED(hr)) {\n\t\t\tdata.texture_mapped[i] = true;\n\t\t\tshmem_copy_data(i, rect.pBits);\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic inline void d3d9_shmem_capture(IDirect3DSurface9 *backbuffer)\n{\n\tD3DTEXTUREFILTERTYPE filter;\n\tIDirect3DSurface9 *copy;\n\tint next_tex;\n\tHRESULT hr;\n\n\td3d9_shmem_capture_queue_copy();\n\n\tnext_tex = (data.cur_tex == NUM_BUFFERS - 1) ?  0 : data.cur_tex + 1;\n\tfilter = data.using_scale ? D3DTEXF_LINEAR : D3DTEXF_NONE;\n\tcopy = data.render_targets[data.cur_tex];\n\n\thr = data.device-\u003eStretchRect(backbuffer, nullptr, copy, nullptr,\n\t\t\tfilter);\n\n\tif (FAILED(hr)) {\n\t\thlog_hr(\"d3d9_shmem_capture: StretchRect failed\", hr);\n\t\treturn;\n\t}\n\n\tif (data.copy_wait \u003c NUM_BUFFERS - 1) {\n\t\tdata.copy_wait++;\n\t} else {\n\t\tIDirect3DSurface9 *src = data.render_targets[next_tex];\n\t\tIDirect3DSurface9 *dst = data.copy_surfaces[next_tex];\n\n\t\tif (shmem_texture_data_lock(next_tex)) {\n\t\t\tdst-\u003eUnlockRect();\n\t\t\tdata.texture_mapped[next_tex] = false;\n\t\t\tshmem_texture_data_unlock(next_tex);\n\t\t}\n\n\t\thr = data.device-\u003eGetRenderTargetData(src, dst);\n\t\tif (FAILED(hr)) {\n\t\t\thlog_hr(\"d3d9_shmem_capture: GetRenderTargetData \"\n\t\t\t        \"failed\", hr);\n\t\t}\n\n\t\tdata.queries[next_tex]-\u003eIssue(D3DISSUE_END);\n\t\tdata.issued_queries[next_tex] = true;\n\t}\n\n\tdata.cur_tex = next_tex;\n}\n\nstatic void d3d9_capture(IDirect3DDevice9 *device,\n\t\tIDirect3DSurface9 *backbuffer)\n{\n\tif (capture_should_stop()) {\n\t\td3d9_free();\n\t}\n\tif (capture_should_init()) {\n\t\td3d9_init(device);\n\t}\n\tif (capture_ready()) {\n\t\tif (data.using_shtex)\n\t\t\td3d9_shtex_capture(backbuffer);\n\t\telse\n\t\t\td3d9_shmem_capture(backbuffer);\n\t}\n}\n\n/* this is used just in case Present calls PresentEx or vise versa. */\nstatic int present_recurse = 0;\n\nstatic inline void present_begin(IDirect3DDevice9 *device,\n\t\tIDirect3DSurface9 *\u0026backbuffer)\n{\n\tHRESULT hr;\n\n\tif (!present_recurse) {\n\t\thr = get_backbuffer(device, \u0026backbuffer);\n\t\tif (FAILED(hr)) {\n\t\t\thlog_hr(\"d3d9_shmem_capture: Failed to get \"\n\t\t\t\t\"backbuffer\", hr);\n\t\t}\n\n\t\tif (!global_hook_info-\u003ecapture_overlay) {\n\t\t\td3d9_capture(device, backbuffer);\n\t\t}\n\t}\n\n\tpresent_recurse++;\n}\n\nstatic inline void present_end(IDirect3DDevice9 *device,\n\t\tIDirect3DSurface9 *backbuffer)\n{\n\tpresent_recurse--;\n\n\tif (!present_recurse) {\n\t\tif (global_hook_info-\u003ecapture_overlay) {\n\t\t\tif (!present_recurse)\n\t\t\t\td3d9_capture(device, backbuffer);\n\t\t}\n\n\t\tif (backbuffer)\n\t\t\tbackbuffer-\u003eRelease();\n\t}\n}\n\nstatic bool hooked_reset = false;\nstatic void setup_reset_hooks(IDirect3DDevice9 *device);\n\nstatic HRESULT STDMETHODCALLTYPE hook_present(IDirect3DDevice9 *device,\n\t\tCONST RECT *src_rect, CONST RECT *dst_rect,\n\t\tHWND override_window, CONST RGNDATA *dirty_region)\n{\n\tIDirect3DSurface9 *backbuffer = nullptr;\n\tHRESULT hr;\n\n\tif (!hooked_reset)\n\t\tsetup_reset_hooks(device);\n\n\tpresent_begin(device, backbuffer);\n\n\tunhook(\u0026present);\n\tpresent_t call = (present_t)present.call_addr;\n\thr = call(device, src_rect, dst_rect, override_window, dirty_region);\n\trehook(\u0026present);\n\n\tpresent_end(device, backbuffer);\n\n\treturn hr;\n}\n\nstatic HRESULT STDMETHODCALLTYPE hook_present_ex(IDirect3DDevice9 *device,\n\t\tCONST RECT *src_rect, CONST RECT *dst_rect,\n\t\tHWND override_window, CONST RGNDATA *dirty_region, DWORD flags)\n{\n\tIDirect3DSurface9 *backbuffer = nullptr;\n\tHRESULT hr;\n\n\tif (!hooked_reset)\n\t\tsetup_reset_hooks(device);\n\n\tpresent_begin(device, backbuffer);\n\n\tunhook(\u0026present_ex);\n\tpresent_ex_t call = (present_ex_t)present_ex.call_addr;\n\thr = call(device, src_rect, dst_rect, override_window, dirty_region,\n\t\t\tflags);\n\trehook(\u0026present_ex);\n\n\tpresent_end(device, backbuffer);\n\n\treturn hr;\n}\n\nstatic HRESULT STDMETHODCALLTYPE hook_present_swap(IDirect3DSwapChain9 *swap,\n\t\tCONST RECT *src_rect, CONST RECT *dst_rect,\n\t\tHWND override_window, CONST RGNDATA *dirty_region, DWORD flags)\n{\n\tIDirect3DSurface9 *backbuffer = nullptr;\n\tIDirect3DDevice9 *device = nullptr;\n\tHRESULT hr;\n\n\tif (!present_recurse) {\n\t\thr = swap-\u003eGetDevice(\u0026device);\n\t\tif (SUCCEEDED(hr)) {\n\t\t\tdevice-\u003eRelease();\n\t\t}\n\t}\n\n\tif (device) {\n\t\tif (!hooked_reset)\n\t\t\tsetup_reset_hooks(device);\n\n\t\tpresent_begin(device, backbuffer);\n\t}\n\n\tunhook(\u0026present_swap);\n\tpresent_swap_t call = (present_swap_t)present_swap.call_addr;\n\thr = call(swap, src_rect, dst_rect, override_window, dirty_region,\n\t\t\tflags);\n\trehook(\u0026present_swap);\n\n\tif (device)\n\t\tpresent_end(device, backbuffer);\n\n\treturn hr;\n}\n\nstatic HRESULT STDMETHODCALLTYPE hook_reset(IDirect3DDevice9 *device,\n\t\tD3DPRESENT_PARAMETERS *params)\n{\n\tHRESULT hr;\n\n\tif (capture_active())\n\t\td3d9_free();\n\n\tunhook(\u0026reset);\n\treset_t call = (reset_t)reset.call_addr;\n\thr = call(device, params);\n\trehook(\u0026reset);\n\n\treturn hr;\n}\n\nstatic HRESULT STDMETHODCALLTYPE hook_reset_ex(IDirect3DDevice9 *device,\n\t\tD3DPRESENT_PARAMETERS *params, D3DDISPLAYMODEEX *dmex)\n{\n\tHRESULT hr;\n\n\tif (capture_active())\n\t\td3d9_free();\n\n\tunhook(\u0026reset_ex);\n\treset_ex_t call = (reset_ex_t)reset_ex.call_addr;\n\thr = call(device, params, dmex);\n\trehook(\u0026reset_ex);\n\n\treturn hr;\n}\n\nstatic void setup_reset_hooks(IDirect3DDevice9 *device)\n{\n\tIDirect3DDevice9Ex *d3d9ex = nullptr;\n\tuintptr_t *vtable = *(uintptr_t**)device;\n\tHRESULT hr;\n\n\thook_init(\u0026reset, (void*)vtable[16], (void*)hook_reset,\n\t\t\t\"IDirect3DDevice9::Reset\");\n\trehook(\u0026reset);\n\n\thr = device-\u003eQueryInterface(__uuidof(IDirect3DDevice9Ex),\n\t\t\t(void**)\u0026d3d9ex);\n\tif (SUCCEEDED(hr)) {\n\t\thook_init(\u0026reset_ex, (void*)vtable[132], (void*)hook_reset_ex,\n\t\t\t\t\"IDirect3DDevice9Ex::ResetEx\");\n\t\trehook(\u0026reset_ex);\n\n\t\td3d9ex-\u003eRelease();\n\t}\n\n\thooked_reset = true;\n}\n\ntypedef HRESULT (WINAPI *d3d9create_ex_t)(UINT, IDirect3D9Ex**);\n\nstatic bool manually_get_d3d9_addrs(HMODULE d3d9_module,\n\t\tvoid **present_addr,\n\t\tvoid **present_ex_addr,\n\t\tvoid **present_swap_addr)\n{\n\td3d9create_ex_t create_ex;\n\tD3DPRESENT_PARAMETERS pp;\n\tHRESULT hr;\n\n\tIDirect3DDevice9Ex *device;\n\tIDirect3D9Ex *d3d9ex;\n\n\thlog(\"D3D9 values invalid, manually obtaining\");\n\n\tcreate_ex = (d3d9create_ex_t)GetProcAddress(d3d9_module,\n\t\t\t\"Direct3DCreate9Ex\");\n\tif (!create_ex) {\n\t\thlog(\"Failed to load Direct3DCreate9Ex\");\n\t\treturn false;\n\t}\n\tif (FAILED(create_ex(D3D_SDK_VERSION, \u0026d3d9ex))) {\n\t\thlog(\"Failed to create D3D9 context\");\n\t\treturn false;\n\t}\n\n\tmemset(\u0026pp, 0, sizeof(pp));\n\tpp.Windowed                 = 1;\n\tpp.SwapEffect               = D3DSWAPEFFECT_FLIP;\n\tpp.BackBufferFormat         = D3DFMT_A8R8G8B8;\n\tpp.BackBufferCount          = 1;\n\tpp.hDeviceWindow            = (HWND)dummy_window;\n\tpp.PresentationInterval     = D3DPRESENT_INTERVAL_IMMEDIATE;\n\n\thr = d3d9ex-\u003eCreateDeviceEx(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL,\n\t\t\tdummy_window,\n\t\t\tD3DCREATE_HARDWARE_VERTEXPROCESSING |\n\t\t\tD3DCREATE_NOWINDOWCHANGES, \u0026pp, NULL, \u0026device);\n\td3d9ex-\u003eRelease();\n\n\tif (SUCCEEDED(hr)) {\n\t\tuintptr_t *vtable = *(uintptr_t**)device;\n\t\tIDirect3DSwapChain9 *swap;\n\n\t\t*present_addr = (void*)vtable[17];\n\t\t*present_ex_addr = (void*)vtable[121];\n\n\t\thr = device-\u003eGetSwapChain(0, \u0026swap);\n\t\tif (SUCCEEDED(hr)) {\n\t\t\tvtable = *(uintptr_t**)swap;\n\t\t\t*present_swap_addr = (void*)vtable[3];\n\n\t\t\tswap-\u003eRelease();\n\t\t}\n\n\t\tdevice-\u003eRelease();\n\t} else {\n\t\thlog(\"Failed to create D3D9 device\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nbool hook_d3d9(void)\n{\n\tHMODULE d3d9_module = get_system_module(\"d3d9.dll\");\n\tuint32_t d3d9_size;\n\tvoid *present_addr = nullptr;\n\tvoid *present_ex_addr = nullptr;\n\tvoid *present_swap_addr = nullptr;\n\n\tif (!d3d9_module) {\n\t\treturn false;\n\t}\n\n\td3d9_size = module_size(d3d9_module);\n\n\tif (global_hook_info-\u003eoffsets.d3d9.present      \u003c d3d9_size \u0026\u0026\n\t    global_hook_info-\u003eoffsets.d3d9.present_ex   \u003c d3d9_size \u0026\u0026\n\t    global_hook_info-\u003eoffsets.d3d9.present_swap \u003c d3d9_size) {\n\n\t\tpresent_addr = get_offset_addr(d3d9_module,\n\t\t\t\tglobal_hook_info-\u003eoffsets.d3d9.present);\n\t\tpresent_ex_addr = get_offset_addr(d3d9_module,\n\t\t\t\tglobal_hook_info-\u003eoffsets.d3d9.present_ex);\n\t\tpresent_swap_addr = get_offset_addr(d3d9_module,\n\t\t\t\tglobal_hook_info-\u003eoffsets.d3d9.present_swap);\n\t} else {\n\t\tif (!dummy_window) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!manually_get_d3d9_addrs(d3d9_module,\n\t\t\t\t\t\u0026present_addr,\n\t\t\t\t\t\u0026present_ex_addr,\n\t\t\t\t\t\u0026present_swap_addr)) {\n\t\t\thlog(\"Failed to get D3D9 values\");\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tif (!present_addr \u0026\u0026 !present_ex_addr \u0026\u0026 !present_swap_addr) {\n\t\thlog(\"Invalid D3D9 values\");\n\t\treturn true;\n\t}\n\n\tif (present_swap_addr) {\n\t\thook_init(\u0026present_swap, present_swap_addr,\n\t\t\t\t(void*)hook_present_swap,\n\t\t\t\t\"IDirect3DSwapChain9::Present\");\n\t\trehook(\u0026present_swap);\n\t}\n\tif (present_ex_addr) {\n\t\thook_init(\u0026present_ex, present_ex_addr,\n\t\t\t\t(void*)hook_present_ex,\n\t\t\t\t\"IDirect3DDevice9Ex::PresentEx\");\n\t\trehook(\u0026present_ex);\n\t}\n\tif (present_addr) {\n\t\thook_init(\u0026present, present_addr,\n\t\t\t\t(void*)hook_present,\n\t\t\t\t\"IDirect3DDevice9::Present\");\n\t\trehook(\u0026present);\n\t}\n\n\thlog(\"Hooked D3D9\");\n\treturn true;\n}\n"}
{"repo_name":"rfloca/MITK","ref":"refs/heads/master","path":"Plugins/org.mitk.gui.qt.diffusionimagingapp/src/internal/Perspectives/QmitkDIAppConnectomicsPerspective.cpp","copies":"3","language":"C++","content":"/*===================================================================\n\nThe Medical Imaging Interaction Toolkit (MITK)\n\nCopyright (c) German Cancer Research Center,\nDivision of Medical and Biological Informatics.\nAll rights reserved.\n\nThis software is distributed WITHOUT ANY WARRANTY; without\neven the implied warranty of MERCHANTABILITY or FITNESS FOR\nA PARTICULAR PURPOSE.\n\nSee LICENSE.txt or http://www.mitk.org for details.\n\n===================================================================*/\n\n#include \"QmitkDIAppConnectomicsPerspective.h\"\n#include \"berryIViewLayout.h\"\n\nvoid QmitkDIAppConnectomicsPerspective::CreateInitialLayout(berry::IPageLayout::Pointer layout)\n{\n\n  /////////////////////////////////////////////////////\n  // all di-app perspectives should have the following:\n  /////////////////////////////////////////////////////\n\n  std::string editorArea = layout-\u003eGetEditorArea();\n\n  layout-\u003eAddStandaloneView(\"org.mitk.views.datamanager\",\n    false, berry::IPageLayout::LEFT, 0.3f, editorArea);\n\n  layout-\u003eAddStandaloneView(\"org.mitk.views.controlvisualizationpropertiesview\",\n    false, berry::IPageLayout::BOTTOM, .15f, \"org.mitk.views.datamanager\");\n\n  berry::IFolderLayout::Pointer left =\n    layout-\u003eCreateFolder(\"org.mbi.diffusionimaginginternal.leftcontrols\",\n    berry::IPageLayout::BOTTOM, 0.1f, \"org.mitk.views.controlvisualizationpropertiesview\");\n\n  layout-\u003eAddStandaloneViewPlaceholder(\"org.mitk.views.imagenavigator\",\n    berry::IPageLayout::BOTTOM, .4f, \"org.mbi.diffusionimaginginternal.leftcontrols\", false);\n\n  /////////////////////////////////////////////\n  // here goes the perspective specific stuff\n  /////////////////////////////////////////////\n\n  left-\u003eAddView(\"org.mitk.views.connectomicsstatistics\");\n  berry::IViewLayout::Pointer lo = layout-\u003eGetViewLayout(\"org.mitk.views.connectomicsstatistics\");\n  lo-\u003eSetCloseable(false);\n\n  left-\u003eAddView(\"org.mitk.views.connectomicsnetworkoperations\");\n  lo = layout-\u003eGetViewLayout(\"org.mitk.views.connectomicsnetworkoperations\");\n  lo-\u003eSetCloseable(false);\n\n  left-\u003eAddView(\"org.mitk.views.connectomicsdata\");\n  lo = layout-\u003eGetViewLayout(\"org.mitk.views.connectomicsdata\");\n  lo-\u003eSetCloseable(false);\n}\n"}
{"repo_name":"hkernbach/arangodb","ref":"refs/heads/devel","path":"3rdParty/boost/1.62.0/libs/phoenix/test/include/core/visit_each.cpp","copies":"59","language":"C++","content":"/*=============================================================================\n    Copyright (c) 2011 Thomas Heller\n    Distributed under the Boost Software License, Version 1.0. (See accompanying\n    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n==============================================================================*/\n#include \u003cboost/phoenix/core/visit_each.hpp\u003e\nint main() {}\n"}
{"repo_name":"ellipsis14/dolfin","ref":"refs/heads/master","path":"test/unit/la/cpp/Vector.cpp","copies":"2","language":"C++","content":"// Copyright (C) 2007 Johan Hake\n//\n// This file is part of DOLFIN.\n//\n// DOLFIN is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// DOLFIN is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with DOLFIN. If not, see \u003chttp://www.gnu.org/licenses/\u003e.\n//\n// First added:  2008-09-30\n// Last changed: 2012-08-21\n//\n// Unit tests Selected methods for GenericVector\n\n#include \u003cdolfin.h\u003e\n#include \u003cdolfin/common/unittest.h\u003e\n\nusing namespace dolfin;\n\nclass TestVector : public CppUnit::TestFixture\n{\n  CPPUNIT_TEST_SUITE(TestVector);\n  CPPUNIT_TEST(test_backends);\n  CPPUNIT_TEST(test_init);\n  CPPUNIT_TEST(test_get_local_empty);\n  CPPUNIT_TEST_SUITE_END();\n\npublic:\n\n  void test_backends()\n  {\n    // Eigen\n    parameters[\"linear_algebra_backend\"] = \"Eigen\";\n    _test_operators(MPI_COMM_SELF);\n\n    // FIXME: Outcommented STL backend to circumvent infinite loops as\n    // FIXME: seen on one buildbot\n    // STL\n    //parameters[\"linear_algebra_backend\"] = \"STL\";\n    //_test_operators();\n\n    // PETSc\n    #ifdef HAS_PETSC\n    parameters[\"linear_algebra_backend\"] = \"PETSc\";\n    _test_operators(MPI_COMM_WORLD);\n    #endif\n  }\n\n  void _test_operators(MPI_Comm comm)\n  {\n    Vector v(comm, 10), u(comm, 10);\n    v = 0.0;\n    u = 0.0;\n    CPPUNIT_ASSERT(v.sum() == 0.0);\n\n    // operator=(double a)\n    v = 1.0;\n    CPPUNIT_ASSERT(v.sum() == v.size());\n\n    // operator=(const GenericVector\u0026 x)\n    u = v;\n    CPPUNIT_ASSERT(u.sum() == u.size());\n\n    // operator+=(const GenericVector\u0026 x)\n    u += v;\n    CPPUNIT_ASSERT(u.sum() == 2*u.size());\n\n    // operator-=(const GenericVector\u0026 x)\n    u -= v;\n    u -= v;\n    CPPUNIT_ASSERT(u.sum() == 0.0);\n\n    // operator*=(double a)\n    v *= 5.0;\n    CPPUNIT_ASSERT(v.sum() == v.size()*5.0);\n\n    // operator/=(double a)\n    v /= 2.0;\n    CPPUNIT_ASSERT(v.sum() == 2.5*v.size());\n\n    // operator*=(const GenericVector\u0026 x)\n    u = 2.0;\n    v*=u;\n    CPPUNIT_ASSERT(v.sum() == v.size()*5.0);\n\n  }\n\n  void test_init()\n  {\n    // Create local and distributed vector layouts\n    const std::vector\u003cstd::size_t\u003e dims(1, 203);\n\n    // Create local vector layout\n    TensorLayout layout_local(0, false);\n    std::vector\u003cstd::pair\u003cstd::size_t, std::size_t\u003e \u003e\n      local_range(1, std::make_pair(0, 203));\n    layout_local.init(MPI_COMM_SELF, dims, 1, local_range);\n\n    // Create distributed vector layout\n    TensorLayout layout_distributed(0, false);\n    std::vector\u003cstd::pair\u003cstd::size_t, std::size_t\u003e \u003e\n      ownership_range(1, dolfin::MPI::local_range(MPI_COMM_WORLD, 203));\n    layout_distributed.init(MPI_COMM_WORLD, dims, 1, ownership_range);\n\n    // Vector\n    #ifdef HAS_PETSC\n    parameters[\"linear_algebra_backend\"] = \"PETSc\";\n    {\n      Vector x;\n      x.init(layout_local);\n      CPPUNIT_ASSERT(x.size() == 203);\n\n      Vector y;\n      y.init(layout_distributed);\n      CPPUNIT_ASSERT(y.size() == 203);\n    }\n    #endif\n\n    // Eigen\n    {\n      EigenVector x;\n      x.init(layout_local);\n      CPPUNIT_ASSERT(x.size() == 203);\n    }\n\n    // PETSc\n    #ifdef HAS_PETSC\n    {\n      PETScVector x;\n      x.init(layout_local);\n      CPPUNIT_ASSERT(x.size() == 203);\n\n      PETScVector y;\n      y.init(layout_distributed);\n      CPPUNIT_ASSERT(y.size() == 203);\n    }\n    #endif\n\n  }\n\n  void test_get_local_empty()\n  {\n    // Create local and distributed vector layouts\n    const std::vector\u003cstd::size_t\u003e dims(1, 203);\n\n    // Create local vector layout\n    TensorLayout layout_local(0, false);\n    std::vector\u003cstd::pair\u003cstd::size_t, std::size_t\u003e \u003e\n      local_range(1, std::make_pair(0, 203));\n    layout_local.init(MPI_COMM_SELF, dims, 1, local_range);\n\n    // Create distributed vector layout\n    TensorLayout layout_distributed(0, false);\n    std::vector\u003cstd::pair\u003cstd::size_t, std::size_t\u003e \u003e\n      ownership_range(1, dolfin::MPI::local_range(MPI_COMM_WORLD, 203));\n    layout_distributed.init(MPI_COMM_WORLD, dims, 1, ownership_range);\n\n    // Vector\n    #ifdef HAS_PETSC\n    parameters[\"linear_algebra_backend\"] = \"PETSc\";\n    {\n      Vector x;\n      x.init(layout_local);\n      CPPUNIT_ASSERT(x.size() == 203);\n\n      Vector y;\n      y.init(layout_distributed);\n      CPPUNIT_ASSERT(y.size() == 203);\n\n      //:get_local(double* block, std::size_t m,\n      //           const dolfin::la_index* rows) const\n\n      double* block = NULL;\n      dolfin::la_index* rows = NULL;\n      x.get_local(block, 0, rows);\n      y.get_local(block, 0, rows);\n\n    }\n    #endif\n\n  }\n\n\n};\n\nCPPUNIT_TEST_SUITE_REGISTRATION(TestVector);\n\nint main()\n{\n  DOLFIN_TEST;\n}\n"}
{"repo_name":"OpenDSA/OpenDSA-stable","ref":"refs/heads/master","path":"SourceCode/C++/Sorting/Heapsort.cpp","copies":"5","language":"C++","content":"#include \"Maxheap.cpp\"\n\n\n/* *** ODSATag: Heapsort *** */\nvoid heapsort(Comparable* A[], int n) {\n  std::cout \u003c\u003c \"Getting started with array:\" \u003c\u003c std::endl;\n  for (int j = 0; j\u003cn; j++)\n    std::cout \u003c\u003c *A[j] \u003c\u003c \" \";\n  std::cout \u003c\u003c std::endl;\n  MaxHeap H(A,n,n);\n  std::cout \u003c\u003c \"Now, ready to unpack the heap\" \u003c\u003c std::endl;\n  for (int i = 0; i \u003c n; i++)\n     H.removemax();\n}\n/* *** ODSAendTag: Heapsort *** */\n\n// With KVPair\n\nbool sorttest(int array[], int n, int threshold) {\n  Comparable* A[n];\n  int i;\n\n  cout \u003c\u003c \"We came in with array:\" \u003c\u003c endl;\n  for (i = 0; i\u003cn; i++)\n    std::cout \u003c\u003c array[i] \u003c\u003c \" \";\n  std::cout \u003c\u003c std::endl;\n\n\n  /* Sort an array of Ints */\n  for (i = 0; i \u003c n; ++i) {\n    A[i] = new Int(array[i]);\n  }\n\n  cout \u003c\u003c \"We are going to call Heapsort with this array:\" \u003c\u003c endl;\n  for (i = 0; i\u003cn; i++)\n    std::cout \u003c\u003c A[i] \u003c\u003c \" \";\n  std::cout \u003c\u003c std::endl;\n\n  //  for (i = 0; i \u003c n; ++i) {\n  //    cout \u003c\u003c *A[i] \u003c\u003c \" \";\n  //  }\n  //  cout \u003c\u003c std::endl;\n\n  heapsort(A, n);\n\n  if (!checkorder(A, n)) return false;\n\n  for (i = 0; i \u003c n; ++i) {\n    delete A[i];\n  }\n\n  /* Sort an array of KVPairs */\n\n  for (i = 0; i \u003c n; ++i) {\n    A[i] = new KVPair(array[i], \u0026array[i]);\n  }\n\n  //heapsort(A, n);\n\n  if (!checkorder(A, n)) return false;\n\n  for (i = 0; i \u003c n; ++i) {\n    delete A[i];\n  }\n\n  delete[] array;\n\n  return true;\n}\n\n#include \"SortTest.cpp\"\n"}
{"repo_name":"lassoan/CTK","ref":"refs/heads/master","path":"Plugins/org.commontk.plugingenerator.ui/ctkPluginGeneratorUiPlugin.cpp","copies":"6","language":"C++","content":"/*=============================================================================\n\n  Library: CTK\n\n  Copyright (c) German Cancer Research Center,\n    Division of Medical and Biological Informatics\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n=============================================================================*/\n\n\n#include \"ctkPluginGeneratorUiPlugin_p.h\"\n\n#include \"ctkPluginGeneratorMainExtension.h\"\n\n#include \u003cctkPluginConstants.h\u003e\n\n#include \u003cQtPlugin\u003e\n#include \u003cQDebug\u003e\n\nvoid ctkPluginGeneratorUiPlugin::start(ctkPluginContext* context)\n{\n  mainExtension = new ctkPluginGeneratorMainExtension();\n\n  ctkDictionary props;\n  props.insert(ctkPluginConstants::SERVICE_RANKING, 0);\n  context-\u003eregisterService(QStringList(\"ctkPluginGeneratorAbstractUiExtension\"),\n                           mainExtension, props);\n\n  qDebug() \u003c\u003c \"Registered Main Extension\";\n}\n\nvoid ctkPluginGeneratorUiPlugin::stop(ctkPluginContext* context)\n{\n  Q_UNUSED(context)\n\n  delete mainExtension;\n}\n\nQ_EXPORT_PLUGIN2(org_commontk_plugingenerator_ui, ctkPluginGeneratorUiPlugin)\n"}
{"repo_name":"Sumahitha/samples","ref":"refs/heads/develop","path":"AllJoyn/Samples/BACnetAdapter/HeadlessAdapterApp/pch.cpp","copies":"222","language":"C++","content":"﻿// Copyright (c) 2015, Microsoft Corporation\n//\n// Permission to use, copy, modify, and/or distribute this software for any\n// purpose with or without fee is hereby granted, provided that the above\n// copyright notice and this permission notice appear in all copies.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY\n// SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR\n// IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n//\n\n#include \"pch.h\"\n"}
{"repo_name":"sjsinju/coreclr","ref":"refs/heads/master","path":"src/pal/tests/palsuite/c_runtime/fmod/test1/test1.cpp","copies":"121","language":"C++","content":"// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\n// See the LICENSE file in the project root for more information.\n\n/*=============================================================================\n**\n** Source: test1.c\n**\n** Purpose: Test to ensure that fmod return the correct values\n** \n** Dependencies: PAL_Initialize\n**               PAL_Terminate\n**               Fail\n**               fabs\n**\n**===========================================================================*/\n\n#include \u003cpalsuite.h\u003e\n\n// binary64 (double) has a machine epsilon of 2^-52 (approx. 2.22e-16). However, this \n// is slightly too accurate when writing tests meant to run against libm implementations\n// for various platforms. 2^-50 (approx. 8.88e-16) seems to be as accurate as we can get.\n//\n// The tests themselves will take PAL_EPSILON and adjust it according to the expected result\n// so that the delta used for comparison will compare the most significant digits and ignore\n// any digits that are outside the double precision range (15-17 digits).\n\n// For example, a test with an expect result in the format of 0.xxxxxxxxxxxxxxxxx will use\n// PAL_EPSILON for the variance, while an expected result in the format of 0.0xxxxxxxxxxxxxxxxx\n// will use PAL_EPSILON / 10 and and expected result in the format of x.xxxxxxxxxxxxxxxx will\n// use PAL_EPSILON * 10.\n#define PAL_EPSILON 8.8817841970012523e-16\n\n#define PAL_NAN     sqrt(-1.0)\n#define PAL_POSINF -log(0.0)\n#define PAL_NEGINF  log(0.0)\n\n/**\n * Helper test structure\n */\nstruct test\n{\n    double numerator;    /* second component of the value to test the function with */\n    double denominator;  /* first component of the value to test the function with */\n    double expected;     /* expected result */\n    double variance;     /* maximum delta between the expected and actual result */\n};\n\n/**\n * validate\n *\n * test validation function\n */\nvoid __cdecl validate(double numerator, double denominator, double expected, double variance)\n{\n    double result = fmod(numerator, denominator);\n\n    /*\n     * The test is valid when the difference between result\n     * and expected is less than or equal to variance\n     */\n    double delta = fabs(result - expected);\n\n    if (delta \u003e variance)\n    {\n        Fail(\"fmod(%g, %g) returned %20.17g when it should have returned %20.17g\",\n             numerator, denominator, result, expected);\n    }\n}\n\n/**\n * validate\n *\n * test validation function for values returning NaN\n */\nvoid __cdecl validate_isnan(double numerator, double denominator)\n{\n    double result = fmod(numerator, denominator);\n\n    if (!_isnan(result))\n    {\n        Fail(\"fmod(%g, %g) returned %20.17g when it should have returned %20.17g\",\n             numerator, denominator, result, PAL_NAN);\n    }\n}\n\n/**\n * main\n * \n * executable entry point\n */\nINT __cdecl main(INT argc, CHAR **argv)\n{\n    struct test tests[] = \n    {\n        /* numerator               denominator             expected                 variance */\n        {  0,                      PAL_POSINF,             0,                       PAL_EPSILON },\n        {  0.31296179620778659,    0.94976571538163866,    0.31296179620778658,     PAL_EPSILON },\n        {  0.42077048331375735,    0.90716712923909839,    0.42077048331375733,     PAL_EPSILON },\n        {  0.59448076852482208,    0.80410982822879171,    0.59448076852482212,     PAL_EPSILON },\n        {  0.63896127631363480,    0.76923890136397213,    0.63896127631363475,     PAL_EPSILON },\n        {  0.64963693908006244,    0.76024459707563015,    0.64963693908006248,     PAL_EPSILON },\n        {  0.70710678118654752,    0.70710678118654752,    0,                       PAL_EPSILON },\n        {  1,                      1,                      0,                       PAL_EPSILON },\n        {  0.84147098480789651,    0.54030230586813972,    0.30116867893975674,     PAL_EPSILON },\n        {  0.90371945743584630,    0.42812514788535792,    0.047469161665130377,    PAL_EPSILON / 10 },\n        {  0.98776594599273553,    0.15594369476537447,    0.052103777400488605,    PAL_EPSILON / 10 },\n        {  0.99180624439366372,    0.12775121753523991,    0.097547721646984359,    PAL_EPSILON / 10 },\n        {  0.74398033695749319,   -0.66820151019031295,    0.075778826767180285,    PAL_EPSILON / 10 },\n        {  0.41078129050290870,   -0.91173391478696510,    0.41078129050290868,     PAL_EPSILON },\n        {  0,                     -1,                      0,                       PAL_EPSILON },\n        {  1,                      PAL_POSINF,             1,                       PAL_EPSILON * 10 },\n    };\n\n\n    // PAL initialization\n    if (PAL_Initialize(argc, argv) != 0)\n    {\n        return FAIL;\n    }\n\n    for (int i = 0; i \u003c (sizeof(tests) / sizeof(struct test)); i++)\n    {\n        validate( tests[i].numerator,  tests[i].denominator,  tests[i].expected, tests[i].variance);\n        validate(-tests[i].numerator,  tests[i].denominator, -tests[i].expected, tests[i].variance);\n        validate( tests[i].numerator, -tests[i].denominator,  tests[i].expected, tests[i].variance);\n        validate(-tests[i].numerator, -tests[i].denominator, -tests[i].expected, tests[i].variance);\n    }\n\n    validate_isnan( 0,    0);\n    validate_isnan(-0.0,  0);\n    validate_isnan( 0,   -0.0);\n    validate_isnan(-0.0, -0.0);\n    \n    validate_isnan( 1,    0);\n    validate_isnan(-1.0,  0);\n    validate_isnan( 1,   -0.0);\n    validate_isnan(-1.0, -0.0);\n    \n    validate_isnan(PAL_POSINF,  PAL_POSINF);\n    validate_isnan(PAL_NEGINF,  PAL_POSINF);\n    validate_isnan(PAL_POSINF, PAL_NEGINF);\n    validate_isnan(PAL_NEGINF, PAL_NEGINF);\n    \n    validate_isnan(PAL_POSINF,  0);\n    validate_isnan(PAL_NEGINF,  0);\n    validate_isnan(PAL_POSINF, -0.0);\n    validate_isnan(PAL_NEGINF, -0.0);\n    \n    validate_isnan(PAL_POSINF,  1);\n    validate_isnan(PAL_NEGINF,  1);\n    validate_isnan(PAL_POSINF, -1.0);\n    validate_isnan(PAL_NEGINF, -1.0);\n    \n    PAL_Terminate();\n    return PASS;\n}\n"}
{"repo_name":"KDE/koffice","ref":"refs/heads/master","path":"kcells/dialogs/StyleManagerDialog.cpp","copies":"1","language":"C++","content":"/* This file is part of the KDE project\n   Copyright 2007 Stefan Nikolaus \u003cstefan.nikolaus@kdemail.net\u003e\n   Copyright 2003 Laurent Montel \u003cmontel@kde.org\u003e\n   Copyright 2003 Norbert Andres \u003cnandres@web.de\u003e\n\n   This library is free software; you can redistribute it and/or\n   modify it under the terms of the GNU Library General Public\n   License as published by the Free Software Foundation; either\n   version 2 of the License, or (at your option) any later version.\n\n   This library is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   Library General Public License for more details.\n\n   You should have received a copy of the GNU Library General Public License\n   along with this library; see the file COPYING.LIB.  If not, write to\n   the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n   Boston, MA 02110-1301, USA.\n*/\n\n#include \"StyleManagerDialog.h\"\n\n#include \u003cQMap\u003e\n#include \u003cQTreeWidget\u003e\n#include \u003cQVBoxLayout\u003e\n\n#include \u003ckcombobox.h\u003e\n#include \u003ckdebug.h\u003e\n#include \u003cklocale.h\u003e\n\n#include \"KCCell.h\"\n#include \"LayoutDialog.h\"\n#include \"ui/Selection.h\"\n#include \"KCSheet.h\"\n#include \"KCStyle.h\"\n#include \"KCStyleManager.h\"\n\n#include \"commands/KCStyleCommand.h\"\n\nStyleManagerDialog::StyleManagerDialog(QWidget* parent, Selection* selection, KCStyleManager* manager)\n        : KDialog(parent)\n        , m_selection(selection)\n        , m_styleManager(manager)\n{\n    setButtons(Apply | User1 | User2 | User3 | Close);\n    setButtonText(User3, i18n(\"\u0026New...\"));\n    setButtonText(User2, i18n(\"\u0026Modify...\"));\n    setButtonText(User1, i18n(\"\u0026Delete...\"));\n    setButtonsOrientation(Qt::Vertical);\n    setCaption(i18n(\"Style Manager\"));\n\n    QWidget* widget = new QWidget(this);\n    setMainWidget(widget);\n\n    QVBoxLayout* layout = new QVBoxLayout(widget);\n\n    m_styleList = new QTreeWidget(this);\n    m_styleList-\u003esetHeaderLabel(i18n(\"Style\"));\n    layout-\u003eaddWidget(m_styleList);\n\n    m_displayBox = new KComboBox(false, this);\n    m_displayBox-\u003einsertItem(0, i18n(\"All Styles\"));\n    m_displayBox-\u003einsertItem(1, i18n(\"Custom Styles\"));\n    m_displayBox-\u003einsertItem(2, i18n(\"Hierarchical\"));\n    layout-\u003eaddWidget(m_displayBox);\n\n    slotDisplayMode(0);\n    enableButton(KDialog::User3, true);\n    enableButton(KDialog::User2, true);\n    enableButton(KDialog::User1, false);\n\n    connect(m_displayBox, SIGNAL(activated(int)),\n            this, SLOT(slotDisplayMode(int)));\n    connect(this, SIGNAL(applyClicked()),\n            this, SLOT(slotOk()));\n    connect(this, SIGNAL(user3Clicked()),\n            this, SLOT(slotNew()));\n    connect(this, SIGNAL(user2Clicked()),\n            this, SLOT(slotEdit()));\n    connect(this, SIGNAL(user1Clicked()),\n            this, SLOT(slotRemove()));\n    connect(m_styleList, SIGNAL(itemDoubleClicked(QTreeWidgetItem*, int)),\n            this, SLOT(slotEdit()));\n    connect(m_styleList, SIGNAL(currentItemChanged(QTreeWidgetItem*, QTreeWidgetItem*)),\n            this, SLOT(selectionChanged(QTreeWidgetItem*)));\n}\n\nStyleManagerDialog::~StyleManagerDialog()\n{\n}\n\nvoid StyleManagerDialog::fillComboBox()\n{\n    typedef QMap\u003cKCCustomStyle*, QTreeWidgetItem*\u003e KCMap;\n    KCMap entries;\n\n    entries.clear();\n    entries[m_styleManager-\u003edefaultStyle()] = new QTreeWidgetItem(m_styleList, QStringList(i18n(\"Default\")));\n\n    CustomStyles::const_iterator iter = m_styleManager-\u003em_styles.constBegin();\n    CustomStyles::const_iterator end  = m_styleManager-\u003em_styles.constEnd();\n\n    while (entries.count() != m_styleManager-\u003em_styles.count() + 1) {\n        if (entries.find(iter.value()) == entries.end()) {\n            if (iter.value()-\u003eparentName().isNull())\n                entries[iter.value()] = new QTreeWidgetItem(entries[m_styleManager-\u003edefaultStyle()],\n                        QStringList(iter.value()-\u003ename()));\n            else {\n                KCCustomStyle* parentStyle = m_styleManager-\u003estyle(iter.value()-\u003eparentName());\n                if (parentStyle) {\n                    KCMap::const_iterator i = entries.constFind(parentStyle);\n                    if (i != entries.constEnd())\n                        entries[iter.value()] = new QTreeWidgetItem(i.value(), QStringList(iter.value()-\u003ename()));\n                }\n            }\n        }\n\n        ++iter;\n        if (iter == end)\n            iter = m_styleManager-\u003em_styles.constBegin();\n    }\n    entries.clear();\n}\n\nvoid StyleManagerDialog::slotDisplayMode(int mode)\n{\n    m_styleList-\u003eclear();\n\n    if (mode != 2) // NOT \"Hierarchical\"\n        m_styleList-\u003esetRootIsDecorated(false);\n    else { // \"Hierarchical\"\n        m_styleList-\u003esetRootIsDecorated(true);\n        fillComboBox();\n        return;\n    }\n\n    if (mode != 1) // NOT \"Custom Styles\"\n        new QTreeWidgetItem(m_styleList, QStringList(i18n(\"Default\")));\n\n    CustomStyles::iterator iter = m_styleManager-\u003em_styles.begin();\n    CustomStyles::iterator end  = m_styleManager-\u003em_styles.end();\n\n    while (iter != end) {\n        KCCustomStyle* styleData = iter.value();\n        if (!styleData || styleData-\u003ename().isEmpty()) {\n            ++iter;\n            continue;\n        }\n\n        if (mode == 1) { // \"Custom Styles\"\n            if (styleData-\u003etype() == KCStyle::CUSTOM)\n                new QTreeWidgetItem(m_styleList, QStringList(styleData-\u003ename()));\n        } else\n            new QTreeWidgetItem(m_styleList, QStringList(styleData-\u003ename()));\n\n        ++iter;\n    }\n}\n\nvoid StyleManagerDialog::slotOk()\n{\n    kDebug() ;\n    QTreeWidgetItem* item = m_styleList-\u003ecurrentItem();\n\n    if (!item) {\n        accept();\n        return;\n    }\n\n    QString name(item-\u003etext(0));\n    if (name == i18n(\"Default\")) {\n        KCStyleCommand* command = new KCStyleCommand();\n        command-\u003esetSheet(m_selection-\u003eactiveSheet());\n        command-\u003esetDefault();\n        command-\u003eadd(*m_selection);\n        command-\u003eexecute(m_selection-\u003ecanvas());\n    } else {\n        KCStyleCommand* command = new KCStyleCommand();\n        command-\u003esetSheet(m_selection-\u003eactiveSheet());\n        command-\u003esetParentName(name);\n        command-\u003eadd(*m_selection);\n        command-\u003eexecute(m_selection-\u003ecanvas());\n    }\n    accept();\n}\n\nvoid StyleManagerDialog::slotNew()\n{\n    KCCustomStyle* parentStyle = 0;\n    QTreeWidgetItem* item = m_styleList-\u003ecurrentItem();\n    if (item) {\n        const QString name = item-\u003etext(0);\n        if (name == i18n(\"Default\"))\n            parentStyle = m_styleManager-\u003edefaultStyle();\n        else\n            parentStyle = m_styleManager-\u003estyle(name);\n    } else\n        parentStyle = m_styleManager-\u003edefaultStyle();\n\n    int i = 1;\n    QString newName(i18n(\"style%1\" , m_styleManager-\u003ecount() + i));\n    while (m_styleManager-\u003estyle(newName) != 0) {\n        ++i;\n        newName = i18n(\"style%1\" , m_styleManager-\u003ecount() + i);\n    }\n\n    KCCustomStyle* style = new KCCustomStyle(newName, parentStyle);\n    style-\u003esetType(KCStyle::TENTATIVE);\n\n    QPointer\u003cCellFormatDialog\u003e dialog = new CellFormatDialog(this, m_selection, style, m_styleManager);\n    dialog-\u003eexec();\n    delete dialog;\n\n    if (style-\u003etype() == KCStyle::TENTATIVE) {\n        delete style;\n        return;\n    }\n\n    m_styleManager-\u003em_styles[ style-\u003ename()] = style;\n\n    slotDisplayMode(m_displayBox-\u003ecurrentIndex());\n}\n\nvoid StyleManagerDialog::slotEdit()\n{\n    QTreeWidgetItem* item = m_styleList-\u003ecurrentItem();\n\n    if (!item)\n        return;\n\n    KCCustomStyle* style = 0;\n\n    QString name(item-\u003etext(0));\n    if (name == i18n(\"Default\"))\n        style = m_styleManager-\u003edefaultStyle();\n    else\n        style = m_styleManager-\u003estyle(name);\n\n    if (!style)\n        return;\n\n    QPointer\u003cCellFormatDialog\u003e dialog = new CellFormatDialog(this, m_selection, style, m_styleManager);\n    dialog-\u003eexec();\n\n    if (dialog-\u003eresult() == Accepted)\n        m_selection-\u003eemitRefreshSheetViews();\n\n    slotDisplayMode(m_displayBox-\u003ecurrentIndex());\n    delete dialog;\n}\n\nvoid StyleManagerDialog::slotRemove()\n{\n    QTreeWidgetItem* item = m_styleList-\u003ecurrentItem();\n    if (!item)\n        return;\n\n    const QString name = item-\u003etext(0);\n    KCCustomStyle* style = 0;\n    if (name == i18n(\"Default\"))\n        style = m_styleManager-\u003edefaultStyle();\n    else\n        style = m_styleManager-\u003estyle(name);\n\n    if (!style)\n        return;\n\n    if (style-\u003etype() != KCStyle::CUSTOM)\n        return;\n\n    m_styleManager-\u003etakeStyle(style);\n    slotDisplayMode(m_displayBox-\u003ecurrentIndex());\n}\n\nvoid StyleManagerDialog::selectionChanged(QTreeWidgetItem* item)\n{\n    if (!item)\n        return;\n    const QString name = item-\u003etext(0);\n    KCCustomStyle* style = 0;\n    if (name == i18n(\"Default\"))\n        style = m_styleManager-\u003edefaultStyle();\n    else\n        style = m_styleManager-\u003estyle(name);\n    if (!style) {\n        enableButton(KDialog::User1, false);\n        return;\n    }\n\n    if (style-\u003etype() == KCStyle::BUILTIN)\n        enableButton(KDialog::User1, false);\n    else\n        enableButton(KDialog::User1, true);\n}\n\n#include \"StyleManagerDialog.moc\"\n"}
{"repo_name":"KonceptGeek/mosesdecoder","ref":"refs/heads/master","path":"mert/TER/infosHasher.cpp","copies":"9","language":"C++","content":"/*********************************\ntercpp: an open-source Translation Edit Rate (TER) scorer tool for Machine Translation.\n\nCopyright 2010-2013, Christophe Servan, LIUM, University of Le Mans, France\nContact: christophe.servan@lium.univ-lemans.fr\n\nThe tercpp tool and library are free software: you can redistribute it and/or modify it\nunder the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 2.1 of the licence, or\n(at your option) any later version.\n\nThis program and library are distributed in the hope that it will be useful, but WITHOUT\nANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License\nfor more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with this library; if not, write to the Free Software Foundation,\nInc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\n**********************************/\n#include \"infosHasher.h\"\n// The following class defines a hash function for strings\n\n\nusing namespace std;\nusing namespace TERCPPNS_Tools;\n\nnamespace TERCPPNS_HashMapSpace\n{\ninfosHasher::infosHasher (long cle,string cleTxt, vector\u003cint\u003e valueVecInt )\n{\n  m_hashKey=cle;\n  m_key=cleTxt;\n  m_value=valueVecInt;\n}\n//     infosHasher::~infosHasher(){};*/\nlong  infosHasher::getHashKey()\n{\n  return m_hashKey;\n}\nstring  infosHasher::getKey()\n{\n  return m_key;\n}\nvector\u003cint\u003e infosHasher::getValue()\n{\n  return m_value;\n}\nvoid infosHasher::setValue ( vector\u003cint\u003e   value )\n{\n  m_value=value;\n}\nstring infosHasher::toString()\n{\n  stringstream to_return;\n  to_return \u003c\u003c m_hashKey \u003c\u003c \"\\t\" \u003c\u003c m_key \u003c\u003c \"\\t\" \u003c\u003c vectorToString(m_value,\"\\t\") \u003c\u003c endl;\n  return to_return.str();\n}\n\n\n// typedef stdext::hash_map\u003cstd::string,string, stringhasher\u003e HASH_S_S;\n}\n"}
{"repo_name":"bredelings/BAli-Phy","ref":"refs/heads/master","path":"external/range-v3/0.4.0/test/algorithm/minmax.cpp","copies":"1","language":"C++","content":"// Range v3 library\n//\n//  Copyright Eric Niebler 2014-present\n//  Copyright Casey Carter 2015\n//\n//  Use, modification and distribution is subject to the\n//  Boost Software License, Version 1.0. (See accompanying\n//  file LICENSE_1_0.txt or copy at\n//  http://www.boost.org/LICENSE_1_0.txt)\n//\n// Project home: https://github.com/ericniebler/range-v3\n\n//===----------------------------------------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#include \u003crange/v3/algorithm/minmax.hpp\u003e\n#include \u003cmemory\u003e\n#include \u003cnumeric\u003e\n#include \u003crandom\u003e\n#include \u003calgorithm\u003e\n#include \"../simple_test.hpp\"\n#include \"../test_utils.hpp\"\n#include \"../test_iterators.hpp\"\n\nRANGES_DIAGNOSTIC_IGNORE_GLOBAL_CONSTRUCTORS\n\nnamespace\n{\n    std::mt19937 gen;\n\n    template\u003cclass Iter, class Sent = Iter\u003e\n    void\n    test_iter(Iter first, Sent last)\n    {\n        RANGES_ENSURE(first != last);\n        auto rng = ranges::make_iterator_range(first, last);\n        auto res = ranges::minmax(rng);\n        for (Iter i = first; i != last; ++i) {\n            CHECK(!(*i \u003c res.first));\n            CHECK(!(res.second \u003c *i));\n        }\n    }\n\n    template\u003cclass Iter, class Sent = Iter\u003e\n    void\n    test_iter(unsigned N)\n    {\n        RANGES_ENSURE(N \u003e 0);\n        std::unique_ptr\u003cint[]\u003e a{new int[N]};\n        std::iota(a.get(), a.get()+N, 0);\n        std::shuffle(a.get(), a.get()+N, gen);\n        test_iter(Iter(a.get()), Sent(a.get()+N));\n    }\n\n    template\u003cclass Iter, class Sent = Iter\u003e\n    void\n    test_iter()\n    {\n        test_iter\u003cIter, Sent\u003e(1);\n        test_iter\u003cIter, Sent\u003e(2);\n        test_iter\u003cIter, Sent\u003e(3);\n        test_iter\u003cIter, Sent\u003e(10);\n        test_iter\u003cIter, Sent\u003e(1000);\n    }\n\n    template\u003cclass Iter, class Sent = Iter\u003e\n    void\n    test_iter_comp(Iter first, Sent last)\n    {\n        RANGES_ENSURE(first != last);\n        typedef std::greater\u003cint\u003e Compare;\n        Compare comp;\n        auto rng = ranges::make_iterator_range(first, last);\n        auto res = ranges::minmax(rng, comp);\n        for (Iter i = first; i != last; ++i) {\n            CHECK(!comp(*i, res.first));\n            CHECK(!comp(res.second, *i));\n        }\n    }\n\n    template\u003cclass Iter, class Sent = Iter\u003e\n    void\n    test_iter_comp(unsigned N)\n    {\n        RANGES_ENSURE(N \u003e 0);\n        std::unique_ptr\u003cint[]\u003e a{new int[N]};\n        std::iota(a.get(), a.get()+N, 0);\n        std::shuffle(a.get(), a.get()+N, gen);\n        test_iter_comp(Iter(a.get()), Sent(a.get()+N));\n    }\n\n    template\u003cclass Iter, class Sent = Iter\u003e\n    void\n    test_iter_comp()\n    {\n        test_iter_comp\u003cIter, Sent\u003e(1);\n        test_iter_comp\u003cIter, Sent\u003e(2);\n        test_iter_comp\u003cIter, Sent\u003e(3);\n        test_iter_comp\u003cIter, Sent\u003e(10);\n        test_iter_comp\u003cIter, Sent\u003e(1000);\n    }\n\n    struct S\n    {\n        int value;\n        int index;\n    };\n}\n\nint main()\n{\n    test_iter\u003cinput_iterator\u003cconst int*\u003e \u003e();\n    test_iter\u003cforward_iterator\u003cconst int*\u003e \u003e();\n    test_iter\u003cbidirectional_iterator\u003cconst int*\u003e \u003e();\n    test_iter\u003crandom_access_iterator\u003cconst int*\u003e \u003e();\n    test_iter\u003cconst int*\u003e();\n    test_iter\u003cinput_iterator\u003cconst int*\u003e, sentinel\u003cconst int*\u003e\u003e();\n    test_iter\u003cforward_iterator\u003cconst int*\u003e, sentinel\u003cconst int*\u003e\u003e();\n    test_iter\u003cbidirectional_iterator\u003cconst int*\u003e, sentinel\u003cconst int*\u003e\u003e();\n    test_iter\u003crandom_access_iterator\u003cconst int*\u003e, sentinel\u003cconst int*\u003e\u003e();\n\n    test_iter\u003cinput_iterator\u003cconst int*\u003e \u003e();\n    test_iter\u003cforward_iterator\u003cconst int*\u003e \u003e();\n    test_iter\u003cbidirectional_iterator\u003cconst int*\u003e \u003e();\n    test_iter\u003crandom_access_iterator\u003cconst int*\u003e \u003e();\n    test_iter\u003cconst int*\u003e();\n    test_iter\u003cinput_iterator\u003cconst int*\u003e, sentinel\u003cconst int*\u003e\u003e();\n    test_iter\u003cforward_iterator\u003cconst int*\u003e, sentinel\u003cconst int*\u003e\u003e();\n    test_iter\u003cbidirectional_iterator\u003cconst int*\u003e, sentinel\u003cconst int*\u003e\u003e();\n    test_iter\u003crandom_access_iterator\u003cconst int*\u003e, sentinel\u003cconst int*\u003e\u003e();\n\n    test_iter_comp\u003cinput_iterator\u003cconst int*\u003e \u003e();\n    test_iter_comp\u003cforward_iterator\u003cconst int*\u003e \u003e();\n    test_iter_comp\u003cbidirectional_iterator\u003cconst int*\u003e \u003e();\n    test_iter_comp\u003crandom_access_iterator\u003cconst int*\u003e \u003e();\n    test_iter_comp\u003cconst int*\u003e();\n    test_iter_comp\u003cinput_iterator\u003cconst int*\u003e, sentinel\u003cconst int*\u003e\u003e();\n    test_iter_comp\u003cforward_iterator\u003cconst int*\u003e, sentinel\u003cconst int*\u003e\u003e();\n    test_iter_comp\u003cbidirectional_iterator\u003cconst int*\u003e, sentinel\u003cconst int*\u003e\u003e();\n    test_iter_comp\u003crandom_access_iterator\u003cconst int*\u003e, sentinel\u003cconst int*\u003e\u003e();\n\n    test_iter_comp\u003cinput_iterator\u003cconst int*\u003e \u003e();\n    test_iter_comp\u003cforward_iterator\u003cconst int*\u003e \u003e();\n    test_iter_comp\u003cbidirectional_iterator\u003cconst int*\u003e \u003e();\n    test_iter_comp\u003crandom_access_iterator\u003cconst int*\u003e \u003e();\n    test_iter_comp\u003cconst int*\u003e();\n    test_iter_comp\u003cinput_iterator\u003cconst int*\u003e, sentinel\u003cconst int*\u003e\u003e();\n    test_iter_comp\u003cforward_iterator\u003cconst int*\u003e, sentinel\u003cconst int*\u003e\u003e();\n    test_iter_comp\u003cbidirectional_iterator\u003cconst int*\u003e, sentinel\u003cconst int*\u003e\u003e();\n    test_iter_comp\u003crandom_access_iterator\u003cconst int*\u003e, sentinel\u003cconst int*\u003e\u003e();\n\n    // Works with projections?\n    S s[] = {S{1,0},S{2,1},S{3,2},S{4,3},S{-4,4},S{40,5},S{-4,6},S{40,7},S{7,8},S{8,9},S{9,10}};\n    auto res = ranges::minmax(s, std::less\u003cint\u003e{}, \u0026S::value);\n    CHECK(res.first.value == -4);\n    CHECK(res.first.index == 4);\n    CHECK(res.second.value == 40);\n    CHECK(res.second.index == 7);\n\n    return test_result();\n}\n"}
{"repo_name":"Rudi9719/curly-octo-barnacle","ref":"refs/heads/master","path":"TrinityCore/src/server/scripts/Northrend/Nexus/Nexus/boss_ormorok.cpp","copies":"40","language":"C++","content":"/*\n * Copyright (C) 2008-2016 TrinityCore \u003chttp://www.trinitycore.org/\u003e\n * Copyright (C) 2006-2009 ScriptDev2 \u003chttps://scriptdev2.svn.sourceforge.net/\u003e\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the\n * Free Software Foundation; either version 2 of the License, or (at your\n * option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n * more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program. If not, see \u003chttp://www.gnu.org/licenses/\u003e.\n */\n\n#include \"ScriptMgr.h\"\n#include \"ScriptedCreature.h\"\n#include \"nexus.h\"\n#include \"SpellScript.h\"\n\nenum Spells\n{\n    SPELL_SPELL_REFLECTION                      = 47981,\n    SPELL_TRAMPLE                               = 48016,\n    SPELL_FRENZY                                = 48017,\n    SPELL_SUMMON_CRYSTALLINE_TANGLER            = 61564,\n    SPELL_CRYSTAL_SPIKES                        = 47958,\n};\nenum Yells\n{\n    SAY_AGGRO                                   = 1,\n    SAY_DEATH                                   = 2,\n    SAY_REFLECT                                 = 3,\n    SAY_CRYSTAL_SPIKES                          = 4,\n    SAY_KILL                                    = 5,\n    SAY_FRENZY                                  = 6\n};\n\nenum Events\n{\n    EVENT_CRYSTAL_SPIKES                        = 1,\n    EVENT_TRAMPLE                               = 2,\n    EVENT_SPELL_REFLECTION                      = 3,\n    EVENT_CRYSTALLINE_TANGLER                   = 4,\n};\n\nclass OrmorokTanglerPredicate\n{\n   public:\n      OrmorokTanglerPredicate(Unit* unit) : me(unit) { }\n\n    bool operator() (WorldObject* object) const\n    {\n        return object-\u003eGetDistance2d(me) \u003e= 5.0f;\n    }\n\n    private:\n        Unit* me;\n};\n\nclass boss_ormorok : public CreatureScript\n{\npublic:\n    boss_ormorok() : CreatureScript(\"boss_ormorok\") { }\n\n    struct boss_ormorokAI : public BossAI\n    {\n        boss_ormorokAI(Creature* creature) : BossAI(creature, DATA_ORMOROK)\n        {\n            Initialize();\n        }\n\n        void Initialize()\n        {\n            frenzy = false;\n        }\n\n        void Reset() override\n        {\n            BossAI::Reset();\n            Initialize();\n        }\n\n        void EnterCombat(Unit* /*who*/) override\n        {\n            _EnterCombat();\n\n            events.ScheduleEvent(EVENT_CRYSTAL_SPIKES, 12000);\n            events.ScheduleEvent(EVENT_TRAMPLE, 10000);\n            events.ScheduleEvent(EVENT_SPELL_REFLECTION, 30000);\n            if (IsHeroic())\n                events.ScheduleEvent(EVENT_CRYSTALLINE_TANGLER, 17000);\n\n            Talk(SAY_AGGRO);\n        }\n\n        void DamageTaken(Unit* /*attacker*/, uint32\u0026 /*damage*/) override\n        {\n            if (!frenzy \u0026\u0026 HealthBelowPct(25))\n            {\n                Talk(SAY_FRENZY);\n                DoCast(me, SPELL_FRENZY);\n                frenzy = true;\n            }\n        }\n\n        void JustDied(Unit* /*killer*/) override\n        {\n            _JustDied();\n            Talk(SAY_DEATH);\n        }\n\n        void KilledUnit(Unit* who) override\n        {\n            if (who-\u003eGetTypeId() == TYPEID_PLAYER)\n                Talk(SAY_KILL);\n        }\n\n        void UpdateAI(uint32 diff) override\n        {\n            if (!UpdateVictim())\n                return;\n\n            events.Update(diff);\n\n            if (me-\u003eHasUnitState(UNIT_STATE_CASTING))\n                return;\n\n            while (uint32 eventId = events.ExecuteEvent())\n            {\n                switch (eventId)\n                {\n                    case EVENT_TRAMPLE:\n                        DoCast(me, SPELL_TRAMPLE);\n                        events.ScheduleEvent(EVENT_TRAMPLE, 10000);\n                        break;\n                    case EVENT_SPELL_REFLECTION:\n                        Talk(SAY_REFLECT);\n                        DoCast(me, SPELL_SPELL_REFLECTION);\n                        events.ScheduleEvent(EVENT_SPELL_REFLECTION, 30000);\n                        break;\n                    case EVENT_CRYSTAL_SPIKES:\n                        Talk(SAY_CRYSTAL_SPIKES);\n                        DoCast(SPELL_CRYSTAL_SPIKES);\n                        events.ScheduleEvent(EVENT_CRYSTAL_SPIKES, 12000);\n                        break;\n                    case EVENT_CRYSTALLINE_TANGLER:\n                        if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 0, OrmorokTanglerPredicate(me)))\n                            DoCast(target, SPELL_SUMMON_CRYSTALLINE_TANGLER);\n                        events.ScheduleEvent(EVENT_CRYSTALLINE_TANGLER, 17000);\n                        break;\n                    default:\n                        break;\n                }\n            }\n\n            DoMeleeAttackIfReady();\n        }\n\n    private:\n        bool frenzy;\n\n    };\n\n    CreatureAI* GetAI(Creature* creature) const override\n    {\n        return GetInstanceAI\u003cboss_ormorokAI\u003e(creature);\n    }\n};\n\nenum CrystalSpikes\n{\n    NPC_CRYSTAL_SPIKE_INITIAL        = 27101,\n    NPC_CRYSTAL_SPIKE_TRIGGER        = 27079,\n\n    DATA_COUNT                       = 1,\n    MAX_COUNT                        = 5,\n\n    SPELL_CRYSTAL_SPIKE_DAMAGE       = 47944,\n\n    GO_CRYSTAL_SPIKE_TRAP            = 188537,\n};\n\nuint32 const crystalSpikeSummon[3] =\n{\n        47936,\n        47942,\n        47943\n};\n\nclass npc_crystal_spike_trigger : public CreatureScript\n{\npublic:\n    npc_crystal_spike_trigger() : CreatureScript(\"npc_crystal_spike_trigger\") { }\n\n    struct npc_crystal_spike_triggerAI : public ScriptedAI\n    {\n        npc_crystal_spike_triggerAI(Creature* creature) : ScriptedAI(creature)\n        {\n            _count = 0;\n            _despawntimer = 0;\n        }\n\n        void IsSummonedBy(Unit* owner) override\n        {\n            switch (me-\u003eGetEntry())\n            {\n                case NPC_CRYSTAL_SPIKE_INITIAL:\n                     _count = 0;\n                     me-\u003eSetFacingToObject(owner);\n                     break;\n                case NPC_CRYSTAL_SPIKE_TRIGGER:\n                    if (Creature* trigger = owner-\u003eToCreature())\n                        _count = trigger-\u003eAI()-\u003eGetData(DATA_COUNT) + 1;\n                    break;\n                default:\n                    _count = MAX_COUNT;\n                    break;\n            }\n\n            if (me-\u003eGetEntry() == NPC_CRYSTAL_SPIKE_TRIGGER)\n                if (GameObject* trap = me-\u003eFindNearestGameObject(GO_CRYSTAL_SPIKE_TRAP, 1.0f))\n                    trap-\u003eUse(me);\n\n            _despawntimer = 2000;\n        }\n\n        uint32 GetData(uint32 type) const override\n        {\n            return type == DATA_COUNT ? _count : 0;\n        }\n\n        void UpdateAI(uint32 diff) override\n        {\n            if (_despawntimer \u003c= diff)\n            {\n                if (me-\u003eGetEntry() == NPC_CRYSTAL_SPIKE_TRIGGER)\n                    if (GameObject* trap = me-\u003eFindNearestGameObject(GO_CRYSTAL_SPIKE_TRAP, 1.0f))\n                        trap-\u003eDelete();\n\n                me-\u003eDespawnOrUnsummon();\n            }\n            else\n                _despawntimer -= diff;\n        }\n\n    private:\n        uint32 _count;\n        uint32 _despawntimer;\n\n    };\n\n    CreatureAI* GetAI(Creature* creature) const override\n    {\n        return new npc_crystal_spike_triggerAI(creature);\n    }\n};\n\nclass spell_crystal_spike : public SpellScriptLoader\n{\n    public:\n        spell_crystal_spike() : SpellScriptLoader(\"spell_crystal_spike\") { }\n\n        class spell_crystal_spike_AuraScript : public AuraScript\n        {\n            PrepareAuraScript(spell_crystal_spike_AuraScript);\n\n            void HandlePeriodic(AuraEffect const* /*aurEff*/)\n            {\n                Unit* target = GetTarget();\n                if (target-\u003eGetEntry() == NPC_CRYSTAL_SPIKE_INITIAL || target-\u003eGetEntry() == NPC_CRYSTAL_SPIKE_TRIGGER)\n                    if (Creature* trigger = target-\u003eToCreature())\n                    {\n                        uint32 spell = target-\u003eGetEntry() == NPC_CRYSTAL_SPIKE_INITIAL ? crystalSpikeSummon[0] : crystalSpikeSummon[urand(0, 2)];\n                        if (trigger-\u003eAI()-\u003eGetData(DATA_COUNT) \u003c MAX_COUNT)\n                            trigger-\u003eCastSpell(trigger, spell, true);\n                    }\n            }\n\n            void Register() override\n            {\n                OnEffectPeriodic += AuraEffectPeriodicFn(spell_crystal_spike_AuraScript::HandlePeriodic, EFFECT_0, SPELL_AURA_PERIODIC_DUMMY);\n            }\n        };\n\n        AuraScript* GetAuraScript() const override\n        {\n            return new spell_crystal_spike_AuraScript();\n        }\n};\n\nvoid AddSC_boss_ormorok()\n{\n    new boss_ormorok();\n    new npc_crystal_spike_trigger();\n    new spell_crystal_spike();\n}\n"}
{"repo_name":"ddark/ecl","ref":"refs/heads/master","path":"src/server/scripts/Northrend/zone_wintergrasp.cpp","copies":"20","language":"C++","content":"/* Copyright (C) 2008 - 2009 Trinity \u003chttp://www.trinitycore.org/\u003e\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\n */\n\n#include \"BattlefieldMgr.h\"\n#include \"BattlefieldWG.h\"\n#include \"Battlefield.h\"\n#include \"ScriptSystem.h\"\n#include \"WorldSession.h\"\n#include \"ObjectMgr.h\"\n#include \"Vehicle.h\"\n#include \"GameObjectAI.h\"\n#include \"ScriptedCreature.h\"\n#include \"ScriptedGossip.h\"\n#include \"SpellScript.h\"\n#include \"Player.h\"\n\n#define GOSSIP_HELLO_DEMO1  \"Build catapult.\"\n#define GOSSIP_HELLO_DEMO2  \"Build demolisher.\"\n#define GOSSIP_HELLO_DEMO3  \"Build siege engine.\"\n#define GOSSIP_HELLO_DEMO4  \"I cannot build more!\"\n\nenum WGqueuenpctext\n{\n    WG_NPCQUEUE_TEXT_H_NOWAR            = 14775,\n    WG_NPCQUEUE_TEXT_H_QUEUE            = 14790,\n    WG_NPCQUEUE_TEXT_H_WAR              = 14777,\n    WG_NPCQUEUE_TEXT_A_NOWAR            = 14782,\n    WG_NPCQUEUE_TEXT_A_QUEUE            = 14791,\n    WG_NPCQUEUE_TEXT_A_WAR              = 14781,\n    WG_NPCQUEUE_TEXTOPTION_JOIN         = 20077,\n};\n\nenum Spells\n{\n    // Demolisher engineers spells\n    SPELL_BUILD_SIEGE_VEHICLE_FORCE_HORDE     = 61409,\n    SPELL_BUILD_SIEGE_VEHICLE_FORCE_ALLIANCE  = 56662,\n    SPELL_BUILD_CATAPULT_FORCE                = 56664,\n    SPELL_BUILD_DEMOLISHER_FORCE              = 56659,\n    SPELL_ACTIVATE_CONTROL_ARMS               = 49899,\n    SPELL_RIDE_WG_VEHICLE                     = 60968,\n\n    SPELL_VEHICLE_TELEPORT                    = 49759,\n\n    // Spirit guide\n    SPELL_CHANNEL_SPIRIT_HEAL                 = 22011,\n};\n\nenum CreatureIds\n{\n    NPC_GOBLIN_MECHANIC                             = 30400,\n    NPC_GNOMISH_ENGINEER                            = 30499,\n\n    NPC_WINTERGRASP_CONTROL_ARMS                    = 27852,\n\n    NPC_WORLD_TRIGGER_LARGE_AOI_NOT_IMMUNE_PC_NPC   = 23472,\n};\n\nenum QuestIds\n{\n    QUEST_BONES_AND_ARROWS_HORDE_ATT              = 13193,\n    QUEST_JINXING_THE_WALLS_HORDE_ATT             = 13202,\n    QUEST_SLAY_THEM_ALL_HORDE_ATT                 = 13180,\n    QUEST_FUELING_THE_DEMOLISHERS_HORDE_ATT       = 13200,\n    QUEST_HEALING_WITH_ROSES_HORDE_ATT            = 13201,\n    QUEST_DEFEND_THE_SIEGE_HORDE_ATT              = 13223,\n\n    QUEST_BONES_AND_ARROWS_HORDE_DEF              = 13199,\n    QUEST_WARDING_THE_WALLS_HORDE_DEF             = 13192,\n    QUEST_SLAY_THEM_ALL_HORDE_DEF                 = 13178,\n    QUEST_FUELING_THE_DEMOLISHERS_HORDE_DEF       = 13191,\n    QUEST_HEALING_WITH_ROSES_HORDE_DEF            = 13194,\n    QUEST_TOPPLING_THE_TOWERS_HORDE_DEF           = 13539,\n    QUEST_STOP_THE_SIEGE_HORDE_DEF                = 13185,\n\n    QUEST_BONES_AND_ARROWS_ALLIANCE_ATT           = 13196,\n    QUEST_WARDING_THE_WARRIORS_ALLIANCE_ATT       = 13198,\n    QUEST_NO_MERCY_FOR_THE_MERCILESS_ALLIANCE_ATT = 13179,\n    QUEST_DEFEND_THE_SIEGE_ALLIANCE_ATT           = 13222,\n    QUEST_A_RARE_HERB_ALLIANCE_ATT                = 13195,\n\n    QUEST_BONES_AND_ARROWS_ALLIANCE_DEF           = 13154,\n    QUEST_WARDING_THE_WARRIORS_ALLIANCE_DEF       = 13153,\n    QUEST_NO_MERCY_FOR_THE_MERCILESS_ALLIANCE_DEF = 13177,\n    QUEST_SHOUTHERN_SABOTAGE_ALLIANCE_DEF         = 13538,\n    QUEST_STOP_THE_SIEGE_ALLIANCE_DEF             = 13186,\n    QUEST_A_RARE_HERB_ALLIANCE_DEF                = 13156,\n};\n\nuint8 const MAX_WINTERGRASP_VEHICLES = 4;\n\nuint32 const vehiclesList[MAX_WINTERGRASP_VEHICLES] =\n{\n    NPC_WINTERGRASP_CATAPULT,\n    NPC_WINTERGRASP_DEMOLISHER,\n    NPC_WINTERGRASP_SIEGE_ENGINE_ALLIANCE,\n    NPC_WINTERGRASP_SIEGE_ENGINE_HORDE\n};\n\nclass npc_wg_demolisher_engineer : public CreatureScript\n{\n    public:\n        npc_wg_demolisher_engineer() : CreatureScript(\"npc_wg_demolisher_engineer\") { }\n\n        bool OnGossipHello(Player* player, Creature* creature) OVERRIDE\n        {\n            if (creature-\u003eIsQuestGiver())\n                player-\u003ePrepareQuestMenu(creature-\u003eGetGUID());\n\n            if (CanBuild(creature))\n            {\n                if (player-\u003eHasAura(SPELL_CORPORAL))\n                    player-\u003eADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_HELLO_DEMO1, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF);\n                else if (player-\u003eHasAura(SPELL_LIEUTENANT))\n                {\n                    player-\u003eADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_HELLO_DEMO1, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF);\n                    player-\u003eADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_HELLO_DEMO2, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF + 1);\n                    player-\u003eADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_HELLO_DEMO3, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF + 2);\n                }\n            }\n            else\n                player-\u003eADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_HELLO_DEMO4, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF + 9);\n\n            player-\u003eSEND_GOSSIP_MENU(player-\u003eGetGossipTextId(creature), creature-\u003eGetGUID());\n            return true;\n        }\n\n        bool OnGossipSelect(Player* player, Creature* creature, uint32 /*sender*/, uint32 action) OVERRIDE\n        {\n            player-\u003eCLOSE_GOSSIP_MENU();\n\n            if (CanBuild(creature))\n            {\n                switch (action - GOSSIP_ACTION_INFO_DEF)\n                {\n                    case 0:\n                        creature-\u003eCastSpell(player, SPELL_BUILD_CATAPULT_FORCE, true);\n                        break;\n                    case 1:\n                        creature-\u003eCastSpell(player, SPELL_BUILD_DEMOLISHER_FORCE, true);\n                        break;\n                    case 2:\n                        creature-\u003eCastSpell(player, player-\u003eGetTeamId() == TEAM_ALLIANCE ? SPELL_BUILD_SIEGE_VEHICLE_FORCE_ALLIANCE : SPELL_BUILD_SIEGE_VEHICLE_FORCE_HORDE, true);\n                        break;\n                }\n                if (Creature* controlArms = creature-\u003eFindNearestCreature(NPC_WINTERGRASP_CONTROL_ARMS, 30.0f, true))\n                    creature-\u003eCastSpell(controlArms, SPELL_ACTIVATE_CONTROL_ARMS, true);\n            }\n            return true;\n        }\n\n    private:\n        bool CanBuild(Creature* creature)\n        {\n            Battlefield* wintergrasp = sBattlefieldMgr-\u003eGetBattlefieldByBattleId(BATTLEFIELD_BATTLEID_WG);\n            if (!wintergrasp)\n                return false;\n\n            switch (creature-\u003eGetEntry())\n            {\n                case NPC_GOBLIN_MECHANIC:\n                    return (wintergrasp-\u003eGetData(BATTLEFIELD_WG_DATA_MAX_VEHICLE_H) \u003e wintergrasp-\u003eGetData(BATTLEFIELD_WG_DATA_VEHICLE_H));\n                case NPC_GNOMISH_ENGINEER:\n                    return (wintergrasp-\u003eGetData(BATTLEFIELD_WG_DATA_MAX_VEHICLE_A) \u003e wintergrasp-\u003eGetData(BATTLEFIELD_WG_DATA_VEHICLE_A));\n                default:\n                    return false;\n            }\n        }\n};\n\nclass npc_wg_spirit_guide : public CreatureScript\n{\n    public:\n        npc_wg_spirit_guide() : CreatureScript(\"npc_wg_spirit_guide\") { }\n\n        bool OnGossipHello(Player* player, Creature* creature) OVERRIDE\n        {\n            if (creature-\u003eIsQuestGiver())\n                player-\u003ePrepareQuestMenu(creature-\u003eGetGUID());\n\n            Battlefield* wintergrasp = sBattlefieldMgr-\u003eGetBattlefieldByBattleId(BATTLEFIELD_BATTLEID_WG);\n            if (!wintergrasp)\n                return true;\n\n            GraveyardVect graveyard = wintergrasp-\u003eGetGraveyardVector();\n            for (uint8 i = 0; i \u003c graveyard.size(); i++)\n                if (graveyard[i]-\u003eGetControlTeamId() == player-\u003eGetTeamId())\n                    player-\u003eADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, sObjectMgr-\u003eGetTrinityStringForDBCLocale(((BfGraveyardWG*)graveyard[i])-\u003eGetTextId()), GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF + i);\n\n            player-\u003eSEND_GOSSIP_MENU(player-\u003eGetGossipTextId(creature), creature-\u003eGetGUID());\n            return true;\n        }\n\n        bool OnGossipSelect(Player* player, Creature* /*creature*/, uint32 /*sender*/, uint32 action) OVERRIDE\n        {\n            player-\u003eCLOSE_GOSSIP_MENU();\n\n            Battlefield* wintergrasp = sBattlefieldMgr-\u003eGetBattlefieldByBattleId(BATTLEFIELD_BATTLEID_WG);\n            if (wintergrasp)\n            {\n                GraveyardVect gy = wintergrasp-\u003eGetGraveyardVector();\n                for (uint8 i = 0; i \u003c gy.size(); i++)\n                    if (action - GOSSIP_ACTION_INFO_DEF == i \u0026\u0026 gy[i]-\u003eGetControlTeamId() == player-\u003eGetTeamId())\n                        if (WorldSafeLocsEntry const* safeLoc = sWorldSafeLocsStore.LookupEntry(gy[i]-\u003eGetGraveyardId()))\n                            player-\u003eTeleportTo(safeLoc-\u003emap_id, safeLoc-\u003ex, safeLoc-\u003ey, safeLoc-\u003ez, 0);\n            }\n            return true;\n        }\n\n        struct npc_wg_spirit_guideAI : public ScriptedAI\n        {\n            npc_wg_spirit_guideAI(Creature* creature) : ScriptedAI(creature) { }\n\n            void UpdateAI(uint32 /*diff*/) OVERRIDE\n            {\n                if (!me-\u003eHasUnitState(UNIT_STATE_CASTING))\n                    DoCast(me, SPELL_CHANNEL_SPIRIT_HEAL);\n            }\n        };\n\n        CreatureAI* GetAI(Creature* creature) const OVERRIDE\n        {\n            return new npc_wg_spirit_guideAI(creature);\n        }\n};\n\nclass npc_wg_queue : public CreatureScript\n{\n    public:\n        npc_wg_queue() : CreatureScript(\"npc_wg_queue\") { }\n\n        bool OnGossipHello(Player* player, Creature* creature) OVERRIDE\n        {\n            if (creature-\u003eIsQuestGiver())\n                player-\u003ePrepareQuestMenu(creature-\u003eGetGUID());\n\n            Battlefield* wintergrasp = sBattlefieldMgr-\u003eGetBattlefieldByBattleId(BATTLEFIELD_BATTLEID_WG);\n            if (!wintergrasp)\n                return true;\n\n            if (wintergrasp-\u003eIsWarTime())\n            {\n                player-\u003eADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, sObjectMgr-\u003eGetTrinityStringForDBCLocale(WG_NPCQUEUE_TEXTOPTION_JOIN), GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF);\n                player-\u003eSEND_GOSSIP_MENU(wintergrasp-\u003eGetDefenderTeam() ? WG_NPCQUEUE_TEXT_H_WAR : WG_NPCQUEUE_TEXT_A_WAR, creature-\u003eGetGUID());\n            }\n            else\n            {\n                uint32 timer = wintergrasp-\u003eGetTimer() / 1000;\n                player-\u003eSendUpdateWorldState(4354, time(NULL) + timer);\n                if (timer \u003c 15 * MINUTE)\n                {\n                    player-\u003eADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, sObjectMgr-\u003eGetTrinityStringForDBCLocale(WG_NPCQUEUE_TEXTOPTION_JOIN), GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF);\n                    player-\u003eSEND_GOSSIP_MENU(wintergrasp-\u003eGetDefenderTeam() ? WG_NPCQUEUE_TEXT_H_QUEUE : WG_NPCQUEUE_TEXT_A_QUEUE, creature-\u003eGetGUID());\n                }\n                else\n                    player-\u003eSEND_GOSSIP_MENU(wintergrasp-\u003eGetDefenderTeam() ? WG_NPCQUEUE_TEXT_H_NOWAR : WG_NPCQUEUE_TEXT_A_NOWAR, creature-\u003eGetGUID());\n            }\n            return true;\n        }\n\n        bool OnGossipSelect(Player* player, Creature* /*creature*/, uint32 /*sender*/, uint32 /*action*/) OVERRIDE\n        {\n            player-\u003eCLOSE_GOSSIP_MENU();\n\n            Battlefield* wintergrasp = sBattlefieldMgr-\u003eGetBattlefieldByBattleId(BATTLEFIELD_BATTLEID_WG);\n            if (!wintergrasp)\n                return true;\n\n            if (wintergrasp-\u003eIsWarTime())\n                wintergrasp-\u003eInvitePlayerToWar(player);\n            else\n            {\n                uint32 timer = wintergrasp-\u003eGetTimer() / 1000;\n                if (timer \u003c 15 * MINUTE)\n                    wintergrasp-\u003eInvitePlayerToQueue(player);\n            }\n            return true;\n        }\n};\n\nclass go_wg_vehicle_teleporter : public GameObjectScript\n{\n    public:\n        go_wg_vehicle_teleporter() : GameObjectScript(\"go_wg_vehicle_teleporter\") { }\n\n        struct go_wg_vehicle_teleporterAI : public GameObjectAI\n        {\n            go_wg_vehicle_teleporterAI(GameObject* gameObject) : GameObjectAI(gameObject), _checkTimer(1000) { }\n\n            void UpdateAI(uint32 diff) OVERRIDE\n            {\n                if (_checkTimer \u003c= diff)\n                {\n                    if (Battlefield* wg = sBattlefieldMgr-\u003eGetBattlefieldByBattleId(BATTLEFIELD_BATTLEID_WG))\n                        // Tabulation madness in the hole!\n                        for (uint8 i = 0; i \u003c MAX_WINTERGRASP_VEHICLES; i++)\n                            if (Creature* vehicleCreature = go-\u003eFindNearestCreature(vehiclesList[i], 3.0f, true))\n                                if (!vehicleCreature-\u003eHasAura(SPELL_VEHICLE_TELEPORT) \u0026\u0026 vehicleCreature-\u003egetFaction() == WintergraspFaction[wg-\u003eGetDefenderTeam()])\n                                    if (Creature* teleportTrigger = vehicleCreature-\u003eFindNearestCreature(NPC_WORLD_TRIGGER_LARGE_AOI_NOT_IMMUNE_PC_NPC, 100.0f, true))\n                                        teleportTrigger-\u003eCastSpell(vehicleCreature, SPELL_VEHICLE_TELEPORT, true);\n\n                    _checkTimer = 1000;\n                }\n                else _checkTimer -= diff;\n            }\n\n          private:\n              uint32 _checkTimer;\n        };\n\n        GameObjectAI* GetAI(GameObject* go) const OVERRIDE\n        {\n            return new go_wg_vehicle_teleporterAI(go);\n        }\n};\n\nclass npc_wg_quest_giver : public CreatureScript\n{\n    public:\n        npc_wg_quest_giver() : CreatureScript(\"npc_wg_quest_giver\") { }\n\n        bool OnGossipHello(Player* player, Creature* creature) OVERRIDE\n        {\n            if (creature-\u003eIsQuestGiver())\n                player-\u003ePrepareQuestMenu(creature-\u003eGetGUID());\n\n            Battlefield* wintergrasp = sBattlefieldMgr-\u003eGetBattlefieldByBattleId(BATTLEFIELD_BATTLEID_WG);\n            if (!wintergrasp)\n                return true;\n\n            if (creature-\u003eIsQuestGiver())\n            {\n                QuestRelationBounds objectQR = sObjectMgr-\u003eGetCreatureQuestRelationBounds(creature-\u003eGetEntry());\n                QuestRelationBounds objectQIR = sObjectMgr-\u003eGetCreatureQuestInvolvedRelationBounds(creature-\u003eGetEntry());\n\n                QuestMenu\u0026 qm = player-\u003ePlayerTalkClass-\u003eGetQuestMenu();\n                qm.ClearMenu();\n\n                for (QuestRelations::const_iterator i = objectQIR.first; i != objectQIR.second; ++i)\n                {\n                    uint32 questId = i-\u003esecond;\n                    QuestStatus status = player-\u003eGetQuestStatus(questId);\n                    if (status == QUEST_STATUS_COMPLETE)\n                        qm.AddMenuItem(questId, 4);\n                    else if (status == QUEST_STATUS_INCOMPLETE)\n                        qm.AddMenuItem(questId, 4);\n                    //else if (status == QUEST_STATUS_AVAILABLE)\n                    //    qm.AddMenuItem(quest_id, 2);\n                }\n\n                for (QuestRelations::const_iterator i = objectQR.first; i != objectQR.second; ++i)\n                {\n                    uint32 questId = i-\u003esecond;\n                    Quest const* quest = sObjectMgr-\u003eGetQuestTemplate(questId);\n                    if (!quest)\n                        continue;\n\n                    switch (questId)\n                    {\n                        // Horde attacker\n                        case QUEST_BONES_AND_ARROWS_HORDE_ATT:\n                        case QUEST_JINXING_THE_WALLS_HORDE_ATT:\n                        case QUEST_SLAY_THEM_ALL_HORDE_ATT:\n                        case QUEST_FUELING_THE_DEMOLISHERS_HORDE_ATT:\n                        case QUEST_HEALING_WITH_ROSES_HORDE_ATT:\n                        case QUEST_DEFEND_THE_SIEGE_HORDE_ATT:\n                            if (wintergrasp-\u003eGetAttackerTeam() == TEAM_HORDE)\n                            {\n                                QuestStatus status = player-\u003eGetQuestStatus(questId);\n\n                                if (quest-\u003eIsAutoComplete() \u0026\u0026 player-\u003eCanTakeQuest(quest, false))\n                                    qm.AddMenuItem(questId, 4);\n                                else if (status == QUEST_STATUS_NONE \u0026\u0026 player-\u003eCanTakeQuest(quest, false))\n                                    qm.AddMenuItem(questId, 2);\n                            }\n                            break;\n                        // Horde defender\n                        case QUEST_BONES_AND_ARROWS_HORDE_DEF:\n                        case QUEST_WARDING_THE_WALLS_HORDE_DEF:\n                        case QUEST_SLAY_THEM_ALL_HORDE_DEF:\n                        case QUEST_FUELING_THE_DEMOLISHERS_HORDE_DEF:\n                        case QUEST_HEALING_WITH_ROSES_HORDE_DEF:\n                        case QUEST_TOPPLING_THE_TOWERS_HORDE_DEF:\n                        case QUEST_STOP_THE_SIEGE_HORDE_DEF:\n                            if (wintergrasp-\u003eGetDefenderTeam() == TEAM_HORDE)\n                            {\n                                QuestStatus status = player-\u003eGetQuestStatus(questId);\n\n                                if (quest-\u003eIsAutoComplete() \u0026\u0026 player-\u003eCanTakeQuest(quest, false))\n                                    qm.AddMenuItem(questId, 4);\n                                else if (status == QUEST_STATUS_NONE \u0026\u0026 player-\u003eCanTakeQuest(quest, false))\n                                    qm.AddMenuItem(questId, 2);\n                            }\n                            break;\n                        // Alliance attacker\n                        case QUEST_BONES_AND_ARROWS_ALLIANCE_ATT:\n                        case QUEST_WARDING_THE_WARRIORS_ALLIANCE_ATT:\n                        case QUEST_NO_MERCY_FOR_THE_MERCILESS_ALLIANCE_ATT:\n                        case QUEST_DEFEND_THE_SIEGE_ALLIANCE_ATT:\n                        case QUEST_A_RARE_HERB_ALLIANCE_ATT:\n                            if (wintergrasp-\u003eGetAttackerTeam() == TEAM_ALLIANCE)\n                            {\n                                QuestStatus status = player-\u003eGetQuestStatus(questId);\n\n                                if (quest-\u003eIsAutoComplete() \u0026\u0026 player-\u003eCanTakeQuest(quest, false))\n                                    qm.AddMenuItem(questId, 4);\n                                else if (status == QUEST_STATUS_NONE \u0026\u0026 player-\u003eCanTakeQuest(quest, false))\n                                    qm.AddMenuItem(questId, 2);\n                            }\n                            break;\n                        // Alliance defender\n                        case QUEST_BONES_AND_ARROWS_ALLIANCE_DEF:\n                        case QUEST_WARDING_THE_WARRIORS_ALLIANCE_DEF:\n                        case QUEST_NO_MERCY_FOR_THE_MERCILESS_ALLIANCE_DEF:\n                        case QUEST_SHOUTHERN_SABOTAGE_ALLIANCE_DEF:\n                        case QUEST_STOP_THE_SIEGE_ALLIANCE_DEF:\n                        case QUEST_A_RARE_HERB_ALLIANCE_DEF:\n                            if (wintergrasp-\u003eGetDefenderTeam() == TEAM_ALLIANCE)\n                            {\n                                QuestStatus status = player-\u003eGetQuestStatus(questId);\n\n                                if (quest-\u003eIsAutoComplete() \u0026\u0026 player-\u003eCanTakeQuest(quest, false))\n                                    qm.AddMenuItem(questId, 4);\n                                else if (status == QUEST_STATUS_NONE \u0026\u0026 player-\u003eCanTakeQuest(quest, false))\n                                    qm.AddMenuItem(questId, 2);\n                            }\n                            break;\n                        default:\n                            QuestStatus status = player-\u003eGetQuestStatus(questId);\n\n                            if (quest-\u003eIsAutoComplete() \u0026\u0026 player-\u003eCanTakeQuest(quest, false))\n                                qm.AddMenuItem(questId, 4);\n                            else if (status == QUEST_STATUS_NONE \u0026\u0026 player-\u003eCanTakeQuest(quest, false))\n                                qm.AddMenuItem(questId, 2);\n                            break;\n                    }\n                }\n            }\n            player-\u003eSEND_GOSSIP_MENU(player-\u003eGetGossipTextId(creature), creature-\u003eGetGUID());\n            return true;\n        }\n};\n\nclass spell_wintergrasp_force_building : public SpellScriptLoader\n{\n    public:\n        spell_wintergrasp_force_building() : SpellScriptLoader(\"spell_wintergrasp_force_building\") { }\n\n        class spell_wintergrasp_force_building_SpellScript : public SpellScript\n        {\n            PrepareSpellScript(spell_wintergrasp_force_building_SpellScript);\n\n            bool Validate(SpellInfo const* /*spell*/) OVERRIDE\n            {\n                if (!sSpellMgr-\u003eGetSpellInfo(SPELL_BUILD_CATAPULT_FORCE)\n                    || !sSpellMgr-\u003eGetSpellInfo(SPELL_BUILD_DEMOLISHER_FORCE)\n                    || !sSpellMgr-\u003eGetSpellInfo(SPELL_BUILD_SIEGE_VEHICLE_FORCE_HORDE)\n                    || !sSpellMgr-\u003eGetSpellInfo(SPELL_BUILD_SIEGE_VEHICLE_FORCE_ALLIANCE))\n                    return false;\n                return true;\n            }\n\n            void HandleScript(SpellEffIndex effIndex)\n            {\n                PreventHitDefaultEffect(effIndex);\n                GetHitUnit()-\u003eCastSpell(GetHitUnit(), GetEffectValue(), false);\n            }\n\n            void Register() OVERRIDE\n            {\n                OnEffectHitTarget += SpellEffectFn(spell_wintergrasp_force_building_SpellScript::HandleScript, EFFECT_0, SPELL_EFFECT_SCRIPT_EFFECT);\n            }\n        };\n\n        SpellScript* GetSpellScript() const OVERRIDE\n        {\n            return new spell_wintergrasp_force_building_SpellScript();\n        }\n};\n\nclass spell_wintergrasp_grab_passenger : public SpellScriptLoader\n{\n    public:\n        spell_wintergrasp_grab_passenger() : SpellScriptLoader(\"spell_wintergrasp_grab_passenger\") { }\n\n        class spell_wintergrasp_grab_passenger_SpellScript : public SpellScript\n        {\n            PrepareSpellScript(spell_wintergrasp_grab_passenger_SpellScript);\n\n            void HandleScript(SpellEffIndex /*effIndex*/)\n            {\n                if (Player* target = GetHitPlayer())\n                    target-\u003eCastSpell(GetCaster(), SPELL_RIDE_WG_VEHICLE, false);\n            }\n\n            void Register() OVERRIDE\n            {\n                OnEffectHitTarget += SpellEffectFn(spell_wintergrasp_grab_passenger_SpellScript::HandleScript, EFFECT_0, SPELL_EFFECT_SCRIPT_EFFECT);\n            }\n        };\n\n        SpellScript* GetSpellScript() const OVERRIDE\n        {\n            return new spell_wintergrasp_grab_passenger_SpellScript();\n        }\n};\n\nclass achievement_wg_didnt_stand_a_chance : public AchievementCriteriaScript\n{\npublic:\n    achievement_wg_didnt_stand_a_chance() : AchievementCriteriaScript(\"achievement_wg_didnt_stand_a_chance\") { }\n\n    bool OnCheck(Player* source, Unit* target) OVERRIDE\n    {\n        if (!target)\n            return false;\n\n        if (Player* victim = target-\u003eToPlayer())\n        {\n            if (!victim-\u003eIsMounted())\n                return false;\n\n            if (Vehicle* vehicle = source-\u003eGetVehicle())\n                if (vehicle-\u003eGetVehicleInfo()-\u003em_ID == 244) // Wintergrasp Tower Cannon\n                    return true;\n        }\n\n        return false;\n    }\n};\n\nenum WgTeleport\n{\n    SPELL_WINTERGRASP_TELEPORT_TRIGGER = 54643,\n};\n\nclass spell_wintergrasp_defender_teleport : public SpellScriptLoader\n{\npublic:\n    spell_wintergrasp_defender_teleport() : SpellScriptLoader(\"spell_wintergrasp_defender_teleport\") { }\n\n    class spell_wintergrasp_defender_teleport_SpellScript : public SpellScript\n    {\n        PrepareSpellScript(spell_wintergrasp_defender_teleport_SpellScript);\n\n        SpellCastResult CheckCast()\n        {\n            if (Battlefield* wg = sBattlefieldMgr-\u003eGetBattlefieldByBattleId(BATTLEFIELD_BATTLEID_WG))\n                if (Player* target = GetExplTargetUnit()-\u003eToPlayer())\n                    // check if we are in Wintergrasp at all, SotA uses same teleport spells\n                    if ((target-\u003eGetZoneId() == 4197 \u0026\u0026 target-\u003eGetTeamId() != wg-\u003eGetDefenderTeam()) || target-\u003eHasAura(SPELL_WINTERGRASP_TELEPORT_TRIGGER))\n                        return SPELL_FAILED_BAD_TARGETS;\n            return SPELL_CAST_OK;\n        }\n\n        void Register() OVERRIDE\n        {\n            OnCheckCast += SpellCheckCastFn(spell_wintergrasp_defender_teleport_SpellScript::CheckCast);\n        }\n    };\n\n    SpellScript* GetSpellScript() const OVERRIDE\n    {\n        return new spell_wintergrasp_defender_teleport_SpellScript();\n    }\n};\n\nclass spell_wintergrasp_defender_teleport_trigger : public SpellScriptLoader\n{\npublic:\n    spell_wintergrasp_defender_teleport_trigger() : SpellScriptLoader(\"spell_wintergrasp_defender_teleport_trigger\") { }\n\n    class spell_wintergrasp_defender_teleport_trigger_SpellScript : public SpellScript\n    {\n        PrepareSpellScript(spell_wintergrasp_defender_teleport_trigger_SpellScript);\n\n        void HandleDummy(SpellEffIndex /*effindex*/)\n        {\n            if (Unit* target = GetHitUnit())\n            {\n                WorldLocation loc;\n                target-\u003eGetPosition(\u0026loc);\n                SetExplTargetDest(loc);\n            }\n        }\n\n        void Register() OVERRIDE\n        {\n            OnEffectHitTarget += SpellEffectFn(spell_wintergrasp_defender_teleport_trigger_SpellScript::HandleDummy, EFFECT_0, SPELL_EFFECT_DUMMY);\n        }\n    };\n\n    SpellScript* GetSpellScript() const OVERRIDE\n    {\n        return new spell_wintergrasp_defender_teleport_trigger_SpellScript();\n    }\n};\n\nvoid AddSC_wintergrasp()\n{\n    new npc_wg_queue();\n    new npc_wg_spirit_guide();\n    new npc_wg_demolisher_engineer();\n    new go_wg_vehicle_teleporter();\n    new npc_wg_quest_giver();\n    new spell_wintergrasp_force_building();\n    new spell_wintergrasp_grab_passenger();\n    new achievement_wg_didnt_stand_a_chance();\n    new spell_wintergrasp_defender_teleport();\n    new spell_wintergrasp_defender_teleport_trigger();\n}\n"}
{"repo_name":"paulfitz/phantomjs","ref":"refs/heads/master","path":"src/qt/qtwebkit/Tools/DumpRenderTree/TestNetscapePlugIn/Tests/GetURLWithJavaScriptURLDestroyingPlugin.cpp","copies":"147","language":"C++","content":"/*\n * Copyright (C) 2011 Apple Inc. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS\n * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"PluginTest.h\"\n\nusing namespace std;\n\n// From NPP_New, call NPN_GetURL to evaluate JavaScript that destroys the plug-in.\n\nclass GetURLWithJavaScriptURLDestroyingPlugin : public PluginTest {\npublic:\n    GetURLWithJavaScriptURLDestroyingPlugin(NPP npp, const string\u0026 identifier)\n        : PluginTest(npp, identifier)\n    {\n    }\n\nprivate:\n\n    virtual NPError NPP_New(NPMIMEType pluginType, uint16_t mode, int16_t argc, char *argn[], char *argv[], NPSavedData *saved)\n    {\n        NPN_GetURL(\"javascript:removePlugin()\", 0);\n        return NPERR_NO_ERROR;\n    }        \n};\n\nstatic PluginTest::Register\u003cGetURLWithJavaScriptURLDestroyingPlugin\u003e getURLWithJavaScriptURLDestroyingPlugin(\"get-url-with-javascript-url-destroying-plugin\");\n"}
{"repo_name":"xlmbn/trscoin","ref":"refs/heads/master","path":"src/test/multisig_tests.cpp","copies":"1336","language":"C++","content":"#include \u003cboost/assert.hpp\u003e\n#include \u003cboost/assign/list_of.hpp\u003e\n#include \u003cboost/assign/list_inserter.hpp\u003e\n#include \u003cboost/assign/std/vector.hpp\u003e\n#include \u003cboost/test/unit_test.hpp\u003e\n#include \u003cboost/foreach.hpp\u003e\n#include \u003cboost/tuple/tuple.hpp\u003e\n\n#include \u003copenssl/ec.h\u003e\n#include \u003copenssl/err.h\u003e\n\n#include \"keystore.h\"\n#include \"main.h\"\n#include \"script.h\"\n#include \"wallet.h\"\n\nusing namespace std;\nusing namespace boost::assign;\n\ntypedef vector\u003cunsigned char\u003e valtype;\n\nextern uint256 SignatureHash(CScript scriptCode, const CTransaction\u0026 txTo, unsigned int nIn, int nHashType);\n\nBOOST_AUTO_TEST_SUITE(multisig_tests)\n\nCScript\nsign_multisig(CScript scriptPubKey, vector\u003cCKey\u003e keys, CTransaction transaction, int whichIn)\n{\n    uint256 hash = SignatureHash(scriptPubKey, transaction, whichIn, SIGHASH_ALL);\n\n    CScript result;\n    result \u003c\u003c OP_0; // CHECKMULTISIG bug workaround\n    BOOST_FOREACH(const CKey \u0026key, keys)\n    {\n        vector\u003cunsigned char\u003e vchSig;\n        BOOST_CHECK(key.Sign(hash, vchSig));\n        vchSig.push_back((unsigned char)SIGHASH_ALL);\n        result \u003c\u003c vchSig;\n    }\n    return result;\n}\n\nBOOST_AUTO_TEST_CASE(multisig_verify)\n{\n    unsigned int flags = SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_STRICTENC;\n\n    CKey key[4];\n    for (int i = 0; i \u003c 4; i++)\n        key[i].MakeNewKey(true);\n\n    CScript a_and_b;\n    a_and_b \u003c\u003c OP_2 \u003c\u003c key[0].GetPubKey() \u003c\u003c key[1].GetPubKey() \u003c\u003c OP_2 \u003c\u003c OP_CHECKMULTISIG;\n\n    CScript a_or_b;\n    a_or_b \u003c\u003c OP_1 \u003c\u003c key[0].GetPubKey() \u003c\u003c key[1].GetPubKey() \u003c\u003c OP_2 \u003c\u003c OP_CHECKMULTISIG;\n\n    CScript escrow;\n    escrow \u003c\u003c OP_2 \u003c\u003c key[0].GetPubKey() \u003c\u003c key[1].GetPubKey() \u003c\u003c key[2].GetPubKey() \u003c\u003c OP_3 \u003c\u003c OP_CHECKMULTISIG;\n\n    CTransaction txFrom;  // Funding transaction\n    txFrom.vout.resize(3);\n    txFrom.vout[0].scriptPubKey = a_and_b;\n    txFrom.vout[1].scriptPubKey = a_or_b;\n    txFrom.vout[2].scriptPubKey = escrow;\n\n    CTransaction txTo[3]; // Spending transaction\n    for (int i = 0; i \u003c 3; i++)\n    {\n        txTo[i].vin.resize(1);\n        txTo[i].vout.resize(1);\n        txTo[i].vin[0].prevout.n = i;\n        txTo[i].vin[0].prevout.hash = txFrom.GetHash();\n        txTo[i].vout[0].nValue = 1;\n    }\n\n    vector\u003cCKey\u003e keys;\n    CScript s;\n\n    // Test a AND b:\n    keys.clear();\n    keys += key[0],key[1]; // magic operator+= from boost.assign\n    s = sign_multisig(a_and_b, keys, txTo[0], 0);\n    BOOST_CHECK(VerifyScript(s, a_and_b, txTo[0], 0, flags, 0));\n\n    for (int i = 0; i \u003c 4; i++)\n    {\n        keys.clear();\n        keys += key[i];\n        s = sign_multisig(a_and_b, keys, txTo[0], 0);\n        BOOST_CHECK_MESSAGE(!VerifyScript(s, a_and_b, txTo[0], 0, flags, 0), strprintf(\"a\u0026b 1: %d\", i));\n\n        keys.clear();\n        keys += key[1],key[i];\n        s = sign_multisig(a_and_b, keys, txTo[0], 0);\n        BOOST_CHECK_MESSAGE(!VerifyScript(s, a_and_b, txTo[0], 0, flags, 0), strprintf(\"a\u0026b 2: %d\", i));\n    }\n\n    // Test a OR b:\n    for (int i = 0; i \u003c 4; i++)\n    {\n        keys.clear();\n        keys += key[i];\n        s = sign_multisig(a_or_b, keys, txTo[1], 0);\n        if (i == 0 || i == 1)\n            BOOST_CHECK_MESSAGE(VerifyScript(s, a_or_b, txTo[1], 0, flags, 0), strprintf(\"a|b: %d\", i));\n        else\n            BOOST_CHECK_MESSAGE(!VerifyScript(s, a_or_b, txTo[1], 0, flags, 0), strprintf(\"a|b: %d\", i));\n    }\n    s.clear();\n    s \u003c\u003c OP_0 \u003c\u003c OP_0;\n    BOOST_CHECK(!VerifyScript(s, a_or_b, txTo[1], 0, flags, 0));\n    s.clear();\n    s \u003c\u003c OP_0 \u003c\u003c OP_1;\n    BOOST_CHECK(!VerifyScript(s, a_or_b, txTo[1], 0, flags, 0));\n\n\n    for (int i = 0; i \u003c 4; i++)\n        for (int j = 0; j \u003c 4; j++)\n        {\n            keys.clear();\n            keys += key[i],key[j];\n            s = sign_multisig(escrow, keys, txTo[2], 0);\n            if (i \u003c j \u0026\u0026 i \u003c 3 \u0026\u0026 j \u003c 3)\n                BOOST_CHECK_MESSAGE(VerifyScript(s, escrow, txTo[2], 0, flags, 0), strprintf(\"escrow 1: %d %d\", i, j));\n            else\n                BOOST_CHECK_MESSAGE(!VerifyScript(s, escrow, txTo[2], 0, flags, 0), strprintf(\"escrow 2: %d %d\", i, j));\n        }\n}\n\nBOOST_AUTO_TEST_CASE(multisig_IsStandard)\n{\n    CKey key[4];\n    for (int i = 0; i \u003c 4; i++)\n        key[i].MakeNewKey(true);\n\n    CScript a_and_b;\n    a_and_b \u003c\u003c OP_2 \u003c\u003c key[0].GetPubKey() \u003c\u003c key[1].GetPubKey() \u003c\u003c OP_2 \u003c\u003c OP_CHECKMULTISIG;\n    BOOST_CHECK(::IsStandard(a_and_b));\n\n    CScript a_or_b;\n    a_or_b  \u003c\u003c OP_1 \u003c\u003c key[0].GetPubKey() \u003c\u003c key[1].GetPubKey() \u003c\u003c OP_2 \u003c\u003c OP_CHECKMULTISIG;\n    BOOST_CHECK(::IsStandard(a_or_b));\n\n    CScript escrow;\n    escrow \u003c\u003c OP_2 \u003c\u003c key[0].GetPubKey() \u003c\u003c key[1].GetPubKey() \u003c\u003c key[2].GetPubKey() \u003c\u003c OP_3 \u003c\u003c OP_CHECKMULTISIG;\n    BOOST_CHECK(::IsStandard(escrow));\n\n    CScript one_of_four;\n    one_of_four \u003c\u003c OP_1 \u003c\u003c key[0].GetPubKey() \u003c\u003c key[1].GetPubKey() \u003c\u003c key[2].GetPubKey() \u003c\u003c key[3].GetPubKey() \u003c\u003c OP_4 \u003c\u003c OP_CHECKMULTISIG;\n    BOOST_CHECK(!::IsStandard(one_of_four));\n\n    CScript malformed[6];\n    malformed[0] \u003c\u003c OP_3 \u003c\u003c key[0].GetPubKey() \u003c\u003c key[1].GetPubKey() \u003c\u003c OP_2 \u003c\u003c OP_CHECKMULTISIG;\n    malformed[1] \u003c\u003c OP_2 \u003c\u003c key[0].GetPubKey() \u003c\u003c key[1].GetPubKey() \u003c\u003c OP_3 \u003c\u003c OP_CHECKMULTISIG;\n    malformed[2] \u003c\u003c OP_0 \u003c\u003c key[0].GetPubKey() \u003c\u003c key[1].GetPubKey() \u003c\u003c OP_2 \u003c\u003c OP_CHECKMULTISIG;\n    malformed[3] \u003c\u003c OP_1 \u003c\u003c key[0].GetPubKey() \u003c\u003c key[1].GetPubKey() \u003c\u003c OP_0 \u003c\u003c OP_CHECKMULTISIG;\n    malformed[4] \u003c\u003c OP_1 \u003c\u003c key[0].GetPubKey() \u003c\u003c key[1].GetPubKey() \u003c\u003c OP_CHECKMULTISIG;\n    malformed[5] \u003c\u003c OP_1 \u003c\u003c key[0].GetPubKey() \u003c\u003c key[1].GetPubKey();\n\n    for (int i = 0; i \u003c 6; i++)\n        BOOST_CHECK(!::IsStandard(malformed[i]));\n}\n\nBOOST_AUTO_TEST_CASE(multisig_Solver1)\n{\n    // Tests Solver() that returns lists of keys that are\n    // required to satisfy a ScriptPubKey\n    //\n    // Also tests IsMine() and ExtractAddress()\n    //\n    // Note: ExtractAddress for the multisignature transactions\n    // always returns false for this release, even if you have\n    // one key that would satisfy an (a|b) or 2-of-3 keys needed\n    // to spend an escrow transaction.\n    //\n    CBasicKeyStore keystore, emptykeystore, partialkeystore;\n    CKey key[3];\n    CTxDestination keyaddr[3];\n    for (int i = 0; i \u003c 3; i++)\n    {\n        key[i].MakeNewKey(true);\n        keystore.AddKey(key[i]);\n        keyaddr[i] = key[i].GetPubKey().GetID();\n    }\n    partialkeystore.AddKey(key[0]);\n\n    {\n        vector\u003cvaltype\u003e solutions;\n        txnouttype whichType;\n        CScript s;\n        s \u003c\u003c key[0].GetPubKey() \u003c\u003c OP_CHECKSIG;\n        BOOST_CHECK(Solver(s, whichType, solutions));\n        BOOST_CHECK(solutions.size() == 1);\n        CTxDestination addr;\n        BOOST_CHECK(ExtractDestination(s, addr));\n        BOOST_CHECK(addr == keyaddr[0]);\n        BOOST_CHECK(IsMine(keystore, s));\n        BOOST_CHECK(!IsMine(emptykeystore, s));\n    }\n    {\n        vector\u003cvaltype\u003e solutions;\n        txnouttype whichType;\n        CScript s;\n        s \u003c\u003c OP_DUP \u003c\u003c OP_HASH160 \u003c\u003c key[0].GetPubKey().GetID() \u003c\u003c OP_EQUALVERIFY \u003c\u003c OP_CHECKSIG;\n        BOOST_CHECK(Solver(s, whichType, solutions));\n        BOOST_CHECK(solutions.size() == 1);\n        CTxDestination addr;\n        BOOST_CHECK(ExtractDestination(s, addr));\n        BOOST_CHECK(addr == keyaddr[0]);\n        BOOST_CHECK(IsMine(keystore, s));\n        BOOST_CHECK(!IsMine(emptykeystore, s));\n    }\n    {\n        vector\u003cvaltype\u003e solutions;\n        txnouttype whichType;\n        CScript s;\n        s \u003c\u003c OP_2 \u003c\u003c key[0].GetPubKey() \u003c\u003c key[1].GetPubKey() \u003c\u003c OP_2 \u003c\u003c OP_CHECKMULTISIG;\n        BOOST_CHECK(Solver(s, whichType, solutions));\n        BOOST_CHECK_EQUAL(solutions.size(), 4U);\n        CTxDestination addr;\n        BOOST_CHECK(!ExtractDestination(s, addr));\n        BOOST_CHECK(IsMine(keystore, s));\n        BOOST_CHECK(!IsMine(emptykeystore, s));\n        BOOST_CHECK(!IsMine(partialkeystore, s));\n    }\n    {\n        vector\u003cvaltype\u003e solutions;\n        txnouttype whichType;\n        CScript s;\n        s \u003c\u003c OP_1 \u003c\u003c key[0].GetPubKey() \u003c\u003c key[1].GetPubKey() \u003c\u003c OP_2 \u003c\u003c OP_CHECKMULTISIG;\n        BOOST_CHECK(Solver(s, whichType, solutions));\n        BOOST_CHECK_EQUAL(solutions.size(), 4U);\n        vector\u003cCTxDestination\u003e addrs;\n        int nRequired;\n        BOOST_CHECK(ExtractDestinations(s, whichType, addrs, nRequired));\n        BOOST_CHECK(addrs[0] == keyaddr[0]);\n        BOOST_CHECK(addrs[1] == keyaddr[1]);\n        BOOST_CHECK(nRequired == 1);\n        BOOST_CHECK(IsMine(keystore, s));\n        BOOST_CHECK(!IsMine(emptykeystore, s));\n        BOOST_CHECK(!IsMine(partialkeystore, s));\n    }\n    {\n        vector\u003cvaltype\u003e solutions;\n        txnouttype whichType;\n        CScript s;\n        s \u003c\u003c OP_2 \u003c\u003c key[0].GetPubKey() \u003c\u003c key[1].GetPubKey() \u003c\u003c key[2].GetPubKey() \u003c\u003c OP_3 \u003c\u003c OP_CHECKMULTISIG;\n        BOOST_CHECK(Solver(s, whichType, solutions));\n        BOOST_CHECK(solutions.size() == 5);\n    }\n}\n\nBOOST_AUTO_TEST_CASE(multisig_Sign)\n{\n    // Test SignSignature() (and therefore the version of Solver() that signs transactions)\n    CBasicKeyStore keystore;\n    CKey key[4];\n    for (int i = 0; i \u003c 4; i++)\n    {\n        key[i].MakeNewKey(true);\n        keystore.AddKey(key[i]);\n    }\n\n    CScript a_and_b;\n    a_and_b \u003c\u003c OP_2 \u003c\u003c key[0].GetPubKey() \u003c\u003c key[1].GetPubKey() \u003c\u003c OP_2 \u003c\u003c OP_CHECKMULTISIG;\n\n    CScript a_or_b;\n    a_or_b  \u003c\u003c OP_1 \u003c\u003c key[0].GetPubKey() \u003c\u003c key[1].GetPubKey() \u003c\u003c OP_2 \u003c\u003c OP_CHECKMULTISIG;\n\n    CScript escrow;\n    escrow \u003c\u003c OP_2 \u003c\u003c key[0].GetPubKey() \u003c\u003c key[1].GetPubKey() \u003c\u003c key[2].GetPubKey() \u003c\u003c OP_3 \u003c\u003c OP_CHECKMULTISIG;\n\n    CTransaction txFrom;  // Funding transaction\n    txFrom.vout.resize(3);\n    txFrom.vout[0].scriptPubKey = a_and_b;\n    txFrom.vout[1].scriptPubKey = a_or_b;\n    txFrom.vout[2].scriptPubKey = escrow;\n\n    CTransaction txTo[3]; // Spending transaction\n    for (int i = 0; i \u003c 3; i++)\n    {\n        txTo[i].vin.resize(1);\n        txTo[i].vout.resize(1);\n        txTo[i].vin[0].prevout.n = i;\n        txTo[i].vin[0].prevout.hash = txFrom.GetHash();\n        txTo[i].vout[0].nValue = 1;\n    }\n\n    for (int i = 0; i \u003c 3; i++)\n    {\n        BOOST_CHECK_MESSAGE(SignSignature(keystore, txFrom, txTo[i], 0), strprintf(\"SignSignature %d\", i));\n    }\n}\n\n\nBOOST_AUTO_TEST_SUITE_END()\n"}
{"repo_name":"DLR-SC/tigl","ref":"refs/heads/master","path":"src/generated/CPACSFarField.cpp","copies":"1","language":"C++","content":"// Copyright (c) 2018 RISC Software GmbH\n//\n// This file was generated by CPACSGen from CPACS XML Schema (c) German Aerospace Center (DLR/SC).\n// Do not edit, all changes are lost when files are re-generated.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\")\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#include \"CPACSFarField.h\"\n#include \"CTiglError.h\"\n#include \"CTiglLogging.h\"\n#include \"TixiHelper.h\"\n\nnamespace tigl\n{\nnamespace generated\n{\n    CPACSFarField::CPACSFarField()\n        : m_referenceLength(0)\n        , m_multiplier(0)\n    {\n    }\n\n    CPACSFarField::~CPACSFarField()\n    {\n    }\n\n    void CPACSFarField::ReadCPACS(const TixiDocumentHandle\u0026 tixiHandle, const std::string\u0026 xpath)\n    {\n        // read element type\n        if (tixi::TixiCheckElement(tixiHandle, xpath + \"/type\")) {\n            m_type = stringToTiglFarFieldType(tixi::TixiGetElement\u003cstd::string\u003e(tixiHandle, xpath + \"/type\"));\n        }\n        else {\n            LOG(ERROR) \u003c\u003c \"Required element type is missing at xpath \" \u003c\u003c xpath;\n        }\n\n        // read element referenceLength\n        if (tixi::TixiCheckElement(tixiHandle, xpath + \"/referenceLength\")) {\n            m_referenceLength = tixi::TixiGetElement\u003cdouble\u003e(tixiHandle, xpath + \"/referenceLength\");\n        }\n        else {\n            LOG(ERROR) \u003c\u003c \"Required element referenceLength is missing at xpath \" \u003c\u003c xpath;\n        }\n\n        // read element multiplier\n        if (tixi::TixiCheckElement(tixiHandle, xpath + \"/multiplier\")) {\n            m_multiplier = tixi::TixiGetElement\u003cdouble\u003e(tixiHandle, xpath + \"/multiplier\");\n        }\n        else {\n            LOG(ERROR) \u003c\u003c \"Required element multiplier is missing at xpath \" \u003c\u003c xpath;\n        }\n\n    }\n\n    void CPACSFarField::WriteCPACS(const TixiDocumentHandle\u0026 tixiHandle, const std::string\u0026 xpath) const\n    {\n        // write element type\n        tixi::TixiCreateElementIfNotExists(tixiHandle, xpath + \"/type\");\n        tixi::TixiSaveElement(tixiHandle, xpath + \"/type\", TiglFarFieldTypeToString(m_type));\n\n        // write element referenceLength\n        tixi::TixiCreateElementIfNotExists(tixiHandle, xpath + \"/referenceLength\");\n        tixi::TixiSaveElement(tixiHandle, xpath + \"/referenceLength\", m_referenceLength);\n\n        // write element multiplier\n        tixi::TixiCreateElementIfNotExists(tixiHandle, xpath + \"/multiplier\");\n        tixi::TixiSaveElement(tixiHandle, xpath + \"/multiplier\", m_multiplier);\n\n    }\n\n    const TiglFarFieldType\u0026 CPACSFarField::GetType() const\n    {\n        return m_type;\n    }\n\n    void CPACSFarField::SetType(const TiglFarFieldType\u0026 value)\n    {\n        m_type = value;\n    }\n\n    const double\u0026 CPACSFarField::GetReferenceLength() const\n    {\n        return m_referenceLength;\n    }\n\n    void CPACSFarField::SetReferenceLength(const double\u0026 value)\n    {\n        m_referenceLength = value;\n    }\n\n    const double\u0026 CPACSFarField::GetMultiplier() const\n    {\n        return m_multiplier;\n    }\n\n    void CPACSFarField::SetMultiplier(const double\u0026 value)\n    {\n        m_multiplier = value;\n    }\n\n} // namespace generated\n} // namespace tigl\n"}
{"repo_name":"aybassiouny/wincaffe-cmake","ref":"refs/heads/master","path":"src/caffe/test/test_power_layer.cpp","copies":"46","language":"C++","content":"// Copyright 2014 BVLC and contributors.\n\n#include \u003calgorithm\u003e\n#include \u003cvector\u003e\n\n#include \"cuda_runtime.h\"\n#include \"gtest/gtest.h\"\n\n#include \"caffe/blob.hpp\"\n#include \"caffe/common.hpp\"\n#include \"caffe/filler.hpp\"\n#include \"caffe/vision_layers.hpp\"\n#include \"caffe/test/test_gradient_check_util.hpp\"\n\n#include \"caffe/test/test_caffe_main.hpp\"\n\nusing std::isnan;\n\nnamespace caffe {\n\nextern cudaDeviceProp CAFFE_TEST_CUDA_PROP;\n\ntemplate \u003ctypename Dtype\u003e\nclass PowerLayerTest : public ::testing::Test {\n protected:\n  PowerLayerTest()\n      : blob_bottom_(new Blob\u003cDtype\u003e(2, 3, 4, 5)),\n        blob_top_(new Blob\u003cDtype\u003e()) {\n    Caffe::set_random_seed(1701);\n    // fill the values\n    FillerParameter filler_param;\n    GaussianFiller\u003cDtype\u003e filler(filler_param);\n    filler.Fill(this-\u003eblob_bottom_);\n    blob_bottom_vec_.push_back(blob_bottom_);\n    blob_top_vec_.push_back(blob_top_);\n  }\n  virtual ~PowerLayerTest() { delete blob_bottom_; delete blob_top_; }\n\n  void TestForward(Dtype power, Dtype scale, Dtype shift) {\n    LayerParameter layer_param;\n    layer_param.mutable_power_param()-\u003eset_power(power);\n    layer_param.mutable_power_param()-\u003eset_scale(scale);\n    layer_param.mutable_power_param()-\u003eset_shift(shift);\n    PowerLayer\u003cDtype\u003e layer(layer_param);\n    layer.SetUp(this-\u003eblob_bottom_vec_, \u0026(this-\u003eblob_top_vec_));\n    layer.Forward(this-\u003eblob_bottom_vec_, \u0026(this-\u003eblob_top_vec_));\n    // Now, check values\n    const Dtype* bottom_data = this-\u003eblob_bottom_-\u003ecpu_data();\n    const Dtype* top_data = this-\u003eblob_top_-\u003ecpu_data();\n    const Dtype min_precision = 1e-5;\n    for (int i = 0; i \u003c this-\u003eblob_bottom_-\u003ecount(); ++i) {\n      Dtype expected_value = pow(shift + scale * bottom_data[i], power);\n      if (power == Dtype(0) || power == Dtype(1) || power == Dtype(2)) {\n        EXPECT_FALSE(isnan(top_data[i]));\n      }\n      if (isnan(expected_value)) {\n        EXPECT_TRUE(isnan(top_data[i]));\n      } else {\n        Dtype precision = max(Dtype(abs(expected_value * 0.0001)),\n                              min_precision);\n        EXPECT_NEAR(expected_value, top_data[i], precision);\n      }\n    }\n  }\n\n  void TestBackward(Dtype power, Dtype scale, Dtype shift) {\n    LayerParameter layer_param;\n    layer_param.mutable_power_param()-\u003eset_power(power);\n    layer_param.mutable_power_param()-\u003eset_scale(scale);\n    layer_param.mutable_power_param()-\u003eset_shift(shift);\n    PowerLayer\u003cDtype\u003e layer(layer_param);\n    if (power != Dtype(0) \u0026\u0026 power != Dtype(1) \u0026\u0026 power != Dtype(2)) {\n      // Avoid NaNs by forcing (shift + scale * x) \u003e= 0\n      Dtype* bottom_data = this-\u003eblob_bottom_-\u003emutable_cpu_data();\n      Dtype min_value = -shift / scale;\n      for (int i = 0; i \u003c this-\u003eblob_bottom_-\u003ecount(); ++i) {\n        if (bottom_data[i] \u003c min_value) {\n          bottom_data[i] = min_value + (min_value - bottom_data[i]);\n        }\n      }\n    }\n    GradientChecker\u003cDtype\u003e checker(1e-2, 1e-2, 1701, 0., 0.01);\n    checker.CheckGradientEltwise(\u0026layer, \u0026(this-\u003eblob_bottom_vec_),\n        \u0026(this-\u003eblob_top_vec_));\n  }\n\n  Blob\u003cDtype\u003e* const blob_bottom_;\n  Blob\u003cDtype\u003e* const blob_top_;\n  vector\u003cBlob\u003cDtype\u003e*\u003e blob_bottom_vec_;\n  vector\u003cBlob\u003cDtype\u003e*\u003e blob_top_vec_;\n};\n\ntypedef ::testing::Types\u003cfloat, double\u003e Dtypes;\nTYPED_TEST_CASE(PowerLayerTest, Dtypes);\n\nTYPED_TEST(PowerLayerTest, TestPowerCPU) {\n  Caffe::set_mode(Caffe::CPU);\n  TypeParam power = 0.37;\n  TypeParam scale = 0.83;\n  TypeParam shift = -2.4;\n  this-\u003eTestForward(power, scale, shift);\n}\n\nTYPED_TEST(PowerLayerTest, TestPowerGradientCPU) {\n  Caffe::set_mode(Caffe::CPU);\n  TypeParam power = 0.37;\n  TypeParam scale = 0.83;\n  TypeParam shift = -2.4;\n  this-\u003eTestBackward(power, scale, shift);\n}\n\nTYPED_TEST(PowerLayerTest, TestPowerGradientShiftZeroCPU) {\n  Caffe::set_mode(Caffe::CPU);\n  TypeParam power = 0.37;\n  TypeParam scale = 0.83;\n  TypeParam shift = 0.0;\n  this-\u003eTestBackward(power, scale, shift);\n}\n\nTYPED_TEST(PowerLayerTest, TestPowerZeroCPU) {\n  Caffe::set_mode(Caffe::CPU);\n  TypeParam power = 0.0;\n  TypeParam scale = 0.83;\n  TypeParam shift = -2.4;\n  this-\u003eTestForward(power, scale, shift);\n}\n\nTYPED_TEST(PowerLayerTest, TestPowerZeroGradientCPU) {\n  Caffe::set_mode(Caffe::CPU);\n  TypeParam power = 0.0;\n  TypeParam scale = 0.83;\n  TypeParam shift = -2.4;\n  this-\u003eTestBackward(power, scale, shift);\n}\n\nTYPED_TEST(PowerLayerTest, TestPowerOneCPU) {\n  Caffe::set_mode(Caffe::CPU);\n  TypeParam power = 1.0;\n  TypeParam scale = 0.83;\n  TypeParam shift = -2.4;\n  this-\u003eTestForward(power, scale, shift);\n}\n\nTYPED_TEST(PowerLayerTest, TestPowerOneGradientCPU) {\n  Caffe::set_mode(Caffe::CPU);\n  TypeParam power = 1.0;\n  TypeParam scale = 0.83;\n  TypeParam shift = -2.4;\n  this-\u003eTestBackward(power, scale, shift);\n}\n\nTYPED_TEST(PowerLayerTest, TestPowerTwoCPU) {\n  Caffe::set_mode(Caffe::CPU);\n  TypeParam power = 2.0;\n  TypeParam scale = 0.34;\n  TypeParam shift = -2.4;\n  this-\u003eTestForward(power, scale, shift);\n}\n\nTYPED_TEST(PowerLayerTest, TestPowerTwoGradientCPU) {\n  Caffe::set_mode(Caffe::CPU);\n  TypeParam power = 2.0;\n  TypeParam scale = 0.83;\n  TypeParam shift = -2.4;\n  this-\u003eTestBackward(power, scale, shift);\n}\n\nTYPED_TEST(PowerLayerTest, TestPowerTwoScaleHalfGradientCPU) {\n  Caffe::set_mode(Caffe::CPU);\n  TypeParam power = 2.0;\n  TypeParam scale = 0.5;\n  TypeParam shift = -2.4;\n  this-\u003eTestBackward(power, scale, shift);\n}\n\nTYPED_TEST(PowerLayerTest, TestPowerGPU) {\n  Caffe::set_mode(Caffe::GPU);\n  TypeParam power = 0.37;\n  TypeParam scale = 0.83;\n  TypeParam shift = -2.4;\n  this-\u003eTestForward(power, scale, shift);\n}\n\nTYPED_TEST(PowerLayerTest, TestPowerGradientGPU) {\n  Caffe::set_mode(Caffe::GPU);\n  TypeParam power = 0.37;\n  TypeParam scale = 0.83;\n  TypeParam shift = -2.4;\n  this-\u003eTestBackward(power, scale, shift);\n}\n\nTYPED_TEST(PowerLayerTest, TestPowerGradientShiftZeroGPU) {\n  Caffe::set_mode(Caffe::GPU);\n  TypeParam power = 0.37;\n  TypeParam scale = 0.83;\n  TypeParam shift = 0.0;\n  this-\u003eTestBackward(power, scale, shift);\n}\n\nTYPED_TEST(PowerLayerTest, TestPowerZeroGPU) {\n  Caffe::set_mode(Caffe::GPU);\n  TypeParam power = 0.0;\n  TypeParam scale = 0.83;\n  TypeParam shift = -2.4;\n  this-\u003eTestForward(power, scale, shift);\n}\n\nTYPED_TEST(PowerLayerTest, TestPowerZeroGradientGPU) {\n  Caffe::set_mode(Caffe::GPU);\n  TypeParam power = 0.0;\n  TypeParam scale = 0.83;\n  TypeParam shift = -2.4;\n  this-\u003eTestBackward(power, scale, shift);\n}\n\nTYPED_TEST(PowerLayerTest, TestPowerOneGPU) {\n  Caffe::set_mode(Caffe::GPU);\n  TypeParam power = 1.0;\n  TypeParam scale = 0.83;\n  TypeParam shift = -2.4;\n  this-\u003eTestForward(power, scale, shift);\n}\n\nTYPED_TEST(PowerLayerTest, TestPowerOneGradientGPU) {\n  Caffe::set_mode(Caffe::GPU);\n  TypeParam power = 1.0;\n  TypeParam scale = 0.83;\n  TypeParam shift = -2.4;\n  this-\u003eTestBackward(power, scale, shift);\n}\n\nTYPED_TEST(PowerLayerTest, TestPowerTwoGPU) {\n  Caffe::set_mode(Caffe::GPU);\n  TypeParam power = 2.0;\n  TypeParam scale = 0.34;\n  TypeParam shift = -2.4;\n  this-\u003eTestForward(power, scale, shift);\n}\n\nTYPED_TEST(PowerLayerTest, TestPowerTwoGradientGPU) {\n  Caffe::set_mode(Caffe::GPU);\n  TypeParam power = 2.0;\n  TypeParam scale = 0.83;\n  TypeParam shift = -2.4;\n  this-\u003eTestBackward(power, scale, shift);\n}\n\nTYPED_TEST(PowerLayerTest, TestPowerTwoScaleHalfGradientGPU) {\n  Caffe::set_mode(Caffe::GPU);\n  TypeParam power = 2.0;\n  TypeParam scale = 0.5;\n  TypeParam shift = -2.4;\n  this-\u003eTestBackward(power, scale, shift);\n}\n\n}  // namespace caffe\n"}
{"repo_name":"pduuubs/render3D","ref":"refs/heads/master","path":"libs/eigen/test/geo_transformations.cpp","copies":"92","language":"C++","content":"// This file is part of Eigen, a lightweight C++ template library\n// for linear algebra.\n//\n// Copyright (C) 2008-2009 Gael Guennebaud \u003cgael.guennebaud@inria.fr\u003e\n//\n// This Source Code Form is subject to the terms of the Mozilla\n// Public License v. 2.0. If a copy of the MPL was not distributed\n// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n#include \"main.h\"\n#include \u003cEigen/Geometry\u003e\n#include \u003cEigen/LU\u003e\n#include \u003cEigen/SVD\u003e\n\ntemplate\u003ctypename T\u003e\nMatrix\u003cT,2,1\u003e angleToVec(T a)\n{\n  return Matrix\u003cT,2,1\u003e(std::cos(a), std::sin(a));\n}\n\n// This permits to workaround a bug in clang/llvm code generation.\ntemplate\u003ctypename T\u003e\nEIGEN_DONT_INLINE\nvoid dont_over_optimize(T\u0026 x) { volatile typename T::Scalar tmp = x(0); x(0) = tmp; }\n\ntemplate\u003ctypename Scalar, int Mode, int Options\u003e void non_projective_only()\n{\n    /* this test covers the following files:\n     Cross.h Quaternion.h, Transform.cpp\n  */\n  typedef Matrix\u003cScalar,3,1\u003e Vector3;\n  typedef Quaternion\u003cScalar\u003e Quaternionx;\n  typedef AngleAxis\u003cScalar\u003e AngleAxisx;\n  typedef Transform\u003cScalar,3,Mode,Options\u003e Transform3;\n  typedef DiagonalMatrix\u003cScalar,3\u003e AlignedScaling3;\n  typedef Translation\u003cScalar,3\u003e Translation3;\n\n  Vector3 v0 = Vector3::Random(),\n          v1 = Vector3::Random();\n\n  Transform3 t0, t1, t2;\n\n  Scalar a = internal::random\u003cScalar\u003e(-Scalar(EIGEN_PI), Scalar(EIGEN_PI));\n\n  Quaternionx q1, q2;\n\n  q1 = AngleAxisx(a, v0.normalized());\n\n  t0 = Transform3::Identity();\n  VERIFY_IS_APPROX(t0.matrix(), Transform3::MatrixType::Identity());\n\n  t0.linear() = q1.toRotationMatrix();\n\n  v0 \u003c\u003c 50, 2, 1;\n  t0.scale(v0);\n\n  VERIFY_IS_APPROX( (t0 * Vector3(1,0,0)).template head\u003c3\u003e().norm(), v0.x());\n\n  t0.setIdentity();\n  t1.setIdentity();\n  v1 \u003c\u003c 1, 2, 3;\n  t0.linear() = q1.toRotationMatrix();\n  t0.pretranslate(v0);\n  t0.scale(v1);\n  t1.linear() = q1.conjugate().toRotationMatrix();\n  t1.prescale(v1.cwiseInverse());\n  t1.translate(-v0);\n\n  VERIFY((t0 * t1).matrix().isIdentity(test_precision\u003cScalar\u003e()));\n\n  t1.fromPositionOrientationScale(v0, q1, v1);\n  VERIFY_IS_APPROX(t1.matrix(), t0.matrix());\n  VERIFY_IS_APPROX(t1*v1, t0*v1);\n\n  // translation * vector\n  t0.setIdentity();\n  t0.translate(v0);\n  VERIFY_IS_APPROX((t0 * v1).template head\u003c3\u003e(), Translation3(v0) * v1);\n\n  // AlignedScaling * vector\n  t0.setIdentity();\n  t0.scale(v0);\n  VERIFY_IS_APPROX((t0 * v1).template head\u003c3\u003e(), AlignedScaling3(v0) * v1);\n}\n\ntemplate\u003ctypename Scalar, int Mode, int Options\u003e void transformations()\n{\n  /* this test covers the following files:\n     Cross.h Quaternion.h, Transform.cpp\n  */\n  using std::cos;\n  using std::abs;\n  typedef Matrix\u003cScalar,3,3\u003e Matrix3;\n  typedef Matrix\u003cScalar,4,4\u003e Matrix4;\n  typedef Matrix\u003cScalar,2,1\u003e Vector2;\n  typedef Matrix\u003cScalar,3,1\u003e Vector3;\n  typedef Matrix\u003cScalar,4,1\u003e Vector4;\n  typedef Quaternion\u003cScalar\u003e Quaternionx;\n  typedef AngleAxis\u003cScalar\u003e AngleAxisx;\n  typedef Transform\u003cScalar,2,Mode,Options\u003e Transform2;\n  typedef Transform\u003cScalar,3,Mode,Options\u003e Transform3;\n  typedef typename Transform3::MatrixType MatrixType;\n  typedef DiagonalMatrix\u003cScalar,3\u003e AlignedScaling3;\n  typedef Translation\u003cScalar,2\u003e Translation2;\n  typedef Translation\u003cScalar,3\u003e Translation3;\n\n  Vector3 v0 = Vector3::Random(),\n          v1 = Vector3::Random();\n  Matrix3 matrot1, m;\n\n  Scalar a = internal::random\u003cScalar\u003e(-Scalar(EIGEN_PI), Scalar(EIGEN_PI));\n  Scalar s0 = internal::random\u003cScalar\u003e(), s1 = internal::random\u003cScalar\u003e();\n  \n  while(v0.norm() \u003c test_precision\u003cScalar\u003e()) v0 = Vector3::Random();\n  while(v1.norm() \u003c test_precision\u003cScalar\u003e()) v1 = Vector3::Random();\n\n  VERIFY_IS_APPROX(v0, AngleAxisx(a, v0.normalized()) * v0);\n  VERIFY_IS_APPROX(-v0, AngleAxisx(Scalar(EIGEN_PI), v0.unitOrthogonal()) * v0);\n  if(abs(cos(a)) \u003e test_precision\u003cScalar\u003e())\n  {\n    VERIFY_IS_APPROX(cos(a)*v0.squaredNorm(), v0.dot(AngleAxisx(a, v0.unitOrthogonal()) * v0));\n  }\n  m = AngleAxisx(a, v0.normalized()).toRotationMatrix().adjoint();\n  VERIFY_IS_APPROX(Matrix3::Identity(), m * AngleAxisx(a, v0.normalized()));\n  VERIFY_IS_APPROX(Matrix3::Identity(), AngleAxisx(a, v0.normalized()) * m);\n\n  Quaternionx q1, q2;\n  q1 = AngleAxisx(a, v0.normalized());\n  q2 = AngleAxisx(a, v1.normalized());\n\n  // rotation matrix conversion\n  matrot1 = AngleAxisx(Scalar(0.1), Vector3::UnitX())\n          * AngleAxisx(Scalar(0.2), Vector3::UnitY())\n          * AngleAxisx(Scalar(0.3), Vector3::UnitZ());\n  VERIFY_IS_APPROX(matrot1 * v1,\n       AngleAxisx(Scalar(0.1), Vector3(1,0,0)).toRotationMatrix()\n    * (AngleAxisx(Scalar(0.2), Vector3(0,1,0)).toRotationMatrix()\n    * (AngleAxisx(Scalar(0.3), Vector3(0,0,1)).toRotationMatrix() * v1)));\n\n  // angle-axis conversion\n  AngleAxisx aa = AngleAxisx(q1);\n  VERIFY_IS_APPROX(q1 * v1, Quaternionx(aa) * v1);\n  \n  // The following test is stable only if 2*angle != angle and v1 is not colinear with axis\n  if( (abs(aa.angle()) \u003e test_precision\u003cScalar\u003e()) \u0026\u0026 (abs(aa.axis().dot(v1.normalized()))\u003c(Scalar(1)-Scalar(4)*test_precision\u003cScalar\u003e())) )\n  {\n    VERIFY( !(q1 * v1).isApprox(Quaternionx(AngleAxisx(aa.angle()*2,aa.axis())) * v1) );\n  }\n\n  aa.fromRotationMatrix(aa.toRotationMatrix());\n  VERIFY_IS_APPROX(q1 * v1, Quaternionx(aa) * v1);\n  // The following test is stable only if 2*angle != angle and v1 is not colinear with axis\n  if( (abs(aa.angle()) \u003e test_precision\u003cScalar\u003e()) \u0026\u0026 (abs(aa.axis().dot(v1.normalized()))\u003c(Scalar(1)-Scalar(4)*test_precision\u003cScalar\u003e())) )\n  {\n    VERIFY( !(q1 * v1).isApprox(Quaternionx(AngleAxisx(aa.angle()*2,aa.axis())) * v1) );\n  }\n\n  // AngleAxis\n  VERIFY_IS_APPROX(AngleAxisx(a,v1.normalized()).toRotationMatrix(),\n    Quaternionx(AngleAxisx(a,v1.normalized())).toRotationMatrix());\n\n  AngleAxisx aa1;\n  m = q1.toRotationMatrix();\n  aa1 = m;\n  VERIFY_IS_APPROX(AngleAxisx(m).toRotationMatrix(),\n    Quaternionx(m).toRotationMatrix());\n\n  // Transform\n  // TODO complete the tests !\n  a = 0;\n  while (abs(a)\u003cScalar(0.1))\n    a = internal::random\u003cScalar\u003e(-Scalar(0.4)*Scalar(EIGEN_PI), Scalar(0.4)*Scalar(EIGEN_PI));\n  q1 = AngleAxisx(a, v0.normalized());\n  Transform3 t0, t1, t2;\n\n  // first test setIdentity() and Identity()\n  t0.setIdentity();\n  VERIFY_IS_APPROX(t0.matrix(), Transform3::MatrixType::Identity());\n  t0.matrix().setZero();\n  t0 = Transform3::Identity();\n  VERIFY_IS_APPROX(t0.matrix(), Transform3::MatrixType::Identity());\n\n  t0.setIdentity();\n  t1.setIdentity();\n  v1 \u003c\u003c 1, 2, 3;\n  t0.linear() = q1.toRotationMatrix();\n  t0.pretranslate(v0);\n  t0.scale(v1);\n  t1.linear() = q1.conjugate().toRotationMatrix();\n  t1.prescale(v1.cwiseInverse());\n  t1.translate(-v0);\n\n  VERIFY((t0 * t1).matrix().isIdentity(test_precision\u003cScalar\u003e()));\n\n  t1.fromPositionOrientationScale(v0, q1, v1);\n  VERIFY_IS_APPROX(t1.matrix(), t0.matrix());\n\n  t0.setIdentity(); t0.scale(v0).rotate(q1.toRotationMatrix());\n  t1.setIdentity(); t1.scale(v0).rotate(q1);\n  VERIFY_IS_APPROX(t0.matrix(), t1.matrix());\n\n  t0.setIdentity(); t0.scale(v0).rotate(AngleAxisx(q1));\n  VERIFY_IS_APPROX(t0.matrix(), t1.matrix());\n\n  VERIFY_IS_APPROX(t0.scale(a).matrix(), t1.scale(Vector3::Constant(a)).matrix());\n  VERIFY_IS_APPROX(t0.prescale(a).matrix(), t1.prescale(Vector3::Constant(a)).matrix());\n\n  // More transform constructors, operator=, operator*=\n\n  Matrix3 mat3 = Matrix3::Random();\n  Matrix4 mat4;\n  mat4 \u003c\u003c mat3 , Vector3::Zero() , Vector4::Zero().transpose();\n  Transform3 tmat3(mat3), tmat4(mat4);\n  if(Mode!=int(AffineCompact))\n    tmat4.matrix()(3,3) = Scalar(1);\n  VERIFY_IS_APPROX(tmat3.matrix(), tmat4.matrix());\n\n  Scalar a3 = internal::random\u003cScalar\u003e(-Scalar(EIGEN_PI), Scalar(EIGEN_PI));\n  Vector3 v3 = Vector3::Random().normalized();\n  AngleAxisx aa3(a3, v3);\n  Transform3 t3(aa3);\n  Transform3 t4;\n  t4 = aa3;\n  VERIFY_IS_APPROX(t3.matrix(), t4.matrix());\n  t4.rotate(AngleAxisx(-a3,v3));\n  VERIFY_IS_APPROX(t4.matrix(), MatrixType::Identity());\n  t4 *= aa3;\n  VERIFY_IS_APPROX(t3.matrix(), t4.matrix());\n\n  do {\n    v3 = Vector3::Random();\n    dont_over_optimize(v3);\n  } while (v3.cwiseAbs().minCoeff()\u003cNumTraits\u003cScalar\u003e::epsilon());\n  Translation3 tv3(v3);\n  Transform3 t5(tv3);\n  t4 = tv3;\n  VERIFY_IS_APPROX(t5.matrix(), t4.matrix());\n  t4.translate((-v3).eval());\n  VERIFY_IS_APPROX(t4.matrix(), MatrixType::Identity());\n  t4 *= tv3;\n  VERIFY_IS_APPROX(t5.matrix(), t4.matrix());\n\n  AlignedScaling3 sv3(v3);\n  Transform3 t6(sv3);\n  t4 = sv3;\n  VERIFY_IS_APPROX(t6.matrix(), t4.matrix());\n  t4.scale(v3.cwiseInverse());\n  VERIFY_IS_APPROX(t4.matrix(), MatrixType::Identity());\n  t4 *= sv3;\n  VERIFY_IS_APPROX(t6.matrix(), t4.matrix());\n\n  // matrix * transform\n  VERIFY_IS_APPROX((t3.matrix()*t4).matrix(), (t3*t4).matrix());\n\n  // chained Transform product\n  VERIFY_IS_APPROX(((t3*t4)*t5).matrix(), (t3*(t4*t5)).matrix());\n\n  // check that Transform product doesn't have aliasing problems\n  t5 = t4;\n  t5 = t5*t5;\n  VERIFY_IS_APPROX(t5, t4*t4);\n\n  // 2D transformation\n  Transform2 t20, t21;\n  Vector2 v20 = Vector2::Random();\n  Vector2 v21 = Vector2::Random();\n  for (int k=0; k\u003c2; ++k)\n    if (abs(v21[k])\u003cScalar(1e-3)) v21[k] = Scalar(1e-3);\n  t21.setIdentity();\n  t21.linear() = Rotation2D\u003cScalar\u003e(a).toRotationMatrix();\n  VERIFY_IS_APPROX(t20.fromPositionOrientationScale(v20,a,v21).matrix(),\n    t21.pretranslate(v20).scale(v21).matrix());\n\n  t21.setIdentity();\n  t21.linear() = Rotation2D\u003cScalar\u003e(-a).toRotationMatrix();\n  VERIFY( (t20.fromPositionOrientationScale(v20,a,v21)\n        * (t21.prescale(v21.cwiseInverse()).translate(-v20))).matrix().isIdentity(test_precision\u003cScalar\u003e()) );\n\n  // Transform - new API\n  // 3D\n  t0.setIdentity();\n  t0.rotate(q1).scale(v0).translate(v0);\n  // mat * aligned scaling and mat * translation\n  t1 = (Matrix3(q1) * AlignedScaling3(v0)) * Translation3(v0);\n  VERIFY_IS_APPROX(t0.matrix(), t1.matrix());\n  t1 = (Matrix3(q1) * Eigen::Scaling(v0)) * Translation3(v0);\n  VERIFY_IS_APPROX(t0.matrix(), t1.matrix());\n  t1 = (q1 * Eigen::Scaling(v0)) * Translation3(v0);\n  VERIFY_IS_APPROX(t0.matrix(), t1.matrix());\n  // mat * transformation and aligned scaling * translation\n  t1 = Matrix3(q1) * (AlignedScaling3(v0) * Translation3(v0));\n  VERIFY_IS_APPROX(t0.matrix(), t1.matrix());\n\n\n  t0.setIdentity();\n  t0.scale(s0).translate(v0);\n  t1 = Eigen::Scaling(s0) * Translation3(v0);\n  VERIFY_IS_APPROX(t0.matrix(), t1.matrix());\n  t0.prescale(s0);\n  t1 = Eigen::Scaling(s0) * t1;\n  VERIFY_IS_APPROX(t0.matrix(), t1.matrix());\n  \n  t0 = t3;\n  t0.scale(s0);\n  t1 = t3 * Eigen::Scaling(s0,s0,s0);\n  VERIFY_IS_APPROX(t0.matrix(), t1.matrix());\n  t0.prescale(s0);\n  t1 = Eigen::Scaling(s0,s0,s0) * t1;\n  VERIFY_IS_APPROX(t0.matrix(), t1.matrix());\n\n  t0 = t3;\n  t0.scale(s0);\n  t1 = t3 * Eigen::Scaling(s0);\n  VERIFY_IS_APPROX(t0.matrix(), t1.matrix());\n  t0.prescale(s0);\n  t1 = Eigen::Scaling(s0) * t1;\n  VERIFY_IS_APPROX(t0.matrix(), t1.matrix());\n\n  t0.setIdentity();\n  t0.prerotate(q1).prescale(v0).pretranslate(v0);\n  // translation * aligned scaling and transformation * mat\n  t1 = (Translation3(v0) * AlignedScaling3(v0)) * Transform3(q1);\n  VERIFY_IS_APPROX(t0.matrix(), t1.matrix());\n  // scaling * mat and translation * mat\n  t1 = Translation3(v0) * (AlignedScaling3(v0) * Transform3(q1));\n  VERIFY_IS_APPROX(t0.matrix(), t1.matrix());\n\n  t0.setIdentity();\n  t0.scale(v0).translate(v0).rotate(q1);\n  // translation * mat and aligned scaling * transformation\n  t1 = AlignedScaling3(v0) * (Translation3(v0) * Transform3(q1));\n  VERIFY_IS_APPROX(t0.matrix(), t1.matrix());\n  // transformation * aligned scaling\n  t0.scale(v0);\n  t1 *= AlignedScaling3(v0);\n  VERIFY_IS_APPROX(t0.matrix(), t1.matrix());\n  t1 = AlignedScaling3(v0) * (Translation3(v0) * Transform3(q1));\n  t1 = t1 * v0.asDiagonal();\n  VERIFY_IS_APPROX(t0.matrix(), t1.matrix());\n  // transformation * translation\n  t0.translate(v0);\n  t1 = t1 * Translation3(v0);\n  VERIFY_IS_APPROX(t0.matrix(), t1.matrix());\n  // translation * transformation\n  t0.pretranslate(v0);\n  t1 = Translation3(v0) * t1;\n  VERIFY_IS_APPROX(t0.matrix(), t1.matrix());\n\n  // transform * quaternion\n  t0.rotate(q1);\n  t1 = t1 * q1;\n  VERIFY_IS_APPROX(t0.matrix(), t1.matrix());\n\n  // translation * quaternion\n  t0.translate(v1).rotate(q1);\n  t1 = t1 * (Translation3(v1) * q1);\n  VERIFY_IS_APPROX(t0.matrix(), t1.matrix());\n\n  // aligned scaling * quaternion\n  t0.scale(v1).rotate(q1);\n  t1 = t1 * (AlignedScaling3(v1) * q1);\n  VERIFY_IS_APPROX(t0.matrix(), t1.matrix());\n\n  // quaternion * transform\n  t0.prerotate(q1);\n  t1 = q1 * t1;\n  VERIFY_IS_APPROX(t0.matrix(), t1.matrix());\n\n  // quaternion * translation\n  t0.rotate(q1).translate(v1);\n  t1 = t1 * (q1 * Translation3(v1));\n  VERIFY_IS_APPROX(t0.matrix(), t1.matrix());\n\n  // quaternion * aligned scaling\n  t0.rotate(q1).scale(v1);\n  t1 = t1 * (q1 * AlignedScaling3(v1));\n  VERIFY_IS_APPROX(t0.matrix(), t1.matrix());\n\n  // test transform inversion\n  t0.setIdentity();\n  t0.translate(v0);\n  do {\n    t0.linear().setRandom();\n  } while(t0.linear().jacobiSvd().singularValues()(2)\u003ctest_precision\u003cScalar\u003e());\n  Matrix4 t044 = Matrix4::Zero();\n  t044(3,3) = 1;\n  t044.block(0,0,t0.matrix().rows(),4) = t0.matrix();\n  VERIFY_IS_APPROX(t0.inverse(Affine).matrix(), t044.inverse().block(0,0,t0.matrix().rows(),4));\n  t0.setIdentity();\n  t0.translate(v0).rotate(q1);\n  t044 = Matrix4::Zero();\n  t044(3,3) = 1;\n  t044.block(0,0,t0.matrix().rows(),4) = t0.matrix();\n  VERIFY_IS_APPROX(t0.inverse(Isometry).matrix(), t044.inverse().block(0,0,t0.matrix().rows(),4));\n\n  Matrix3 mat_rotation, mat_scaling;\n  t0.setIdentity();\n  t0.translate(v0).rotate(q1).scale(v1);\n  t0.computeRotationScaling(\u0026mat_rotation, \u0026mat_scaling);\n  VERIFY_IS_APPROX(t0.linear(), mat_rotation * mat_scaling);\n  VERIFY_IS_APPROX(mat_rotation*mat_rotation.adjoint(), Matrix3::Identity());\n  VERIFY_IS_APPROX(mat_rotation.determinant(), Scalar(1));\n  t0.computeScalingRotation(\u0026mat_scaling, \u0026mat_rotation);\n  VERIFY_IS_APPROX(t0.linear(), mat_scaling * mat_rotation);\n  VERIFY_IS_APPROX(mat_rotation*mat_rotation.adjoint(), Matrix3::Identity());\n  VERIFY_IS_APPROX(mat_rotation.determinant(), Scalar(1));\n\n  // test casting\n  Transform\u003cfloat,3,Mode\u003e t1f = t1.template cast\u003cfloat\u003e();\n  VERIFY_IS_APPROX(t1f.template cast\u003cScalar\u003e(),t1);\n  Transform\u003cdouble,3,Mode\u003e t1d = t1.template cast\u003cdouble\u003e();\n  VERIFY_IS_APPROX(t1d.template cast\u003cScalar\u003e(),t1);\n\n  Translation3 tr1(v0);\n  Translation\u003cfloat,3\u003e tr1f = tr1.template cast\u003cfloat\u003e();\n  VERIFY_IS_APPROX(tr1f.template cast\u003cScalar\u003e(),tr1);\n  Translation\u003cdouble,3\u003e tr1d = tr1.template cast\u003cdouble\u003e();\n  VERIFY_IS_APPROX(tr1d.template cast\u003cScalar\u003e(),tr1);\n\n  AngleAxis\u003cfloat\u003e aa1f = aa1.template cast\u003cfloat\u003e();\n  VERIFY_IS_APPROX(aa1f.template cast\u003cScalar\u003e(),aa1);\n  AngleAxis\u003cdouble\u003e aa1d = aa1.template cast\u003cdouble\u003e();\n  VERIFY_IS_APPROX(aa1d.template cast\u003cScalar\u003e(),aa1);\n\n  Rotation2D\u003cScalar\u003e r2d1(internal::random\u003cScalar\u003e());\n  Rotation2D\u003cfloat\u003e r2d1f = r2d1.template cast\u003cfloat\u003e();\n  VERIFY_IS_APPROX(r2d1f.template cast\u003cScalar\u003e(),r2d1);\n  Rotation2D\u003cdouble\u003e r2d1d = r2d1.template cast\u003cdouble\u003e();\n  VERIFY_IS_APPROX(r2d1d.template cast\u003cScalar\u003e(),r2d1);\n  \n  for(int k=0; k\u003c100; ++k)\n  {\n    Scalar angle = internal::random\u003cScalar\u003e(-100,100);\n    Rotation2D\u003cScalar\u003e rot2(angle);\n    VERIFY( rot2.smallestPositiveAngle() \u003e= 0 );\n    VERIFY( rot2.smallestPositiveAngle() \u003c= Scalar(2)*Scalar(EIGEN_PI) );\n    VERIFY_IS_APPROX( angleToVec(rot2.smallestPositiveAngle()), angleToVec(rot2.angle()) );\n    \n    VERIFY( rot2.smallestAngle() \u003e= -Scalar(EIGEN_PI) );\n    VERIFY( rot2.smallestAngle() \u003c=  Scalar(EIGEN_PI) );\n    VERIFY_IS_APPROX( angleToVec(rot2.smallestAngle()), angleToVec(rot2.angle()) );\n\n    Matrix\u003cScalar,2,2\u003e rot2_as_mat(rot2);\n    Rotation2D\u003cScalar\u003e rot3(rot2_as_mat);\n    VERIFY_IS_APPROX( angleToVec(rot2.smallestAngle()),  angleToVec(rot3.angle()) );\n  }\n\n  s0 = internal::random\u003cScalar\u003e(-100,100);\n  s1 = internal::random\u003cScalar\u003e(-100,100);\n  Rotation2D\u003cScalar\u003e R0(s0), R1(s1);\n  \n  t20 = Translation2(v20) * (R0 * Eigen::Scaling(s0));\n  t21 = Translation2(v20) * R0 * Eigen::Scaling(s0);\n  VERIFY_IS_APPROX(t20,t21);\n  \n  t20 = Translation2(v20) * (R0 * R0.inverse() * Eigen::Scaling(s0));\n  t21 = Translation2(v20) * Eigen::Scaling(s0);\n  VERIFY_IS_APPROX(t20,t21);\n  \n  VERIFY_IS_APPROX(s0, (R0.slerp(0, R1)).angle());\n  VERIFY_IS_APPROX( angleToVec(R1.smallestPositiveAngle()), angleToVec((R0.slerp(1, R1)).smallestPositiveAngle()) );\n  VERIFY_IS_APPROX(R0.smallestPositiveAngle(), (R0.slerp(0.5, R0)).smallestPositiveAngle());\n\n  if(std::cos(s0)\u003e0)\n    VERIFY_IS_MUCH_SMALLER_THAN((R0.slerp(0.5, R0.inverse())).smallestAngle(), Scalar(1));\n  else\n    VERIFY_IS_APPROX(Scalar(EIGEN_PI), (R0.slerp(0.5, R0.inverse())).smallestPositiveAngle());\n  \n  // Check path length\n  Scalar l = 0;\n  int path_steps = 100;\n  for(int k=0; k\u003cpath_steps; ++k)\n  {\n    Scalar a1 = R0.slerp(Scalar(k)/Scalar(path_steps), R1).angle();\n    Scalar a2 = R0.slerp(Scalar(k+1)/Scalar(path_steps), R1).angle();\n    l += std::abs(a2-a1);\n  }\n  VERIFY(l\u003c=Scalar(EIGEN_PI)*(Scalar(1)+NumTraits\u003cScalar\u003e::epsilon()*Scalar(path_steps/2)));\n  \n  // check basic features\n  {\n    Rotation2D\u003cScalar\u003e r1;           // default ctor\n    r1 = Rotation2D\u003cScalar\u003e(s0);     // copy assignment\n    VERIFY_IS_APPROX(r1.angle(),s0);\n    Rotation2D\u003cScalar\u003e r2(r1);       // copy ctor\n    VERIFY_IS_APPROX(r2.angle(),s0);\n  }\n\n  {\n    Transform3 t32(Matrix4::Random()), t33, t34;\n    t34 = t33 = t32;\n    t32.scale(v0);\n    t33*=AlignedScaling3(v0);\n    VERIFY_IS_APPROX(t32.matrix(), t33.matrix());\n    t33 = t34 * AlignedScaling3(v0);\n    VERIFY_IS_APPROX(t32.matrix(), t33.matrix());\n  }\n\n}\n\ntemplate\u003ctypename A1, typename A2, typename P, typename Q, typename V, typename H\u003e\nvoid transform_associativity_left(const A1\u0026 a1, const A2\u0026 a2, const P\u0026 p, const Q\u0026 q, const V\u0026 v, const H\u0026 h)\n{\n  VERIFY_IS_APPROX( q*(a1*v), (q*a1)*v );\n  VERIFY_IS_APPROX( q*(a2*v), (q*a2)*v );\n  VERIFY_IS_APPROX( q*(p*h).hnormalized(),  ((q*p)*h).hnormalized() );\n}\n\ntemplate\u003ctypename A1, typename A2, typename P, typename Q, typename V, typename H\u003e\nvoid transform_associativity2(const A1\u0026 a1, const A2\u0026 a2, const P\u0026 p, const Q\u0026 q, const V\u0026 v, const H\u0026 h)\n{\n  VERIFY_IS_APPROX( a1*(q*v), (a1*q)*v );\n  VERIFY_IS_APPROX( a2*(q*v), (a2*q)*v );\n  VERIFY_IS_APPROX( p *(q*v).homogeneous(), (p *q)*v.homogeneous() );\n\n  transform_associativity_left(a1, a2,p, q, v, h);\n}\n\ntemplate\u003ctypename Scalar, int Dim, int Options,typename RotationType\u003e\nvoid transform_associativity(const RotationType\u0026 R)\n{\n  typedef Matrix\u003cScalar,Dim,1\u003e VectorType;\n  typedef Matrix\u003cScalar,Dim+1,1\u003e HVectorType;\n  typedef Matrix\u003cScalar,Dim,Dim\u003e LinearType;\n  typedef Matrix\u003cScalar,Dim+1,Dim+1\u003e MatrixType;\n  typedef Transform\u003cScalar,Dim,AffineCompact,Options\u003e AffineCompactType;\n  typedef Transform\u003cScalar,Dim,Affine,Options\u003e AffineType;\n  typedef Transform\u003cScalar,Dim,Projective,Options\u003e ProjectiveType;\n  typedef DiagonalMatrix\u003cScalar,Dim\u003e ScalingType;\n  typedef Translation\u003cScalar,Dim\u003e TranslationType;\n\n  AffineCompactType A1c; A1c.matrix().setRandom();\n  AffineCompactType A2c; A2c.matrix().setRandom();\n  AffineType A1(A1c);\n  AffineType A2(A2c);\n  ProjectiveType P1; P1.matrix().setRandom();\n  VectorType v1 = VectorType::Random();\n  VectorType v2 = VectorType::Random();\n  HVectorType h1 = HVectorType::Random();\n  Scalar s1 = internal::random\u003cScalar\u003e();\n  LinearType L = LinearType::Random();\n  MatrixType M = MatrixType::Random();\n\n  CALL_SUBTEST( transform_associativity2(A1c, A1, P1, A2, v2, h1) );\n  CALL_SUBTEST( transform_associativity2(A1c, A1, P1, A2c, v2, h1) );\n  CALL_SUBTEST( transform_associativity2(A1c, A1, P1, v1.asDiagonal(), v2, h1) );\n  CALL_SUBTEST( transform_associativity2(A1c, A1, P1, ScalingType(v1), v2, h1) );\n  CALL_SUBTEST( transform_associativity2(A1c, A1, P1, Scaling(v1), v2, h1) );\n  CALL_SUBTEST( transform_associativity2(A1c, A1, P1, Scaling(s1), v2, h1) );\n  CALL_SUBTEST( transform_associativity2(A1c, A1, P1, TranslationType(v1), v2, h1) );\n  CALL_SUBTEST( transform_associativity_left(A1c, A1, P1, L, v2, h1) );\n  CALL_SUBTEST( transform_associativity2(A1c, A1, P1, R, v2, h1) );\n\n  VERIFY_IS_APPROX( A1*(M*h1), (A1*M)*h1 );\n  VERIFY_IS_APPROX( A1c*(M*h1), (A1c*M)*h1 );\n  VERIFY_IS_APPROX( P1*(M*h1), (P1*M)*h1 );\n\n  VERIFY_IS_APPROX( M*(A1*h1), (M*A1)*h1 );\n  VERIFY_IS_APPROX( M*(A1c*h1), (M*A1c)*h1 );\n  VERIFY_IS_APPROX( M*(P1*h1),  ((M*P1)*h1) );\n}\n\ntemplate\u003ctypename Scalar\u003e void transform_alignment()\n{\n  typedef Transform\u003cScalar,3,Projective,AutoAlign\u003e Projective3a;\n  typedef Transform\u003cScalar,3,Projective,DontAlign\u003e Projective3u;\n\n  EIGEN_ALIGN_MAX Scalar array1[16];\n  EIGEN_ALIGN_MAX Scalar array2[16];\n  EIGEN_ALIGN_MAX Scalar array3[16+1];\n  Scalar* array3u = array3+1;\n\n  Projective3a *p1 = ::new(reinterpret_cast\u003cvoid*\u003e(array1)) Projective3a;\n  Projective3u *p2 = ::new(reinterpret_cast\u003cvoid*\u003e(array2)) Projective3u;\n  Projective3u *p3 = ::new(reinterpret_cast\u003cvoid*\u003e(array3u)) Projective3u;\n  \n  p1-\u003ematrix().setRandom();\n  *p2 = *p1;\n  *p3 = *p1;\n\n  VERIFY_IS_APPROX(p1-\u003ematrix(), p2-\u003ematrix());\n  VERIFY_IS_APPROX(p1-\u003ematrix(), p3-\u003ematrix());\n  \n  VERIFY_IS_APPROX( (*p1) * (*p1), (*p2)*(*p3));\n  \n  #if defined(EIGEN_VECTORIZE) \u0026\u0026 EIGEN_MAX_STATIC_ALIGN_BYTES\u003e0\n  if(internal::packet_traits\u003cScalar\u003e::Vectorizable)\n    VERIFY_RAISES_ASSERT((::new(reinterpret_cast\u003cvoid*\u003e(array3u)) Projective3a));\n  #endif\n}\n\ntemplate\u003ctypename Scalar, int Dim, int Options\u003e void transform_products()\n{\n  typedef Matrix\u003cScalar,Dim+1,Dim+1\u003e Mat;\n  typedef Transform\u003cScalar,Dim,Projective,Options\u003e Proj;\n  typedef Transform\u003cScalar,Dim,Affine,Options\u003e Aff;\n  typedef Transform\u003cScalar,Dim,AffineCompact,Options\u003e AffC;\n\n  Proj p; p.matrix().setRandom();\n  Aff a; a.linear().setRandom(); a.translation().setRandom();\n  AffC ac = a;\n\n  Mat p_m(p.matrix()), a_m(a.matrix());\n\n  VERIFY_IS_APPROX((p*p).matrix(), p_m*p_m);\n  VERIFY_IS_APPROX((a*a).matrix(), a_m*a_m);\n  VERIFY_IS_APPROX((p*a).matrix(), p_m*a_m);\n  VERIFY_IS_APPROX((a*p).matrix(), a_m*p_m);\n  VERIFY_IS_APPROX((ac*a).matrix(), a_m*a_m);\n  VERIFY_IS_APPROX((a*ac).matrix(), a_m*a_m);\n  VERIFY_IS_APPROX((p*ac).matrix(), p_m*a_m);\n  VERIFY_IS_APPROX((ac*p).matrix(), a_m*p_m);\n}\n\nvoid test_geo_transformations()\n{\n  for(int i = 0; i \u003c g_repeat; i++) {\n    CALL_SUBTEST_1(( transformations\u003cdouble,Affine,AutoAlign\u003e() ));\n    CALL_SUBTEST_1(( non_projective_only\u003cdouble,Affine,AutoAlign\u003e() ));\n    \n    CALL_SUBTEST_2(( transformations\u003cfloat,AffineCompact,AutoAlign\u003e() ));\n    CALL_SUBTEST_2(( non_projective_only\u003cfloat,AffineCompact,AutoAlign\u003e() ));\n    CALL_SUBTEST_2(( transform_alignment\u003cfloat\u003e() ));\n    \n    CALL_SUBTEST_3(( transformations\u003cdouble,Projective,AutoAlign\u003e() ));\n    CALL_SUBTEST_3(( transformations\u003cdouble,Projective,DontAlign\u003e() ));\n    CALL_SUBTEST_3(( transform_alignment\u003cdouble\u003e() ));\n    \n    CALL_SUBTEST_4(( transformations\u003cfloat,Affine,RowMajor|AutoAlign\u003e() ));\n    CALL_SUBTEST_4(( non_projective_only\u003cfloat,Affine,RowMajor\u003e() ));\n    \n    CALL_SUBTEST_5(( transformations\u003cdouble,AffineCompact,RowMajor|AutoAlign\u003e() ));\n    CALL_SUBTEST_5(( non_projective_only\u003cdouble,AffineCompact,RowMajor\u003e() ));\n\n    CALL_SUBTEST_6(( transformations\u003cdouble,Projective,RowMajor|AutoAlign\u003e() ));\n    CALL_SUBTEST_6(( transformations\u003cdouble,Projective,RowMajor|DontAlign\u003e() ));\n\n\n    CALL_SUBTEST_7(( transform_products\u003cdouble,3,RowMajor|AutoAlign\u003e() ));\n    CALL_SUBTEST_7(( transform_products\u003cfloat,2,AutoAlign\u003e() ));\n\n    CALL_SUBTEST_8(( transform_associativity\u003cdouble,2,ColMajor\u003e(Rotation2D\u003cdouble\u003e(internal::random\u003cdouble\u003e()*double(EIGEN_PI))) ));\n    CALL_SUBTEST_8(( transform_associativity\u003cdouble,3,ColMajor\u003e(Quaterniond::UnitRandom()) ));\n  }\n}\n"}
{"repo_name":"eriser/Obxd","ref":"refs/heads/master","path":"JuceLibraryCode/modules/juce_box2d/box2d/Common/b2StackAllocator.cpp","copies":"16","language":"C++","content":"/*\n* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org\n*\n* This software is provided 'as-is', without any express or implied\n* warranty.  In no event will the authors be held liable for any damages\n* arising from the use of this software.\n* Permission is granted to anyone to use this software for any purpose,\n* including commercial applications, and to alter it and redistribute it\n* freely, subject to the following restrictions:\n* 1. The origin of this software must not be misrepresented; you must not\n* claim that you wrote the original software. If you use this software\n* in a product, an acknowledgment in the product documentation would be\n* appreciated but is not required.\n* 2. Altered source versions must be plainly marked as such, and must not be\n* misrepresented as being the original software.\n* 3. This notice may not be removed or altered from any source distribution.\n*/\n\n#include \"b2StackAllocator.h\"\n#include \"b2Math.h\"\n\nb2StackAllocator::b2StackAllocator()\n{\n\tm_index = 0;\n\tm_allocation = 0;\n\tm_maxAllocation = 0;\n\tm_entryCount = 0;\n}\n\nb2StackAllocator::~b2StackAllocator()\n{\n\tb2Assert(m_index == 0);\n\tb2Assert(m_entryCount == 0);\n}\n\nvoid* b2StackAllocator::Allocate(int32 size)\n{\n\tb2Assert(m_entryCount \u003c b2_maxStackEntries);\n\n\tb2StackEntry* entry = m_entries + m_entryCount;\n\tentry-\u003esize = size;\n\tif (m_index + size \u003e b2_stackSize)\n\t{\n\t\tentry-\u003edata = (char*)b2Alloc(size);\n\t\tentry-\u003eusedMalloc = true;\n\t}\n\telse\n\t{\n\t\tentry-\u003edata = m_data + m_index;\n\t\tentry-\u003eusedMalloc = false;\n\t\tm_index += size;\n\t}\n\n\tm_allocation += size;\n\tm_maxAllocation = b2Max(m_maxAllocation, m_allocation);\n\t++m_entryCount;\n\n\treturn entry-\u003edata;\n}\n\nvoid b2StackAllocator::Free(void* p)\n{\n\tb2Assert(m_entryCount \u003e 0);\n\tb2StackEntry* entry = m_entries + m_entryCount - 1;\n\tb2Assert(p == entry-\u003edata);\n\tif (entry-\u003eusedMalloc)\n\t{\n\t\tb2Free(p);\n\t}\n\telse\n\t{\n\t\tm_index -= entry-\u003esize;\n\t}\n\tm_allocation -= entry-\u003esize;\n\t--m_entryCount;\n\n\tp = NULL;\n}\n\nint32 b2StackAllocator::GetMaxAllocation() const\n{\n\treturn m_maxAllocation;\n}\n"}
{"repo_name":"Baha/z3","ref":"refs/heads/master","path":"src/qe/qe_arith_plugin.cpp","copies":"16","language":"C++","content":"/*++\nCopyright (c) 2010 Microsoft Corporation\n\nModule Name:\n\n    arith_plugin.cpp\n\nAbstract:\n\n    Eliminate Arithmetical variable from formula\n\nAuthor:\n\n    Nikolaj Bjorner (nbjorner) 2010-02-19\n\nRevision History:\n\n\n--*/\n\n#include \"qe.h\"\n#include \"ast_pp.h\"\n#include \"expr_safe_replace.h\"\n#include \"bool_rewriter.h\"\n#include \"bv_decl_plugin.h\"\n#include \"arith_decl_plugin.h\"\n#include \"arith_eq_solver.h\"\n#include \"arith_rewriter.h\"\n#include \"th_rewriter.h\"\n#include \"factor_rewriter.h\"\n#include \"obj_pair_hashtable.h\"\n#include \"nlarith_util.h\"\n#include \"model_evaluator.h\"\n#include \"smt_kernel.h\"\n\nnamespace qe {\n\n    class bound {        \n        rational   m_coeff;\n        expr_ref  m_term;\n        bool      m_is_strict;\n    public:\n        bound(ast_manager\u0026 m, rational const\u0026 n, expr* t, bool is_strict) : m_coeff(n), m_term(t, m), m_is_strict(is_strict) { \n        }\n        bool  is_strict() const { return m_is_strict; }\n        expr* term() const { return m_term.get(); }\n        rational const\u0026 coeff() const { return m_coeff; }\n        \n        void update(rational const\u0026 k, expr* t) {\n            m_coeff = k;\n            m_term = t;\n        }\n        \n        void pp(std::ostream\u0026 out, app* x) {\n            ast_manager\u0026 m = m_term.get_manager();\n            out \u003c\u003c \"(\u003c= (+ (* \" \u003c\u003c coeff() \u003c\u003c \" \" \u003c\u003c mk_pp(x, m)\n                \u003c\u003c \") \" \u003c\u003c mk_pp(term(), m) \u003c\u003c \") 0)\";\n        }\n    };\n\n    typedef rational numeral;\n\n    // m_k | (m_a * x + m_term)\n    class div_constraint {        \n        numeral  m_k;\n        numeral  m_a;\n        expr*    m_term;\n    public:\n        div_constraint(numeral const\u0026 k, numeral const\u0026 a, expr* t):\n            m_k(k), m_a(a), m_term(t) {}\n        numeral const\u0026 a() const { return m_a; }\n        numeral const\u0026 k() const { return m_k; }\n        expr*         t() const { return m_term; }\n        numeral\u0026   a_ref() { return m_a; }\n        numeral\u0026   k_ref() { return m_k; }\n        expr*\u0026     t_ref() { return m_term; }\n    };\n    typedef vector\u003cdiv_constraint\u003e div_constraints;\n\n    class arith_qe_util {\n        ast_manager\u0026      m;\n        i_solver_context\u0026 m_ctx;\n    public:\n        arith_util        m_arith; // initialize before m_zero_i, etc.\n        th_rewriter       simplify;\n    private:\n        arith_eq_solver   m_arith_solver;\n        bv_util           m_bv;\n\n        expr_ref     m_zero_i;\n        expr_ref     m_one_i;\n        expr_ref     m_minus_one_i;\n        expr_ref     m_zero_r;\n        expr_ref     m_one_r;\n        expr_ref     m_tmp;\n    public: \n        expr_safe_replace          m_replace;\n        \n        bool_rewriter              m_bool_rewriter;\n        arith_rewriter             m_arith_rewriter;\n\n        arith_qe_util(ast_manager\u0026 m, smt_params\u0026 p, i_solver_context\u0026 ctx) : \n            m(m), \n            m_ctx(ctx),\n            m_arith(m),\n            simplify(m),\n            m_arith_solver(m),\n            m_bv(m),\n            m_zero_i(m_arith.mk_numeral(numeral(0), true), m),\n            m_one_i(m_arith.mk_numeral(numeral(1), true), m),\n            m_minus_one_i(m_arith.mk_numeral(numeral(-1), true), m),\n            m_zero_r(m_arith.mk_numeral(numeral(0), false), m),\n            m_one_r(m_arith.mk_numeral(numeral(1), false), m),\n            m_tmp(m), \n            m_replace(m),\n            m_bool_rewriter(m),\n            m_arith_rewriter(m) {\n        }\n\n        ast_manager\u0026 get_manager() { return m; }\n        \n        //\n        // match e := k*x + rest, where k != 0.\n        // \n        bool get_coeff(contains_app\u0026 contains_x, expr* p, rational\u0026 k, expr_ref\u0026 rest) {\n            app* x = contains_x.x();\n            ptr_vector\u003cexpr\u003e restl, todo;\n            todo.push_back(p);\n            bool found = false;\n            expr* e1, *e2;\n            while (!todo.empty()) {\n                expr* e = todo.back();\n                todo.pop_back();\n                if (m_arith.is_add(e)) {\n                    for (unsigned i = 0; i \u003c to_app(e)-\u003eget_num_args(); ++i) {\n                        todo.push_back(to_app(e)-\u003eget_arg(i));\n                    }\n                }\n                else if (e == x) {\n                    k = numeral(1);\n                    found = true;\n                    break;\n                }\n                else if (m_arith.is_mul(e, e1, e2) \u0026\u0026 \n                         e1 == x \u0026\u0026\n                         m_arith.is_numeral(e2, k)) {\n                    found = true;\n                    break;\n                }\n                else if (m_arith.is_mul(e, e1, e2) \u0026\u0026 \n                         e2 == x \u0026\u0026\n                         m_arith.is_numeral(e1, k)) {\n                    found = true;\n                    break;\n                }\n                else {\n                    restl.push_back(e);\n                }\n            }\n            if (!found) {\n                TRACE(\"qe_verbose\", \n                      tout \n                      \u003c\u003c \"Did not find: \" \n                      \u003c\u003c mk_pp(x, m) \u003c\u003c \" in \" \n                      \u003c\u003c mk_pp(p, m) \u003c\u003c \"\\n\";\n                      );\n\n                return false;\n            }\n\n            while (!todo.empty()) {\n                restl.push_back(todo.back());\n                todo.pop_back();\n            }\n            if (restl.empty()) {\n                rest = mk_zero(x);\n            }\n            else {\n                rest = m_arith.mk_add(restl.size(), restl.c_ptr());\n            }\n            if (contains_x(rest)) {\n                return false;\n            }\n            TRACE(\"qe_verbose\", \n                  tout \n                  \u003c\u003c mk_pp(p, m) \u003c\u003c \" = \" \n                  \u003c\u003c \"(+ (* \" \u003c\u003c k \u003c\u003c \" \"\n                  \u003c\u003c mk_pp(x, m) \u003c\u003c \") \"\n                  \u003c\u003c mk_pp(rest, m) \u003c\u003c \")\\n\";\n                  );\n            return true;\n        }\n\n        //\n        // match p := k + rest\n        // where k is a numeral and rest does not contain numerals.\n        //\n        void get_const(expr* p, rational\u0026 k, expr_ref\u0026 rest) {\n            ptr_vector\u003cexpr\u003e todo, restl;\n            todo.push_back(p);\n            k = numeral(0);\n            while(!todo.empty()) {\n                p = todo.back();\n                todo.pop_back();\n                if (m_arith.is_add(p)) {\n                    for (unsigned i = 0; i \u003c to_app(p)-\u003eget_num_args(); ++i) {\n                        todo.push_back(to_app(p)-\u003eget_arg(i));\n                    }\n                }\n                else if (m_arith.is_numeral(p, k)) {\n                    break;\n                }\n                else {\n                    restl.push_back(p);\n                }\n            }\n            while (!todo.empty()) {\n                restl.push_back(todo.back());\n                todo.pop_back();\n            }\n            if (restl.empty()) {        \n                rest = mk_zero(p);\n            }\n            else {\n                rest = m_arith.mk_add(restl.size(), restl.c_ptr());\n            }\n        }\n\n        //\n        // match (not ne)\n        bool is_neg(app* e, expr_ref\u0026 ne) {\n            if (m.is_not(e)) {\n                ne = to_app(e)-\u003eget_arg(0);\n                return true;\n            }\n            return false;\n        }\n\n        bool is_le(app* e, expr_ref\u0026 p) {\n            return is_le_ge_core\u003c1\u003e(e, p);\n        }\n \n        bool is_ge(app* e, expr_ref\u0026 p) {\n            return is_le_ge_core\u003c0\u003e(e, p);\n        }\n                \n        // match e = p \u003c 0 or p \u003e 0\n        bool is_lt(app* e, expr_ref\u0026 p) {\n            numeral   k;        \n            expr* a1, *a2;\n\n            if (m_arith.is_lt(e, a1, a2) || m_arith.is_gt(e, a2, a1)) {\n                p = a1;\n                if (m_arith.is_numeral(a2, k) \u0026\u0026 k.is_zero()) {\n                    return true;\n                }\n            }\n            else {\n                return false;\n            }\n            p = mk_sub(p, a2);\n            simplify(p);\n            return true;\n        }\n\n        // \n        // match 0 == p mod k, p mod k == 0\n        //\n        bool is_divides(app* e, numeral\u0026 k, expr_ref\u0026 p) {\n            expr* e1, *e2;\n            if (!m.is_eq(e, e1, e2)) {\n                return false;\n            }\n            return is_divides(e1, e2, k, p) || is_divides(e2, e1, k, p);\n        }\n    \n        bool is_divides(expr* e1, expr* e2, numeral\u0026 k, expr_ref\u0026 p) {  \n            if (m_arith.is_mod(e2) \u0026\u0026 \n                m_arith.is_numeral(e1, k) \u0026\u0026 \n                k.is_zero() \u0026\u0026\n                m_arith.is_numeral(to_app(e2)-\u003eget_arg(1), k)) {\n                p = to_app(e2)-\u003eget_arg(0);\n                return true;\n            }\n            return false;\n        }\n\n        bool is_not_divides(app* e, app_ref\u0026 n, numeral\u0026 k, expr_ref\u0026 p) {\n            if (!m.is_not(e)) {\n                return false;\n            }\n            if (!is_app(to_app(e)-\u003eget_arg(0))) {\n                return false;\n            }\n            n = to_app(to_app(e)-\u003eget_arg(0));\n            return is_divides(n, k, p);\n        }\n\n\n        bool is_real(app* x) const { return m_arith.is_real(x); }\n\n        //\n        // b*t \u003c= a*s  \n        //\n        \n        template\u003cbool is_strict\u003e\n        void mk_bound_aux(rational const\u0026 a, expr* t, rational const\u0026 b, expr* s, expr_ref\u0026 result) {\n            SASSERT(a.is_neg() == b.is_neg());\n            expr_ref tt(t, m), ss(s, m), e(m);\n            // hack to fix wierd gcc compilation error\n            rational abs_a(a);\n            rational abs_b(b);\n            if (abs_a.is_neg()) abs_a.neg();\n            if (abs_b.is_neg()) abs_b.neg();\n            ss = mk_mul(abs_a, ss);\n            tt = mk_mul(abs_b, tt);\n            if(a.is_neg()) {\n                e = mk_sub(tt, ss);\n                if (is_strict) {\n                    if (m_arith.is_int(e)) {\n                        e = mk_add(e, m_one_i);\n                        mk_le(e, result);\n                    }\n                    else {\n                        mk_lt(e, result);\n                    }\n                }\n                else {\n                    mk_le(e, result);\n                }\n            }\n            else {\n                e = mk_sub(ss, tt);\n                if (is_strict) {\n                    if (m_arith.is_int(e)) {\n                        e = mk_add(e, m_one_i);\n                        mk_le(e, result);\n                    }\n                    else {\n                        mk_lt(e, result);\n                    }\n                }\n                else {\n                    mk_le(e, result);\n                }\n            }\n        }\n        \n        void mk_bound(rational const\u0026 a, expr* t, rational const\u0026 b, expr* s, expr_ref\u0026 result) {\n            mk_bound_aux\u003cfalse\u003e(a, t, b, s, result);\n        }\n        \n        void mk_strict_bound(rational const\u0026 a, expr* t, rational const\u0026 b, expr* s, expr_ref\u0026 result) {\n            mk_bound_aux\u003ctrue\u003e(a, t, b, s, result);\n        }\n\n        void mk_divides(numeral n, expr* e, expr_ref\u0026 result) {\n            SASSERT(n.is_int());\n            expr_ref tmp1(e, m), tmp2(m);\n            simplify(tmp1);\n            m_arith_rewriter.mk_mod(tmp1, mk_numeral(n), tmp2);\n            m_bool_rewriter.mk_eq(m_zero_i, tmp2, result);\n        }\n\n        void mk_div(expr* a, numeral const \u0026 k, expr_ref\u0026 result) {\n            result = m_arith.mk_div(a, m_arith.mk_numeral(k, false));\n            simplify(result);\n        }\n\n        expr* mk_numeral(numeral const\u0026 k, bool is_int = true) { return m_arith.mk_numeral(k, is_int); }\n\n        expr* mk_numeral(int k, bool is_int) { return mk_numeral(numeral(k),is_int); }\n\n        expr* mk_uminus(expr* e) {\n            return m_arith.mk_uminus(e);\n        }\n\n        expr* mk_abs(expr* e) {\n            rational val;\n            if (m_arith.is_numeral(e, val)) {\n                if (val.is_neg()) {\n                    return m_arith.mk_uminus(e);\n                }\n                else {\n                    return e;\n                }\n            }\n            else {\n                return m.mk_ite(m_arith.mk_le(mk_zero(e), e), e, m_arith.mk_uminus(e));\n            }\n        }\n\n        template\u003cbool is_max\u003e\n        expr_ref mk_min_max(unsigned num_args, expr* const* args) {\n            SASSERT(num_args \u003e 0);\n            if (num_args == 1) {\n                return expr_ref(args[0], m);\n            }\n            else {\n                expr_ref e2 = mk_min_max\u003cis_max\u003e(num_args-1,args+1);\n                expr* e1 = args[0];\n                expr* cmp = is_max?m_arith.mk_le(e1, e2):m_arith.mk_le(e2, e1);\n                return expr_ref(m.mk_ite(cmp, e2, e1), m);\n            }\n        }\n\n        expr_ref mk_max(unsigned num_args, expr* const* args) {\n            return mk_min_max\u003ctrue\u003e(num_args, args);\n        }\n\n        expr_ref mk_min(unsigned num_args, expr* const* args) {\n            return mk_min_max\u003cfalse\u003e(num_args, args);\n        }\n\n        expr* mk_mul(expr* a, expr* b) { return m_arith.mk_mul(a,b); }\n\n        expr* mk_add(expr* a, expr* b) { return m_arith.mk_add(a,b); }\n\n        expr* mk_sub(expr* a, expr* b) { return m_arith.mk_sub(a,b); }\n\n        expr* mk_mul(numeral const\u0026 a, expr* b) { \n            if (a.is_one()) return b;\n            return m_arith.mk_mul(mk_numeral(a, m_arith.is_int(b)),b); \n        }\n\n        expr* mk_zero(sort* s) { return m_arith.is_int(s)?m_zero_i:m_zero_r; }\n\n        expr* mk_zero(expr* e) { return m_arith.is_int(e)?m_zero_i:m_zero_r; }\n        \n        expr* mk_one(sort* s) { return m_arith.is_int(s)?m_one_i:m_one_r; }\n        \n        expr* mk_one(expr* e) { return m_arith.is_int(e)?m_one_i:m_one_r; }\n\n        void mk_le(expr* e, expr_ref\u0026 result) {\n            expr_ref tmp(e, m);\n            simplify(tmp);\n            m_arith_rewriter.mk_le(tmp, mk_zero(e), result);\n        }\n\n        void mk_lt(expr* e, expr_ref\u0026 result) {\n            rational r;\n            if (m_arith.is_numeral(e, r)) {\n                if (r.is_neg()) {\n                    result = m.mk_true();\n                }\n                else {\n                    result = m.mk_false();\n                }\n            }\n            else if (m_arith.is_int(e)) {\n                result = m_arith.mk_le(e, m_minus_one_i);\n            }\n            else {\n                result = m.mk_not(m_arith.mk_le(mk_zero(e), e));\n            }\n            simplify(result);\n            TRACE(\"qe_verbose\", tout \u003c\u003c \"mk_lt \" \u003c\u003c mk_pp(result, m) \u003c\u003c \"\\n\";);\n        }\n\n        // ax + t = 0\n        void mk_eq(rational const\u0026 a, app* x, expr* t, expr_ref\u0026 result) {\n            result = m_arith.mk_eq(mk_add(mk_mul(a, x), t), mk_zero(x));\n        }\n\n        void mk_and(unsigned sz, expr*const* args, expr_ref\u0026 result) {\n            m_bool_rewriter.mk_and(sz, args, result);\n        }\n        \n        void mk_and(expr* e1, expr* e2, expr_ref\u0026 result) {\n            m_bool_rewriter.mk_and(e1, e2, result);\n        }\n\n        void add_and(expr* e, ptr_vector\u003cexpr\u003e\u0026 conjs) {\n            if (m.is_and(e)) {\n                conjs.append(to_app(e)-\u003eget_num_args(), to_app(e)-\u003eget_args());\n            }\n            else {\n                conjs.push_back(e);\n            }\n        }\n\n        void mk_flat_and(expr* e1, expr* e2, expr_ref\u0026 result) {\n            ptr_vector\u003cexpr\u003e conjs;\n            add_and(e1, conjs);\n            add_and(e2, conjs);\n            m_bool_rewriter.mk_and(conjs.size(), conjs.c_ptr(), result);\n        }\n        \n        void mk_or(unsigned sz, expr*const* args, expr_ref\u0026 result) {\n            m_bool_rewriter.mk_or(sz, args, result);\n        }\n        \n        void mk_or(expr* e1, expr* e2, expr_ref\u0026 result) {\n            m_bool_rewriter.mk_or(e1, e2, result);\n        }\n\n        //\n        // b*t \u003c= a*s\n        // \n        void mk_resolve(app* x, bool is_strict, rational const\u0026 a, expr* t, rational const\u0026 b, expr* s, expr_ref\u0026 result) {\n            rational abs_a(abs(a)), abs_b(abs(b));\n            SASSERT(a.is_neg() == b.is_pos());\n            SASSERT(!is_strict || (abs_a.is_one() \u0026\u0026 abs_b.is_one()));\n            \n            expr_ref bt(mk_mul(abs_b, t), m);\n            expr_ref as(mk_mul(abs_a, s), m);\n            expr_ref as_bt(mk_add(as, bt), m);\n            \n            if(is_strict) {\n                mk_lt(as_bt, result);\n            }\n            else {\n                mk_le(as_bt, result);\n            }\n            \n            if (!abs_a.is_one() \u0026\u0026 !abs_b.is_one()) {\n                // integer resolution case.            \n                SASSERT(!is_strict);\n                SASSERT(abs_a \u003e rational::one() \u0026\u0026 abs_b \u003e rational::one());\n                expr_ref slack(mk_numeral((abs_a-numeral(1))*(abs_b-numeral(1)), true), m);\n                expr_ref result1(m), result2(m);\n                \n                // a*s + b*t \u003c= 0\n                expr_ref as_bt_le_0(result, m), tmp2(m), asz_bt_le_0(m), tmp3(m), tmp4(m);\n                expr_ref b_divides_sz(m);\n                \n                // a*s + b*t + (a-1)(b-1) \u003c= 0\n                tmp2 = m_arith.mk_add(as_bt, slack);\n                mk_le(tmp2, result1);\n                \n                rational a1 = a, b1 = b;\n                if (abs_a \u003c abs_b) {\n                    std::swap(abs_a, abs_b);\n                    std::swap(a1, b1);\n                    std::swap(s, t);\n                    std::swap(as, bt);\n                }\n                SASSERT(abs_a \u003e= abs_b);\n                \n                // create finite disjunction for |b|.                                \n                //    exists x, z in [0 .. |b|-2] . b*x + s + z = 0 \u0026\u0026 ax + t \u003c= 0 \u0026\u0026 bx + s \u003c= 0\n                // \u003c=\u003e \n                //    exists x, z in [0 .. |b|-2] . b*x = -z - s \u0026\u0026 ax + t \u003c= 0 \u0026\u0026 bx + s \u003c= 0\n                // \u003c=\u003e\n                //    exists x, z in [0 .. |b|-2] . b*x = -z - s \u0026\u0026 a|b|x + |b|t \u003c= 0 \u0026\u0026 bx + s \u003c= 0\n                // \u003c=\u003e\n                //    exists x, z in [0 .. |b|-2] . b*x = -z - s \u0026\u0026 a|b|x + |b|t \u003c= 0 \u0026\u0026 -z - s + s \u003c= 0\n                // \u003c=\u003e\n                //    exists x, z in [0 .. |b|-2] . b*x = -z - s \u0026\u0026 a|b|x + |b|t \u003c= 0 \u0026\u0026 -z \u003c= 0\n                // \u003c=\u003e\n                //    exists x, z in [0 .. |b|-2] . b*x = -z - s \u0026\u0026 a|b|x + |b|t \u003c= 0\n                // \u003c=\u003e\n                //    exists x, z in [0 .. |b|-2] . b*x = -z - s \u0026\u0026 a*n_sign(b)(s + z) + |b|t \u003c= 0\n                // \u003c=\u003e\n                //    exists z in [0 .. |b|-2] . |b| | (z + s) \u0026\u0026 a*n_sign(b)(s + z) + |b|t \u003c= 0\n                //\n                \n                expr_ref sz(mk_add(s, x), m);\n                \n                if (b1.is_pos()) {\n                    sz = m_arith.mk_uminus(sz);\n                }\n                tmp4 = mk_add(mk_mul(a1, sz), bt);\n                mk_le(tmp4, asz_bt_le_0);\n\n                if (to_app(asz_bt_le_0)-\u003eget_arg(0) == x \u0026\u0026\n                    m_arith.is_zero(to_app(asz_bt_le_0)-\u003eget_arg(1))) {\n                    //    exists z in [0 .. |b|-2] . |b| | (z + s) \u0026\u0026 z \u003c= 0\n                    // \u003c=\u003e\n                    //    |b| | s \n                    mk_divides(abs_b, s, tmp2);\n                }\n                else {\n                    mk_divides(abs_b, sz, b_divides_sz);\n                    mk_and(b_divides_sz, asz_bt_le_0, tmp4);\n                    mk_big_or(abs_b - numeral(2), x, tmp4, tmp2);                  \n                    TRACE(\"qe\",\n                          tout \u003c\u003c \"b | s + z: \" \u003c\u003c mk_pp(b_divides_sz, m) \u003c\u003c \"\\n\";\n                          tout \u003c\u003c \"a(s+z) + bt \u003c= 0: \" \u003c\u003c mk_pp(asz_bt_le_0, m) \u003c\u003c \"\\n\";\n                          );                   \n                }\n                mk_flat_and(as_bt_le_0, tmp2, result2); \n                mk_or(result1, result2, result);\n                simplify(result);\n\n\n                //    a*s + b*t + (a-1)(b-1) \u003c= 0 \n                // or exists z in [0 .. |b|-2] . |b| | (z + s) \u0026\u0026 a*n_sign(b)(s + z) + |b|t \u003c= 0\n            }\n            \n            TRACE(\"qe\", \n                  {\n                      tout \u003c\u003c (is_strict?\"strict\":\"non-strict\") \u003c\u003c \"\\n\";\n                      bound(m, a, t, false).pp(tout, x);\n                      tout \u003c\u003c \"\\n\";\n                      bound(m, b, s, false).pp(tout, x);\n                      tout \u003c\u003c \"\\n\";\n                      tout \u003c\u003c mk_pp(result, m) \u003c\u003c \"\\n\";\n                  });            \n        }\n        \n        struct mul_lt {\n            arith_util\u0026 u;\n            mul_lt(arith_qe_util\u0026 u): u(u.m_arith) {}\n            bool operator()(expr* n1, expr* n2) const {\n                \n                expr* x, *y;\n                if (u.is_mul(n1, x, y) \u0026\u0026 u.is_numeral(x)) {\n                    n1 = y;\n                }\n                if (u.is_mul(n2, x, y) \u0026\u0026 u.is_numeral(x)) {\n                    n2 = y;\n                }\n                return n1-\u003eget_id() \u003c n2-\u003eget_id();\n            }\n        };\n\n        void normalize_sum(expr_ref\u0026 p) {\n            simplify(p);\n            if (!m_arith.is_add(p)) {\n                return;\n            }\n            unsigned sz = to_app(p)-\u003eget_num_args();\n            ptr_buffer\u003cexpr\u003e args;\n            for (unsigned i = 0; i \u003c sz; ++i) {\n                args.push_back(to_app(p)-\u003eget_arg(i));\n            }\n            std::sort(args.begin(), args.end(), mul_lt(*this));\n            p = m_arith.mk_add(args.size(), args.c_ptr());\n        }\n\n        void pp_div(std::ostream\u0026 out, app* x, div_constraint const\u0026 div) {\n            out \u003c\u003c div.k() \u003c\u003c \" | (\" \u003c\u003c div.a() \u003c\u003c \"*\" \u003c\u003c mk_pp(x, m) \n                \u003c\u003c \" + \" \u003c\u003c mk_pp(div.t(), m) \u003c\u003c \") \";\n        }\n        \n        void pp_divs(std::ostream\u0026 out, app* x, div_constraints const\u0026 divs) {\n            for (unsigned i = 0; i \u003c divs.size(); ++i) {\n                pp_div(out, x, divs[i]);\n                out \u003c\u003c \" \";\n            }\n        }\n\n        bool mk_atom(expr* e, bool p, expr_ref\u0026 result) {\n            // retain equalities.\n            if (!is_app(e)) {\n                return false;\n            }\n            app* a = to_app(e);\n\n            expr_ref t1(m), t2(m);\n            expr_ref tmp1(m), tmp2(m);\n            rational k;\n            expr* a0, *a1;\n\n            if (p \u0026\u0026 is_divides(a, k, tmp1)) {\n                result = e;\n            }\n            else if (!p \u0026\u0026 is_divides(a, k, tmp1)) {\n                m_bool_rewriter.mk_not(e, result);\n            }\n            else if (p \u0026\u0026 m.is_eq(e, a0, a1) \u0026\u0026 is_arith(a0)) {\n                t1 = mk_sub(a0, a1);                                \n                simplify(t1);\n                t2 = mk_sub(a1, a0);\n                simplify(t2);\n                mk_le(t1, tmp1);  \n                mk_le(t2, tmp2);  \n                mk_and(tmp1, tmp2, result);\n            }\n            else if (!p \u0026\u0026 m.is_eq(e, a0, a1) \u0026\u0026 m_arith.is_int(a0)) {\n                tmp1 = mk_sub(a0, a1);                                \n                t1 = mk_add(mk_one(a0), tmp1);\n                simplify(t1);\n                t2 = mk_sub(mk_one(a0), tmp1);\n                simplify(t2);\n                mk_le(t1, tmp1);  // a0 \u003c a1 \u003c=\u003e 1 + a0 - a1 \u003c= 0\n                mk_le(t2, tmp2);  // a0 \u003e a1 \u003c=\u003e 1 - a0 + a1 \u003c= 0 \n                mk_or(tmp1, tmp2, result);\n            }\n            else if (!p \u0026\u0026 m.is_eq(e, a0, a1) \u0026\u0026 m_arith.is_real(a0)) {\n                t1 = mk_sub(a0, a1);                                \n                simplify(t1);\n                t2 = mk_sub(a1, a0);\n                simplify(t2);\n                mk_lt(t1, tmp1); \n                mk_lt(t2, tmp2);  \n                mk_or(tmp1, tmp2, result);\n            }\n            else if (!p \u0026\u0026 (m_arith.is_le(e, a0, a1) || m_arith.is_ge(e, a1, a0))) {\n                tmp1 = mk_sub(a1, a0);                                \n                mk_lt(tmp1, result);\n            }\n            else if (p \u0026\u0026 (m_arith.is_le(e) || m_arith.is_ge(e))) {\n                result = e;\n            }\n            else if (p \u0026\u0026 (m_arith.is_lt(e, a0, a1) || m_arith.is_gt(e, a1, a0))) {\n                tmp1 = mk_sub(a0, a1);\n                mk_lt(tmp1, result);\n            }\n            else if (!p \u0026\u0026 (m_arith.is_lt(e, a0, a1) || m_arith.is_gt(e, a1, a0))) {\n                tmp1 = mk_sub(a1, a0);\n                mk_le(tmp1, result);\n            }\n            else {\n                return false;\n            }\n            TRACE(\"qe_verbose\", tout \u003c\u003c \"Atom: \" \u003c\u003c mk_pp(result, m) \u003c\u003c \"\\n\";);\n            return true;\n        }\n\n        void mk_bounded_var(rational const\u0026 n, app_ref\u0026 z_bv, app_ref\u0026 z) {\n            rational two(2), b(n);\n            unsigned sz = 0;\n            do {\n                ++sz;\n                b = div(b, two);\n            }\n            while (b.is_pos());\n            sort* s = m_bv.mk_sort(sz);\n            z_bv = m.mk_fresh_const(\"z\", s);\n            expr_ref tmp(m);\n            z = m_bv.mk_bv2int(z_bv);\n        }\n\n        bool solve(conj_enum\u0026 conjs, expr* fml) {\n            expr_ref_vector eqs(m);\n            extract_equalities(conjs, eqs);\n            return reduce_equations(eqs.size(), eqs.c_ptr(), fml);\n        }\n\n        // ----------------------------------------------------------------------\n        // \n        // Equation solving features.\n        //\n        // Extract equalities from current goal.\n        // \n        void extract_equalities(conj_enum\u0026 conjs, expr_ref_vector\u0026 eqs) { \n            obj_hashtable\u003cexpr\u003e leqs;\n            expr_ref_vector trail(m);\n            expr_ref tmp1(m), tmp2(m);\n            expr *a0, *a1;\n            eqs.reset();\n            conj_enum::iterator it = conjs.begin(), end = conjs.end();\n            for (; it != end; ++it) {\n                expr* e = *it;\n                bool is_leq = false;\n                \n                if (m.is_eq(e, a0, a1) \u0026\u0026 is_arith(a0)) {\n                    m_arith_rewriter.mk_sub(a0, a1, tmp1);\n                    simplify(tmp1);\n                    eqs.push_back(tmp1);\n                }\n                else if (m_arith.is_le(e, a0, a1) || m_arith.is_ge(e, a1, a0)) {\n                    m_arith_rewriter.mk_sub(a0, a1, tmp1);\n                    is_leq = true;\n                }\n                else {\n                    // drop equality.\n                }\n                \n                if (is_leq) {\n                    normalize_sum(tmp1);\n                    tmp2 = m_arith.mk_uminus(tmp1);\n                    normalize_sum(tmp2);\n                    if (leqs.contains(tmp2)) {\n                        eqs.push_back(tmp1);\n                        TRACE(\"qe\", tout \u003c\u003c \"found:  \" \u003c\u003c mk_pp(tmp1, m) \u003c\u003c \"\\n\";);\n                    }\n                    else {\n                        trail.push_back(tmp1);\n                        leqs.insert(tmp1);\n                        TRACE(\"qe_verbose\", tout \u003c\u003c \"insert: \" \u003c\u003c mk_pp(tmp1, m) \u003c\u003c \"\\n\";);\n                    }\n                }\n            }\n        }\n\n\n    private:\n\n        //\n        // match p \u003c= 0 or p \u003e= 0\n        //\n        template\u003cunsigned IS_LE\u003e\n        bool is_le_ge_core(app* e, expr_ref\u0026 p) { \n            numeral   k;        \n            expr_ref  tmp(m);\n            expr* a2;\n\n            if (m_arith.is_le(e)) {\n                p = e-\u003eget_arg(1-IS_LE);\n                a2 = e-\u003eget_arg(IS_LE);\n                if (m_arith.is_numeral(a2, k) \u0026\u0026 k.is_zero()) {\n                    return true;\n                }\n            }\n            else if (m_arith.is_ge(e)) {\n                p = e-\u003eget_arg(IS_LE);\n                a2 = e-\u003eget_arg(1-IS_LE);\n                if (m_arith.is_numeral(a2, k) \u0026\u0026 k.is_zero()) {\n                    return true;\n                }\n            }\n            else {\n                return false;\n            }\n            p = mk_sub(p, a2);\n            simplify(p);\n            return true;\n        }\n\n        bool is_arith(expr* e) {\n            return m_arith.is_int(e) || m_arith.is_real(e);\n        }\n\n        void mk_big_or(numeral up, app* x, expr* body, expr_ref\u0026 result) {\n            TRACE(\"qe\", tout \u003c\u003c mk_pp(x, m) \u003c\u003c \" \" \u003c\u003c mk_pp(body, m) \u003c\u003c \"\\n\";);\n            if (numeral(1) \u003e= up) {\n                mk_big_or_blast(up, x, body, result);\n            }\n            else {\n                mk_big_or_symbolic_blast(up, x, body, result);\n            }\n        }\n    \n        void mk_big_or_blast(numeral up, app* x, expr* body, expr_ref\u0026 result) {        \n            expr_ref_vector ors(m);\n            numeral index(0);\n            while (index \u003c= up) {\n                expr* n = mk_numeral(index);\n                result = body;\n                m_replace.apply_substitution(x, n, result);\n                ors.push_back(result);\n                ++index;\n            }\n            mk_or(ors.size(), ors.c_ptr(), result);\n            TRACE(\"qe\", \n                  tout \n                  \u003c\u003c \"[0 \" \u003c\u003c up \u003c\u003c \"] \" \n                  \u003c\u003c mk_pp(x, m) \u003c\u003c \"\\n\" \n                  \u003c\u003c mk_pp(body, m) \u003c\u003c \"\\n\" \n                  \u003c\u003c mk_pp(result, m) \u003c\u003c \"\\n\";);\n        }\n\n        void mk_big_or_symbolic(numeral up, app* x, expr* body, expr_ref\u0026 result) {\n            app_ref z_bv(m);\n            mk_big_or_symbolic(up, x, body, z_bv, result);\n            m_ctx.add_var(z_bv);\n        }        \n\n        void mk_big_or_symbolic_blast(numeral up, app* x, expr* body, expr_ref\u0026 result) {\n            app_ref z_bv(m);\n            mk_big_or_symbolic(up, x, body, z_bv, result);\n            m_ctx.blast_or(z_bv, result);\n        }\n\n        void mk_big_or_symbolic(numeral up, app* x, expr* body, app_ref\u0026 z_bv, expr_ref\u0026 result) {\n            expr* e1 = m_arith.mk_le(x, m_arith.mk_numeral(up, true));\n            mk_flat_and(e1, body, result);\n            app_ref z(m);\n            mk_bounded_var(up, z_bv, z);\n            m_replace.apply_substitution(x, z, result);\n        }        \n\n\n\n\n\n        //\n        // Determine if 'x' can be isolated.\n        // Return the coefficient if found.\n        //\n        bool isolate_x(expr* p, app* x, contains_app\u0026 contains_x, numeral\u0026 coeff) {\n            numeral k;\n            \n            while (m_arith.is_add(p)) {\n                bool found_x = false;\n                expr* next_p = 0;\n                for (unsigned i = 0; i \u003c to_app(p)-\u003eget_num_args(); ++i) {\n                    expr* arg = to_app(p)-\u003eget_arg(i);\n                    if (contains_x(arg)) {\n                        if (found_x) {\n                            return false;\n                        }\n                        found_x = true;\n                        next_p = arg;\n                    }\n                }\n                if (!next_p) {\n                    return false;\n                }\n                p = next_p;\n            }\n            \n            expr *e1, *e2;\n            if (p == x) {\n                coeff = numeral(1);\n                return true;\n            }\n            else if (m_arith.is_mul(p, e1, e2) \u0026\u0026\n                     m_arith.is_numeral(e1, k) \u0026\u0026\n                     e2 == x) {\n                coeff = k;\n                return true;\n            }\n            else if (m_arith.is_mul(p, e1, e2) \u0026\u0026\n                     m_arith.is_numeral(e2, k) \u0026\u0026\n                     e1 == x) {\n                coeff = k;\n                return true;\n            }\n            return false;        \n        }\n\n        //\n        // Reduce equations.\n        // Singular equations eliminate variables directly.\n        // Linear equations eliminate original variables and introduce auxiliary variables.\n        // \n        \n        bool reduce_equations(unsigned num_eqs, expr * const* eqs, expr* fml) {\n            for (unsigned i = 0; i \u003c num_eqs; ++i) {\n                if (reduce_equation(eqs[i], fml)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        bool solve_singular(unsigned var_idx, expr* p, expr* fml) {\n            rational k;\n            expr_ref e(m), tmp(m);\n\n            app* x = m_ctx.get_var(var_idx);\n\n            if (!isolate_x(p, x, m_ctx.contains(var_idx), k)) {\n                return false;\n            }\n            if (m_arith.is_int(x) \u0026\u0026 !(abs(k).is_one())) {\n                return false;\n            }\n\n            if (abs(k).is_one()) {\n                if (k.is_neg()) {\n                    e = m_arith.mk_add(p, x);\n                }\n                else {\n                    e = m_arith.mk_sub(x, p);\n                }\n            }\n            else {\n                SASSERT(!m_arith.is_int(x));\n                //    p = p' + k*x = 0\n                // \u003c=\u003e\n                //    -k*x = p' = p - k*x\n                // =\u003e\n                //    x = (p - k*x)/ -k\n                expr* ke = m_arith.mk_numeral(-k, false);\n                tmp = m_arith.mk_mul(ke, x);\n                tmp = m_arith.mk_add(p, tmp);\n                e = m_arith.mk_div(tmp, ke);\n            }\n            TRACE(\"qe\", \n                  tout \u003c\u003c \"is singular:\\n\" \n                  \u003c\u003c mk_pp(p, m) \u003c\u003c \"\\n\"\n                  \u003c\u003c mk_pp(fml, m) \u003c\u003c \"\\n\"\n                  \u003c\u003c mk_pp(x, m) \u003c\u003c \" = \" \n                  \u003c\u003c mk_pp(e, m) \u003c\u003c \"\\n\";\n                  );\n            expr_ref result(fml, m);\n            m_replace.apply_substitution(x, e, result);\n            simplify(result);\n            TRACE(\"qe\", \n                  tout \u003c\u003c \"singular solved:\\n\" \n                  \u003c\u003c mk_pp(result, m) \u003c\u003c \"\\n\";\n                  );\n            m_ctx.elim_var(var_idx, result, e);\n            return true;\n        }\n\n        bool solve_singular(expr* p, expr* fml) {\n            unsigned num_vars = m_ctx.get_num_vars();\n            for (unsigned i = 0; i \u003c num_vars; ++i) {\n                if (solve_singular(i, p, fml)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        bool solve_linear(expr* p, expr* fml) {\n            vector\u003cnumeral\u003e values;\n            unsigned num_vars = m_ctx.get_num_vars();\n            app*const* vars_ptr = m_ctx.get_vars();\n            \n            if (!is_linear(p, num_vars, vars_ptr, values)) {\n                return false;\n            }\n\n            TRACE(\"qe\", tout \u003c\u003c \"is linear: \" \u003c\u003c mk_pp(p, m) \u003c\u003c \"\\n\";);\n            SASSERT(values.size() == num_vars + 1);\n            SASSERT(num_vars \u003e 0);\n            \n            unsigned index;\n            bool is_aux;\n            //\n            // The first entry in values is the constant.\n            //\n            VERIFY(m_arith_solver.solve_integer_equation(values, index, is_aux));\n\n            SASSERT(1 \u003c= index \u0026\u0026 index \u003c= num_vars);\n            app_ref x(m_ctx.get_var(index-1), m);\n            app_ref z(m);\n            expr_ref p1(m);\n            if (is_aux) {\n                // An auxiliary variable was introduced in lieu of 'x'.\n                // it has coefficient 'm' = values[index].\n                SASSERT(values[index] \u003e= rational(3));\n                z  = m.mk_fresh_const(\"x\", m_arith.mk_int());\n                m_ctx.add_var(z);\n                p1 = m_arith.mk_mul(m_arith.mk_numeral(values[index], true), z);\n            }\n            else {                \n                // the coefficient to 'x' is -1.\n                p1 = m_arith.mk_numeral(numeral(0), true);\n            }\n            \n            for (unsigned i = 1; i \u003c= num_vars; ++i) {\n                numeral k = values[i];\n                if (!k.is_zero() \u0026\u0026 i != index) {\n                    p1 = m_arith.mk_add(p1, m_arith.mk_mul(m_arith.mk_numeral(k, true), m_ctx.get_var(i-1)));\n                }\n            }\n            p1 = m_arith.mk_add(p1, m_arith.mk_numeral(values[0], true));\n            \n            TRACE(\"qe\", \n                  tout \u003c\u003c \"is linear:\\n\" \n                  \u003c\u003c mk_pp(fml, m) \u003c\u003c \"\\n\"\n                  \u003c\u003c mk_pp(p, m) \u003c\u003c \"\\n\"\n                  \u003c\u003c mk_pp(x, m) \u003c\u003c \" = \" \n                  \u003c\u003c mk_pp(p1, m) \u003c\u003c \"\\n\";\n                  tout \u003c\u003c values[0] \u003c\u003c \" + \";\n                  for (unsigned i = 0; i \u003c num_vars; ++i) {\n                      tout \u003c\u003c \" + \" \u003c\u003c values[i+1] \u003c\u003c \" * \" \u003c\u003c mk_pp(m_ctx.get_var(i), m) \u003c\u003c \" \";\n                  }\n                  tout \u003c\u003c \" = 0\\n\";\n                  );\n            expr_ref result(fml, m);\n            m_replace.apply_substitution(x, p1, result);\n            simplify(result);            \n            m_ctx.elim_var(index-1, result, p1);\n            TRACE(\"qe\", tout \u003c\u003c \"Reduced: \" \u003c\u003c mk_pp(result, m) \u003c\u003c \"\\n\";);\n            return true;\n        }        \n\n        bool reduce_equation(expr* p, expr* fml) {\n            numeral k;\n            \n            if (m_arith.is_numeral(p, k) \u0026\u0026 k.is_zero()) {\n                return false;\n            }\n\n            return \n                solve_singular(p, fml) ||\n                solve_linear(p, fml);\n        }\n\n        bool find_variable(expr* p, unsigned num_vars, app* const* vars, numeral* values, numeral const\u0026 k) {\n            if (!is_app(p) || to_app(p)-\u003eget_num_args() \u003e 0) {\n                return false;\n            }        \n            for (unsigned i = 0; i \u003c num_vars; ++i) {\n                if (p == vars[i]) {\n                    values[i] += k;\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        bool is_linear(expr* p, unsigned num_vars, app* const* vars, vector\u003cnumeral\u003e\u0026 values) {\n            if (num_vars == 0) {\n                return false;\n            }\n            values.reset();\n            for (unsigned i = 0; i \u003c= num_vars; ++i) {\n                values.push_back(numeral(0));\n            }\n            numeral* vars_ptr = values.c_ptr() + 1;\n            ptr_vector\u003cexpr\u003e todo;\n            numeral k;\n            expr* e1, *e2;\n            todo.push_back(p);\n            while (!todo.empty()) {\n                p = todo.back();\n                todo.pop_back();\n                if (m_arith.is_add(p)) {\n                    for (unsigned i = 0; i \u003c to_app(p)-\u003eget_num_args(); ++i) {\n                        todo.push_back(to_app(p)-\u003eget_arg(i));\n                    }\n                }\n                else if (m_arith.is_mul(p, e1, e2) \u0026\u0026\n                         m_arith.is_numeral(e1, k) \u0026\u0026\n                         find_variable(e2, num_vars, vars, vars_ptr, k)) {\n                    // ok\n                }\n                else if (m_arith.is_mul(p, e1, e2) \u0026\u0026\n                         m_arith.is_numeral(e2, k) \u0026\u0026\n                         find_variable(e1, num_vars, vars, vars_ptr, k)) {\n                    // ok\n                }\n                else if (find_variable(p, num_vars, vars, vars_ptr, k)) {\n                    // ok\n                }\n                else if (m_arith.is_numeral(p, k)) {\n                    values[0] += k;\n                }\n                else {\n                    TRACE(\"qe_verbose\", tout \u003c\u003c \"non-linear \" \u003c\u003c mk_pp(p, m) \u003c\u003c \"\\n\";);\n                    return false;\n                }\n            }\n            return true;\n        }\n\n    };\n\n    class bounds_proc {\n        arith_qe_util\u0026   m_util;\n        ast_mark         m_mark;\n        expr_ref_vector  m_le_terms, m_ge_terms, m_lt_terms, m_gt_terms;\n        vector\u003crational\u003e m_le_coeffs, m_ge_coeffs, m_lt_coeffs, m_gt_coeffs;\n        app_ref_vector   m_le_atoms, m_ge_atoms, m_lt_atoms, m_gt_atoms;\n        \n        expr_ref_vector  m_div_terms;\n        vector\u003crational\u003e m_div_coeffs, m_div_divisors;\n        app_ref_vector   m_div_atoms;\n        app_ref          m_div_z;\n\n        expr_ref_vector  m_nested_div_terms;\n        vector\u003crational\u003e m_nested_div_coeffs, m_nested_div_divisors;\n        app_ref_vector   m_nested_div_atoms;\n        app_ref_vector   m_nested_div_z;\n        rational         m_d;\n\n    public:\n        bounds_proc(arith_qe_util\u0026 u):\n            m_util(u),\n            m_le_terms(u.get_manager()),\n            m_ge_terms(u.get_manager()),\n            m_lt_terms(u.get_manager()),\n            m_gt_terms(u.get_manager()),\n            m_le_atoms(u.get_manager()),\n            m_ge_atoms(u.get_manager()),\n            m_lt_atoms(u.get_manager()),\n            m_gt_atoms(u.get_manager()),\n            m_div_terms(u.get_manager()),\n            m_div_atoms(u.get_manager()),\n            m_div_z(u.get_manager()),\n            m_nested_div_terms(u.get_manager()),\n            m_nested_div_atoms(u.get_manager()),\n            m_nested_div_z(u.get_manager())\n        {\n            reset();\n        }\n        \n\n        bool get_bound(contains_app\u0026 contains_x, app* a) {\n            ast_manager\u0026 m = m_util.get_manager();\n            app* x = contains_x.x();\n            if (m_mark.is_marked(a) ||\n                get_le_bound(contains_x, a) ||\n                get_lt_bound(contains_x, a) ||\n                get_divides(contains_x, a) ||\n                get_nested_divs(contains_x, a)) {\n                TRACE(\"qe_verbose\", tout \u003c\u003c \"Bound for \" \u003c\u003c mk_pp(x, m) \u003c\u003c \" within \" \u003c\u003c mk_pp(a, m) \u003c\u003c \"\\n\";);\n                m_mark.mark(a, true);\n                return true;\n            }\n            else {\n                TRACE(\"qe\", tout \u003c\u003c \"No bound for \" \u003c\u003c mk_pp(x, m) \u003c\u003c \" within \" \u003c\u003c mk_pp(a, m) \u003c\u003c \"\\n\";);\n                return false;\n            }\n        }\n\n        unsigned lt_size() { return m_lt_terms.size(); }\n        unsigned le_size() { return m_le_terms.size(); }\n        unsigned gt_size() { return m_gt_terms.size(); }\n        unsigned ge_size() { return m_ge_terms.size(); }\n        unsigned t_size(bool is_l) { return is_l?lt_size():gt_size(); }\n        unsigned e_size(bool is_l) { return is_l?le_size():ge_size(); }\n        unsigned size(bool is_strict, bool is_l) { return is_strict?t_size(is_l):e_size(is_l); }\n\n        expr* const* lt() { return m_lt_terms.c_ptr(); }\n        expr* const* le() { return m_le_terms.c_ptr(); }\n        expr* const* gt() { return m_gt_terms.c_ptr(); }\n        expr* const* ge() { return m_ge_terms.c_ptr(); }\n        expr* const* t(bool is_l) { return is_l?lt():gt(); }\n        expr* const* e(bool is_l) { return is_l?le():ge(); }\n        expr* const* exprs(bool is_strict, bool is_l) { return is_strict?t(is_l):e(is_l);}\n\n        rational const* lt_coeffs() { return m_lt_coeffs.c_ptr(); }\n        rational const* le_coeffs() { return m_le_coeffs.c_ptr(); }\n        rational const* gt_coeffs() { return m_gt_coeffs.c_ptr(); }\n        rational const* ge_coeffs() { return m_ge_coeffs.c_ptr(); }\n        rational const* t_coeffs(bool is_l) { return is_l?lt_coeffs():gt_coeffs(); }\n        rational const* e_coeffs(bool is_l) { return is_l?le_coeffs():ge_coeffs(); }\n        rational const* coeffs(bool is_strict, bool is_l) { return is_strict?t_coeffs(is_l):e_coeffs(is_l); }\n\n        app* const* lt_atoms() { return m_lt_atoms.c_ptr(); }\n        app* const* le_atoms() { return m_le_atoms.c_ptr(); }\n        app* const* gt_atoms() { return m_gt_atoms.c_ptr(); }\n        app* const* ge_atoms() { return m_ge_atoms.c_ptr(); }\n        app* const* t_atoms(bool is_l) { return is_l?lt_atoms():gt_atoms(); }\n        app* const* e_atoms(bool is_l) { return is_l?le_atoms():ge_atoms(); }\n        app* const* atoms(bool is_strict, bool is_l) { return is_strict?t_atoms(is_l):e_atoms(is_l); }\n        \n        unsigned div_size() const    { return m_div_terms.size(); }\n        app* const* div_atoms()      { return m_div_atoms.c_ptr(); }\n        rational const* div_coeffs() { return m_div_coeffs.c_ptr(); }\n        expr* const* div_terms()     { return m_div_terms.c_ptr(); }\n        rational const* divisors()   { return m_div_divisors.c_ptr(); }\n\n        bool div_z(rational \u0026 d, app_ref\u0026 z_bv, app_ref\u0026 z) {\n            if (m_div_z.get()) {\n                z = m_div_z;\n                z_bv = to_app(z-\u003eget_arg(0));\n                d = m_d;\n                return true;\n            }\n            if (m_div_terms.empty() \u0026\u0026 m_nested_div_terms.empty()) {\n                return false;\n            }\n            m_d = rational(1);\n            for (unsigned i = 0; i \u003c m_div_divisors.size(); ++i) {\n                m_d = lcm(m_div_divisors[i], m_d); \n            }\n            for (unsigned i = 0; i \u003c m_nested_div_divisors.size(); ++i) {\n                m_d = lcm(m_nested_div_divisors[i], m_d); \n            }\n            if (abs(m_d).is_one()) {\n                return false;\n            }\n            m_util.mk_bounded_var(m_d, z_bv, m_div_z);\n            z = m_div_z;\n            d = m_d;\n            return true;\n        }\n\n        unsigned nested_div_size() const               { return m_nested_div_terms.size(); }\n        app* nested_div_atom(unsigned idx)             { return m_nested_div_atoms[idx].get(); }\n        rational const\u0026 nested_div_coeff(unsigned idx) { return m_nested_div_coeffs[idx]; }\n        expr* nested_div_term(unsigned idx)            { return m_nested_div_terms[idx].get(); }\n        rational const\u0026 nested_divisor(unsigned idx)   { return m_nested_div_divisors[idx]; }\n        app* nested_div_z(unsigned idx)                { return m_nested_div_z[idx].get(); }\n        app* nested_div_z_bv(unsigned idx)             { return to_app(m_nested_div_z[idx]-\u003eget_arg(0)); }\n\n        void reset() {\n            m_lt_terms.reset();\n            m_gt_terms.reset();\n            m_ge_terms.reset();\n            m_le_terms.reset();\n            m_gt_coeffs.reset();\n            m_lt_coeffs.reset();\n            m_ge_coeffs.reset();\n            m_le_coeffs.reset();\n            m_lt_atoms.reset();\n            m_gt_atoms.reset();\n            m_le_atoms.reset();\n            m_ge_atoms.reset();\n            m_div_terms.reset();\n            m_div_coeffs.reset();\n            m_div_divisors.reset();\n            m_div_atoms.reset();\n            m_div_z = 0;\n            m_nested_div_terms.reset();\n            m_nested_div_coeffs.reset();\n            m_nested_div_divisors.reset();\n            m_nested_div_atoms.reset();\n            m_nested_div_z.reset();\n        }\n\n    private:\n        bool get_nested_divs(contains_app\u0026 contains_x, app* a) {\n            ast_manager\u0026 m = m_util.get_manager();\n            ptr_vector\u003cexpr\u003e todo;\n            todo.push_back(a);\n            rational k1, k2;\n            expr_ref rest(m);\n            while (!todo.empty()) {\n                expr* e = todo.back();\n                todo.pop_back();\n                if (m_mark.is_marked(e)) {\n                    continue;\n                }\n                m_mark.mark(e, true);\n                if (!contains_x(e)) {\n                    continue;\n                }\n                if (contains_x.x() == e) {\n                    return false;\n                }\n                if (!is_app(e)) {\n                    return false;\n                }\n                a = to_app(e);\n                if (m_util.m_arith.is_mod(e) \u0026\u0026 \n                    m_util.m_arith.is_numeral(to_app(e)-\u003eget_arg(1), k1) \u0026\u0026\n                    m_util.get_coeff(contains_x, to_app(e)-\u003eget_arg(0), k2, rest)) {\n                    app_ref z(m), z_bv(m);\n                    m_util.mk_bounded_var(k1, z_bv, z);\n                    m_nested_div_terms.push_back(rest);\n                    m_nested_div_divisors.push_back(k1);\n                    m_nested_div_coeffs.push_back(k2);\n                    m_nested_div_atoms.push_back(a);\n                    m_nested_div_z.push_back(z);\n                    continue;\n                }\n                unsigned num_args = a-\u003eget_num_args();\n                for (unsigned i = 0; i \u003c num_args; ++i) {\n                    todo.push_back(a-\u003eget_arg(i));\n                }                \n            }              \n            return true;\n        }\n\n        bool get_le_bound(contains_app\u0026 contains_x, app* a) {\n            ast_manager\u0026 m = m_util.get_manager();\n            expr_ref p(m), rest(m);\n            rational k;\n            if (m_util.is_le(a, p) \u0026\u0026 m_util.get_coeff(contains_x, p, k, rest)) {\n                // k*x + rest \u003c= 0\n                if (m_util.is_real(contains_x.x())) {\n                    m_util.mk_div(rest, abs(k), rest);\n                    k = k.is_pos()?rational::one():rational::minus_one();\n                }\n                if (k.is_neg()) {\n                    m_le_terms.push_back(rest);\n                    m_le_coeffs.push_back(k);\n                    m_le_atoms.push_back(a);\n                }\n                else {\n                    m_ge_terms.push_back(rest);\n                    m_ge_coeffs.push_back(k);\n                    m_ge_atoms.push_back(a);\n                }\n                return true;\n            }\n            return false;\n        }\n\n        bool get_lt_bound(contains_app\u0026 contains_x, app* a) {\n            ast_manager\u0026 m = m_util.get_manager();\n            expr_ref p(m), rest(m), na(m);\n            rational k;\n            if (m_util.is_lt(a, p) \u0026\u0026 m_util.get_coeff(contains_x, p, k, rest)) {  \n                // k*x + rest \u003c 0\n            }\n            else if (m_util.is_neg(a, na) \u0026\u0026 is_app(na) \u0026\u0026 \n                     m_util.is_ge(to_app(na), p) \u0026\u0026 \n                     m_util.get_coeff(contains_x, p, k, rest)) {\n                //\n                //   not (k*x + rest \u003e= 0)\n                // \u003c=\u003e\n                //   k*x + rest \u003c 0\n                //\n            }\n            else {\n                return false;\n            }\n\n            SASSERT(m_util.is_real(contains_x.x()));\n            m_util.mk_div(rest, abs(k), rest);\n            if (k.is_neg()) {\n                m_lt_terms.push_back(rest);\n                m_lt_coeffs.push_back(rational::minus_one());\n                m_lt_atoms.push_back(a);\n            }\n            else {\n                m_gt_terms.push_back(rest);\n                m_gt_coeffs.push_back(rational::one());\n                m_gt_atoms.push_back(a);\n            }\n            return true;\n        }\n\n        bool get_divides(contains_app\u0026 contains_x, app* a) {\n            ast_manager\u0026 m = m_util.get_manager();\n            expr_ref p(m), rest(m);\n            app_ref a2(m);\n            numeral k, k2;\n\n            if (m_util.is_divides(a, k, p) \u0026\u0026 m_util.get_coeff(contains_x, p, k2, rest)) {\n                m_div_terms.push_back(rest);\n                m_div_divisors.push_back(k);\n                m_div_coeffs.push_back(k2);\n                m_div_atoms.push_back(a);\n                return true;\n            }\n            if (m_util.is_not_divides(a, a2, k, p) \u0026\u0026 m_util.get_coeff(contains_x, p, k2, rest)) {\n                m_div_terms.push_back(rest);\n                m_div_divisors.push_back(k);\n                m_div_coeffs.push_back(k2);\n                m_div_atoms.push_back(a2);\n                return true;\n            }\n            return false;\n        }\npublic:\n        void display(std::ostream\u0026 out) {\n            ast_manager\u0026 m = m_util.get_manager();\n            for (unsigned i = 0; i \u003c lt_size(); ++i) {\n                out \u003c\u003c mk_pp(lt()[i], m) \u003c\u003c \" \u003c 0\\n\";\n            }\n            for (unsigned i = 0; i \u003c le_size(); ++i) {\n                out \u003c\u003c mk_pp(le()[i], m) \u003c\u003c \" \u003c 0\\n\";\n            }\n            for (unsigned i = 0; i \u003c gt_size(); ++i) {\n                out \u003c\u003c mk_pp(gt()[i], m) \u003c\u003c \" \u003c 0\\n\";\n            }\n            for (unsigned i = 0; i \u003c ge_size(); ++i) {\n                out \u003c\u003c mk_pp(ge()[i], m) \u003c\u003c \" \u003c 0\\n\";\n            }\n        }\n    };\n\n    class x_subst {\n        arith_qe_util\u0026 m_super;\n        expr_ref m_t;\n        rational m_coeff;\n    public:\n\n        x_subst(arith_qe_util\u0026 s):\n            m_super(s),\n            m_t(s.get_manager()),\n            m_coeff(rational::one())\n        {}\n\n        void set_term(expr* t) { m_t = t; }\n\n        void set_coeff(rational const\u0026 k) { m_coeff = k; }\n\n        expr* get_term() const { return m_t; }\n\n        rational get_coeff() const { return m_coeff; }\n\n        expr_ref mk_term(rational const\u0026 c, expr* t) {\n            // return t + c*m_t\n            ast_manager\u0026 m = m_super.get_manager();\n            if (m_t.get()) {\n                return expr_ref(m_super.mk_add(m_super.mk_mul(c, m_t), t), m);\n            }\n            else {\n                return expr_ref(t, m);\n            }            \n        }\n\n        rational mk_coeff(rational const\u0026 k) {\n            return k * m_coeff;\n        }\n    };\n\n    \n    struct branch_formula {\n        expr*    m_fml;\n        app*     m_var;\n        unsigned m_branch;\n        expr*    m_result;\n        rational m_coeff;\n        expr*    m_term;\n\n        branch_formula(): m_fml(0), m_var(0), m_branch(0), m_result(0), m_term(0) {}\n        \n        branch_formula(expr* fml, app* var, unsigned b, expr* r, rational coeff, expr* term):\n            m_fml(fml),\n            m_var(var),\n            m_branch(b),\n            m_result(r),\n            m_coeff(coeff),\n            m_term(term)\n        {}\n        \n        unsigned mk_hash() const {\n            return mk_mix(m_fml?m_fml-\u003ehash():0, m_var?m_var-\u003ehash():0, m_branch);\n        }\n        \n        bool mk_eq(branch_formula const\u0026 other) const {\n            return \n                m_fml == other.m_fml \u0026\u0026\n                m_var == other.m_var \u0026\u0026\n                m_branch == other.m_branch;\n        }\n        \n        struct hash {\n            typedef branch_formula data;\n            unsigned operator()(data const\u0026 d) const { return d.mk_hash(); }\n        };\n        \n        struct eq {\n            typedef branch_formula data;\n            bool operator()(data const\u0026 x, data const\u0026 y) const { return x.mk_eq(y); }\n        };\n    };\n\n    class arith_plugin : public qe_solver_plugin {\n        typedef obj_pair_map\u003capp,  expr, bounds_proc*\u003e bounds_cache;\n        typedef obj_pair_map\u003cexpr, expr, expr*\u003e        resolve_cache;\n        typedef hashtable\u003cbranch_formula, branch_formula::hash, branch_formula::eq\u003e subst_cache;\n\n        arith_qe_util      m_util;\n        expr_ref_vector    m_trail;\n        bounds_cache       m_bounds_cache;\n        subst_cache        m_subst;\n\n    public:\n        arith_plugin(i_solver_context\u0026 ctx, ast_manager\u0026 m, smt_params\u0026 p): \n            qe_solver_plugin(m, m.mk_family_id(\"arith\"), ctx),\n            m_util(m, p, ctx),\n            m_trail(m)\n        {}\n\n        ~arith_plugin() {\n            bounds_cache::iterator it = m_bounds_cache.begin(), end = m_bounds_cache.end();\n            for (; it != end; ++it) {\n                dealloc(it-\u003eget_value());\n            }\n        }\n\n        virtual void assign(contains_app\u0026 contains_x, expr* fml, rational const\u0026 vl) {\n            SASSERT(vl.is_unsigned());\n            app* x = contains_x.x();\n            unsigned v     = vl.get_unsigned();\n            expr_ref result(fml, m);\n            unsigned t_size, e_size;\n            x_subst x_t(m_util);\n\n            if (get_cache(x, fml, v, result)) {\n                return;\n            }\n            \n            bounds_proc\u0026 bounds = get_bounds(x, fml);            \n            bool is_lower = get_bound_sizes(bounds, x, t_size, e_size);            \n            assign_nested_divs(contains_x, bounds, result);\n            assign_divs(contains_x, bounds, x_t, result);\n\n            //assign_all(contains_x, fml);\n\n            if (v == 0) {\n                //\n                // index is for the infinity case.\n                // assert v =\u003e ~(x \u003c= t) each t\n                // assert v =\u003e (x \u003e= s) each s\n                //\n                mk_non_bounds(bounds, true,   is_lower, result);\n                mk_non_bounds(bounds, false,  is_lower, result);\n                \n                mk_non_resolve(bounds, true,  is_lower, result);\n                mk_non_resolve(bounds, false, is_lower, result);\n                m_util.simplify(result);\n                add_cache(x, fml, v, result, x_t.get_coeff(), x_t.get_term());\n                TRACE(\"qe\", \n                        tout \u003c\u003c vl \u003c\u003c \" \" \u003c\u003c mk_pp(x, m) \u003c\u003c \" infinite case\\n\";\n                        tout \u003c\u003c mk_pp(fml, m) \u003c\u003c \"\\n\";\n                        tout \u003c\u003c mk_pp(result, m) \u003c\u003c \"\\n\";);\n                return;\n            }\n            unsigned index = v-1;\n            bool is_strict = e_size \u003c= index;\n            bool is_eq = false;\n            \n            SASSERT(index \u003c t_size + e_size);\n            if (is_strict) {\n                index -= e_size;\n                TRACE(\"qe_verbose\", bounds.display(tout); );               \n            }\n            else if (m_util.is_real(x)) {\n                SASSERT(0 == (e_size \u0026 0x1));\n                is_eq = (0 == (index \u0026 0x1));\n                index  /= 2;\n                e_size /= 2;\n            }\n            SASSERT(is_strict || index \u003c e_size);\n            SASSERT(!is_strict || index \u003c t_size);\n\n            // \n            // index is for the upper/lower-bound case.\n            // assert v =\u003e (x \u003c= t_i) \n            // assert v =\u003e (x \u003c= t_j =\u003e t_i \u003c= t_j), add new atom to stack.\n            // assert v =\u003e (x \u003e= s   =\u003e s \u003c= t_i),   add new atom to stack.\n            //\n            // assert v =\u003e (x \u003c t_j =\u003e t_i \u003c t_j)\n            //\n            SASSERT(index \u003c bounds.size(is_strict, is_lower));\n            expr_ref t(bounds.exprs(is_strict, is_lower)[index], m);\n            rational a = bounds.coeffs(is_strict, is_lower)[index];\n\n            \n                                \n            mk_bounds(bounds, x, true,  is_eq, is_strict, is_lower, index, a, t, result);\n            mk_bounds(bounds, x, false, is_eq, is_strict, is_lower, index, a, t, result);\n\n            t = x_t.mk_term(a, t);\n            a = x_t.mk_coeff(a);\n            \n            mk_resolve(bounds, x, x_t, true,  is_eq, is_strict, is_lower, index, a, t, result);\n            mk_resolve(bounds, x, x_t, false, is_eq, is_strict, is_lower, index, a, t, result);\n            m_util.simplify(result);\n            add_cache(x, fml, v, result, x_t.get_coeff(), x_t.get_term());\n            TRACE(\"qe\", \n                  {\n                      tout \u003c\u003c vl \u003c\u003c \" \" \u003c\u003c mk_pp(bounds.atoms(is_strict, is_lower)[index],m) \u003c\u003c \"\\n\";\n                      tout \u003c\u003c mk_pp(fml, m) \u003c\u003c \"\\n\";\n                      tout \u003c\u003c mk_pp(result, m) \u003c\u003c \"\\n\";\n                  }\n                  );\n        }\n\n\n        virtual bool get_num_branches(contains_app\u0026 contains_x, expr* fml, rational\u0026 nb) { \n            app* x = contains_x.x();\n            if (!update_bounds(contains_x, fml)) {\n                return false;\n            }\n            bounds_proc\u0026 bounds = get_bounds(x, fml);\n            unsigned t_size, e_size;\n            get_bound_sizes(bounds, x, t_size, e_size);\n            nb = rational(t_size + e_size + 1);\n            return true;\n        }\n\n        virtual void subst(contains_app\u0026 contains_x, rational const\u0026 vl, expr_ref\u0026 fml, expr_ref* def) {\n            SASSERT(vl.is_unsigned());            \n           if (def) {\n               get_def(contains_x, vl.get_unsigned(), fml, *def);\n            }\n            VERIFY(get_cache(contains_x.x(), fml, vl.get_unsigned(), fml));\n            TRACE(\"qe\", tout \u003c\u003c mk_pp(contains_x.x(), m) \u003c\u003c \" \" \u003c\u003c vl \u003c\u003c \"\\n\" \u003c\u003c mk_pp(fml, m) \u003c\u003c \"\\n\";);\n        } \n\n        virtual bool project(contains_app\u0026 x, model_ref\u0026 model, expr_ref\u0026 fml) {\n            if (!update_bounds(x, fml)) {\n                TRACE(\"qe\", tout \u003c\u003c mk_pp(x.x(), m) \u003c\u003c \" failed to update bounds\\n\";);\n                return false;\n            }\n            if (m_util.m_arith.is_real(x.x())) {\n                return project_real(x, model, fml);\n            }\n            else {\n                return project_int(x, model, fml);\n            }\n        }\n\n\n        virtual unsigned get_weight(contains_app\u0026 contains_x, expr* fml) {\n            return 2;\n        }\n\n        virtual bool solve(conj_enum\u0026 conjs, expr* fml) {\n            return m_util.solve(conjs, fml);\n        }\n\n        virtual bool mk_atom(expr* e, bool p, expr_ref\u0026 result) {\n            return m_util.mk_atom(e, p, result);\n        }\n\n        virtual bool is_uninterpreted(app* f) {\n            switch(f-\u003eget_decl_kind()) {\n            case OP_NUM:\n            case OP_LE:\n            case OP_LT:\n            case OP_GE:\n            case OP_GT:\n            case OP_ADD:\n            case OP_SUB:\n            case OP_UMINUS:\n                return false;\n            case OP_MOD:\n                if(m_util.m_arith.is_numeral(f-\u003eget_arg(1))) {\n                    return false;\n                }\n                return true;\n            case OP_MUL: {\n                arith_util\u0026 a = m_util.m_arith;\n                expr* m, *n;\n                if (a.is_mul(f, m, n) \u0026\u0026 (a.is_numeral(m) || a.is_numeral(n))) {\n                    return false;\n                }\n                return true;\n            }\n            default:                \n                return true;\n            }\n        }\n\n    private:\n\n        /**\n           \\brief Compute least upper/greatest lower bounds for x.\n\n           Assume:\n           (not (= k 0))\n           (\u003c= 0 (mod m k)) \n           (\u003c (mod m k) (abs k))\n           (= m (+ (* k (div m k)) (mod m k)))\n           i.e. \n             k * (e div k) + (e mod k) = e\n\n           \n           When k is positive, least upper bound \n           for x such that: k*x \u003c= e is e div k\n\n           When k is negative, greatest lower bound \n           for x such that k*x \u003c= e is e div k\n\n           k * (e div k) + (e mod k) = e                   \n         */\n        expr_ref mk_idiv(expr* e, numeral k) {            \n            SASSERT(!k.is_zero());\n            arith_util\u0026 a = m_util.m_arith; \n            if (k.is_one()) {\n                return expr_ref(e, m);\n            }\n            if (k.is_minus_one()) {\n                return expr_ref(a.mk_uminus(e), m);\n            }\n            SASSERT(a.is_int(e));\n            return expr_ref(a.mk_idiv(e, a.mk_numeral(k, true)), m);\n        }\n    \n\n        void get_def(contains_app\u0026 contains_x, unsigned v, expr* fml, expr_ref\u0026 def) {\n            app* x = contains_x.x();\n            x_subst x_t(m_util);\n            bounds_proc\u0026 bounds = get_bounds(x, fml);    \n            branch_formula bf;\n            VERIFY (m_subst.find(branch_formula(fml, x, v, 0, rational::zero(), 0), bf));\n            x_t.set_term(bf.m_term);\n            x_t.set_coeff(bf.m_coeff);\n\n            // x is of the form: x_t.get_coeff()*x' + x_t.get_term()\n            CTRACE(\"qe\", x_t.get_term(), tout \u003c\u003c x_t.get_coeff() \u003c\u003c \" \" \u003c\u003c mk_pp(x_t.get_term(), m) \u003c\u003c \"\\n\";);\n            //\n            // a*x + t \u003c= 0\n            // a*(c*x' + s) + t \u003c= 0\n            // a*c*x' + a*s + t \u003c= 0\n            // \n\n            unsigned t_size, e_size, sz;        \n            bool is_lower = get_bound_sizes(bounds, x, t_size, e_size);            \n            bool is_strict;\n            if (v == 0) {\n                is_strict = false;\n                sz = bounds.size(is_strict, !is_lower);\n                expr_ref_vector terms(m);\n                if (sz == 0) {\n                    terms.push_back(m_util.mk_zero(x));\n                }\n                for (unsigned i = 0; i \u003c sz; ++i) {\n                    // a*x + term \u003c= 0\n                    expr_ref term(bounds.exprs(is_strict, !is_lower)[i], m);\n                    rational a = bounds.coeffs(is_strict, !is_lower)[i];\n\n                    if (x_t.get_term()) {\n                        // x := coeff * x' + s                        \n                        // solve instead for\n                        // a*coeff*x' + term + a*s \u003c= 0\n                        TRACE(\"qe\", tout \u003c\u003c x_t.get_coeff() \u003c\u003c \"* \" \u003c\u003c mk_pp(x,m) \u003c\u003c \" + \" \n                              \u003c\u003c mk_pp(x_t.get_term(), m) \u003c\u003c \"\\n\";);\n                        SASSERT(x_t.get_coeff().is_pos());\n                        term = m_util.mk_add(term, m_util.mk_mul(a, x_t.get_term()));\n                        a    = a * x_t.get_coeff();\n                    }\n\n                    TRACE(\"qe\", tout \u003c\u003c a \u003c\u003c \"* \" \u003c\u003c mk_pp(x,m) \u003c\u003c \" + \" \u003c\u003c mk_pp(term, m) \u003c\u003c \" \u003c= 0\\n\";);\n                    SASSERT(a.is_int());\n                    SASSERT(is_lower == a.is_pos());                    \n\n                    //    a*x + t \u003c= 0\n                    // \u003c=\n                    //   x \u003c= -t div a + 1\n                    \n                    term = m_util.mk_uminus(term);\n                    term = mk_idiv(term, a);\n                    terms.push_back(term);\n                    TRACE(\"qe\", tout \u003c\u003c \"a: \" \u003c\u003c a \u003c\u003c \" term: \" \u003c\u003c mk_pp(term, m) \u003c\u003c \"\\n\";);\n                }\n                is_strict = true;\n                sz = bounds.size(is_strict, !is_lower);\n                for (unsigned i = 0; i \u003c sz; ++i) {\n                    expr_ref term(bounds.exprs(is_strict, !is_lower)[i], m);\n                    SASSERT(abs(bounds.coeffs(is_strict, !is_lower)[i]).is_one());\n                    //\n                    if (is_lower) {\n                        //    x + t \u003c 0\n                        // \u003c= \n                        //    x \u003c= -t -1\n                        term = m_util.mk_uminus(m_util.mk_add(term, m_util.mk_one(x)));\n                    }\n                    else {\n                        //   -x + t \u003c 0\n                        // \u003c=\n                        //    t + 1 \u003c= x\n                        term = m_util.mk_add(term, m_util.mk_one(x));\n                    }\n                    terms.push_back(term);\n                }\n                if (is_lower) {\n                    def = m_util.mk_min(terms.size(), terms.c_ptr());\n                }\n                else {\n                    def = m_util.mk_max(terms.size(), terms.c_ptr());\n                }\n                \n                if (x_t.get_term()) {\n                    // x := coeff * x + s\n                    TRACE(\"qe\", tout \u003c\u003c x_t.get_coeff() \u003c\u003c \"* \" \u003c\u003c mk_pp(x,m) \u003c\u003c \" + \" \n                          \u003c\u003c mk_pp(x_t.get_term(), m) \u003c\u003c \"\\n\";);\n                    def = m_util.mk_add(m_util.mk_mul(x_t.get_coeff(), def), x_t.get_term());\n                }\n                m_util.simplify(def);\n                return;\n            }\n            --v;\n            is_strict = e_size \u003c= v;\n            \n            SASSERT(v \u003c t_size + e_size);\n            if (is_strict) {\n                v -= e_size;\n                TRACE(\"qe_verbose\", bounds.display(tout); );               \n            }\n            else if (m_util.is_real(x)) {\n                SASSERT(0 == (e_size \u0026 0x1));\n                v  /= 2;\n                e_size /= 2;\n            }\n            SASSERT(is_strict || v \u003c e_size);\n            SASSERT(!is_strict || v \u003c t_size); \n\n            // \n            // index is for the upper/lower-bound case.\n            // assert v =\u003e (x \u003c= t_i) \n            //\n            SASSERT(v \u003c bounds.size(is_strict, is_lower));\n            def = bounds.exprs(is_strict, is_lower)[v];\n            rational a = bounds.coeffs(is_strict, is_lower)[v];\n\n            if (x_t.get_term()) {\n                // x := coeff * x' + s                        \n                // solve instead for\n                // a*coeff*x' + term + a*s \u003c= 0\n                TRACE(\"qe\", tout \u003c\u003c x_t.get_coeff() \u003c\u003c \"* \" \u003c\u003c mk_pp(x,m) \u003c\u003c \" + \" \n                      \u003c\u003c mk_pp(x_t.get_term(), m) \u003c\u003c \"\\n\";);\n                SASSERT(x_t.get_coeff().is_pos());\n                def = m_util.mk_add(def, m_util.mk_mul(a, x_t.get_term()));\n                a    = a * x_t.get_coeff();\n            }\n\n            SASSERT(a.is_int());\n            SASSERT(is_lower != a.is_pos());                    \n\n            //    a*x + t \u003c= 0\n            // \u003c=\n            //   x \u003c= -t div a \n            \n            def = m_util.mk_uminus(def);\n            def = mk_idiv(def, a);\n\n            if (x_t.get_term()) {\n                // x := coeff * x + s\n                def = m_util.mk_add(m_util.mk_mul(x_t.get_coeff(), def), x_t.get_term());\n            }\n            if (is_strict) {\n                SASSERT(m_util.m_arith.is_real(x));\n                // We actually want a supremum, such that dual inequalities are satisfied.\n                // i.e. for every dual inequality , if the dual bound is feasible, make sure to\n                // choose a value in the feasible range.\n                def = m_util.mk_sub(def, m_util.mk_one(x));\n            }\n\n            m_util.simplify(def);\n\n\n            TRACE(\"qe\", tout \u003c\u003c \"TBD (for Real): \" \u003c\u003c a \u003c\u003c \" \" \u003c\u003c mk_pp(def, m) \u003c\u003c \"\\n\";);\n        }\n\n        expr_ref mk_not(expr* e) {\n            expr* r;\n            if (m.is_not(e,r)) {\n                return expr_ref(r, m);\n            }\n            return expr_ref(m.mk_not(e), m);\n        }\n\n        //\n        // Projection function for x of type real.\n        // TBD: model-based selection soundness/completeness?\n        //      when model selects bound different from what is the smaller half, what then?\n        //      shouldn't we find candidate among either lt or gt, and then if both can be found\n        //      only then select which one to go with. Then assign has to be context-aware.\n        //      Perhaps not really: the model is used as a hint.\n        // \n\n        bool project_real(contains_app\u0026 x, model_ref\u0026 model, expr_ref\u0026 fml) {\n            SASSERT(m_util.m_arith.is_real(x.x()));\n            model_evaluator model_eval(*model);\n            bounds_proc\u0026 bounds = get_bounds(x.x(), fml);\n            bool is_lower   = bounds.le_size() + bounds.lt_size() \u003c bounds.ge_size() + bounds.gt_size();\n            unsigned e_size = bounds.e_size(is_lower);\n            numeral bound1, bound2, vl, x_val;\n            unsigned idx1, idx2;\n            bool found1 = find_min_max(is_lower, false, bounds, model_eval, bound1, idx1);\n            bool found2 = find_min_max(is_lower, true,  bounds, model_eval, bound2, idx2);\n\n            if (!found1 \u0026\u0026 !found2) {\n                vl = numeral(0);\n            }\n            else if (found2 \u0026\u0026 (!found1 || bound2 \u003c= bound1)) {\n                // strict indices come after non-strict indices. There \n                // is a pair of index values for non-strict inequalities \n                // corresponding to the disjunction (x \u003c t || x = t)\n                vl = numeral(1 + 2*e_size + idx2);\n            }\n            else if (found1 \u0026\u0026 (!found2 || bound1 \u003c bound2)) {\n                expr_ref val_x(m);\n                model_eval(x.x(), val_x);\n                VERIFY(m_util.m_arith.is_numeral(val_x, x_val));\n                if (x_val == bound1) {\n                    vl = numeral(1 + 2*idx1); // even indicates equality between x and bound.\n                }\n                else {\n                    vl = numeral(1 + 2*idx1 + 1); // odd indicates strict bound.\n                }\n            }\n            assign(x, fml, vl);\n            subst(x, vl, fml, 0);\n            TRACE(\"qe\", tout \u003c\u003c mk_pp(fml, m) \u003c\u003c \"\\n\";);            \n            return true;\n        }\n\n        bool project_int(contains_app\u0026 x, model_ref\u0026 model, expr_ref\u0026 fml) {\n            model_evaluator model_eval(*model);\n            bounds_proc\u0026 bounds = get_bounds(x.x(), fml);\n            SASSERT(m_util.m_arith.is_int(x.x()));\n            SASSERT(bounds.lt_size() == 0 \u0026\u0026 bounds.gt_size() == 0);\n            bool is_lower   = bounds.le_size() \u003c bounds.ge_size();\n            numeral bound, vl, x_val;\n            unsigned idx = bounds.le_size() + bounds.ge_size();\n            bool found = find_min_max(is_lower, false, bounds, model_eval, bound, idx);\n\n            if (found) {\n                SASSERT(idx \u003c bounds.size(false, is_lower));\n                vl = numeral(1 + idx);\n            }\n            else {\n                vl = numeral(0);\n            }\n            assign(x, fml, vl);\n            subst(x, vl, fml, 0);\n            TRACE(\"qe\", tout \u003c\u003c mk_pp(fml, m) \u003c\u003c \"\\n\";);\n            \n            return true;\n        }\n\n        bool find_min_max(bool is_lower, bool is_strict, bounds_proc\u0026 bounds, \n                          model_evaluator\u0026 eval, rational\u0026 bound, unsigned\u0026 idx) {\n            bool found = false;\n            unsigned num_bounds = bounds.size(is_strict, is_lower);\n            rational num;\n            for (unsigned i = 0; i \u003c num_bounds; ++i) {\n                expr_ref vl(m);\n                eval(bounds.atoms(is_strict, is_lower)[i], vl);\n                if (!m.is_true(vl)) {\n                    continue;\n                }\n                eval(bounds.exprs(is_strict, is_lower)[i], vl);\n                VERIFY(m_util.m_arith.is_numeral(vl, num));\n                num /= abs(bounds.coeffs(is_strict,is_lower)[i]);\n                if (found) {\n                    if (is_lower?(num \u003c bound):(num \u003e bound)) {\n                        bound = num;\n                        idx = i;\n                    }\n                }\n                else {\n                    found = true;\n                    idx = i;\n                    bound = num;\n                }                \n            }\n            return found;\n        }\n\n\n        bool get_bound_sizes(bounds_proc\u0026 bounds, app* x, unsigned\u0026 t_size, unsigned\u0026 e_size) {\n            unsigned le_size = bounds.le_size();\n            unsigned ge_size = bounds.ge_size();\n            if (m_util.is_real(x)) {\n                le_size *= 2;\n                ge_size *= 2;\n            }\n            if (le_size + bounds.lt_size() \u003c ge_size + bounds.gt_size()) {\n                e_size = le_size;\n                t_size = bounds.lt_size();\n                return true;\n            }\n            else {\n                e_size = ge_size;\n                t_size = bounds.gt_size();\n                return false;\n            }\n        }\n\n        void add_cache(app* x, expr* fml, unsigned v, expr* result, rational coeff, expr* term) {\n            m_trail.push_back(x);\n            m_trail.push_back(fml);\n            m_trail.push_back(result);\n            if (term) m_trail.push_back(term);\n            m_subst.insert(branch_formula(fml, x, v, result, coeff, term));\n        }\n        \n        bool get_cache(app* x, expr* fml, unsigned v, expr_ref\u0026 result) {\n            branch_formula bf;\n            if (!m_subst.find(branch_formula(fml, x, v, 0, rational::zero(), 0), bf)) {\n                return false;\n            }\n            SASSERT(bf.m_result);\n            result = bf.m_result;\n            return true;\n        }\n\n        void assign_divs(contains_app\u0026 contains_x, bounds_proc\u0026 bounds, x_subst\u0026 x_t, expr_ref\u0026 result) {\n            app* x = contains_x.x();\n            \n            app_ref z(m), z_bv(m);\n            rational d;\n            if (!bounds.div_z(d, z_bv, z)) {\n                return;\n            }\n            m_ctx.add_var(z_bv);\n            \n            //\n            // assert \n            //        z \u003c d\n            //        d | (x - z)\n            //        (c | ax + t \u003c-\u003e c | az + t) for each divisor.\n            // \n\n            // z \u003c d\n            expr* z_lt_d = m_util.m_arith.mk_le(z, m_util.m_arith.mk_numeral(d-rational(1), true));\n            m_ctx.add_constraint(false, z_lt_d);\n\n            // result \u003c- result \u0026 z \u003c= d - 1\n            SASSERT(!abs(d).is_one());\n            rational d1 = d - rational(1);\n            expr_ref tmp(m);\n            m_util.m_arith_rewriter.mk_le(z, m_util.m_arith.mk_numeral(d1, true), tmp);\n            m_util.m_bool_rewriter.mk_and(result, tmp, result);\n\n            // d | (x - z)\n            expr_ref t1(m), new_atom(m);\n            t1 = m_util.mk_sub(x, z);\n            m_util.mk_divides(d, t1, new_atom);\n            m_ctx.add_constraint(false, new_atom);\n            \n            // (c | ax + t \u003c-\u003e c | az + t) for each divisor.\n            mk_div_equivs(bounds, z, result);\n            \n            // update x_t to map x |-\u003e dx + z\n            x_t.set_term(z);\n            x_t.set_coeff(d);\n        }\n\n        //\n        //   (c | ax + t \u003c-\u003e c | az + t) for each divisor.\n        //\n        void mk_div_equivs(bounds_proc\u0026 bounds, expr* z, expr_ref\u0026 result) {\n            unsigned sz = bounds.div_size();\n            app* const* atoms        = bounds.div_atoms();\n            rational const* coeffs   = bounds.div_coeffs();\n            expr* const* terms       = bounds.div_terms();\n            rational const* divisors = bounds.divisors();\n            expr_ref new_atom(m), t1(m);\n\n            for (unsigned i = 0; i \u003c sz; ++i) {        \n                app* atm = atoms[i];        \n                t1 = m_util.mk_add(m_util.mk_mul(coeffs[i], z), terms[i]);\n                m_util.mk_divides(divisors[i], t1, new_atom);\n                m_util.m_replace.apply_substitution(atm, new_atom.get(), result);\n                \n                m_ctx.add_constraint(false, mk_not(atm), new_atom);\n                m_ctx.add_constraint(false, mk_not(new_atom), atm);\n            }\n        }\n\n        void assign_nested_divs(contains_app\u0026 contains_x, bounds_proc\u0026 bounds, expr_ref\u0026 result) {\n            unsigned num_nested_divs = bounds.nested_div_size();\n            if (num_nested_divs == 0) {\n                return;\n            }\n            app_ref z(m), z_bv(m);\n            rational d;\n            VERIFY (bounds.div_z(d, z_bv, z));\n            for (unsigned i = 0; i \u003c num_nested_divs; ++i) {\n                //\n                // mod_term = arg_0 mod k\n                //\n                app* atm = bounds.nested_div_atom(i);\n                rational const\u0026 k = bounds.nested_divisor(i);\n\n                app* z1_bv = bounds.nested_div_z_bv(i);\n                app* z1 = bounds.nested_div_z(i);\n\n                m_ctx.add_var(z1_bv);\n\n                //\n                // assert\n                //    z \u003c k\n                //    (coeff*x + rest - z) mod k == 0\n                // \n\n                expr* z_lt_k = m_util.m_arith.mk_le(z1, m_util.m_arith.mk_numeral(k-rational(1), true));\n                m_ctx.add_constraint(false, z_lt_k);\n                expr* e1 = m_util.m_arith.mk_sub(atm-\u003eget_arg(0), z1);\n                expr* e2 = atm-\u003eget_arg(1);\n                expr_ref mod_term2(m_util.m_arith.mk_mod(e1, e2), m);\n                m_util.simplify(mod_term2);\n                m_ctx.add_constraint(false, m.mk_eq(mod_term2, m_util.mk_zero(mod_term2)));\n\n                m_util.m_replace.apply_substitution(atm, z1, result);  \n\n                //\n                // conjoin (coeff*z + rest - z1) mod k == 0 to result\n                //\n                expr_ref mod_eq(m), tmp1(m), tmp2(m);\n                \n                tmp2 = m_util.mk_numeral(bounds.nested_div_coeff(i), true);\n                tmp1 = m_util.m_arith.mk_mul(tmp2, z1);\n                tmp2 = m_util.m_arith.mk_sub(bounds.nested_div_term(i), z);\n                tmp2 = m_util.m_arith.mk_add(tmp1, tmp2);\n                tmp1 = m_util.m_arith.mk_mod(tmp2, bounds.nested_div_atom(i)-\u003eget_arg(1));\n\n                mod_eq = m.mk_eq(tmp1, m_util.mk_zero(z));\n                m_util.simplify(mod_eq);\n                result = m.mk_and(result, mod_eq);\n\n                TRACE(\"qe\", tout \u003c\u003c mk_pp(mod_eq, m) \u003c\u003c \"\\n\";);\n            }\n        }\n\n        bounds_proc\u0026 get_bounds(app* x, expr* fml) {\n            bounds_proc* result = 0;\n            VERIFY (m_bounds_cache.find(x, fml, result));\n            return *result;\n        }      \n\n        void mk_non_bounds(bounds_proc\u0026 bounds, bool is_strict, bool is_lower, expr_ref\u0026 result) {\n            unsigned sz = bounds.size(is_strict, is_lower);\n            for (unsigned i = 0; i \u003c sz; ++i) {\n                app* e = bounds.atoms(is_strict, is_lower)[i];\n                m_ctx.add_constraint(true, mk_not(e));\n                m_util.m_replace.apply_substitution(e, m.mk_false(), result);\n            }            \n        }\n\n        void mk_non_resolve(bounds_proc\u0026 bounds, bool is_strict, bool is_lower, expr_ref\u0026 result) {\n            unsigned sz = bounds.size(is_strict, !is_lower);\n            for (unsigned i = 0; i \u003c sz; ++i) {\n                app* e = bounds.atoms(is_strict, !is_lower)[i];\n                m_ctx.add_constraint(true, e);\n                m_util.m_replace.apply_substitution(e, m.mk_true(), result); \n            }\n        }\n\n        //\n        // phi[x \u003c t, x \u003c= s, x \u003e= u, x \u003e v]\n        // \n        // x = +oo: phi[false, false, true, true]\n        // x \u003c t:   phi[true,    t-e \u003c s, t - e \u003e= u, t - e \u003e v] == phi[true,   t \u003c= s, t \u003e u,  t \u003e v]\n        // x \u003c s:   phi[s-e \u003c t, true,    s - e \u003e= u, s - e \u003e v] == phi[s \u003c= t, true,   s \u003e u,  s \u003e v]\n        // x = s:                                                   phi[s \u003c t,  true,   s \u003e= u, s \u003e v]\n        // \n        // assert \n        //      path1 =\u003e x \u003c t \n        // bounds:\n        //      path1 =\u003e x \u003c t' =\u003e t \u003c t'  when index(t') \u003c index(t)\n        //      path1 =\u003e x \u003c t' =\u003e t \u003c= t' when index(t') \u003e= index(t)\n        //      path1 =\u003e x \u003c= s =\u003e t \u003c= s\n        // resolve:\n        //      path1 =\u003e x \u003e= u =\u003e t \u003e u\n        //      path1 =\u003e x \u003e v  =\u003e t \u003e v\n        // symmetry reduction:\n        //      \n        // \n        //      path2 =\u003e x \u003c= s\n        // bounds:\n        //      path2 =\u003e x \u003c s =\u003e x \u003c t =\u003e s \u003c= t\n        //      path2 =\u003e x = s =\u003e x \u003c t =\u003e s \u003c t\n        //      path2 =\u003e x \u003c= s =\u003e x \u003c= s' =\u003e s \u003c  s' when index(s') \u003c index(s)\n        //      path2 =\u003e x \u003c= s =\u003e x \u003c= s' =\u003e s \u003c= s' when index(s') \u003e= index(s)\n        // resolve:\n        //      path2 =\u003e x \u003c s =\u003e x \u003e= u =\u003e s \u003e u\n        //      path2 =\u003e x = s =\u003e x \u003e= u =\u003e s \u003e= u\n        //      path2 =\u003e x \u003c= s =\u003e x \u003e v =\u003e s \u003e v\n        //\n\n\n        void mk_bound(bool is_strict, bool is_lower, \n                      rational const\u0026 a, expr* t,\n                      rational const\u0026 b, expr* s,\n                      expr_ref\u0026 result) \n        {\n            if (is_strict) {\n                if (is_lower) {\n                    // b*t \u003e a*s\n                    m_util.mk_strict_bound(b, s, a, t, result);\n                }\n                else {\n                    // b*t \u003c a*s\n                    m_util.mk_strict_bound(a, t, b, s, result);\n                }\n            }\n            else {                        \n                if (is_lower) {\n                    // b*t \u003e= a*s\n                    m_util.mk_bound(b, s, a, t, result);\n                }\n                else {\n                    // b*t \u003c= a*s\n                    m_util.mk_bound(a, t, b, s, result);\n                }\n            }\n            m_util.simplify(result);\n            TRACE(\"qe\", \n                  tout \u003c\u003c (is_strict?\"strict\":\"non-strict\") \u003c\u003c \"\\n\";\n                  tout \u003c\u003c (is_lower?\"is-lower\":\"is-upper\") \u003c\u003c \"\\n\";\n                  tout \u003c\u003c \"a: \" \u003c\u003c a \u003c\u003c \" \" \u003c\u003c mk_pp(t, m) \u003c\u003c \"\\n\";\n                  tout \u003c\u003c \"b: \" \u003c\u003c b \u003c\u003c \" \" \u003c\u003c mk_pp(s, m) \u003c\u003c \"\\n\";\n                  tout \u003c\u003c mk_pp(result, m) \u003c\u003c \"\\n\";);\n        }\n\n        //\n        // a*x \u003c= t, a*x \u003c t\n        // \n        /*\n            - bounds \n            - add_assertion - flag whether to add side-effect to state\n            - x             - the variable to be eliminated\n            - is_strict     - whether to loop over strict inequalities\n            - is_eq_ctx     - whether non-strict inequality is to be treated as equality case.\n            - is_strict_ctx - whether 'atm' is a strict inequality\n            - is_lower      - whether 'x' is given a lower-bound in 'atm'\n            - index         - index of 'atm' in 'bounds' 'atm = bounds[index]'\n            - a             - coefficient to 'x' in 'atm'\n            - t             - upper/lower bound to 'x' in 'atm'\n        */\n\n\n        void mk_bounds(bounds_proc\u0026 bounds, \n                       app* x, bool is_strict, bool is_eq_ctx, \n                       bool is_strict_ctx, bool is_lower, unsigned index, \n                       rational const\u0026 a, expr* t,\n                       expr_ref\u0026 result) \n        {\n            TRACE(\"qe\", tout \u003c\u003c mk_pp(t, m) \u003c\u003c \"\\n\";);\n            SASSERT(!is_eq_ctx || !is_strict_ctx);\n            unsigned sz = bounds.size(is_strict, is_lower);\n            expr_ref tmp(m), eq(m);            \n            bool same_strict = (is_strict == is_strict_ctx);\n            bool non_strict_real = m_util.is_real(x) \u0026\u0026 !is_strict_ctx;\n            app* atm = bounds.atoms(is_strict_ctx, is_lower)[index];\n\n            for (unsigned i = 0; i \u003c sz; ++i) {\n                app* e   = bounds.atoms(is_strict, is_lower)[i];\n                expr_ref s(bounds.exprs(is_strict, is_lower)[i], m);\n                rational b = bounds.coeffs(is_strict, is_lower)[i]; \n               \n                if (same_strict \u0026\u0026 i == index) {                    \n                    if (non_strict_real) {\n                        m_util.mk_eq(a, x, t, eq);\n                        TRACE(\"qe\", tout \u003c\u003c \"a:\" \u003c\u003c a \u003c\u003c \" x: \" \u003c\u003c mk_pp(x, m) \u003c\u003c \"t: \" \u003c\u003c \n                              mk_pp(t, m) \u003c\u003c \" eq: \" \u003c\u003c mk_pp(eq, m) \u003c\u003c \"\\n\";);\n                        if (is_eq_ctx) {\n                            m_ctx.add_constraint(true, eq);\n                        }\n                        else {\n                            m_ctx.add_constraint(true, mk_not(eq));\n                            m_ctx.add_constraint(true, e);\n                        }\n                    }\n                    else {\n                        m_ctx.add_constraint(true, e);\n                    }\n                    m_util.m_replace.apply_substitution(atm, m.mk_true(), result);\n                    continue;\n                }\n           \n                //\n                // Break symmetries by using index:\n                // bounds before me are strictly larger.\n                // Cases:\n                // ax \u003c= t \u0026 ax != t \u0026 bx \u003c s =\u003e bt \u003c= as\n                // ax \u003c= t \u0026 ax = t  \u0026 bx \u003c s =\u003e bt \u003c as\n                //                     bx \u003c= s =\u003e bt \u003c as or bt \u003c= as depending on symmetry\n                //     \n                bool result_is_strict = \n                    (non_strict_real \u0026\u0026 is_eq_ctx \u0026\u0026 is_strict) ||\n                    (same_strict \u0026\u0026 i \u003c index);\n\n\n                mk_bound(result_is_strict, is_lower, a, t, b, s, tmp);\n                m_util.m_replace.apply_substitution(e, tmp.get(), result);\n\n                TRACE(\"qe\", \n                      tout \u003c\u003c (result_is_strict?\"strict result\":\"non-strict result\") \u003c\u003c \"\\n\";\n                      tout \u003c\u003c (is_strict?\"strict\":\"non-strict\") \u003c\u003c \"\\n\";\n                      tout \u003c\u003c mk_pp(atm, m) \u003c\u003c \" \u0026 \";\n                      tout \u003c\u003c mk_pp(e,  m) \u003c\u003c \" --\u003e \";\n                      tout \u003c\u003c mk_pp(tmp.get(), m) \u003c\u003c \"\\n\";);\n\n                m_ctx.add_constraint(true, mk_not(e), tmp);\n            }\n        }\n\n        //  x \u003c= t\n        //      x != t =\u003e x \u003e= u =\u003e t \u003e u\n        //      x = t =\u003e x \u003e= u =\u003e t \u003e= u\n        void mk_resolve(bounds_proc\u0026 bounds, \n                        app* x, x_subst\u0026 x_t, bool is_strict, bool is_eq_ctx, bool is_strict_ctx, bool is_lower, \n                        unsigned index, \n                        rational const\u0026 a, expr* t, expr_ref\u0026 result) \n        {\n            expr_ref tmp(m);\n            unsigned sz = bounds.size(is_strict, !is_lower);\n            bool is_strict_real = !is_eq_ctx \u0026\u0026 m_util.is_real(x) \u0026\u0026 !is_strict_ctx;                   \n            bool strict_resolve = is_strict || is_strict_ctx || is_strict_real;\n            app* atm = bounds.atoms(is_strict_ctx, is_lower)[index];    \n\n            for (unsigned i = 0; i \u003c sz; ++i) {\n                app* e = bounds.atoms(is_strict, !is_lower)[i];\n                expr_ref s(bounds.exprs(is_strict, !is_lower)[i], m);\n                rational b = bounds.coeffs(is_strict, !is_lower)[i];\n                SASSERT(!b.is_zero());\n                SASSERT(b.is_pos() != a.is_pos());\n                \n                s = x_t.mk_term(b, s);\n                b = x_t.mk_coeff(b);\n                m_util.mk_resolve(x, strict_resolve, a, t, b, s, tmp);\n                expr_ref save_result(result);\n                m_util.m_replace.apply_substitution(e, tmp.get(), result);\n                \n                m_ctx.add_constraint(true, mk_not(e), tmp);\n\n                TRACE(\"qe_verbose\", \n                      tout \u003c\u003c mk_pp(atm, m) \u003c\u003c \" \";\n                      tout \u003c\u003c mk_pp(e, m) \u003c\u003c \" ==\u003e\\n\";\n                      tout \u003c\u003c mk_pp(tmp, m) \u003c\u003c \"\\n\";\n                      tout \u003c\u003c \"old fml: \" \u003c\u003c mk_pp(save_result, m) \u003c\u003c \"\\n\";\n                      tout \u003c\u003c \"new fml: \" \u003c\u003c mk_pp(result, m) \u003c\u003c \"\\n\";\n                      );           \n            }            \n        }\n\n        bool update_bounds(bounds_proc\u0026 bounds, contains_app\u0026 contains_x, expr* fml, atom_set const\u0026 tbl, bool is_pos) \n        {\n            app_ref tmp(m);\n            atom_set::iterator it = tbl.begin(), end = tbl.end();\n            for (; it != end; ++it) {\n                app* e = *it; \n                if (!contains_x(e)) {\n                    continue;\n                }\n\n                if (!is_pos) {\n                    SASSERT(!m.is_not(e));\n                    tmp = m.mk_not(e);\n                    e = tmp;\n                }\n                \n                if (!bounds.get_bound(contains_x, e)) {\n                    return false;\n                }\n            }    \n            return true;\n        }\n\n        bool update_bounds(contains_app\u0026 contains_x, expr* fml) {\n            bounds_proc* bounds = 0;\n            if (m_bounds_cache.find(contains_x.x(), fml, bounds)) {\n                return true;\n            }\n            bounds = alloc(bounds_proc, m_util);\n\n            if (!update_bounds(*bounds, contains_x, fml, m_ctx.pos_atoms(), true)) {\n                dealloc(bounds);\n                return false;\n            }\n            if (!update_bounds(*bounds, contains_x, fml, m_ctx.neg_atoms(), false)) {\n                dealloc(bounds);\n                return false;\n            }\n            \n            m_trail.push_back(contains_x.x());\n            m_trail.push_back(fml);\n            m_bounds_cache.insert(contains_x.x(), fml, bounds);\n            return true;\n        }\n    };\n\n    // ---------------------\n    // non-linear arithmetic\n    class nlarith_plugin : public qe_solver_plugin {\n        typedef obj_map\u003capp, unsigned\u003e weight_m;\n        typedef obj_pair_map\u003cexpr, expr, nlarith::branch_conditions*\u003e bcs_t;\n        typedef obj_map\u003cexpr, weight_m* \u003e weights_t;\n        bcs_t                        m_cache;\n        weights_t                    m_weights;\n        th_rewriter                  m_rewriter;        \n        nlarith::util                m_util;\n        expr_safe_replace            m_replace;\n        expr_ref_vector              m_trail;\n        factor_rewriter_star         m_factor_rw;\n        bool                         m_produce_models;\n    public:\n        nlarith_plugin(i_solver_context\u0026 ctx, ast_manager\u0026 m, bool produce_models) : \n            qe_solver_plugin(m, m.mk_family_id(\"arith\"), ctx),\n            m_rewriter(m),\n            m_util(m),\n            m_replace(m),\n            m_trail(m),\n            m_factor_rw(m),\n            m_produce_models(produce_models) {\n            TRACE(\"qe\", tout \u003c\u003c \"produce models: \" \u003c\u003c produce_models \u003c\u003c \"\\n\";);\n            m_util.set_enable_linear(true); // (produce_models);\n        }\n\n        virtual ~nlarith_plugin() {\n            bcs_t::iterator it = m_cache.begin(), end = m_cache.end();\n            for (; it != end; ++it) {\n                dealloc(it-\u003eget_value());\n            }\n            weights_t::iterator it2 = m_weights.begin(), e2 = m_weights.end();\n            for (; it2 != e2; ++it2) {\n                dealloc(it2-\u003eget_value());\n            }                        \n        }\n\n        virtual bool simplify(expr_ref\u0026 fml) { \n            expr_ref tmp(m), tmp2(m);\n            m_factor_rw(fml, tmp);\n            m_rewriter(tmp, tmp2);\n            if (fml.get() != tmp2.get()) {\n                fml = tmp2;\n                return true;\n            }\n            return false; \n        }\n                \n        virtual void assign(contains_app\u0026 x, expr* fml, rational const\u0026 vl) {\n            nlarith::branch_conditions *brs;\n            VERIFY (m_cache.find(x.x(), fml, brs));\n            SASSERT(vl.is_unsigned());\n            SASSERT(vl.get_unsigned() \u003c brs-\u003esize());\n            expr* branch_fml = brs-\u003ebranches(vl.get_unsigned());\n            expr_ref result(m), tmp(m);\n            m_factor_rw(branch_fml, tmp);\n            m_rewriter(tmp, result);\n            TRACE(\"qe\", tout \u003c\u003c vl \u003c\u003c \" \" \u003c\u003c mk_pp(result.get(), m) \u003c\u003c \"\\n\";);\n            m_ctx.add_constraint(true, result);\n        }\n        \n        virtual bool get_num_branches(contains_app\u0026 x, \n                                      expr* fml, rational\u0026 num_branches) {\n            nlarith::branch_conditions *brs;\n            if (m_cache.find(x.x(), fml, brs)) {\n                num_branches = rational(brs-\u003esize());\n                return true;\n            }\n            expr_ref_vector lits(m);\n            update_bounds(lits, m_ctx.pos_atoms(), true);\n            update_bounds(lits, m_ctx.neg_atoms(), false);\n\n            brs = alloc(nlarith::branch_conditions, m);\n            \n            TRACE(\"nlarith\", tout \u003c\u003c mk_pp(fml, m) \u003c\u003c \"\\n\";);\n            if (!m_util.create_branches(x.x(), lits.size(), lits.c_ptr(), *brs)) {\n                TRACE(\"nlarith\", tout \u003c\u003c \"no branches for \" \u003c\u003c mk_pp(x.x(), m) \u003c\u003c \"\\n\";);\n                dealloc(brs);\n                return false;\n            }            \n            num_branches = rational(brs-\u003esize());            \n            insert_cache(x.x(), fml, brs);\n            return true;\n        }\n        \n        virtual void subst(contains_app\u0026 x, rational const\u0026 vl, expr_ref\u0026 fml, expr_ref* def) {\n            nlarith::branch_conditions *brs;\n            VERIFY (m_cache.find(x.x(), fml, brs));\n            SASSERT(vl.is_unsigned());\n            SASSERT(vl.get_unsigned() \u003c brs-\u003esize());\n            unsigned j = vl.get_unsigned();\n            m_replace.reset();            \n            for (unsigned i = 0; i \u003c brs-\u003epreds().size(); ++i) {\n                m_replace.insert(brs-\u003epreds(i), brs-\u003esubst(j)[i]);\n            }\n            m_replace(fml);\n            expr_ref tmp(m.mk_and(brs-\u003econstraints(j), fml), m);\n            m_factor_rw(tmp, fml);\n            if (def) {\n                m_factor_rw(brs-\u003edef(j), *def);\n            }\n        }\n\n        \n        virtual unsigned get_weight(contains_app\u0026 x, expr* fml) { \n            obj_map\u003capp, unsigned\u003e* weights = 0;\n            unsigned weight = 0;\n            if (!m_weights.find(fml, weights)) {\n                weights = alloc(weight_m);\n                m_weights.insert(fml, weights);\n                m_trail.push_back(fml);\n                ptr_vector\u003capp\u003e nl_vars;\n                m_util.extract_non_linear(to_app(fml), nl_vars);\n                for (unsigned i = 0; i \u003c nl_vars.size(); ++i) {\n                    weights-\u003einsert(nl_vars[i], 100);                   \n                }\n            }\n            if (weights-\u003efind(x.x(), weight)) {\n                return weight;\n            }\n            return UINT_MAX; \n        }\n\n        virtual bool solve(conj_enum\u0026 conjs, expr* fml) { return false; }\n\n        // we don't need to modify the atom.\n        virtual bool mk_atom(expr* e, bool p, expr_ref\u0026 result) { return false;  }\n\n        virtual bool is_uninterpreted(app* f) {\n            if (m_produce_models) {\n                return true;\n            }\n            switch(f-\u003eget_decl_kind()) {\n            case OP_NUM:\n            case OP_LE:\n            case OP_LT:\n            case OP_GE:\n            case OP_GT:\n            case OP_ADD:\n            case OP_SUB:\n            case OP_UMINUS:\n                return false;\n            case OP_MUL: {\n                arith_util a(m);\n                expr* m, *n;\n                if (a.is_mul(f, m, n) \u0026\u0026 (a.is_numeral(m) || a.is_numeral(n))) {\n                    return false;\n                }\n                return true;\n            }\n            default:                \n                return true;\n            }\n            return true;\n        }\n    private:\n\n        void insert_cache(app* x, expr* e, nlarith::branch_conditions* brs) {\n            m_trail.push_back(x);\n            m_trail.push_back(e);\n            m_cache.insert(x, e, brs);\n        }\n\n        void update_bounds(expr_ref_vector\u0026 lits, atom_set const\u0026 tbl, bool is_pos) {\n            atom_set::iterator it = tbl.begin(), end = tbl.end();\n            for (; it != end; ++it) {\n                app* e = *it; \n                lits.push_back(is_pos?e:m.mk_not(e));                \n            }                \n        }\n    };\n\n\n    qe_solver_plugin* mk_arith_plugin(i_solver_context\u0026 ctx, bool produce_models, smt_params\u0026 p) {\n        if (p.m_nlquant_elim) {\n            return alloc(nlarith_plugin, ctx, ctx.get_manager(), produce_models);\n        }\n        else {\n            return alloc(arith_plugin, ctx, ctx.get_manager(), p);\n        }\n    }\n\n}\n"}
{"repo_name":"qtproject/qtwebkit","ref":"refs/heads/dev","path":"Source/WebCore/html/HTMLFrameSetElement.cpp","copies":"2","language":"C++","content":"/*\n * Copyright (C) 1999 Lars Knoll (knoll@kde.org)\n *           (C) 1999 Antti Koivisto (koivisto@kde.org)\n *           (C) 2000 Simon Hausmann (hausmann@kde.org)\n *           (C) 2001 Dirk Mueller (mueller@kde.org)\n * Copyright (C) 2004, 2006, 2009, 2010 Apple Inc. All rights reserved.\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Library General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Library General Public License for more details.\n *\n * You should have received a copy of the GNU Library General Public License\n * along with this library; see the file COPYING.LIB.  If not, write to\n * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n * Boston, MA 02110-1301, USA.\n */\n\n#include \"config.h\"\n#include \"HTMLFrameSetElement.h\"\n\n#include \"CSSPropertyNames.h\"\n#include \"Document.h\"\n#include \"ElementIterator.h\"\n#include \"Event.h\"\n#include \"EventNames.h\"\n#include \"Frame.h\"\n#include \"FrameLoader.h\"\n#include \"FrameLoaderClient.h\"\n#include \"HTMLBodyElement.h\"\n#include \"HTMLNames.h\"\n#include \"Length.h\"\n#include \"MouseEvent.h\"\n#include \"RenderFrameSet.h\"\n#include \"Text.h\"\n\nnamespace WebCore {\n\nusing namespace HTMLNames;\n\nHTMLFrameSetElement::HTMLFrameSetElement(const QualifiedName\u0026 tagName, Document\u0026 document)\n    : HTMLElement(tagName, document)\n    , m_totalRows(1)\n    , m_totalCols(1)\n    , m_border(6)\n    , m_borderSet(false)\n    , m_borderColorSet(false)\n    , m_frameborder(true)\n    , m_frameborderSet(false)\n    , m_noresize(false)\n{\n    ASSERT(hasTagName(framesetTag));\n    setHasCustomStyleResolveCallbacks();\n}\n\nRef\u003cHTMLFrameSetElement\u003e HTMLFrameSetElement::create(const QualifiedName\u0026 tagName, Document\u0026 document)\n{\n    return adoptRef(*new HTMLFrameSetElement(tagName, document));\n}\n\nbool HTMLFrameSetElement::isPresentationAttribute(const QualifiedName\u0026 name) const\n{\n    if (name == bordercolorAttr)\n        return true;\n    return HTMLElement::isPresentationAttribute(name);\n}\n\nvoid HTMLFrameSetElement::collectStyleForPresentationAttribute(const QualifiedName\u0026 name, const AtomicString\u0026 value, MutableStyleProperties\u0026 style)\n{\n    if (name == bordercolorAttr)\n        addHTMLColorToStyle(style, CSSPropertyBorderColor, value);\n    else\n        HTMLElement::collectStyleForPresentationAttribute(name, value, style);\n}\n\nvoid HTMLFrameSetElement::parseAttribute(const QualifiedName\u0026 name, const AtomicString\u0026 value)\n{\n    if (name == rowsAttr) {\n        // FIXME: What is the right thing to do when removing this attribute?\n        // Why not treat it the same way we treat setting it to the empty string?\n        if (!value.isNull()) {\n            m_rowLengths = newLengthArray(value.string(), m_totalRows);\n            // FIXME: Would be nice to optimize the case where m_rowLengths did not change.\n            setNeedsStyleRecalc();\n        }\n        return;\n    }\n\n    if (name == colsAttr) {\n        // FIXME: What is the right thing to do when removing this attribute?\n        // Why not treat it the same way we treat setting it to the empty string?\n        if (!value.isNull()) {\n            m_colLengths = newLengthArray(value.string(), m_totalCols);\n            // FIXME: Would be nice to optimize the case where m_colLengths did not change.\n            setNeedsStyleRecalc();\n        }\n        return;\n    }\n\n    if (name == frameborderAttr) {\n        if (!value.isNull()) {\n            if (equalLettersIgnoringASCIICase(value, \"no\") || value == \"0\") {\n                m_frameborder = false;\n                m_frameborderSet = true;\n            } else if (equalLettersIgnoringASCIICase(value, \"yes\") || value == \"1\") {\n                m_frameborderSet = true;\n            }\n        } else {\n            m_frameborder = false;\n            m_frameborderSet = false;\n        }\n        // FIXME: Do we need to trigger repainting?\n        return;\n    }\n\n    if (name == noresizeAttr) {\n        // FIXME: This should set m_noresize to false if the value is null.\n        m_noresize = true;\n        return;\n    }\n\n    if (name == borderAttr) {\n        if (!value.isNull()) {\n            m_border = value.toInt();\n            m_borderSet = true;\n        } else\n            m_borderSet = false;\n        // FIXME: Do we need to trigger repainting?\n        return;\n    }\n\n    if (name == bordercolorAttr) {\n        m_borderColorSet = !value.isEmpty();\n        // FIXME: Clearly wrong: This can overwrite the value inherited from the parent frameset.\n        // FIXME: Do we need to trigger repainting?\n        return;\n    }\n\n    auto\u0026 eventName = HTMLBodyElement::eventNameForWindowEventHandlerAttribute(name);\n    if (!eventName.isNull()) {\n        document().setWindowAttributeEventListener(eventName, name, value);\n        return;\n    }\n\n    HTMLElement::parseAttribute(name, value);\n}\n\nbool HTMLFrameSetElement::rendererIsNeeded(const RenderStyle\u0026 style)\n{\n    // For compatibility, frames render even when display: none is set.\n    // However, we delay creating a renderer until stylesheets have loaded. \n    return style.isStyleAvailable();\n}\n\nRenderPtr\u003cRenderElement\u003e HTMLFrameSetElement::createElementRenderer(Ref\u003cRenderStyle\u003e\u0026\u0026 style, const RenderTreePosition\u0026)\n{\n    if (style.get().hasContent())\n        return RenderElement::createFor(*this, WTFMove(style));\n    \n    return createRenderer\u003cRenderFrameSet\u003e(*this, WTFMove(style));\n}\n\nHTMLFrameSetElement* HTMLFrameSetElement::findContaining(Element* descendant)\n{\n    return ancestorsOfType\u003cHTMLFrameSetElement\u003e(*descendant).first();\n}\n\nvoid HTMLFrameSetElement::willAttachRenderers()\n{\n    // Inherit default settings from parent frameset.\n    // FIXME: This is not dynamic.\n    const HTMLFrameSetElement* containingFrameSet = findContaining(this);\n    if (!containingFrameSet)\n        return;\n    if (!m_frameborderSet)\n        m_frameborder = containingFrameSet-\u003ehasFrameBorder();\n    if (m_frameborder) {\n        if (!m_borderSet)\n            m_border = containingFrameSet-\u003eborder();\n        if (!m_borderColorSet)\n            m_borderColorSet = containingFrameSet-\u003ehasBorderColor();\n    }\n    if (!m_noresize)\n        m_noresize = containingFrameSet-\u003enoResize();\n}\n\nvoid HTMLFrameSetElement::defaultEventHandler(Event* event)\n{\n    ASSERT(event);\n    if (is\u003cMouseEvent\u003e(*event) \u0026\u0026 !m_noresize \u0026\u0026 is\u003cRenderFrameSet\u003e(renderer())) {\n        if (downcast\u003cRenderFrameSet\u003e(*renderer()).userResize(downcast\u003cMouseEvent\u003e(event))) {\n            event-\u003esetDefaultHandled();\n            return;\n        }\n    }\n    HTMLElement::defaultEventHandler(event);\n}\n\nbool HTMLFrameSetElement::willRecalcStyle(Style::Change)\n{\n    if (needsStyleRecalc() \u0026\u0026 renderer()) {\n        renderer()-\u003esetNeedsLayout();\n        clearNeedsStyleRecalc();\n    }\n    return true;\n}\n\nNode::InsertionNotificationRequest HTMLFrameSetElement::insertedInto(ContainerNode\u0026 insertionPoint)\n{\n    HTMLElement::insertedInto(insertionPoint);\n    if (insertionPoint.inDocument()) {\n        if (Frame* frame = document().frame())\n            frame-\u003eloader().client().dispatchDidBecomeFrameset(document().isFrameSet());\n    }\n\n    return InsertionDone;\n}\n\nvoid HTMLFrameSetElement::removedFrom(ContainerNode\u0026 insertionPoint)\n{\n    HTMLElement::removedFrom(insertionPoint);\n    if (insertionPoint.inDocument()) {\n        if (Frame* frame = document().frame())\n            frame-\u003eloader().client().dispatchDidBecomeFrameset(document().isFrameSet());\n    }\n}\n\n} // namespace WebCore\n"}
{"repo_name":"alejocb/rgbdtam","ref":"refs/heads/master","path":"ThirdParty/g2o/g2o/core/marginal_covariance_cholesky.cpp","copies":"18","language":"C++","content":"// g2o - General Graph Optimization\n// Copyright (C) 2011 R. Kuemmerle, G. Grisetti, W. Burgard\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n// * Redistributions of source code must retain the above copyright notice,\n//   this list of conditions and the following disclaimer.\n// * Redistributions in binary form must reproduce the above copyright\n//   notice, this list of conditions and the following disclaimer in the\n//   documentation and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n// IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\n// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\n// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n#include \"marginal_covariance_cholesky.h\"\n\n#include \u003calgorithm\u003e\n#include \u003ccassert\u003e\nusing namespace std;\n\nnamespace g2o {\n\nstruct MatrixElem\n{\n  int r, c;\n  MatrixElem(int r_, int c_) : r(r_), c(c_) {}\n  bool operator\u003c(const MatrixElem\u0026 other) const\n  {\n    return c \u003e other.c || (c == other.c \u0026\u0026 r \u003e other.r);\n  }\n};\n\nMarginalCovarianceCholesky::MarginalCovarianceCholesky() :\n  _n(0), _Ap(0), _Ai(0), _Ax(0), _perm(0)\n{\n}\n\nMarginalCovarianceCholesky::~MarginalCovarianceCholesky()\n{\n}\n\nvoid MarginalCovarianceCholesky::setCholeskyFactor(int n, int* Lp, int* Li, double* Lx, int* permInv)\n{\n  _n = n;\n  _Ap = Lp;\n  _Ai = Li;\n  _Ax = Lx;\n  _perm = permInv;\n\n  // pre-compute reciprocal values of the diagonal of L\n  _diag.resize(n);\n  for (int r = 0; r \u003c n; ++r) {\n    const int\u0026 sc = _Ap[r]; // L is lower triangular, thus the first elem in the column is the diagonal entry\n    assert(r == _Ai[sc] \u0026\u0026 \"Error in CCS storage of L\");\n    _diag[r] = 1.0 / _Ax[sc];\n  }\n}\n\ndouble MarginalCovarianceCholesky::computeEntry(int r, int c)\n{\n  assert(r \u003c= c);\n  int idx = computeIndex(r, c);\n\n  LookupMap::const_iterator foundIt = _map.find(idx);\n  if (foundIt != _map.end()) {\n    return foundIt-\u003esecond;\n  }\n\n  // compute the summation over column r\n  double s = 0.;\n  const int\u0026 sc = _Ap[r];\n  const int\u0026 ec = _Ap[r+1];\n  for (int j = sc+1; j \u003c ec; ++j) { // sum over row r while skipping the element on the diagonal\n    const int\u0026 rr = _Ai[j];\n    double val = rr \u003c c ? computeEntry(rr, c) : computeEntry(c, rr);\n    s += val * _Ax[j];\n  }\n\n  double result;\n  if (r == c) {\n    const double\u0026 diagElem = _diag[r];\n    result = diagElem * (diagElem - s);\n  } else {\n    result = -s * _diag[r];\n  }\n  _map[idx] = result;\n  return result;\n}\n\nvoid MarginalCovarianceCholesky::computeCovariance(double** covBlocks, const std::vector\u003cint\u003e\u0026 blockIndices)\n{\n  _map.clear();\n  int base = 0;\n  vector\u003cMatrixElem\u003e elemsToCompute;\n  for (size_t i = 0; i \u003c blockIndices.size(); ++i) {\n    int nbase = blockIndices[i];\n    int vdim = nbase - base;\n    for (int rr = 0; rr \u003c vdim; ++rr)\n      for (int cc = rr; cc \u003c vdim; ++cc) {\n        int r = _perm ? _perm[rr + base] : rr + base; // apply permutation\n        int c = _perm ? _perm[cc + base] : cc + base;\n        if (r \u003e c) // make sure it's still upper triangular after applying the permutation\n          swap(r, c);\n        elemsToCompute.push_back(MatrixElem(r, c));\n      }\n    base = nbase;\n  }\n\n  // sort the elems to reduce the recursive calls\n  sort(elemsToCompute.begin(), elemsToCompute.end());\n\n  // compute the inverse elements we need\n  for (size_t i = 0; i \u003c elemsToCompute.size(); ++i) {\n    const MatrixElem\u0026 me = elemsToCompute[i];\n    computeEntry(me.r, me.c);\n  }\n\n  // set the marginal covariance for the vertices, by writing to the blocks memory\n  base = 0;\n  for (size_t i = 0; i \u003c blockIndices.size(); ++i) {\n    int nbase = blockIndices[i];\n    int vdim = nbase - base;\n    double* cov = covBlocks[i];\n    for (int rr = 0; rr \u003c vdim; ++rr)\n      for (int cc = rr; cc \u003c vdim; ++cc) {\n        int r = _perm ? _perm[rr + base] : rr + base; // apply permutation\n        int c = _perm ? _perm[cc + base] : cc + base;\n        if (r \u003e c) // upper triangle\n          swap(r, c);\n        int idx = computeIndex(r, c);\n        LookupMap::const_iterator foundIt = _map.find(idx);\n        assert(foundIt != _map.end());\n        cov[rr*vdim + cc] = foundIt-\u003esecond;\n        if (rr != cc)\n          cov[cc*vdim + rr] = foundIt-\u003esecond;\n      }\n    base = nbase;\n  }\n}\n\n\nvoid MarginalCovarianceCholesky::computeCovariance(SparseBlockMatrix\u003cMatrixXd\u003e\u0026 spinv, const std::vector\u003cint\u003e\u0026 rowBlockIndices, const std::vector\u003c std::pair\u003cint, int\u003e \u003e\u0026 blockIndices)\n{\n  // allocate the sparse\n  spinv = SparseBlockMatrix\u003cMatrixXd\u003e(\u0026rowBlockIndices[0], \n              \u0026rowBlockIndices[0], \n              rowBlockIndices.size(),\n              rowBlockIndices.size(), true);\n  _map.clear();\n  vector\u003cMatrixElem\u003e elemsToCompute;\n  for (size_t i = 0; i \u003c blockIndices.size(); ++i) {\n    int blockRow=blockIndices[i].first;    \n    int blockCol=blockIndices[i].second;\n    assert(blockRow\u003e=0);\n    assert(blockRow \u003c (int)rowBlockIndices.size());\n    assert(blockCol\u003e=0);\n    assert(blockCol \u003c (int)rowBlockIndices.size());\n\n    int rowBase=spinv.rowBaseOfBlock(blockRow);\n    int colBase=spinv.colBaseOfBlock(blockCol);\n    \n    MatrixXd *block=spinv.block(blockRow, blockCol, true);\n    assert(block);\n    for (int iRow=0; iRow\u003cblock-\u003erows(); ++iRow)\n      for (int iCol=0; iCol\u003cblock-\u003ecols(); ++iCol){\n  int rr=rowBase+iRow;\n  int cc=colBase+iCol;\n        int r = _perm ? _perm[rr] : rr; // apply permutation\n        int c = _perm ? _perm[cc] : cc;\n        if (r \u003e c)\n          swap(r, c);\n        elemsToCompute.push_back(MatrixElem(r, c));\n      }\n  }\n\n  // sort the elems to reduce the number of recursive calls\n  sort(elemsToCompute.begin(), elemsToCompute.end());\n\n  // compute the inverse elements we need\n  for (size_t i = 0; i \u003c elemsToCompute.size(); ++i) {\n    const MatrixElem\u0026 me = elemsToCompute[i];\n    computeEntry(me.r, me.c);\n  }\n\n  // set the marginal covariance \n  for (size_t i = 0; i \u003c blockIndices.size(); ++i) {\n    int blockRow=blockIndices[i].first;    \n    int blockCol=blockIndices[i].second;\n    int rowBase=spinv.rowBaseOfBlock(blockRow);\n    int colBase=spinv.colBaseOfBlock(blockCol);\n    \n    MatrixXd *block=spinv.block(blockRow, blockCol);\n    assert(block);\n    for (int iRow=0; iRow\u003cblock-\u003erows(); ++iRow)\n      for (int iCol=0; iCol\u003cblock-\u003ecols(); ++iCol){\n  int rr=rowBase+iRow;\n  int cc=colBase+iCol;\n        int r = _perm ? _perm[rr] : rr; // apply permutation\n        int c = _perm ? _perm[cc] : cc;\n        if (r \u003e c)\n          swap(r, c);\n        int idx = computeIndex(r, c);\n        LookupMap::const_iterator foundIt = _map.find(idx);\n        assert(foundIt != _map.end());\n  (*block)(iRow, iCol) = foundIt-\u003esecond;\n      }\n  }\n}\n\n} // end namespace\n"}
{"repo_name":"SatoshiMabuchi/Crystal","ref":"refs/heads/master","path":"ThirdParty/glm-0.9.8.5/test/core/core_type_length.cpp","copies":"67","language":"C++","content":"#include \u003cglm/glm.hpp\u003e\n\nint test_length_mat_non_squared()\n{\n\tint Error = 0;\n\n\tError += glm::mat2x3().length() == 2 ? 0 : 1;\n\tError += glm::mat2x4().length() == 2 ? 0 : 1;\n\tError += glm::mat3x2().length() == 3 ? 0 : 1;\n\tError += glm::mat3x4().length() == 3 ? 0 : 1;\n\tError += glm::mat4x2().length() == 4 ? 0 : 1;\n\tError += glm::mat4x3().length() == 4 ? 0 : 1;\n\t\n\tError += glm::dmat2x3().length() == 2 ? 0 : 1;\n\tError += glm::dmat2x4().length() == 2 ? 0 : 1;\n\tError += glm::dmat3x2().length() == 3 ? 0 : 1;\n\tError += glm::dmat3x4().length() == 3 ? 0 : 1;\n\tError += glm::dmat4x2().length() == 4 ? 0 : 1;\n\tError += glm::dmat4x3().length() == 4 ? 0 : 1;\n\t\n\treturn Error;\n}\n\nint test_length_mat()\n{\n\tint Error = 0;\n\t\n\tError += glm::mat2().length() == 2 ? 0 : 1;\n\tError += glm::mat3().length() == 3 ? 0 : 1;\n\tError += glm::mat4().length() == 4 ? 0 : 1;\n\tError += glm::mat2x2().length() == 2 ? 0 : 1;\n\tError += glm::mat3x3().length() == 3 ? 0 : 1;\n\tError += glm::mat4x4().length() == 4 ? 0 : 1;\n\t\n\tError += glm::dmat2().length() == 2 ? 0 : 1;\n\tError += glm::dmat3().length() == 3 ? 0 : 1;\n\tError += glm::dmat4().length() == 4 ? 0 : 1;\n\tError += glm::dmat2x2().length() == 2 ? 0 : 1;\n\tError += glm::dmat3x3().length() == 3 ? 0 : 1;\n\tError += glm::dmat4x4().length() == 4 ? 0 : 1;\n\t\n\treturn Error;\n}\n\nint test_length_vec()\n{\n\n\tint Error = 0;\n\t\n\tError += glm::vec2().length() == 2 ? 0 : 1;\n\tError += glm::vec3().length() == 3 ? 0 : 1;\n\tError += glm::vec4().length() == 4 ? 0 : 1;\n\n\tError += glm::ivec2().length() == 2 ? 0 : 1;\n\tError += glm::ivec3().length() == 3 ? 0 : 1;\n\tError += glm::ivec4().length() == 4 ? 0 : 1;\n\n\tError += glm::uvec2().length() == 2 ? 0 : 1;\n\tError += glm::uvec3().length() == 3 ? 0 : 1;\n\tError += glm::uvec4().length() == 4 ? 0 : 1;\t\n\t\n\tError += glm::dvec2().length() == 2 ? 0 : 1;\n\tError += glm::dvec3().length() == 3 ? 0 : 1;\n\tError += glm::dvec4().length() == 4 ? 0 : 1;\n\t\n\treturn Error;\n}\n\nint main()\n{\n\tint Error = 0;\n\t\n\tError += test_length_vec();\n\tError += test_length_mat();\n\tError += test_length_mat_non_squared();\n\t\n\treturn Error;\n}\n\n"}
{"repo_name":"ericzhou2008/WinObjC","ref":"refs/heads/master","path":"deps/3rdparty/iculegacy/source/common/parsepos.cpp","copies":"443","language":"C++","content":"/*\n**********************************************************************\n*   Copyright (C) 2003-2003, International Business Machines\n*   Corporation and others.  All Rights Reserved.\n**********************************************************************\n*/\n\n#include \"unicode/parsepos.h\"\n\nU_NAMESPACE_BEGIN\n\nUOBJECT_DEFINE_RTTI_IMPLEMENTATION(ParsePosition)\n\nParsePosition::~ParsePosition() {}\n\nParsePosition *\nParsePosition::clone() const {\n    return new ParsePosition(*this);\n}\n\nU_NAMESPACE_END\n"}
{"repo_name":"ElvishArtisan/rivendell","ref":"refs/heads/master","path":"ripcd/btsrc8iii.cpp","copies":"2","language":"C++","content":"// btsrc8iii.cpp\n//\n// A Rivendell switcher driver for the BroadcastTools SRC-8 III\n//\n//   (C) Copyright 2002-2019 Fred Gleason \u003cfredg@paravelsystems.com\u003e\n//\n//   This program is free software; you can redistribute it and/or modify\n//   it under the terms of the GNU General Public License version 2 as\n//   published by the Free Software Foundation.\n//\n//   This program is distributed in the hope that it will be useful,\n//   but WITHOUT ANY WARRANTY; without even the implied warranty of\n//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//   GNU General Public License for more details.\n//\n//   You should have received a copy of the GNU General Public\n//   License along with this program; if not, write to the Free Software\n//   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n//\n\n#include \u003cstdlib.h\u003e\n\n#include \u003cqtimer.h\u003e\n\n#include \u003crdapplication.h\u003e\n\n#include \"btsrc8iii.h\"\n#include \"globals.h\"\n\nBtSrc8Iii::BtSrc8Iii(RDMatrix *matrix,QObject *parent)\n  : Switcher(matrix,parent)\n{\n  //\n  // Initialize Data Structures\n  //\n  bt_istate=0;\n  for(int i=0;i\u003cBTSRC8III_GPIO_PINS;i++) {\n    bt_gpi_state[i]=false;\n    bt_gpi_mask[i]=false;\n  }\n\n  //\n  // Get Matrix Parameters\n  //\n  bt_matrix=matrix-\u003ematrix();\n  bt_gpis=matrix-\u003egpis();\n  bt_gpos=matrix-\u003egpos();\n\n  //\n  // Initialize the TTY Port\n  //\n  RDTty *tty=new RDTty(rda-\u003estation()-\u003ename(),matrix-\u003eport(RDMatrix::Primary));\n  bt_device=new RDTTYDevice();\n  if(tty-\u003eactive()) {\n    bt_device-\u003esetName(tty-\u003eport());\n    bt_device-\u003esetSpeed(tty-\u003ebaudRate());\n    bt_device-\u003esetWordLength(tty-\u003edataBits());\n    bt_device-\u003esetParity(tty-\u003eparity());\n    bt_device-\u003eopen(QIODevice::Unbuffered|QIODevice::ReadWrite);\n  }\n  delete tty;\n\n  //\n  // Interval OneShots\n  //\n  bt_gpi_oneshot=new RDOneShot(this);\n  connect(bt_gpi_oneshot,SIGNAL(timeout(int)),this,SLOT(gpiOneshotData(int)));\n  bt_gpo_oneshot=new RDOneShot(this);\n  connect(bt_gpo_oneshot,SIGNAL(timeout(int)),this,SLOT(gpoOneshotData(int)));\n\n  //\n  // The Poll Timer\n  //\n  QTimer *timer=new QTimer(this,\"poll_timer\");\n  connect(timer,SIGNAL(timeout()),this,SLOT(processStatus()));\n  timer-\u003estart(BTSRC8III_POLL_INTERVAL);\n}\n\n\nBtSrc8Iii::~BtSrc8Iii()\n{\n  delete bt_device;\n  delete bt_gpi_oneshot;\n  delete bt_gpo_oneshot;\n}\n\n\nRDMatrix::Type BtSrc8Iii::type()\n{\n  return RDMatrix::BtSrc8III;\n}\n\n\nunsigned BtSrc8Iii::gpiQuantity()\n{\n  return bt_gpis;\n}\n\n\nunsigned BtSrc8Iii::gpoQuantity()\n{\n  return bt_gpos;\n}\n\n\nbool BtSrc8Iii::primaryTtyActive()\n{\n  return true;\n}\n\n\nbool BtSrc8Iii::secondaryTtyActive()\n{\n  return false;\n}\n\n\nvoid BtSrc8Iii::processCommand(RDMacro *cmd)\n{\n  char str[9];\n\n  switch(cmd-\u003ecommand()) {\n      case RDMacro::GO:\n\tif((cmd-\u003eargQuantity()!=5)||\n\t   ((cmd-\u003earg(1).lower()!=\"i\")\u0026\u0026\n\t    (cmd-\u003earg(1).lower()!=\"o\"))||\n\t   (cmd-\u003earg(2).toInt()\u003c1)||(cmd-\u003earg(3).toInt()\u003ebt_gpos)||\n\t   (cmd-\u003earg(2).toInt()\u003ebt_gpos)||\n\t   ((cmd-\u003earg(3).toInt()!=1)\u0026\u0026(cmd-\u003earg(3).toInt()!=0)\u0026\u0026\n\t    (cmd-\u003earg(1).lower()!=\"i\"))||\n\t   ((cmd-\u003earg(3).toInt()!=1)\u0026\u0026(cmd-\u003earg(3).toInt()!=0)\u0026\u0026\n\t    (cmd-\u003earg(3).toInt()!=-1)\u0026\u0026(cmd-\u003earg(1).lower()==\"i\"))||\n\t   (cmd-\u003earg(4).toInt()\u003c0)) {\n\t  cmd-\u003eacknowledge(false);\n\t  emit rmlEcho(cmd);\n\t  return;\n\t}\n\tif(cmd-\u003earg(3).toInt()==0) {  // Turn OFF\n\t  if(cmd-\u003earg(4).toInt()==0) {\n\t    if(cmd-\u003earg(1).lower()==\"i\") {\n\t      if(bt_gpi_state[cmd-\u003earg(2).toInt()-1]) {\n\t\temit gpiChanged(bt_matrix,cmd-\u003earg(2).toInt()-1,false);\n\t\tbt_gpi_state[cmd-\u003earg(2).toInt()-1]=false;\n\t      }\n\t      bt_gpi_mask[cmd-\u003earg(2).toInt()-1]=true;\n\t    }\n\t    if(cmd-\u003earg(1).lower()==\"o\") {\n\t      sprintf(str,\"*%dOR%dF\\r\\n\",BTSRC8III_UNIT_ID,cmd-\u003earg(2).toInt());\n\t      bt_device-\u003ewrite(str,8);\n\t      emit gpoChanged(bt_matrix,cmd-\u003earg(2).toInt()-1,false);\n\t    }\n\t  }\n\t  else {\n\t    if(cmd-\u003eechoRequested()) {\n\t      cmd-\u003eacknowledge(false);\n\t      emit rmlEcho(cmd);\n\t    }\n\t    return;\n\t  }\n\t}\n\telse {\n\t  if(cmd-\u003earg(3).toInt()==-1) {  // Clear input\n\t    bt_gpi_mask[cmd-\u003earg(2).toInt()-1]=false;\n\t    bt_device-\u003ewrite(\"*0SPA\\r\\n\",7);\n\t  }\n\t  else { \n\t    if(cmd-\u003earg(4).toInt()==0) {  // Turn ON\n\t      if(cmd-\u003earg(1).lower()==\"i\") {\n\t\tif(!bt_gpi_state[cmd-\u003earg(2).toInt()-1]) {\n\t\t  emit gpiChanged(bt_matrix,cmd-\u003earg(2).toInt()-1,true);\n\t\t  bt_gpi_state[cmd-\u003earg(2).toInt()-1]=true;\n\t\t}\n\t\tbt_gpi_mask[cmd-\u003earg(2).toInt()-1]=true;\n\t      }\n\t      if(cmd-\u003earg(1).lower()==\"o\") {\n\t\tsprintf(str,\"*%dOR%dL\\r\\n\",\n\t\t\tBTSRC8III_UNIT_ID,cmd-\u003earg(2).toInt());\n\t\tbt_device-\u003ewrite(str,8);\n\t\temit gpoChanged(bt_matrix,cmd-\u003earg(2).toInt()-1,true);\n\t      }\n\t    }\n\t    else {  // Pulse\n\t      if(cmd-\u003earg(1).lower()==\"i\") {\n\t\tif(!bt_gpi_state[cmd-\u003earg(2).toInt()-1]) {\n\t\t  emit gpiChanged(bt_matrix,cmd-\u003earg(2).toInt()-1,true);\n\t\t  bt_gpi_state[cmd-\u003earg(2).toInt()-1]=true;\n\t\t}\n\t\tbt_gpi_mask[cmd-\u003earg(2).toInt()-1]=true;\n\t\tbt_gpi_oneshot-\u003estart(cmd-\u003earg(2).toInt()-1,500);\n\t      }\n\t      if(cmd-\u003earg(1).lower()==\"o\") {\n\t\tsprintf(str,\"*%dOR%dP%02d\\r\\n\",\n\t\t\tBTSRC8III_UNIT_ID,cmd-\u003earg(2).toInt(),\n\t\t\tcmd-\u003earg(4).toInt()/100+1);\n\t\tbt_device-\u003ewrite(str,10);\n\t\temit gpoChanged(bt_matrix,cmd-\u003earg(2).toInt()-1,true);\n\t\tbt_gpo_oneshot-\u003estart(cmd-\u003earg(2).toInt()-1,500);\n\t      }\n\t    }\n\t  }\n\t}\n\tif(cmd-\u003eechoRequested()) {\n\t  cmd-\u003eacknowledge(true);\n\t  emit rmlEcho(cmd);\n\t}\n\tbreak;\n\n      default:\n\tcmd-\u003eacknowledge(false);\n\temit rmlEcho(cmd);\n\tbreak;\n  }\n}\n\n\nvoid BtSrc8Iii::processStatus()\n{\n  char buffer[256];\n  int n;\n  int gpi;\n\n  while((n=bt_device-\u003eread(buffer,255))\u003e0) {\n    for(int i=0;i\u003cn;i++) {\n      switch(bt_istate) {\n\t  case 0:\n\t    if(buffer[i]=='S') {\n\t      bt_istate=1;\n\t    }\n\t    break;\n\n\t  case 1:\n\t    if(buffer[i]==(BTSRC8III_UNIT_ID+'0')) {\n\t      bt_istate=2;\n\t    }\n\t    else {\n\t      bt_istate=0;\n\t    }\n\t    break;\n\n\t  case 2:\n\t    if(buffer[i]=='P') {\n\t      bt_istate=3;\n\t    }\n\t    else {\n\t      bt_istate=0;\n\t    }\n\t    break;\n\n\t  case 3:\n\t    if(buffer[i]==',') {\n\t      bt_istate=4;\n\t    }\n\t    else {\n\t      bt_istate=0;\n\t    }\n\t    break;\n\n\t  case 4:\n\t    if(buffer[i]=='A') {\n\t      bt_istate=5;\n\t    }\n\t    else {\n\t      bt_istate=0;\n\t    }\n\t    break;\n\n\t  case 5:\n\t  case 7:\n\t  case 9:\n\t  case 11:\n\t  case 13:\n\t  case 15:\n\t  case 17:\n\t  case 19:\n\t    if(buffer[i]==',') {\n\t      bt_istate++;\n\t    }\n\t    else {\n\t      bt_istate=0;\n\t    }\n\t    break;\n\n\t  case 6:\n\t  case 8:\n\t  case 10:\n\t  case 12:\n\t  case 14:\n\t  case 16:\n\t  case 18:\n\t  case 20:\n\t    if(buffer[i]=='0') {\n\t      gpi=(bt_istate-6)/2;\n\t      if(bt_gpi_state[gpi]\u0026\u0026(!bt_gpi_mask[gpi])) {\n\t\temit gpiChanged(bt_matrix,gpi,false);\n\t\tbt_gpi_state[gpi]=false;\n\t      }\n\t      bt_istate++;\n\t    }\n\t    if(buffer[i]=='1') {\n\t      gpi=(bt_istate-6)/2;\n\t      if((!bt_gpi_state[gpi])\u0026\u0026(!bt_gpi_mask[gpi])) {\n\t\temit gpiChanged(bt_matrix,gpi,true);\n\t\tbt_gpi_state[gpi]=true;\n\t      }\n\t      bt_istate++;\n\t    }\n\t    break;\n\n\t  default:\n\t    bt_istate=0;\n      }\n    }\n  }\n}\n\n\nvoid BtSrc8Iii::gpiOneshotData(int value)\n{\n  bt_gpi_mask[value]=false;\n  bt_device-\u003ewrite(\"*0SPA\",5);\n}\n\n\nvoid BtSrc8Iii::gpoOneshotData(int value)\n{\n  emit gpoChanged(bt_matrix,value,false);\n}\n"}
{"repo_name":"murraymeehan/marsyas","ref":"refs/heads/master","path":"src/otherlibs/ANN/kd_pr_search.cpp","copies":"78","language":"C++","content":"//----------------------------------------------------------------------\n// File:\t\t\tkd_pr_search.cpp\n// Programmer:\t\tSunil Arya and David Mount\n// Description:\t\tPriority search for kd-trees\n// Last modified:\t01/04/05 (Version 1.0)\n//----------------------------------------------------------------------\n// Copyright (c) 1997-2005 University of Maryland and Sunil Arya and\n// David Mount.  All Rights Reserved.\n// \n// This software and related documentation is part of the Approximate\n// Nearest Neighbor Library (ANN).  This software is provided under\n// the provisions of the Lesser GNU Public License (LGPL).  See the\n// file ../ReadMe.txt for further information.\n// \n// The University of Maryland (U.M.) and the authors make no\n// representations about the suitability or fitness of this software for\n// any purpose.  It is provided \"as is\" without express or implied\n// warranty.\n//----------------------------------------------------------------------\n// History:\n//\tRevision 0.1  03/04/98\n//\t\tInitial release\n//----------------------------------------------------------------------\n\n#include \"kd_pr_search.h\"\t\t\t\t// kd priority search declarations\n\n//----------------------------------------------------------------------\n//\tApproximate nearest neighbor searching by priority search.\n//\t\tThe kd-tree is searched for an approximate nearest neighbor.\n//\t\tThe point is returned through one of the arguments, and the\n//\t\tdistance returned is the SQUARED distance to this point.\n//\n//\t\tThe method used for searching the kd-tree is called priority\n//\t\tsearch.  (It is described in Arya and Mount, ``Algorithms for\n//\t\tfast vector quantization,'' Proc. of DCC '93: Data Compression\n//\t\tConference}, eds. J. A. Storer and M. Cohn, IEEE Press, 1993,\n//\t\t381--390.)\n//\n//\t\tThe cell of the kd-tree containing the query point is located,\n//\t\tand cells are visited in increasing order of distance from the\n//\t\tquery point.  This is done by placing each subtree which has\n//\t\tNOT been visited in a priority queue, according to the closest\n//\t\tdistance of the corresponding enclosing rectangle from the\n//\t\tquery point.  The search stops when the distance to the nearest\n//\t\tremaining rectangle exceeds the distance to the nearest point\n//\t\tseen by a factor of more than 1/(1+eps). (Implying that any\n//\t\tpoint found subsequently in the search cannot be closer by more\n//\t\tthan this factor.)\n//\n//\t\tThe main entry point is annkPriSearch() which sets things up and\n//\t\tthen call the recursive routine ann_pri_search().  This is a\n//\t\trecursive routine which performs the processing for one node in\n//\t\tthe kd-tree.  There are two versions of this virtual procedure,\n//\t\tone for splitting nodes and one for leaves. When a splitting node\n//\t\tis visited, we determine which child to continue the search on\n//\t\t(the closer one), and insert the other child into the priority\n//\t\tqueue.  When a leaf is visited, we compute the distances to the\n//\t\tpoints in the buckets, and update information on the closest\n//\t\tpoints.\n//\n//\t\tSome trickery is used to incrementally update the distance from\n//\t\ta kd-tree rectangle to the query point.  This comes about from\n//\t\tthe fact that which each successive split, only one component\n//\t\t(along the dimension that is split) of the squared distance to\n//\t\tthe child rectangle is different from the squared distance to\n//\t\tthe parent rectangle.\n//----------------------------------------------------------------------\n\n//----------------------------------------------------------------------\n//\t\tTo keep argument lists short, a number of global variables\n//\t\tare maintained which are common to all the recursive calls.\n//\t\tThese are given below.\n//----------------------------------------------------------------------\n\ndouble\t\t\tANNprEps;\t\t\t\t// the error bound\nint\t\t\t\tANNprDim;\t\t\t\t// dimension of space\nANNpoint\t\tANNprQ;\t\t\t\t\t// query point\ndouble\t\t\tANNprMaxErr;\t\t\t// max tolerable squared error\nANNpointArray\tANNprPts;\t\t\t\t// the points\nANNpr_queue\t\t*ANNprBoxPQ;\t\t\t// priority queue for boxes\nANNmin_k\t\t*ANNprPointMK;\t\t\t// set of k closest points\n\n//----------------------------------------------------------------------\n//\tannkPriSearch - priority search for k nearest neighbors\n//----------------------------------------------------------------------\n\nvoid ANNkd_tree::annkPriSearch(\n\tANNpoint\t\t\tq,\t\t\t\t// query point\n\tint\t\t\t\t\tk,\t\t\t\t// number of near neighbors to return\n\tANNidxArray\t\t\tnn_idx,\t\t\t// nearest neighbor indices (returned)\n\tANNdistArray\t\tdd,\t\t\t\t// dist to near neighbors (returned)\n\tdouble\t\t\t\teps)\t\t\t// error bound (ignored)\n{\n\t\t\t\t\t\t\t\t\t\t// max tolerable squared error\n\tANNprMaxErr = ANN_POW(1.0 + eps);\n\tANN_FLOP(2)\t\t\t\t\t\t\t// increment floating ops\n\n\tANNprDim = dim;\t\t\t\t\t\t// copy arguments to static equivs\n\tANNprQ = q;\n\tANNprPts = pts;\n\tANNptsVisited = 0;\t\t\t\t\t// initialize count of points visited\n\n\tANNprPointMK = new ANNmin_k(k);\t\t// create set for closest k points\n\n\t\t\t\t\t\t\t\t\t\t// distance to root box\n\tANNdist box_dist = annBoxDistance(q,\n\t\t\t\tbnd_box_lo, bnd_box_hi, dim);\n\n\tANNprBoxPQ = new ANNpr_queue(n_pts);// create priority queue for boxes\n\tANNprBoxPQ-\u003einsert(box_dist, root); // insert root in priority queue\n\n\twhile (ANNprBoxPQ-\u003enon_empty() \u0026\u0026\n\t\t(!(ANNmaxPtsVisited != 0 \u0026\u0026 ANNptsVisited \u003e ANNmaxPtsVisited))) {\n\t\tANNkd_ptr np;\t\t\t\t\t// next box from prior queue\n\n\t\t\t\t\t\t\t\t\t\t// extract closest box from queue\n\t\tANNprBoxPQ-\u003eextr_min(box_dist, (void *\u0026) np);\n\n\t\tANN_FLOP(2)\t\t\t\t\t\t// increment floating ops\n\t\tif (box_dist*ANNprMaxErr \u003e= ANNprPointMK-\u003emax_key())\n\t\t\tbreak;\n\n\t\tnp-\u003eann_pri_search(box_dist);\t// search this subtree.\n\t}\n\n\tfor (int i = 0; i \u003c k; i++) {\t\t// extract the k-th closest points\n\t\tdd[i] = ANNprPointMK-\u003eith_smallest_key(i);\n\t\tnn_idx[i] = ANNprPointMK-\u003eith_smallest_info(i);\n\t}\n\n\tdelete ANNprPointMK;\t\t\t\t// deallocate closest point set\n\tdelete ANNprBoxPQ;\t\t\t\t\t// deallocate priority queue\n}\n\n//----------------------------------------------------------------------\n//\tkd_split::ann_pri_search - search a splitting node\n//----------------------------------------------------------------------\n\nvoid ANNkd_split::ann_pri_search(ANNdist box_dist)\n{\n\tANNdist new_dist;\t\t\t\t\t// distance to child visited later\n\t\t\t\t\t\t\t\t\t\t// distance to cutting plane\n\tANNcoord cut_diff = ANNprQ[cut_dim] - cut_val;\n\n\tif (cut_diff \u003c 0) {\t\t\t\t\t// left of cutting plane\n\t\tANNcoord box_diff = cd_bnds[ANN_LO] - ANNprQ[cut_dim];\n\t\tif (box_diff \u003c 0)\t\t\t\t// within bounds - ignore\n\t\t\tbox_diff = 0;\n\t\t\t\t\t\t\t\t\t\t// distance to further box\n\t\tnew_dist = (ANNdist) ANN_SUM(box_dist,\n\t\t\t\tANN_DIFF(ANN_POW(box_diff), ANN_POW(cut_diff)));\n\n\t\tif (child[ANN_HI] != KD_TRIVIAL)// enqueue if not trivial\n\t\t\tANNprBoxPQ-\u003einsert(new_dist, child[ANN_HI]);\n\t\t\t\t\t\t\t\t\t\t// continue with closer child\n\t\tchild[ANN_LO]-\u003eann_pri_search(box_dist);\n\t}\n\telse {\t\t\t\t\t\t\t\t// right of cutting plane\n\t\tANNcoord box_diff = ANNprQ[cut_dim] - cd_bnds[ANN_HI];\n\t\tif (box_diff \u003c 0)\t\t\t\t// within bounds - ignore\n\t\t\tbox_diff = 0;\n\t\t\t\t\t\t\t\t\t\t// distance to further box\n\t\tnew_dist = (ANNdist) ANN_SUM(box_dist,\n\t\t\t\tANN_DIFF(ANN_POW(box_diff), ANN_POW(cut_diff)));\n\n\t\tif (child[ANN_LO] != KD_TRIVIAL)// enqueue if not trivial\n\t\t\tANNprBoxPQ-\u003einsert(new_dist, child[ANN_LO]);\n\t\t\t\t\t\t\t\t\t\t// continue with closer child\n\t\tchild[ANN_HI]-\u003eann_pri_search(box_dist);\n\t}\n\tANN_SPL(1)\t\t\t\t\t\t\t// one more splitting node visited\n\tANN_FLOP(8)\t\t\t\t\t\t\t// increment floating ops\n}\n\n//----------------------------------------------------------------------\n//\tkd_leaf::ann_pri_search - search points in a leaf node\n//\n//\t\tThis is virtually identical to the ann_search for standard search.\n//----------------------------------------------------------------------\n\nvoid ANNkd_leaf::ann_pri_search(ANNdist box_dist)\n{\n\tregister ANNdist dist;\t\t\t\t// distance to data point\n\tregister ANNcoord* pp;\t\t\t\t// data coordinate pointer\n\tregister ANNcoord* qq;\t\t\t\t// query coordinate pointer\n\tregister ANNdist min_dist;\t\t\t// distance to k-th closest point\n\tregister ANNcoord t;\n\tregister int d;\n\n\tmin_dist = ANNprPointMK-\u003emax_key(); // k-th smallest distance so far\n\n\tfor (int i = 0; i \u003c n_pts; i++) {\t// check points in bucket\n\n\t\tpp = ANNprPts[bkt[i]];\t\t\t// first coord of next data point\n\t\tqq = ANNprQ;\t\t\t\t\t// first coord of query point\n\t\tdist = 0;\n\n\t\tfor(d = 0; d \u003c ANNprDim; d++) {\n\t\t\tANN_COORD(1)\t\t\t\t// one more coordinate hit\n\t\t\tANN_FLOP(4)\t\t\t\t\t// increment floating ops\n\n\t\t\tt = *(qq++) - *(pp++);\t\t// compute length and adv coordinate\n\t\t\t\t\t\t\t\t\t\t// exceeds dist to k-th smallest?\n\t\t\tif( (dist = ANN_SUM(dist, ANN_POW(t))) \u003e min_dist) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (d \u003e= ANNprDim \u0026\u0026\t\t\t\t\t// among the k best?\n\t\t   (ANN_ALLOW_SELF_MATCH || dist!=0)) { // and no self-match problem\n\t\t\t\t\t\t\t\t\t\t\t\t// add it to the list\n\t\t\tANNprPointMK-\u003einsert(dist, bkt[i]);\n\t\t\tmin_dist = ANNprPointMK-\u003emax_key();\n\t\t}\n\t}\n\tANN_LEAF(1)\t\t\t\t\t\t\t// one more leaf node visited\n\tANN_PTS(n_pts)\t\t\t\t\t\t// increment points visited\n\tANNptsVisited += n_pts;\t\t\t\t// increment number of points visited\n}\n"}
{"repo_name":"xdajog/samsung_sources_i927","ref":"refs/heads/SGH-I927_ATT","path":"external/webkit/Source/WebKit2/Shared/DictionaryPopupInfo.cpp","copies":"22","language":"C++","content":"/*\n * Copyright (C) 2011 Apple Inc. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS\n * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"config.h\"\n#include \"DictionaryPopupInfo.h\"\n\n#include \"WebCoreArgumentCoders.h\"\n\n#if PLATFORM(MAC)\n#include \"ArgumentCodersCF.h\"\n#endif\n\nnamespace WebKit {\n\nvoid DictionaryPopupInfo::encode(CoreIPC::ArgumentEncoder* encoder) const\n{\n    encoder-\u003eencode(origin);\n    encoder-\u003eencode(fontInfo);\n    encoder-\u003eencodeEnum(type);\n\n#if PLATFORM(MAC) \u0026\u0026 !defined(BUILDING_ON_SNOW_LEOPARD)\n    CoreIPC::encode(encoder, options.get());\n#endif\n}\n\nbool DictionaryPopupInfo::decode(CoreIPC::ArgumentDecoder* decoder, DictionaryPopupInfo\u0026 result)\n{\n    if (!decoder-\u003edecode(result.origin))\n        return false;\n    if (!decoder-\u003edecode(result.fontInfo))\n        return false;\n    if (!decoder-\u003edecodeEnum(result.type))\n        return false;\n#if PLATFORM(MAC) \u0026\u0026 !defined(BUILDING_ON_SNOW_LEOPARD)\n    if (!CoreIPC::decode(decoder, result.options))\n        return false;\n#endif\n    return true;\n}\n\n} // namespace WebKit\n"}
{"repo_name":"Shutok/OregonCustom","ref":"refs/heads/master","path":"dep/g3dlite/source/Color3.cpp","copies":"676","language":"C++","content":"/**\n @file Color3.cpp\n\n Color class.\n\n @author Morgan McGuire, http://graphics.cs.williams.edu\n\n @created 2001-06-02\n @edited  2010-01-28\n */\n\n#include \"G3D/platform.h\"\n#include \u003cstdlib.h\u003e\n#include \"G3D/Color3.h\"\n#include \"G3D/Vector3.h\"\n#include \"G3D/format.h\"\n#include \"G3D/BinaryInput.h\"\n#include \"G3D/BinaryOutput.h\"\n#include \"G3D/Color3uint8.h\"\n#include \"G3D/Any.h\"\n#include \"G3D/stringutils.h\"\n\nnamespace G3D {\n\nColor3::Color3(const Any\u0026 any) {\n    *this = Color3::zero();\n    any.verifyName(\"Color3\");\n    std::string name = toLower(any.name());\n\n    switch (any.type()) {\n    case Any::TABLE:\n\n        for (Any::AnyTable::Iterator it = any.table().begin(); it.hasMore(); ++it) {\n            const std::string\u0026 key = toLower(it-\u003ekey);\n            if (key == \"r\") {\n                r = it-\u003evalue;\n            } else if (key == \"g\") {\n                g = it-\u003evalue;\n            } else if (key == \"b\") {\n                b = it-\u003evalue;\n            } else {\n                any.verify(false, \"Illegal key: \" + it-\u003ekey);\n            }\n        }\n        break;\n\n    case Any::ARRAY:\n        if (name == \"color3\") {\n            any.verifySize(3);\n            r = any[0];\n            g = any[1];\n            b = any[2];\n        } else if (name == \"color3::one\") {\n            any.verifySize(0);\n            *this = one();\n        } else if (name == \"color3::zero\") {\n            any.verifySize(0);\n            *this = zero();\n        } else if (name == \"color3::fromargb\") {\n            *this = Color3::fromARGB((int)any[0].number());\n        } else {\n            any.verify(false, \"Expected Color3 constructor\");\n        }\n        break;\n\n    default:\n        any.verify(false, \"Bad Color3 constructor\");\n    }\n}\n   \n\nColor3::operator Any() const {\n    Any a(Any::ARRAY, \"Color3\");\n    a.append(r, g, b);\n    return a;\n}\n\n\nColor3 Color3::ansiMap(uint32 i) {\n    static const Color3 map[] = \n        {Color3::black(), Color3::red() * 0.75f, Color3::green() * 0.75f, Color3::yellow() * 0.75f, \n         Color3::blue() * 0.75f, Color3::purple() * 0.75f, Color3::cyan() * 0.75f, Color3::white() * 0.75f,\n         Color3::white() * 0.90f, Color3::red(), Color3::green(), Color3::yellow(), Color3::blue(), \n         Color3::purple(), Color3::cyan(), Color3::white()};\n\n    return map[i \u0026 15];\n}\n\n\nColor3 Color3::pastelMap(uint32 i) {\n    uint32 x = Crypto::crc32(\u0026i, sizeof(uint32));\n    // Create fairly bright, saturated colors\n    Vector3 v(((x \u003e\u003e 22) \u0026 1023) / 1023.0f,\n              (((x \u003e\u003e 11) \u0026 2047) / 2047.0f) * 0.5f + 0.25f, \n              ((x \u0026 2047) / 2047.0f) * 0.75f + 0.25f);\n    return Color3::fromHSV(v);\n}\n\n\nconst Color3\u0026 Color3::red() {\n    static Color3 c(1.0f, 0.0f, 0.0f);\n    return c;\n}\n\n\nconst Color3\u0026 Color3::green() {\n    static Color3 c(0.0f, 1.0f, 0.0f);\n    return c;\n}\n\n\nconst Color3\u0026 Color3::blue() {\n    static Color3 c(0.0f, 0.0f, 1.0f);\n    return c;\n}\n\n\nconst Color3\u0026 Color3::purple() {\n    static Color3 c(0.7f, 0.0f, 1.0f);\n    return c;\n}\n\n\nconst Color3\u0026 Color3::cyan() {\n    static Color3 c(0.0f, 0.7f, 1.0f);\n    return c;\n}\n\n\nconst Color3\u0026 Color3::yellow() {\n    static Color3 c(1.0f, 1.0f, 0.0f);\n    return c;\n}\n\n\nconst Color3\u0026 Color3::brown() {\n    static Color3 c(0.5f, 0.5f, 0.0f);\n    return c;\n}\n\n\nconst Color3\u0026 Color3::orange() {\n    static Color3 c(1.0f, 0.5f, 0.0f);\n    return c;\n}\n\n\nconst Color3\u0026 Color3::black() {\n    static Color3 c(0.0f, 0.0f, 0.0f);\n    return c;\n}\n\nconst Color3\u0026 Color3::zero() {\n    static Color3 c(0.0f, 0.0f, 0.0f);\n    return c;\n}\n\n\nconst Color3\u0026 Color3::one() {\n    static Color3 c(1.0f, 1.0f, 1.0f);\n    return c;\n}\n\n\nconst Color3\u0026 Color3::gray() {\n    static Color3 c(0.7f, 0.7f, 0.7f);\n    return c;\n}\n\n\nconst Color3\u0026 Color3::white() {\n    static Color3 c(1, 1, 1);\n    return c;\n}\n\n\nbool Color3::isFinite() const {\n    return G3D::isFinite(r) \u0026\u0026 G3D::isFinite(g) \u0026\u0026 G3D::isFinite(b);\n}\n\n\nColor3::Color3(BinaryInput\u0026 bi) {\n    deserialize(bi);\n}\n\n\nvoid Color3::deserialize(BinaryInput\u0026 bi) {\n    r = bi.readFloat32();\n    g = bi.readFloat32();\n    b = bi.readFloat32();\n}\n\n\nvoid Color3::serialize(BinaryOutput\u0026 bo) const {\n    bo.writeFloat32(r);\n    bo.writeFloat32(g);\n    bo.writeFloat32(b);\n}\n\n\nconst Color3\u0026 Color3::wheelRandom() {\n    static const Color3 colorArray[8] =\n    {Color3::blue(),   Color3::red(),    Color3::green(),\n     Color3::orange(), Color3::yellow(), \n     Color3::cyan(),   Color3::purple(), Color3::brown()};\n\n    return colorArray[iRandom(0, 7)];\n}\n\n\nsize_t Color3::hashCode() const {\n    unsigned int rhash = (*(int*)(void*)(\u0026r));\n    unsigned int ghash = (*(int*)(void*)(\u0026g));\n    unsigned int bhash = (*(int*)(void*)(\u0026b));\n\n    return rhash + (ghash * 37) + (bhash * 101);\n}\n\n\nColor3::Color3(const Vector3\u0026 v) {\n    r = v.x;\n    g = v.y;\n    b = v.z;\n}\n\n\nColor3::Color3(const class Color3uint8\u0026 other) {\n    r = other.r / 255.0f;\n    g = other.g / 255.0f;\n    b = other.b / 255.0f;\n}\n\n\nColor3 Color3::fromARGB(uint32 x) {\n    return Color3((float)((x \u003e\u003e 16) \u0026 0xFF), (float)((x \u003e\u003e 8) \u0026 0xFF), (float)(x \u0026 0xFF)) / 255.0f;\n}\n\n//----------------------------------------------------------------------------\n\n\nColor3 Color3::random() {\n    return Color3(uniformRandom(), \n                  uniformRandom(),\n                  uniformRandom()).direction();\n}\n\n//----------------------------------------------------------------------------\nColor3\u0026 Color3::operator/= (float fScalar) {\n    if (fScalar != 0.0f) {\n\t\tfloat fInvScalar = 1.0f / fScalar;\n        r *= fInvScalar;\n        g *= fInvScalar;\n        b *= fInvScalar;\n    } else {\n        r = (float)G3D::finf();\n        g = (float)G3D::finf();\n        b = (float)G3D::finf();\n    }\n\n    return *this;\n}\n\n//----------------------------------------------------------------------------\nfloat Color3::unitize (float fTolerance) {\n\tfloat fLength = length();\n\n    if ( fLength \u003e fTolerance ) {\n\t\tfloat fInvLength = 1.0f / fLength;\n        r *= fInvLength;\n        g *= fInvLength;\n        b *= fInvLength;\n    } else {\n        fLength = 0.0f;\n    }\n\n    return fLength;\n}\n\n//----------------------------------------------------------------------------\nColor3 Color3::fromHSV(const Vector3\u0026 _hsv) {\n    debugAssertM((_hsv.x \u003c= 1.0f \u0026\u0026 _hsv.x \u003e= 0.0f)\n                 \u0026\u0026 (_hsv.y \u003c= 1.0f \u0026\u0026 _hsv.y \u003e= 0.0f) \n                 \u0026\u0026 ( _hsv.z \u003c= 1.0f \u0026\u0026 _hsv.z \u003e= 0.0f), \"H,S,V must be between [0,1]\");\n    const int i = iMin(5, G3D::iFloor(6.0 * _hsv.x));\n    const float f = 6.0f * _hsv.x - i;\n    const float m = _hsv.z * (1.0f - (_hsv.y));\n    const float n = _hsv.z * (1.0f - (_hsv.y * f));\n    const float k = _hsv.z * (1.0f - (_hsv.y * (1 - f)));\n    switch(i) {\n    case 0:\n        return Color3(_hsv.z, k, m);\n        \n    case 1:\n        return Color3(n, _hsv.z, m);\n        \n    case 2:\n        return Color3(m, _hsv.z, k);\n        \n    case 3:\n        return Color3(m, n, _hsv.z);\n        \n    case 4:\n        return Color3(k, m, _hsv.z);\n        \n    case 5:\n        return Color3(_hsv.z, m, n);\n        \n    default:\n        debugAssertM(false, \"fell through switch..\");\n    }\n    return Color3::black();\n}\n\n\nVector3 Color3::toHSV(const Color3\u0026 _rgb) {\n\tdebugAssertM((_rgb.r \u003c= 1.0f \u0026\u0026 _rgb.r \u003e= 0.0f) \n\t\t\t\u0026\u0026 (_rgb.g \u003c= 1.0f \u0026\u0026 _rgb.g \u003e= 0.0f)\n\t\t\t\u0026\u0026 (_rgb.b \u003c= 1.0f \u0026\u0026 _rgb.b \u003e= 0.0f), \"R,G,B must be between [0,1]\");\n\tVector3 hsv = Vector3::zero();\n\thsv.z = G3D::max(G3D::max(_rgb.r, _rgb.g), _rgb.b);\n\tif (G3D::fuzzyEq(hsv.z, 0.0f)) {\n\t\treturn hsv;\n\t}\n\t\n    const float x =  G3D::min(G3D::min(_rgb.r, _rgb.g), _rgb.b);\n\thsv.y = (hsv.z - x) / hsv.z; \n\n    if (G3D::fuzzyEq(hsv.y, 0.0f)) {\n\t\treturn hsv;\n\t}\n\n\tVector3 rgbN;\n\trgbN.x = (hsv.z - _rgb.r) / (hsv.z - x);\n\trgbN.y = (hsv.z - _rgb.g) / (hsv.z - x);\n\trgbN.z = (hsv.z - _rgb.b) / (hsv.z - x);\n\n\tif (_rgb.r == hsv.z) {  // note from the max we know that it exactly equals one of the three.\n\t\thsv.x = (_rgb.g == x)? 5.0f + rgbN.z : 1.0f - rgbN.y;\n\t} else if (_rgb.g == hsv.z) {\n\t\thsv.x = (_rgb.b == x)? 1.0f + rgbN.x : 3.0f - rgbN.z;\n\t} else {\n\t\thsv.x = (_rgb.r == x)? 3.0f + rgbN.y : 5.0f - rgbN.x;\n\t}\n\t\n    hsv.x /= 6.0f;\n\n\treturn hsv;\n}\n\nColor3 Color3::jetColorMap(const float\u0026 val) {\n\tdebugAssertM(val \u003c= 1.0f \u0026\u0026 val \u003e= 0.0f , \"value should be in [0,1]\");\n\n\t//truncated triangles where sides have slope 4\n\tColor3 jet;\n\n\tjet.r = G3D::min(4.0f * val - 1.5f,-4.0f * val + 4.5f) ;\n\tjet.g = G3D::min(4.0f * val - 0.5f,-4.0f * val + 3.5f) ;\n\tjet.b = G3D::min(4.0f * val + 0.5f,-4.0f * val + 2.5f) ;\n\n\n\tjet.r = G3D::clamp(jet.r, 0.0f, 1.0f);\n\tjet.g = G3D::clamp(jet.g, 0.0f, 1.0f);\n\tjet.b = G3D::clamp(jet.b, 0.0f, 1.0f);\n\n\treturn jet;\n}\n\n\n\n\n\nstd::string Color3::toString() const {\n    return G3D::format(\"(%g, %g, %g)\", r, g, b);\n}\n\n//----------------------------------------------------------------------------\n\nColor3 Color3::rainbowColorMap(float hue) {\n    return fromHSV(Vector3(hue, 1.0f, 1.0f));\n}\n\n\n}; // namespace\n\n"}
{"repo_name":"dgrat/ANNetGPGPU","ref":"refs/heads/next","path":"examples/designer/ANNetDesigner.cpp","copies":"2","language":"C++","content":"#include \u003cQApplication\u003e\n#include \"gui/QMainWindow.h\"\n\n\nint main(int argc, char *argv[])\n{\n    QApplication a(argc, argv);\n    MainWindow w;\n\n    w.show();\n    \n    return a.exec();\n}\n"}
{"repo_name":"victorzhao/miniblink49","ref":"refs/heads/master","path":"third_party/WebKit/Source/core/html/HTMLContentElement.cpp","copies":"12","language":"C++","content":"/*\n * Copyright (C) 2011 Google Inc. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Neither the name of Google Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"config.h\"\n#include \"core/html/HTMLContentElement.h\"\n\n#include \"core/HTMLNames.h\"\n#include \"core/css/SelectorChecker.h\"\n#include \"core/css/parser/CSSParser.h\"\n#include \"core/dom/QualifiedName.h\"\n#include \"core/dom/shadow/ElementShadow.h\"\n#include \"core/dom/shadow/ShadowRoot.h\"\n#include \"platform/RuntimeEnabledFeatures.h\"\n\nnamespace blink {\n\nusing namespace HTMLNames;\n\nPassRefPtrWillBeRawPtr\u003cHTMLContentElement\u003e HTMLContentElement::create(Document\u0026 document, PassOwnPtrWillBeRawPtr\u003cHTMLContentSelectFilter\u003e filter)\n{\n    return adoptRefWillBeNoop(new HTMLContentElement(document, filter));\n}\n\ninline HTMLContentElement::HTMLContentElement(Document\u0026 document, PassOwnPtrWillBeRawPtr\u003cHTMLContentSelectFilter\u003e filter)\n    : InsertionPoint(contentTag, document)\n    , m_shouldParseSelect(false)\n    , m_isValidSelector(true)\n    , m_filter(filter)\n{\n}\n\nHTMLContentElement::~HTMLContentElement()\n{\n}\n\nDEFINE_TRACE(HTMLContentElement)\n{\n    visitor-\u003etrace(m_filter);\n    InsertionPoint::trace(visitor);\n}\n\nvoid HTMLContentElement::parseSelect()\n{\n    ASSERT(m_shouldParseSelect);\n\n    CSSParser::parseSelector(CSSParserContext(document(), 0), m_select, m_selectorList);\n    m_shouldParseSelect = false;\n    m_isValidSelector = validateSelect();\n    if (!m_isValidSelector) {\n        CSSSelectorList emptyList;\n        m_selectorList.adopt(emptyList);\n    }\n}\n\nvoid HTMLContentElement::parseAttribute(const QualifiedName\u0026 name, const AtomicString\u0026 value)\n{\n    if (name == selectAttr) {\n        if (ShadowRoot* root = containingShadowRoot())\n            root-\u003eowner()-\u003ewillAffectSelector();\n        m_shouldParseSelect = true;\n        m_select = value;\n    } else {\n        InsertionPoint::parseAttribute(name, value);\n    }\n}\n\nstatic inline bool includesDisallowedPseudoClass(const CSSSelector\u0026 selector)\n{\n    if (selector.pseudoType() == CSSSelector::PseudoNot) {\n        const CSSSelector* subSelector = selector.selectorList()-\u003efirst();\n        return subSelector-\u003ematch() == CSSSelector::PseudoClass;\n    }\n    return selector.match() == CSSSelector::PseudoClass;\n}\n\nbool HTMLContentElement::validateSelect() const\n{\n    ASSERT(!m_shouldParseSelect);\n\n    if (m_select.isNull() || m_select.isEmpty())\n        return true;\n\n    if (!m_selectorList.isValid())\n        return false;\n\n    for (const CSSSelector* selector = m_selectorList.first(); selector; selector = m_selectorList.next(*selector)) {\n        if (!selector-\u003eisCompound())\n            return false;\n        for (const CSSSelector* subSelector = selector; subSelector; subSelector = subSelector-\u003etagHistory()) {\n            if (includesDisallowedPseudoClass(*subSelector))\n                return false;\n        }\n    }\n    return true;\n}\n\n// TODO(esprehn): element should really be const, but matching a selector is not\n// const for some SelectorCheckingModes (mainly ResolvingStyle) where it sets\n// dynamic restyle flags on elements.\nbool HTMLContentElement::matchSelector(Element\u0026 element) const\n{\n    SelectorChecker selectorChecker(SelectorChecker::QueryingRules);\n    SelectorChecker::SelectorCheckingContext context(\u0026element, SelectorChecker::VisitedMatchDisabled);\n    for (const CSSSelector* selector = selectorList().first(); selector; selector = CSSSelectorList::next(*selector)) {\n        context.selector = selector;\n        if (selectorChecker.match(context))\n            return true;\n    }\n    return false;\n}\n\n}\n"}
{"repo_name":"ichu501/WinObjC","ref":"refs/heads/master","path":"deps/3rdparty/icu/icu/source/test/intltest/tsmthred.cpp","copies":"166","language":"C++","content":"/********************************************************************\n * COPYRIGHT:\n * Copyright (c) 1999-2014, International Business Machines Corporation and\n * others. All Rights Reserved.\n ********************************************************************/\n\n#if defined(hpux)\n# ifndef _INCLUDE_POSIX_SOURCE\n#  define _INCLUDE_POSIX_SOURCE\n# endif\n#endif\n\n#include \"simplethread.h\"\n\n#include \"unicode/utypes.h\"\n#include \"unicode/ustring.h\"\n#include \"umutex.h\"\n#include \"cmemory.h\"\n#include \"cstring.h\"\n#include \"uparse.h\"\n#include \"unicode/localpointer.h\"\n#include \"unicode/resbund.h\"\n#include \"unicode/udata.h\"\n#include \"unicode/uloc.h\"\n#include \"unicode/locid.h\"\n#include \"putilimp.h\"\n#include \"intltest.h\"\n#include \"tsmthred.h\"\n#include \"unicode/ushape.h\"\n#include \"unicode/translit.h\"\n#include \"sharedobject.h\"\n#include \"unifiedcache.h\"\n#include \"uassert.h\"\n\n#if U_PLATFORM_USES_ONLY_WIN32_API\n    /* Prefer native Windows APIs even if POSIX is implemented (i.e., on Cygwin). */\n#   undef POSIX\n#elif U_PLATFORM_IMPLEMENTS_POSIX\n#   define POSIX\n#else\n#   undef POSIX\n#endif\n\n/* Needed by z/OS to get usleep */\n#if U_PLATFORM == U_PF_OS390\n#define __DOT1 1\n#define __UU\n#ifndef _XPG4_2\n#define _XPG4_2\n#endif\n#include \u003cunistd.h\u003e\n#endif\n#if defined(POSIX)\n\n#define HAVE_IMP\n\n#if (ICU_USE_THREADS == 1)\n#include \u003cpthread.h\u003e\n#endif\n\n#if defined(__hpux) \u0026\u0026 defined(HPUX_CMA)\n# if defined(read)  // read being defined as cma_read causes trouble with iostream::read\n#  undef read\n# endif\n#endif\n\n/* Define __EXTENSIONS__ for Solaris and old friends in strict mode. */\n#ifndef __EXTENSIONS__\n#define __EXTENSIONS__\n#endif\n\n#if U_PLATFORM == U_PF_OS390\n#include \u003csys/types.h\u003e\n#endif\n\n#if U_PLATFORM != U_PF_OS390\n#include \u003csignal.h\u003e\n#endif\n\n/* Define _XPG4_2 for Solaris and friends. */\n#ifndef _XPG4_2\n#define _XPG4_2\n#endif\n\n/* Define __USE_XOPEN_EXTENDED for Linux and glibc. */\n#ifndef __USE_XOPEN_EXTENDED\n#define __USE_XOPEN_EXTENDED\n#endif\n\n/* Define _INCLUDE_XOPEN_SOURCE_EXTENDED for HP/UX (11?). */\n#ifndef _INCLUDE_XOPEN_SOURCE_EXTENDED\n#define _INCLUDE_XOPEN_SOURCE_EXTENDED\n#endif\n\n#include \u003cunistd.h\u003e\n\n#endif\n/* HPUX */\n#ifdef sleep\n#undef sleep\n#endif\n\n#define TSMTHREAD_FAIL(msg) errln(\"%s at file %s, line %d\", msg, __FILE__, __LINE__)\n#define TSMTHREAD_ASSERT(expr) {if (!(expr)) {TSMTHREAD_FAIL(\"Fail\");}}\n\nMultithreadTest::MultithreadTest()\n{\n}\n\nMultithreadTest::~MultithreadTest()\n{\n}\n\n\n\n#if (ICU_USE_THREADS==0)\nvoid MultithreadTest::runIndexedTest( int32_t index, UBool exec,\n                const char* \u0026name, char* /*par*/ ) {\n  if (exec) logln(\"TestSuite MultithreadTest: \");\n\n  if(index == 0)\n      name = \"NO_THREADED_TESTS\";\n  else\n      name = \"\";\n\n  if(exec) { logln(\"MultithreadTest - test DISABLED.  ICU_USE_THREADS set to 0, check your configuration if this is a problem..\");\n  }\n}\n#else\n\n#include \u003cstdio.h\u003e\n#include \u003cstring.h\u003e\n#include \u003cctype.h\u003e    // tolower, toupper\n\n#include \"unicode/putil.h\"\n\n// for mthreadtest\n#include \"unicode/numfmt.h\"\n#include \"unicode/choicfmt.h\"\n#include \"unicode/msgfmt.h\"\n#include \"unicode/locid.h\"\n#include \"unicode/coll.h\"\n#include \"unicode/calendar.h\"\n#include \"ucaconf.h\"\n\nvoid SimpleThread::errorFunc() {\n    // *(char *)0 = 3;            // Force entry into a debugger via a crash;\n}\n\nvoid MultithreadTest::runIndexedTest( int32_t index, UBool exec,\n                const char* \u0026name, char* /*par*/ ) {\n    if (exec)\n        logln(\"TestSuite MultithreadTest: \");\n    switch (index) {\n    case 0:\n        name = \"TestThreads\";\n        if (exec)\n            TestThreads();\n        break;\n\n    case 1:\n        name = \"TestMutex\";\n        if (exec)\n            TestMutex();\n        break;\n\n    case 2:\n        name = \"TestThreadedIntl\";\n#if !UCONFIG_NO_FORMATTING\n        if (exec) {\n            TestThreadedIntl();\n        }\n#endif\n        break;\n\n    case 3:\n      name = \"TestCollators\";\n#if !UCONFIG_NO_COLLATION\n      if (exec) {\n            TestCollators();\n      }\n#endif /* #if !UCONFIG_NO_COLLATION */\n      break;\n\n    case 4:\n        name = \"TestString\";\n        if (exec) {\n            TestString();\n        }\n        break;\n\n    case 5:\n        name = \"TestArabicShapingThreads\";\n        if (exec) {\n            TestArabicShapingThreads();\n        }\n        break;\n\n    case 6:\n        name = \"TestAnyTranslit\";\n        if (exec) {\n            TestAnyTranslit();\n        }\n        break;\n\n    case 7:\n        name = \"TestConditionVariables\";\n        if (exec) {\n            TestConditionVariables();\n        }\n        break;\n    case 8:\n        name = \"TestUnifiedCache\";\n        if (exec) {\n            TestUnifiedCache();\n        }\n        break;\n    default:\n        name = \"\";\n        break; //needed to end loop\n    }\n}\n\n\n//-----------------------------------------------------------------------------------\n//\n//   TestThreads -- see if threads really work at all.\n//\n//   Set up N threads pointing at N chars. When they are started, they will\n//   each sleep 1 second and then set their chars. At the end we make sure they\n//   are all set.\n//\n//-----------------------------------------------------------------------------------\n#define THREADTEST_NRTHREADS 8\n#define ARABICSHAPE_THREADTEST 30\n\nclass TestThreadsThread : public SimpleThread\n{\npublic:\n    TestThreadsThread(char* whatToChange) { fWhatToChange = whatToChange; }\n    virtual void run() { SimpleThread::sleep(1000);\n                         Mutex m;\n                         *fWhatToChange = '*';\n    }\nprivate:\n    char *fWhatToChange;\n};\n//-----------------------------------------------------------------------------------\n//\n//   TestArabicShapeThreads -- see if calls to u_shapeArabic in many threads works successfully\n//\n//   Set up N threads pointing at N chars. When they are started, they will make calls to doTailTest which tests\n//   u_shapeArabic, if the calls are successful it will the set * chars.\n//   At the end we make sure all threads managed to run u_shapeArabic successfully.\n//   This is a unit test for ticket 9473\n//\n//-----------------------------------------------------------------------------------\nclass TestArabicShapeThreads : public SimpleThread\n{\npublic:\n    TestArabicShapeThreads(char* whatToChange) { fWhatToChange = whatToChange;}\n    virtual void run() {\n\t    if(doTailTest()==TRUE)\n\t\t\t*fWhatToChange = '*';\n    }\nprivate:\n    char *fWhatToChange;\n\t\n\tUBool doTailTest(void) {\n  static const UChar src[] = { 0x0020, 0x0633, 0 };\n  static const UChar dst_old[] = { 0xFEB1, 0x200B,0 };\n  static const UChar dst_new[] = { 0xFEB1, 0xFE73,0 };\n  UChar dst[3] = { 0x0000, 0x0000,0 };\n  int32_t length;\n  UErrorCode status;\n  IntlTest inteltst =  IntlTest();\n\n  status = U_ZERO_ERROR;\n  length = u_shapeArabic(src, -1, dst, UPRV_LENGTHOF(dst),\n                         U_SHAPE_LETTERS_SHAPE|U_SHAPE_SEEN_TWOCELL_NEAR, \u0026status);\n  if(U_FAILURE(status)) {\n\t   inteltst.errln(\"Fail: status %s\\n\", u_errorName(status));\n\treturn FALSE;\n  } else if(length!=2) {\n    inteltst.errln(\"Fail: len %d expected 3\\n\", length);\n\treturn FALSE;\n  } else if(u_strncmp(dst,dst_old,UPRV_LENGTHOF(dst))) {\n    inteltst.errln(\"Fail: got U+%04X U+%04X expected U+%04X U+%04X\\n\",\n            dst[0],dst[1],dst_old[0],dst_old[1]);\n\treturn FALSE;\n  }\n\n\n  //\"Trying new tail\n  status = U_ZERO_ERROR;\n  length = u_shapeArabic(src, -1, dst, UPRV_LENGTHOF(dst),\n                         U_SHAPE_LETTERS_SHAPE|U_SHAPE_SEEN_TWOCELL_NEAR|U_SHAPE_TAIL_NEW_UNICODE, \u0026status);\n  if(U_FAILURE(status)) {\n    inteltst.errln(\"Fail: status %s\\n\", u_errorName(status));\n\treturn FALSE;\n  } else if(length!=2) {\n    inteltst.errln(\"Fail: len %d expected 3\\n\", length);\n\treturn FALSE;\n  } else if(u_strncmp(dst,dst_new,UPRV_LENGTHOF(dst))) {\n    inteltst.errln(\"Fail: got U+%04X U+%04X expected U+%04X U+%04X\\n\",\n            dst[0],dst[1],dst_new[0],dst_new[1]);\n\treturn FALSE;\n  }\n\n\n  return TRUE;\n\n}\n\t\n\n};\n\nvoid MultithreadTest::TestThreads()\n{\n    char threadTestChars[THREADTEST_NRTHREADS + 1];\n    SimpleThread *threads[THREADTEST_NRTHREADS];\n    int32_t numThreadsStarted = 0;\n\n    int32_t i;\n    for(i=0;i\u003cTHREADTEST_NRTHREADS;i++)\n    {\n        threadTestChars[i] = ' ';\n        threads[i] = new TestThreadsThread(\u0026threadTestChars[i]);\n    }\n    threadTestChars[THREADTEST_NRTHREADS] = '\\0';\n\n    logln(\"-\u003e\" + UnicodeString(threadTestChars) + \"\u003c- Firing off threads.. \");\n    for(i=0;i\u003cTHREADTEST_NRTHREADS;i++)\n    {\n        if (threads[i]-\u003estart() != 0) {\n            errln(\"Error starting thread %d\", i);\n        }\n        else {\n            numThreadsStarted++;\n        }\n        SimpleThread::sleep(100);\n        logln(\" Subthread started.\");\n    }\n\n    logln(\"Waiting for threads to be set..\");\n    if (numThreadsStarted == 0) {\n        errln(\"No threads could be started for testing!\");\n        return;\n    }\n\n    int32_t patience = 40; // seconds to wait\n\n    while(patience--)\n    {\n        int32_t count = 0;\n        umtx_lock(NULL);\n        for(i=0;i\u003cTHREADTEST_NRTHREADS;i++)\n        {\n            if(threadTestChars[i] == '*')\n            {\n                count++;\n            }\n        }\n        umtx_unlock(NULL);\n\n        if(count == THREADTEST_NRTHREADS)\n        {\n            logln(\"-\u003e\" + UnicodeString(threadTestChars) + \"\u003c- Got all threads! cya\");\n            for(i=0;i\u003cTHREADTEST_NRTHREADS;i++)\n            {\n                delete threads[i];\n            }\n            return;\n        }\n\n        logln(\"-\u003e\" + UnicodeString(threadTestChars) + \"\u003c- Waiting..\");\n        SimpleThread::sleep(500);\n    }\n\n    errln(\"-\u003e\" + UnicodeString(threadTestChars) + \"\u003c- PATIENCE EXCEEDED!! Still missing some.\");\n    for(i=0;i\u003cTHREADTEST_NRTHREADS;i++)\n    {\n        delete threads[i];\n    }\n}\n\n\nvoid MultithreadTest::TestArabicShapingThreads()\n{\n    char threadTestChars[ARABICSHAPE_THREADTEST + 1];\n    SimpleThread *threads[ARABICSHAPE_THREADTEST];\n    int32_t numThreadsStarted = 0;\n\n    int32_t i;\n\n    for(i=0;i\u003cARABICSHAPE_THREADTEST;i++)\n    {\n        threadTestChars[i] = ' ';\n        threads[i] = new TestArabicShapeThreads(\u0026threadTestChars[i]);\n    }\n    threadTestChars[ARABICSHAPE_THREADTEST] = '\\0';\n\n    logln(\"-\u003e do TestArabicShapingThreads \u003c- Firing off threads.. \");\n    for(i=0;i\u003cARABICSHAPE_THREADTEST;i++)\n    {\n        if (threads[i]-\u003estart() != 0) {\n            errln(\"Error starting thread %d\", i);\n        }\n        else {\n            numThreadsStarted++;\n        }\n        //SimpleThread::sleep(100);\n        logln(\" Subthread started.\");\n    }\n\n    logln(\"Waiting for threads to be set..\");\n    if (numThreadsStarted == 0) {\n        errln(\"No threads could be started for testing!\");\n        return;\n    }\n\n    int32_t patience = 100; // seconds to wait\n\n    while(patience--)\n    {\n        int32_t count = 0;\n        umtx_lock(NULL);\n        for(i=0;i\u003cARABICSHAPE_THREADTEST;i++)\n        {\n            if(threadTestChars[i] == '*')\n            {\n                count++;\n            }\n        }\n        umtx_unlock(NULL);\n\n        if(count == ARABICSHAPE_THREADTEST)\n        {\n            logln(\"-\u003eTestArabicShapingThreads \u003c- Got all threads! cya\");\n            for(i=0;i\u003cARABICSHAPE_THREADTEST;i++)\n            {\n                delete threads[i];\n            }\n            return;\n        }\n\n        logln(\"-\u003e TestArabicShapingThreads \u003c- Waiting..\");\n        SimpleThread::sleep(500);\n    }\n\n    errln(\"-\u003e TestArabicShapingThreads \u003c- PATIENCE EXCEEDED!! Still missing some.\");\n    for(i=0;i\u003cARABICSHAPE_THREADTEST;i++)\n    {\n        delete threads[i];\n    }\n\t\n}\n\n\n//-----------------------------------------------------------------------\n//\n//  TestMutex  - a simple (non-stress) test to verify that ICU mutexes\n//               are actually mutexing.  Does not test the use of\n//               mutexes within ICU services, but rather that the\n//               platform's mutex support is at least superficially there.\n//\n//----------------------------------------------------------------------\nstatic UMutex    gTestMutexA = U_MUTEX_INITIALIZER;\nstatic UMutex    gTestMutexB = U_MUTEX_INITIALIZER;\n\nstatic int     gThreadsStarted = 0;\nstatic int     gThreadsInMiddle = 0;\nstatic int     gThreadsDone = 0;\n\nstatic const int TESTMUTEX_THREAD_COUNT = 4;\n\nstatic int safeIncr(int \u0026var, int amt) {\n    // Thread safe (using global mutex) increment of a variable.\n    // Return the updated value.\n    // Can also be used as a safe load of a variable by incrementing it by 0.\n    Mutex m;\n    var += amt;\n    return var;\n}\n\nclass TestMutexThread : public SimpleThread\n{\npublic:\n    virtual void run()\n    {\n        // This is the code that each of the spawned threads runs.\n        // All of the spawned threads bunch up together at each of the two mutexes\n        // because the main holds the mutexes until they do.\n        //\n        safeIncr(gThreadsStarted, 1);\n        umtx_lock(\u0026gTestMutexA);\n        umtx_unlock(\u0026gTestMutexA);\n        safeIncr(gThreadsInMiddle, 1);\n        umtx_lock(\u0026gTestMutexB);\n        umtx_unlock(\u0026gTestMutexB);\n        safeIncr(gThreadsDone, 1);\n    }\n};\n\nvoid MultithreadTest::TestMutex()\n{\n    // Start up the test threads.  They should all pile up waiting on\n    // gTestMutexA, which we (the main thread) hold until the test threads\n    //   all get there.\n    gThreadsStarted = 0;\n    gThreadsInMiddle = 0;\n    gThreadsDone = 0;\n    umtx_lock(\u0026gTestMutexA);\n    TestMutexThread  *threads[TESTMUTEX_THREAD_COUNT];\n    int i;\n    int32_t numThreadsStarted = 0;\n    for (i=0; i\u003cTESTMUTEX_THREAD_COUNT; i++) {\n        threads[i] = new TestMutexThread;\n        if (threads[i]-\u003estart() != 0) {\n            errln(\"Error starting thread %d\", i);\n        }\n        else {\n            numThreadsStarted++;\n        }\n    }\n    if (numThreadsStarted == 0) {\n        errln(\"No threads could be started for testing!\");\n        return;\n    }\n\n    int patience = 0;\n    while (safeIncr(gThreadsStarted, 0) != TESTMUTEX_THREAD_COUNT) {\n        if (patience++ \u003e 24) {\n            TSMTHREAD_FAIL(\"Patience Exceeded\");\n            return;\n        }\n        SimpleThread::sleep(500);\n    }\n    // None of the test threads should have advanced past the first mutex.\n    TSMTHREAD_ASSERT(gThreadsInMiddle==0);\n    TSMTHREAD_ASSERT(gThreadsDone==0);\n\n    //  All of the test threads have made it to the first mutex.\n    //  We (the main thread) now let them advance to the second mutex,\n    //   where they should all pile up again.\n    umtx_lock(\u0026gTestMutexB);\n    umtx_unlock(\u0026gTestMutexA);\n\n    patience = 0;\n    while (safeIncr(gThreadsInMiddle, 0) != TESTMUTEX_THREAD_COUNT) {\n        if (patience++ \u003e 24) {\n            TSMTHREAD_FAIL(\"Patience Exceeded\");\n            return;\n        }\n        SimpleThread::sleep(500);\n    }\n    TSMTHREAD_ASSERT(gThreadsDone==0);\n\n    //  All test threads made it to the second mutex.\n    //   Now let them proceed from there.  They will all terminate.\n    umtx_unlock(\u0026gTestMutexB);\n    patience = 0;\n    while (safeIncr(gThreadsDone, 0) != TESTMUTEX_THREAD_COUNT) {\n        if (patience++ \u003e 24) {\n            TSMTHREAD_FAIL(\"Patience Exceeded\");\n            return;\n        }\n        SimpleThread::sleep(500);\n    }\n\n    // All threads made it by both mutexes.\n\n    for (i=0; i\u003cTESTMUTEX_THREAD_COUNT; i++) {\n        delete threads[i];\n    }\n\n}\n\n\n//-------------------------------------------------------------------------------------------\n//\n// class ThreadWithStatus - a thread that we can check the status and error condition of\n//\n//-------------------------------------------------------------------------------------------\nclass ThreadWithStatus : public SimpleThread\n{\npublic:\n    UBool  getError() { return (fErrors \u003e 0); }\n    UBool  getError(UnicodeString\u0026 fillinError) { fillinError = fErrorString; return (fErrors \u003e 0); }\n    virtual ~ThreadWithStatus(){}\nprotected:\n    ThreadWithStatus() :  fErrors(0) {}\n    void error(const UnicodeString \u0026error) {\n        fErrors++; fErrorString = error;\n        SimpleThread::errorFunc();\n    }\n    void error() { error(\"An error occured.\"); }\nprivate:\n    int32_t fErrors;\n    UnicodeString fErrorString;\n};\n\n\n\n//-------------------------------------------------------------------------------------------\n//\n//   TestMultithreadedIntl.  Test ICU Formatting n a multi-threaded environment\n//\n//-------------------------------------------------------------------------------------------\n\n\n// * Show exactly where the string's differences lie.\nUnicodeString showDifference(const UnicodeString\u0026 expected, const UnicodeString\u0026 result)\n{\n    UnicodeString res;\n    res = expected + \"\u003cExpected\\n\";\n    if(expected.length() != result.length())\n        res += \" [ Different lengths ] \\n\";\n    else\n    {\n        for(int32_t i=0;i\u003cexpected.length();i++)\n        {\n            if(expected[i] == result[i])\n            {\n                res += \" \";\n            }\n            else\n            {\n                res += \"|\";\n            }\n        }\n        res += \"\u003cDifferences\";\n        res += \"\\n\";\n    }\n    res += result + \"\u003cResult\\n\";\n\n    return res;\n}\n\n\n\n\n//-------------------------------------------------------------------------------------------\n//\n//   FormatThreadTest - a thread that tests performing a number of numberformats.\n//\n//-------------------------------------------------------------------------------------------\n\nconst int kFormatThreadIterations = 100;  // # of iterations per thread\nconst int kFormatThreadThreads    = 10;  // # of threads to spawn\n\n#if !UCONFIG_NO_FORMATTING\n\n\n\nstruct FormatThreadTestData\n{\n    double number;\n    UnicodeString string;\n    FormatThreadTestData(double a, const UnicodeString\u0026 b) : number(a),string(b) {}\n} ;\n\n\n// \"Someone from {2} is receiving a #{0} error - {1}. Their telephone call is costing {3 number,currency}.\"\n\nstatic void formatErrorMessage(UErrorCode \u0026realStatus, const UnicodeString\u0026 pattern, const Locale\u0026 theLocale,\n                     UErrorCode inStatus0, /* statusString 1 */ const Locale \u0026inCountry2, double currency3, // these numbers are the message arguments.\n                     UnicodeString \u0026result)\n{\n    if(U_FAILURE(realStatus))\n        return; // you messed up\n\n    UnicodeString errString1(u_errorName(inStatus0));\n\n    UnicodeString countryName2;\n    inCountry2.getDisplayCountry(theLocale,countryName2);\n\n    Formattable myArgs[] = {\n        Formattable((int32_t)inStatus0),   // inStatus0      {0}\n        Formattable(errString1), // statusString1 {1}\n        Formattable(countryName2),  // inCountry2 {2}\n        Formattable(currency3)// currency3  {3,number,currency}\n    };\n\n    MessageFormat *fmt = new MessageFormat(\"MessageFormat's API is broken!!!!!!!!!!!\",realStatus);\n    fmt-\u003esetLocale(theLocale);\n    fmt-\u003eapplyPattern(pattern, realStatus);\n\n    if (U_FAILURE(realStatus)) {\n        delete fmt;\n        return;\n    }\n\n    FieldPosition ignore = 0;\n    fmt-\u003eformat(myArgs,4,result,ignore,realStatus);\n\n    delete fmt;\n}\n\n/**\n  * Shared formatters \u0026  data used by instances of ThreadSafeFormat.\n  * Exactly one instance of this class is created, and it is then shared concurrently\n  * by the multiple instances of ThreadSafeFormat.\n  */\nclass ThreadSafeFormatSharedData {\n  public:\n    ThreadSafeFormatSharedData(UErrorCode \u0026status);\n    ~ThreadSafeFormatSharedData();\n    LocalPointer\u003cNumberFormat\u003e  fFormat;\n    Formattable    fYDDThing;\n    Formattable    fBBDThing;\n    UnicodeString  fYDDStr;\n    UnicodeString  fBBDStr;\n};\n\nconst ThreadSafeFormatSharedData *gSharedData = NULL;\n\nThreadSafeFormatSharedData::ThreadSafeFormatSharedData(UErrorCode \u0026status) {\n    fFormat.adoptInstead(NumberFormat::createCurrencyInstance(Locale::getUS(), status));\n    static const UChar kYDD[] = { 0x59, 0x44, 0x44, 0x00 };\n    static const UChar kBBD[] = { 0x42, 0x42, 0x44, 0x00 };\n    fYDDThing.adoptObject(new CurrencyAmount(123.456, kYDD, status));\n    fBBDThing.adoptObject(new CurrencyAmount(987.654, kBBD, status));\n    if (U_FAILURE(status)) {\n        return;\n    }\n    fFormat-\u003eformat(fYDDThing, fYDDStr, NULL, status);\n    fFormat-\u003eformat(fBBDThing, fBBDStr, NULL, status);\n    gSharedData = this;\n}\n\nThreadSafeFormatSharedData::~ThreadSafeFormatSharedData() {\n    gSharedData = NULL;\n}\n\n/**\n * Class for thread-safe testing of format.\n *   Instances of this class appear as members of class FormatThreadTest.\n *   Multiple instances of FormatThreadTest coexist.\n *   ThreadSafeFormat::doStuff() is called concurrently to test the thread safety of\n *   various shared format operations.\n */\nclass ThreadSafeFormat {\npublic:\n  /* give a unique offset to each thread */\n  ThreadSafeFormat(UErrorCode \u0026status);\n  UBool doStuff(int32_t offset, UnicodeString \u0026appendErr, UErrorCode \u0026status) const;\nprivate:\n  LocalPointer\u003cNumberFormat\u003e fFormat; // formatter - en_US constructed currency\n};\n\n\nThreadSafeFormat::ThreadSafeFormat(UErrorCode \u0026status) {\n  fFormat.adoptInstead(NumberFormat::createCurrencyInstance(Locale::getUS(), status));\n}\n\nstatic const UChar kUSD[] = { 0x55, 0x53, 0x44, 0x00 };\n\nUBool ThreadSafeFormat::doStuff(int32_t offset, UnicodeString \u0026appendErr, UErrorCode \u0026status) const {\n  UBool okay = TRUE;\n\n  if(u_strcmp(fFormat-\u003egetCurrency(), kUSD)) {\n    appendErr.append(\"fFormat currency != \")\n      .append(kUSD)\n      .append(\", =\")\n      .append(fFormat-\u003egetCurrency())\n      .append(\"! \");\n    okay = FALSE;\n  }\n\n  if(u_strcmp(gSharedData-\u003efFormat-\u003egetCurrency(), kUSD)) {\n    appendErr.append(\"gFormat currency != \")\n      .append(kUSD)\n      .append(\", =\")\n      .append(gSharedData-\u003efFormat-\u003egetCurrency())\n      .append(\"! \");\n    okay = FALSE;\n  }\n  UnicodeString str;\n  const UnicodeString *o=NULL;\n  Formattable f;\n  const NumberFormat *nf = NULL; // only operate on it as const.\n  switch(offset%4) {\n  case 0:  f = gSharedData-\u003efYDDThing;  o = \u0026gSharedData-\u003efYDDStr;  nf = gSharedData-\u003efFormat.getAlias();  break;\n  case 1:  f = gSharedData-\u003efBBDThing;  o = \u0026gSharedData-\u003efBBDStr;  nf = gSharedData-\u003efFormat.getAlias();  break;\n  case 2:  f = gSharedData-\u003efYDDThing;  o = \u0026gSharedData-\u003efYDDStr;  nf = fFormat.getAlias();  break;\n  case 3:  f = gSharedData-\u003efBBDThing;  o = \u0026gSharedData-\u003efBBDStr;  nf = fFormat.getAlias();  break;\n  }\n  nf-\u003eformat(f, str, NULL, status);\n\n  if(*o != str) {\n    appendErr.append(showDifference(*o, str));\n    okay = FALSE;\n  }\n  return okay;\n}\n\nUBool U_CALLCONV isAcceptable(void *, const char *, const char *, const UDataInfo *) {\n    return TRUE;\n}\n\n//static UMTX debugMutex = NULL;\n//static UMTX gDebugMutex;\n\n\nclass FormatThreadTest : public ThreadWithStatus\n{\npublic:\n    int     fNum;\n    int     fTraceInfo;\n\n    LocalPointer\u003cThreadSafeFormat\u003e fTSF;\n\n    FormatThreadTest() // constructor is NOT multithread safe.\n        : ThreadWithStatus(),\n        fNum(0),\n        fTraceInfo(0),\n        fTSF(NULL),\n        fOffset(0)\n        // the locale to use\n    {\n        UErrorCode status = U_ZERO_ERROR;      // TODO: rearrange code to allow checking of status.\n        fTSF.adoptInstead(new ThreadSafeFormat(status));\n        static int32_t fgOffset = 0;\n        fgOffset += 3;\n        fOffset = fgOffset;\n    }\n\n\n    virtual void run()\n    {\n        fTraceInfo                     = 1;\n        LocalPointer\u003cNumberFormat\u003e percentFormatter;\n        UErrorCode status = U_ZERO_ERROR;\n\n#if 0\n        // debugging code,\n        for (int i=0; i\u003c4000; i++) {\n            status = U_ZERO_ERROR;\n            UDataMemory *data1 = udata_openChoice(0, \"res\", \"en_US\", isAcceptable, 0, \u0026status);\n            UDataMemory *data2 = udata_openChoice(0, \"res\", \"fr\", isAcceptable, 0, \u0026status);\n            udata_close(data1);\n            udata_close(data2);\n            if (U_FAILURE(status)) {\n                error(\"udata_openChoice failed.\\n\");\n                break;\n            }\n        }\n        return;\n#endif\n\n#if 0\n        // debugging code,\n        int m;\n        for (m=0; m\u003c4000; m++) {\n            status         = U_ZERO_ERROR;\n            UResourceBundle *res   = NULL;\n            const char *localeName = NULL;\n\n            Locale  loc = Locale::getEnglish();\n\n            localeName = loc.getName();\n            // localeName = \"en\";\n\n            // ResourceBundle bund = ResourceBundle(0, loc, status);\n            //umtx_lock(\u0026gDebugMutex);\n            res = ures_open(NULL, localeName, \u0026status);\n            //umtx_unlock(\u0026gDebugMutex);\n\n            //umtx_lock(\u0026gDebugMutex);\n            ures_close(res);\n            //umtx_unlock(\u0026gDebugMutex);\n\n            if (U_FAILURE(status)) {\n                error(\"Resource bundle construction failed.\\n\");\n                break;\n            }\n        }\n        return;\n#endif\n\n        // Keep this data here to avoid static initialization.\n        FormatThreadTestData kNumberFormatTestData[] =\n        {\n            FormatThreadTestData((double)5.0, UnicodeString(\"5\", \"\")),\n                FormatThreadTestData( 6.0, UnicodeString(\"6\", \"\")),\n                FormatThreadTestData( 20.0, UnicodeString(\"20\", \"\")),\n                FormatThreadTestData( 8.0, UnicodeString(\"8\", \"\")),\n                FormatThreadTestData( 8.3, UnicodeString(\"8.3\", \"\")),\n                FormatThreadTestData( 12345, UnicodeString(\"12,345\", \"\")),\n                FormatThreadTestData( 81890.23, UnicodeString(\"81,890.23\", \"\")),\n        };\n        int32_t kNumberFormatTestDataLength = UPRV_LENGTHOF(kNumberFormatTestData);\n\n        // Keep this data here to avoid static initialization.\n        FormatThreadTestData kPercentFormatTestData[] =\n        {\n            FormatThreadTestData((double)5.0, CharsToUnicodeString(\"500\\\\u00a0%\")),\n                FormatThreadTestData( 1.0, CharsToUnicodeString(\"100\\\\u00a0%\")),\n                FormatThreadTestData( 0.26, CharsToUnicodeString(\"26\\\\u00a0%\")),\n                FormatThreadTestData(\n                   16384.99, CharsToUnicodeString(\"1\\\\u00a0638\\\\u00a0499\\\\u00a0%\")), // U+00a0 = NBSP\n                FormatThreadTestData(\n                    81890.23, CharsToUnicodeString(\"8\\\\u00a0189\\\\u00a0023\\\\u00a0%\")),\n        };\n        int32_t kPercentFormatTestDataLength = UPRV_LENGTHOF(kPercentFormatTestData);\n        int32_t iteration;\n\n        status = U_ZERO_ERROR;\n        LocalPointer\u003cNumberFormat\u003e formatter(NumberFormat::createInstance(Locale::getEnglish(),status));\n        if(U_FAILURE(status)) {\n            error(\"Error on NumberFormat::createInstance().\");\n            goto cleanupAndReturn;\n        }\n\n        percentFormatter.adoptInstead(NumberFormat::createPercentInstance(Locale::getFrench(),status));\n        if(U_FAILURE(status))             {\n            error(\"Error on NumberFormat::createPercentInstance().\");\n            goto cleanupAndReturn;\n        }\n\n        for(iteration = 0;!getError() \u0026\u0026 iteration\u003ckFormatThreadIterations;iteration++)\n        {\n\n            int32_t whichLine = (iteration + fOffset)%kNumberFormatTestDataLength;\n\n            UnicodeString  output;\n\n            formatter-\u003eformat(kNumberFormatTestData[whichLine].number, output);\n\n            if(0 != output.compare(kNumberFormatTestData[whichLine].string)) {\n                error(\"format().. expected \" + kNumberFormatTestData[whichLine].string\n                        + \" got \" + output);\n                goto cleanupAndReturn;\n            }\n\n            // Now check percent.\n            output.remove();\n            whichLine = (iteration + fOffset)%kPercentFormatTestDataLength;\n\n            percentFormatter-\u003eformat(kPercentFormatTestData[whichLine].number, output);\n            if(0 != output.compare(kPercentFormatTestData[whichLine].string))\n            {\n                error(\"percent format().. \\n\" +\n                        showDifference(kPercentFormatTestData[whichLine].string,output));\n                goto cleanupAndReturn;\n            }\n\n            // Test message error\n            const int       kNumberOfMessageTests = 3;\n            UErrorCode      statusToCheck;\n            UnicodeString   patternToCheck;\n            Locale          messageLocale;\n            Locale          countryToCheck;\n            double          currencyToCheck;\n\n            UnicodeString   expected;\n\n            // load the cases.\n            switch((iteration+fOffset) % kNumberOfMessageTests)\n            {\n            default:\n            case 0:\n                statusToCheck=                      U_FILE_ACCESS_ERROR;\n                patternToCheck=        \"0:Someone from {2} is receiving a #{0}\"\n                                       \" error - {1}. Their telephone call is costing \"\n                                       \"{3,number,currency}.\"; // number,currency\n                messageLocale=                      Locale(\"en\",\"US\");\n                countryToCheck=                     Locale(\"\",\"HR\");\n                currencyToCheck=                    8192.77;\n                expected=  \"0:Someone from Croatia is receiving a #4 error - \"\n                            \"U_FILE_ACCESS_ERROR. Their telephone call is costing $8,192.77.\";\n                break;\n            case 1:\n                statusToCheck=                      U_INDEX_OUTOFBOUNDS_ERROR;\n                patternToCheck=                     \"1:A customer in {2} is receiving a #{0} error - {1}. \"\n                                                    \"Their telephone call is costing {3,number,currency}.\"; // number,currency\n                messageLocale=                      Locale(\"de\",\"DE@currency=DEM\");\n                countryToCheck=                     Locale(\"\",\"BF\");\n                currencyToCheck=                    2.32;\n                expected=                           CharsToUnicodeString(\n                                                    \"1:A customer in Burkina Faso is receiving a #8 error - U_INDEX_OUTOFBOUNDS_ERROR. \"\n                                                    \"Their telephone call is costing 2,32\\\\u00A0DM.\");\n                break;\n            case 2:\n                statusToCheck=                      U_MEMORY_ALLOCATION_ERROR;\n                patternToCheck=   \"2:user in {2} is receiving a #{0} error - {1}. \"\n                                  \"They insist they just spent {3,number,currency} \"\n                                  \"on memory.\"; // number,currency\n                messageLocale=                      Locale(\"de\",\"AT@currency=ATS\"); // Austrian German\n                countryToCheck=                     Locale(\"\",\"US\"); // hmm\n                currencyToCheck=                    40193.12;\n                expected=       CharsToUnicodeString(\n                            \"2:user in Vereinigte Staaten is receiving a #7 error\"\n                            \" - U_MEMORY_ALLOCATION_ERROR. They insist they just spent\"\n                            \" \\\\u00f6S\\\\u00A040.193,12 on memory.\");\n                break;\n            }\n\n            UnicodeString result;\n            UErrorCode status = U_ZERO_ERROR;\n            formatErrorMessage(status,patternToCheck,messageLocale,statusToCheck,\n                                countryToCheck,currencyToCheck,result);\n            if(U_FAILURE(status))\n            {\n                UnicodeString tmp(u_errorName(status));\n                error(\"Failure on message format, pattern=\" + patternToCheck +\n                        \", error = \" + tmp);\n                goto cleanupAndReturn;\n            }\n\n            if(result != expected)\n            {\n                error(\"PatternFormat: \\n\" + showDifference(expected,result));\n                goto cleanupAndReturn;\n            }\n            // test the Thread Safe Format\n            UnicodeString appendErr;\n            if(!fTSF-\u003edoStuff(fNum, appendErr, status)) {\n              error(appendErr);\n              goto cleanupAndReturn;\n            }\n        }   /*  end of for loop */\n\n\n\ncleanupAndReturn:\n        //  while (fNum == 4) {SimpleThread::sleep(10000);}   // Force a failure by preventing thread from finishing\n        fTraceInfo = 2;\n    }\n\nprivate:\n    int32_t fOffset; // where we are testing from.\n};\n\n// ** The actual test function.\n\nvoid MultithreadTest::TestThreadedIntl()\n{\n    int i;\n    UnicodeString theErr;\n    UBool   haveDisplayedInfo[kFormatThreadThreads];\n    static const int32_t PATIENCE_SECONDS = 45;\n\n    UErrorCode threadSafeErr = U_ZERO_ERROR;\n\n    ThreadSafeFormatSharedData sharedData(threadSafeErr);\n    assertSuccess(\"initializing ThreadSafeFormat\", threadSafeErr, TRUE);\n\n    //\n    //  Create and start the test threads\n    //\n    logln(\"Spawning: %d threads * %d iterations each.\",\n                kFormatThreadThreads, kFormatThreadIterations);\n    LocalArray\u003cFormatThreadTest\u003e tests(new FormatThreadTest[kFormatThreadThreads]);\n    for(int32_t j = 0; j \u003c kFormatThreadThreads; j++) {\n        tests[j].fNum = j;\n        int32_t threadStatus = tests[j].start();\n        if (threadStatus != 0) {\n            errln(\"System Error %d starting thread number %d.\", threadStatus, j);\n            SimpleThread::errorFunc();\n            return;\n        }\n        haveDisplayedInfo[j] = FALSE;\n    }\n\n\n    // Spin, waiting for the test threads to finish.\n    UBool   stillRunning;\n    UDate startTime, endTime;\n    startTime = Calendar::getNow();\n    double lastComplaint = 0;\n    do {\n        /*  Spin until the test threads  complete. */\n        stillRunning = FALSE;\n        endTime = Calendar::getNow();\n        double elapsedSeconds =  ((int32_t)(endTime - startTime)/U_MILLIS_PER_SECOND);\n        if (elapsedSeconds \u003e PATIENCE_SECONDS) {\n            errln(\"Patience exceeded. Test is taking too long.\");\n            return;\n        } else if((elapsedSeconds-lastComplaint) \u003e 2.0) {\n            infoln(\"%.1f seconds elapsed (still waiting..)\", elapsedSeconds);\n            lastComplaint = elapsedSeconds;\n        }\n        /*\n         The following sleep must be here because the *BSD operating systems\n         have a brain dead thread scheduler. They starve the child threads from\n         CPU time.\n        */\n        SimpleThread::sleep(1); // yield\n        for(i=0;i\u003ckFormatThreadThreads;i++) {\n            if (tests[i].isRunning()) {\n                stillRunning = TRUE;\n            } else if (haveDisplayedInfo[i] == FALSE) {\n                logln(\"Thread # %d is complete..\", i);\n                if(tests[i].getError(theErr)) {\n                    dataerrln(UnicodeString(\"#\") + i + \": \" + theErr);\n                    SimpleThread::errorFunc();\n                }\n                haveDisplayedInfo[i] = TRUE;\n            }\n        }\n    } while (stillRunning);\n\n    //\n    //  All threads have finished.\n    //\n    assertSuccess(\"finalizing ThreadSafeFormat\", threadSafeErr, TRUE);\n}\n#endif /* #if !UCONFIG_NO_FORMATTING */\n\n\n\n\n\n//-------------------------------------------------------------------------------------------\n//\n// Collation threading test\n//\n//-------------------------------------------------------------------------------------------\n#if !UCONFIG_NO_COLLATION\n\n#define kCollatorThreadThreads   10  // # of threads to spawn\n#define kCollatorThreadPatience kCollatorThreadThreads*30\n\nstruct Line {\n    UChar buff[25];\n    int32_t buflen;\n} ;\n\nstatic UBool\nskipLineBecauseOfBug(const UChar *s, int32_t length) {\n    // TODO: Fix ICU ticket #8052\n    if(length \u003e= 3 \u0026\u0026\n            (s[0] == 0xfb2 || s[0] == 0xfb3) \u0026\u0026\n            s[1] == 0x334 \u0026\u0026\n            (s[2] == 0xf73 || s[2] == 0xf75 || s[2] == 0xf81)) {\n        return TRUE;\n    }\n    return FALSE;\n}\n\nstatic UCollationResult\nnormalizeResult(int32_t result) {\n    return result\u003c0 ? UCOL_LESS : result==0 ? UCOL_EQUAL : UCOL_GREATER;\n}\n\nclass CollatorThreadTest : public ThreadWithStatus\n{\nprivate:\n    const Collator *coll;\n    const Line *lines;\n    int32_t noLines;\n    UBool isAtLeastUCA62;\npublic:\n    CollatorThreadTest()  : ThreadWithStatus(),\n        coll(NULL),\n        lines(NULL),\n        noLines(0),\n        isAtLeastUCA62(TRUE)\n    {\n    };\n    void setCollator(Collator *c, Line *l, int32_t nl, UBool atLeastUCA62)\n    {\n        coll = c;\n        lines = l;\n        noLines = nl;\n        isAtLeastUCA62 = atLeastUCA62;\n    }\n    virtual void run() {\n        uint8_t sk1[1024], sk2[1024];\n        uint8_t *oldSk = NULL, *newSk = sk1;\n        int32_t oldLen = 0;\n        int32_t prev = 0;\n        int32_t i = 0;\n\n        for(i = 0; i \u003c noLines; i++) {\n            if(lines[i].buflen == 0) { continue; }\n\n            if(skipLineBecauseOfBug(lines[i].buff, lines[i].buflen)) { continue; }\n\n            int32_t resLen = coll-\u003egetSortKey(lines[i].buff, lines[i].buflen, newSk, 1024);\n\n            if(oldSk != NULL) {\n                int32_t skres = strcmp((char *)oldSk, (char *)newSk);\n                int32_t cmpres = coll-\u003ecompare(lines[prev].buff, lines[prev].buflen, lines[i].buff, lines[i].buflen);\n                int32_t cmpres2 = coll-\u003ecompare(lines[i].buff, lines[i].buflen, lines[prev].buff, lines[prev].buflen);\n\n                if(cmpres != -cmpres2) {\n                    error(UnicodeString(\"Compare result not symmetrical on line \") + (i + 1));\n                    break;\n                }\n\n                if(cmpres != normalizeResult(skres)) {\n                    error(UnicodeString(\"Difference between coll-\u003ecompare and sortkey compare on line \") + (i + 1));\n                    break;\n                }\n\n                int32_t res = cmpres;\n                if(res == 0 \u0026\u0026 !isAtLeastUCA62) {\n                    // Up to UCA 6.1, the collation test files use a custom tie-breaker,\n                    // comparing the raw input strings.\n                    res = u_strcmpCodePointOrder(lines[prev].buff, lines[i].buff);\n                    // Starting with UCA 6.2, the collation test files use the standard UCA tie-breaker,\n                    // comparing the NFD versions of the input strings,\n                    // which we do via setting strength=identical.\n                }\n                if(res \u003e 0) {\n                    error(UnicodeString(\"Line is not greater or equal than previous line, for line \") + (i + 1));\n                    break;\n                }\n            }\n\n            oldSk = newSk;\n            oldLen = resLen;\n            (void)oldLen;   // Suppress set but not used warning.\n            prev = i;\n\n            newSk = (newSk == sk1)?sk2:sk1;\n        }\n    }\n};\n\nvoid MultithreadTest::TestCollators()\n{\n\n    UErrorCode status = U_ZERO_ERROR;\n    FILE *testFile = NULL;\n    char testDataPath[1024];\n    strcpy(testDataPath, IntlTest::getSourceTestData(status));\n    if (U_FAILURE(status)) {\n        errln(\"ERROR: could not open test data %s\", u_errorName(status));\n        return;\n    }\n    strcat(testDataPath, \"CollationTest_\");\n\n    const char* type = \"NON_IGNORABLE\";\n\n    const char *ext = \".txt\";\n    if(testFile) {\n        fclose(testFile);\n    }\n    char buffer[1024];\n    strcpy(buffer, testDataPath);\n    strcat(buffer, type);\n    size_t bufLen = strlen(buffer);\n\n    // we try to open 3 files:\n    // path/CollationTest_type.txt\n    // path/CollationTest_type_SHORT.txt\n    // path/CollationTest_type_STUB.txt\n    // we are going to test with the first one that we manage to open.\n\n    strcpy(buffer+bufLen, ext);\n\n    testFile = fopen(buffer, \"rb\");\n\n    if(testFile == 0) {\n        strcpy(buffer+bufLen, \"_SHORT\");\n        strcat(buffer, ext);\n        testFile = fopen(buffer, \"rb\");\n\n        if(testFile == 0) {\n            strcpy(buffer+bufLen, \"_STUB\");\n            strcat(buffer, ext);\n            testFile = fopen(buffer, \"rb\");\n\n            if (testFile == 0) {\n                *(buffer+bufLen) = 0;\n                dataerrln(\"could not open any of the conformance test files, tried opening base %s\", buffer);\n                return;\n            } else {\n                infoln(\n                    \"INFO: Working with the stub file.\\n\"\n                    \"If you need the full conformance test, please\\n\"\n                    \"download the appropriate data files from:\\n\"\n                    \"http://source.icu-project.org/repos/icu/tools/trunk/unicodetools/com/ibm/text/data/\");\n            }\n        }\n    }\n\n    LocalArray\u003cLine\u003e lines(new Line[200000]);\n    memset(lines.getAlias(), 0, sizeof(Line)*200000);\n    int32_t lineNum = 0;\n\n    UChar bufferU[1024];\n    uint32_t first = 0;\n\n    while (fgets(buffer, 1024, testFile) != NULL) {\n        if(*buffer == 0 || buffer[0] == '#') {\n            // Store empty and comment lines so that errors are reported\n            // for the real test file lines.\n            lines[lineNum].buflen = 0;\n            lines[lineNum].buff[0] = 0;\n        } else {\n            int32_t buflen = u_parseString(buffer, bufferU, 1024, \u0026first, \u0026status);\n            lines[lineNum].buflen = buflen;\n            u_memcpy(lines[lineNum].buff, bufferU, buflen);\n            lines[lineNum].buff[buflen] = 0;\n        }\n        lineNum++;\n    }\n    fclose(testFile);\n    if(U_FAILURE(status)) {\n      dataerrln(\"Couldn't read the test file!\");\n      return;\n    }\n\n    UVersionInfo uniVersion;\n    static const UVersionInfo v62 = { 6, 2, 0, 0 };\n    u_getUnicodeVersion(uniVersion);\n    UBool isAtLeastUCA62 = uprv_memcmp(uniVersion, v62, 4) \u003e= 0;\n\n    LocalPointer\u003cCollator\u003e coll(Collator::createInstance(Locale::getRoot(), status));\n    if(U_FAILURE(status)) {\n        errcheckln(status, \"Couldn't open UCA collator\");\n        return;\n    }\n    coll-\u003esetAttribute(UCOL_NORMALIZATION_MODE, UCOL_ON, status);\n    coll-\u003esetAttribute(UCOL_CASE_FIRST, UCOL_OFF, status);\n    coll-\u003esetAttribute(UCOL_CASE_LEVEL, UCOL_OFF, status);\n    coll-\u003esetAttribute(UCOL_STRENGTH, isAtLeastUCA62 ? UCOL_IDENTICAL : UCOL_TERTIARY, status);\n    coll-\u003esetAttribute(UCOL_ALTERNATE_HANDLING, UCOL_NON_IGNORABLE, status);\n\n    int32_t noSpawned = 0;\n    int32_t spawnResult = 0;\n    LocalArray\u003cCollatorThreadTest\u003e tests(new CollatorThreadTest[kCollatorThreadThreads]);\n\n    logln(UnicodeString(\"Spawning: \") + kCollatorThreadThreads + \" threads * \" + kFormatThreadIterations + \" iterations each.\");\n    int32_t j = 0;\n    for(j = 0; j \u003c kCollatorThreadThreads; j++) {\n        //logln(\"Setting collator %i\", j);\n        tests[j].setCollator(coll.getAlias(), lines.getAlias(), lineNum, isAtLeastUCA62);\n    }\n    for(j = 0; j \u003c kCollatorThreadThreads; j++) {\n        log(\"%i \", j);\n        spawnResult = tests[j].start();\n        if(spawnResult != 0) {\n            infoln(\"THREAD INFO: Couldn't spawn more than %i threads\", noSpawned);\n            break;\n        }\n        noSpawned++;\n    }\n    logln(\"Spawned all\");\n    if (noSpawned == 0) {\n        errln(\"No threads could be spawned.\");\n        return;\n    }\n\n    for(int32_t patience = kCollatorThreadPatience;patience \u003e 0; patience --)\n    {\n        logln(\"Waiting...\");\n\n        int32_t i;\n        int32_t terrs = 0;\n        int32_t completed =0;\n\n        for(i=0;i\u003ckCollatorThreadThreads;i++)\n        {\n            if (tests[i].isRunning() == FALSE)\n            {\n                completed++;\n\n                //logln(UnicodeString(\"Test #\") + i + \" is complete.. \");\n\n                UnicodeString theErr;\n                if(tests[i].getError(theErr))\n                {\n                    terrs++;\n                    errln(UnicodeString(\"#\") + i + \": \" + theErr);\n                }\n                // print out the error, too, if any.\n            }\n        }\n        logln(\"Completed %i tests\", completed);\n\n        if(completed == noSpawned)\n        {\n            logln(\"Done! All %i tests are finished\", noSpawned);\n\n            if(terrs)\n            {\n                errln(\"There were errors.\");\n                SimpleThread::errorFunc();\n            }\n            return;\n        }\n\n        SimpleThread::sleep(900);\n    }\n    errln(\"patience exceeded. \");\n    SimpleThread::errorFunc();\n}\n\n#endif /* #if !UCONFIG_NO_COLLATION */\n\n\n\n\n//-------------------------------------------------------------------------------------------\n//\n//   StringThreadTest2\n//\n//-------------------------------------------------------------------------------------------\n\nconst int kStringThreadIterations = 2500;// # of iterations per thread\nconst int kStringThreadThreads    = 10;  // # of threads to spawn\nconst int kStringThreadPatience   = 120; // time in seconds to wait for all threads\n\n\nclass StringThreadTest2 : public ThreadWithStatus\n{\npublic:\n    int                 fNum;\n    int                 fTraceInfo;\n    const UnicodeString *fSharedString;\n\n    StringThreadTest2(const UnicodeString *sharedString, int num) // constructor is NOT multithread safe.\n        : ThreadWithStatus(),\n        fNum(num),\n        fTraceInfo(0),\n        fSharedString(sharedString)\n    {\n    };\n\n\n    virtual void run()\n    {\n        fTraceInfo    = 1;\n        int loopCount = 0;\n\n        for (loopCount = 0; loopCount \u003c kStringThreadIterations; loopCount++) {\n            if (*fSharedString != \"This is the original test string.\") {\n                error(\"Original string is corrupt.\");\n                break;\n            }\n            UnicodeString s1 = *fSharedString;\n            s1 += \"cat this\";\n            UnicodeString s2(s1);\n            UnicodeString s3 = *fSharedString;\n            s2 = s3;\n            s3.truncate(12);\n            s2.truncate(0);\n        }\n\n        //  while (fNum == 4) {SimpleThread::sleep(10000);}   // Force a failure by preventing thread from finishing\n        fTraceInfo = 2;\n    }\n\n};\n\n// ** The actual test function.\n\nvoid MultithreadTest::TestString()\n{\n    int     patience;\n    int     terrs = 0;\n    int     j;\n\n    UnicodeString *testString = new UnicodeString(\"This is the original test string.\");\n\n    // Not using LocalArray\u003cStringThreadTest2\u003e tests[kStringThreadThreads];\n    // because we don't always want to delete them.\n    // See the comments below the cleanupAndReturn label.\n    StringThreadTest2  *tests[kStringThreadThreads];\n    for(j = 0; j \u003c kStringThreadThreads; j++) {\n        tests[j] = new StringThreadTest2(testString, j);\n    }\n\n    logln(UnicodeString(\"Spawning: \") + kStringThreadThreads + \" threads * \" + kStringThreadIterations + \" iterations each.\");\n    for(j = 0; j \u003c kStringThreadThreads; j++) {\n        int32_t threadStatus = tests[j]-\u003estart();\n        if (threadStatus != 0) {\n            errln(\"System Error %d starting thread number %d.\", threadStatus, j);\n            SimpleThread::errorFunc();\n            goto cleanupAndReturn;\n        }\n    }\n\n    for(patience = kStringThreadPatience;patience \u003e 0; patience --)\n    {\n        logln(\"Waiting...\");\n\n        int32_t i;\n        terrs = 0;\n        int32_t completed =0;\n\n        for(i=0;i\u003ckStringThreadThreads;i++) {\n            if (tests[i]-\u003eisRunning() == FALSE)\n            {\n                completed++;\n\n                logln(UnicodeString(\"Test #\") + i + \" is complete.. \");\n\n                UnicodeString theErr;\n                if(tests[i]-\u003egetError(theErr))\n                {\n                    terrs++;\n                    errln(UnicodeString(\"#\") + i + \": \" + theErr);\n                }\n                // print out the error, too, if any.\n            }\n        }\n\n        if(completed == kStringThreadThreads)\n        {\n            logln(\"Done!\");\n            if(terrs) {\n                errln(\"There were errors.\");\n            }\n            break;\n        }\n\n        SimpleThread::sleep(900);\n    }\n\n    if (patience \u003c= 0) {\n        errln(\"patience exceeded. \");\n        // while (TRUE) {SimpleThread::sleep(10000);}   // TODO:   for debugging.  Sleep forever on failure.\n        terrs++;\n    }\n\n    if (terrs \u003e 0) {\n        SimpleThread::errorFunc();\n    }\n\ncleanupAndReturn:\n    if (terrs == 0) {\n        /*\n        Don't clean up if there are errors. This prevents crashes if the\n        threads are still running and using this data. This will only happen\n        if there is an error with the test, ICU, or the machine is too slow.\n        It's better to leak than crash.\n        */\n        for(j = 0; j \u003c kStringThreadThreads; j++) {\n            delete tests[j];\n        }\n        delete testString;\n    }\n}\n\n\n// Test for ticket #10673, race in cache code in AnyTransliterator.\n// It's difficult to make the original unsafe code actually fail, but\n// this test will fairly reliably take the code path for races in\n// populating the cache.\n\n#if !UCONFIG_NO_TRANSLITERATION\nclass TxThread: public SimpleThread {\n  private:\n    Transliterator *fSharedTranslit;\n  public:\n    UBool fSuccess;\n    TxThread(Transliterator *tx) : fSharedTranslit(tx), fSuccess(FALSE) {};\n    ~TxThread();\n    void run();\n};\n\nTxThread::~TxThread() {}\nvoid TxThread::run() {\n    UnicodeString greekString(\"\\\\u03B4\\\\u03B9\\\\u03B1\\\\u03C6\\\\u03BF\\\\u03C1\\\\u03B5\\\\u03C4\\\\u03B9\\\\u03BA\\\\u03BF\\\\u03CD\\\\u03C2\");\n    greekString = greekString.unescape();\n    fSharedTranslit-\u003etransliterate(greekString);\n    fSuccess = greekString[0] == 0x64; // 'd'. The whole transliterated string is \"diaphoretikous\" (accented u).\n}\n#endif\n\n\nvoid MultithreadTest::TestAnyTranslit() {\n#if !UCONFIG_NO_TRANSLITERATION\n    UErrorCode status = U_ZERO_ERROR;\n    LocalPointer\u003cTransliterator\u003e tx(Transliterator::createInstance(\"Any-Latin\", UTRANS_FORWARD, status));\n    if (U_FAILURE(status)) {\n        dataerrln(\"File %s, Line %d: Error, status = %s\", __FILE__, __LINE__, u_errorName(status));\n        return;\n    }\n    TxThread * threads[4];\n    int32_t i;\n    for (i=0; i\u003c4; i++) {\n        threads[i] = new TxThread(tx.getAlias());\n    }\n    for (i=0; i\u003c4; i++) {\n        threads[i]-\u003estart();\n    }\n    int32_t patience = 100;\n    UBool success;\n    UBool someThreadRunning;\n    do {\n        someThreadRunning = FALSE;\n        success = TRUE;\n        for (i=0; i\u003c4; i++) {\n            if (threads[i]-\u003eisRunning()) {\n                someThreadRunning = TRUE;\n                SimpleThread::sleep(10);\n                break;\n            } else {\n                if (threads[i]-\u003efSuccess == FALSE) {\n                    success = FALSE;\n                }\n            }\n        }\n    } while (someThreadRunning \u0026\u0026 --patience \u003e 0);\n\n    if (patience \u003c= 0) {\n        errln(\"File %s, Line %d: Error, one or more threads did not complete.\", __FILE__, __LINE__);\n    }\n    if (success == FALSE) {\n        errln(\"File %s, Line %d: Error, transliteration result incorrect.\", __FILE__, __LINE__);\n    }\n\n    for (i=0; i\u003c4; i++) {\n        delete threads[i];\n    }\n#endif  // !UCONFIG_NO_TRANSLITERATION\n}\n\n\n// Condition Variables Test\n//   Create a swarm of threads.\n//   Using a mutex and a condition variables each thread\n//     Increments a global count of started threads.\n//     Broadcasts that it has started.\n//     Waits on the condition that all threads have started.\n//     Increments a global count of finished threads.\n//     Waits on the condition that all threads have finished.\n//     Exits.\n\nclass CondThread: public SimpleThread {\n  public:\n    CondThread() :fFinished(false)  {};\n    ~CondThread() {};\n    void run();\n    bool  fFinished;\n};\n\nstatic UMutex gCTMutex = U_MUTEX_INITIALIZER;\nstatic UConditionVar gCTConditionVar = U_CONDITION_INITIALIZER;\nint gConditionTestOne = 1;   // Value one. Non-const, extern linkage to inhibit\n                             //   compiler assuming a known value.\nint gStartedThreads;\nint gFinishedThreads;\nstatic const int NUMTHREADS = 10;\n\nstatic MultithreadTest *gThisTest = NULL; // Make test frame work functions available to\n                                          //   non-member functions.\n\n// Worker thread function.\nvoid CondThread::run() {\n    umtx_lock(\u0026gCTMutex);\n    gStartedThreads += gConditionTestOne;\n    umtx_condBroadcast(\u0026gCTConditionVar);\n\n    while (gStartedThreads \u003c NUMTHREADS) {\n        if (gFinishedThreads != 0) {\n            gThisTest-\u003eerrln(\"File %s, Line %d: Error, gStartedThreads = %d, gFinishedThreads = %d\",\n                             __FILE__, __LINE__, gStartedThreads, gFinishedThreads);\n        }\n        umtx_condWait(\u0026gCTConditionVar, \u0026gCTMutex);\n    }\n\n    gFinishedThreads += gConditionTestOne;\n    fFinished = true;\n    umtx_condBroadcast(\u0026gCTConditionVar);\n\n    while (gFinishedThreads \u003c NUMTHREADS) {\n        umtx_condWait(\u0026gCTConditionVar, \u0026gCTMutex);\n    }\n    umtx_unlock(\u0026gCTMutex);\n}\n\nvoid MultithreadTest::TestConditionVariables() {\n    gThisTest = this;\n    gStartedThreads = 0;\n    gFinishedThreads = 0;\n    int i;\n\n    umtx_lock(\u0026gCTMutex);\n    CondThread *threads[NUMTHREADS];\n    for (i=0; i\u003cNUMTHREADS; ++i) {\n        threads[i] = new CondThread;\n        threads[i]-\u003estart();\n    }\n\n    while (gStartedThreads \u003c NUMTHREADS) {\n        umtx_condWait(\u0026gCTConditionVar, \u0026gCTMutex);\n    }\n\n    while (gFinishedThreads \u003c NUMTHREADS) {\n        umtx_condWait(\u0026gCTConditionVar, \u0026gCTMutex);\n    }\n\n    umtx_unlock(\u0026gCTMutex);\n\n    for (i=0; i\u003cNUMTHREADS; ++i) {\n        if (!threads[i]-\u003efFinished) {\n            errln(\"File %s, Line %d: Error, threads[%d]-\u003efFinished == false\", __FILE__, __LINE__, i);\n        }\n        delete threads[i];\n    }\n}\n\nstatic const char *gCacheLocales[] = {\"en_US\", \"en_GB\", \"fr_FR\", \"fr\"};\nstatic int32_t gObjectsCreated = 0;\nstatic const int32_t CACHE_LOAD = 3;\n\nclass UCTMultiThreadItem : public SharedObject {\n  public:\n    char *value;\n    UCTMultiThreadItem(const char *x) : value(NULL) {\n        value = uprv_strdup(x);\n    }\n    virtual ~UCTMultiThreadItem() {\n        uprv_free(value);\n    }\n};\n\nU_NAMESPACE_BEGIN\n\ntemplate\u003c\u003e U_EXPORT\nconst UCTMultiThreadItem *LocaleCacheKey\u003cUCTMultiThreadItem\u003e::createObject(\n        const void * /*unused*/, UErrorCode \u0026 /* status */) const {\n    // Since multiple threads are hitting the cache for the first time,\n    // no objects should be created yet.\n    umtx_lock(\u0026gCTMutex);\n    if (gObjectsCreated != 0) {\n        gThisTest-\u003eerrln(\"Expected no objects to be created yet.\");\n    }\n    umtx_unlock(\u0026gCTMutex);\n\n    // Big, expensive object that takes 1 second to create.\n    SimpleThread::sleep(1000);\n\n    // Log that we created an object.\n    umtx_lock(\u0026gCTMutex);\n    ++gObjectsCreated;\n    umtx_unlock(\u0026gCTMutex);\n    UCTMultiThreadItem *result = new UCTMultiThreadItem(fLoc.getName());\n    result-\u003eaddRef();\n    return result;\n}\n\nU_NAMESPACE_END\n\nclass UnifiedCacheThread: public SimpleThread {\n  public:\n    UnifiedCacheThread(const char *loc) : fLoc(loc) {};\n    ~UnifiedCacheThread() {};\n    void run();\n    const char *fLoc;\n};\n\nvoid UnifiedCacheThread::run() {\n    UErrorCode status = U_ZERO_ERROR;\n    const UnifiedCache *cache = UnifiedCache::getInstance(status);\n    U_ASSERT(status == U_ZERO_ERROR);\n    const UCTMultiThreadItem *item = NULL;\n    cache-\u003eget(LocaleCacheKey\u003cUCTMultiThreadItem\u003e(fLoc), item, status);\n    U_ASSERT(item != NULL);\n    if (uprv_strcmp(fLoc, item-\u003evalue)) {\n      gThisTest-\u003eerrln(\"Expected %s, got %s\", fLoc, item-\u003evalue);\n    }\n    item-\u003eremoveRef();\n\n    // Mark this thread as finished\n    umtx_lock(\u0026gCTMutex);\n    ++gFinishedThreads;\n    umtx_condBroadcast(\u0026gCTConditionVar);\n    umtx_unlock(\u0026gCTMutex);\n}\n\nvoid MultithreadTest::TestUnifiedCache() {\n    UErrorCode status = U_ZERO_ERROR;\n    const UnifiedCache *cache = UnifiedCache::getInstance(status);\n    U_ASSERT(cache != NULL);\n    cache-\u003eflush();\n    gThisTest = this;\n    gFinishedThreads = 0;\n    gObjectsCreated = 0;\n\n    UnifiedCacheThread *threads[CACHE_LOAD][UPRV_LENGTHOF(gCacheLocales)];\n    for (int32_t i=0; i\u003cCACHE_LOAD; ++i) {\n        for (int32_t j=0; j\u003cUPRV_LENGTHOF(gCacheLocales); ++j) {\n            threads[i][j] = new UnifiedCacheThread(gCacheLocales[j]);\n            threads[i][j]-\u003estart();\n        }\n    }\n    // Wait on all the threads to complete verify that LENGTHOF(gCacheLocales)\n    // objects were created.\n    umtx_lock(\u0026gCTMutex);\n    while (gFinishedThreads \u003c CACHE_LOAD*UPRV_LENGTHOF(gCacheLocales)) {\n        umtx_condWait(\u0026gCTConditionVar, \u0026gCTMutex);\n    }\n    assertEquals(\"Objects created\", UPRV_LENGTHOF(gCacheLocales), gObjectsCreated);\n    umtx_unlock(\u0026gCTMutex);\n\n    // clean up threads\n    for (int32_t i=0; i\u003cCACHE_LOAD; ++i) {\n        for (int32_t j=0; j\u003cUPRV_LENGTHOF(gCacheLocales); ++j) {\n            delete threads[i][j];\n        }\n    }\n}\n\n#endif // ICU_USE_THREADS\n"}
{"repo_name":"weolar/miniblink49","ref":"refs/heads/master","path":"gen/blink/bindings/core/v8/V8VideoTrackList.cpp","copies":"4","language":"C++","content":"// Copyright 2014 The Chromium Authors. All rights reserved.\r\n// Use of this source code is governed by a BSD-style license that can be\r\n// found in the LICENSE file.\r\n\r\n// This file has been auto-generated by code_generator_v8.py. DO NOT MODIFY!\r\n\r\n#include \"config.h\"\r\n#include \"V8VideoTrackList.h\"\r\n\r\n#include \"bindings/core/v8/ExceptionState.h\"\r\n#include \"bindings/core/v8/V8AbstractEventListener.h\"\r\n#include \"bindings/core/v8/V8DOMConfiguration.h\"\r\n#include \"bindings/core/v8/V8EventListenerList.h\"\r\n#include \"bindings/core/v8/V8GCController.h\"\r\n#include \"bindings/core/v8/V8ObjectConstructor.h\"\r\n#include \"bindings/core/v8/V8VideoTrack.h\"\r\n#include \"core/dom/ContextFeatures.h\"\r\n#include \"core/dom/Document.h\"\r\n#include \"core/dom/Element.h\"\r\n#include \"platform/RuntimeEnabledFeatures.h\"\r\n#include \"platform/TraceEvent.h\"\r\n#include \"wtf/GetPtr.h\"\r\n#include \"wtf/RefPtr.h\"\r\n\r\nnamespace blink {\r\n\r\n// Suppress warning: global constructors, because struct WrapperTypeInfo is trivial\r\n// and does not depend on another global objects.\r\n#if defined(COMPONENT_BUILD) \u0026\u0026 defined(WIN32) \u0026\u0026 COMPILER(CLANG)\r\n#pragma clang diagnostic push\r\n#pragma clang diagnostic ignored \"-Wglobal-constructors\"\r\n#endif\r\nconst WrapperTypeInfo V8VideoTrackList::wrapperTypeInfo = { gin::kEmbedderBlink, V8VideoTrackList::domTemplate, V8VideoTrackList::refObject, V8VideoTrackList::derefObject, V8VideoTrackList::trace, 0, V8VideoTrackList::visitDOMWrapper, V8VideoTrackList::preparePrototypeObject, V8VideoTrackList::installConditionallyEnabledProperties, \"VideoTrackList\", \u0026V8EventTarget::wrapperTypeInfo, WrapperTypeInfo::WrapperTypeObjectPrototype, WrapperTypeInfo::ObjectClassId, WrapperTypeInfo::InheritFromEventTarget, WrapperTypeInfo::Dependent, WrapperTypeInfo::WillBeGarbageCollectedObject };\r\n#if defined(COMPONENT_BUILD) \u0026\u0026 defined(WIN32) \u0026\u0026 COMPILER(CLANG)\r\n#pragma clang diagnostic pop\r\n#endif\r\n\r\n// This static member must be declared by DEFINE_WRAPPERTYPEINFO in VideoTrackList.h.\r\n// For details, see the comment of DEFINE_WRAPPERTYPEINFO in\r\n// bindings/core/v8/ScriptWrappable.h.\r\nconst WrapperTypeInfo\u0026 VideoTrackList::s_wrapperTypeInfo = V8VideoTrackList::wrapperTypeInfo;\r\n\r\nnamespace VideoTrackListV8Internal {\r\n\r\nstatic void lengthAttributeGetter(const v8::FunctionCallbackInfo\u003cv8::Value\u003e\u0026 info)\r\n{\r\n    v8::Local\u003cv8::Object\u003e holder = info.Holder();\r\n    VideoTrackList* impl = V8VideoTrackList::toImpl(holder);\r\n    v8SetReturnValueUnsigned(info, impl-\u003elength());\r\n}\r\n\r\nstatic void lengthAttributeGetterCallback(const v8::FunctionCallbackInfo\u003cv8::Value\u003e\u0026 info)\r\n{\r\n    TRACE_EVENT_SET_SAMPLING_STATE(\"blink\", \"DOMGetter\");\r\n    VideoTrackListV8Internal::lengthAttributeGetter(info);\r\n    TRACE_EVENT_SET_SAMPLING_STATE(\"v8\", \"V8Execution\");\r\n}\r\n\r\nstatic void selectedIndexAttributeGetter(const v8::FunctionCallbackInfo\u003cv8::Value\u003e\u0026 info)\r\n{\r\n    v8::Local\u003cv8::Object\u003e holder = info.Holder();\r\n    VideoTrackList* impl = V8VideoTrackList::toImpl(holder);\r\n    v8SetReturnValueInt(info, impl-\u003eselectedIndex());\r\n}\r\n\r\nstatic void selectedIndexAttributeGetterCallback(const v8::FunctionCallbackInfo\u003cv8::Value\u003e\u0026 info)\r\n{\r\n    TRACE_EVENT_SET_SAMPLING_STATE(\"blink\", \"DOMGetter\");\r\n    VideoTrackListV8Internal::selectedIndexAttributeGetter(info);\r\n    TRACE_EVENT_SET_SAMPLING_STATE(\"v8\", \"V8Execution\");\r\n}\r\n\r\nstatic void onchangeAttributeGetter(const v8::FunctionCallbackInfo\u003cv8::Value\u003e\u0026 info)\r\n{\r\n    v8::Local\u003cv8::Object\u003e holder = info.Holder();\r\n    VideoTrackList* impl = V8VideoTrackList::toImpl(holder);\r\n    EventListener* cppValue(impl-\u003eonchange());\r\n    v8SetReturnValue(info, cppValue ? v8::Local\u003cv8::Value\u003e(V8AbstractEventListener::cast(cppValue)-\u003egetListenerObject(impl-\u003eexecutionContext())) : v8::Local\u003cv8::Value\u003e(v8::Null(info.GetIsolate())));\r\n}\r\n\r\nstatic void onchangeAttributeGetterCallback(const v8::FunctionCallbackInfo\u003cv8::Value\u003e\u0026 info)\r\n{\r\n    TRACE_EVENT_SET_SAMPLING_STATE(\"blink\", \"DOMGetter\");\r\n    VideoTrackListV8Internal::onchangeAttributeGetter(info);\r\n    TRACE_EVENT_SET_SAMPLING_STATE(\"v8\", \"V8Execution\");\r\n}\r\n\r\nstatic void onchangeAttributeSetter(v8::Local\u003cv8::Value\u003e v8Value, const v8::FunctionCallbackInfo\u003cv8::Value\u003e\u0026 info)\r\n{\r\n    v8::Local\u003cv8::Object\u003e holder = info.Holder();\r\n    VideoTrackList* impl = V8VideoTrackList::toImpl(holder);\r\n    moveEventListenerToNewWrapper(info.GetIsolate(), holder, impl-\u003eonchange(), v8Value, V8VideoTrackList::eventListenerCacheIndex);\r\n    impl-\u003esetOnchange(V8EventListenerList::getEventListener(ScriptState::current(info.GetIsolate()), v8Value, true, ListenerFindOrCreate));\r\n}\r\n\r\nstatic void onchangeAttributeSetterCallback(const v8::FunctionCallbackInfo\u003cv8::Value\u003e\u0026 info)\r\n{\r\n    v8::Local\u003cv8::Value\u003e v8Value = info[0];\r\n    TRACE_EVENT_SET_SAMPLING_STATE(\"blink\", \"DOMSetter\");\r\n    VideoTrackListV8Internal::onchangeAttributeSetter(v8Value, info);\r\n    TRACE_EVENT_SET_SAMPLING_STATE(\"v8\", \"V8Execution\");\r\n}\r\n\r\nstatic void onaddtrackAttributeGetter(const v8::FunctionCallbackInfo\u003cv8::Value\u003e\u0026 info)\r\n{\r\n    v8::Local\u003cv8::Object\u003e holder = info.Holder();\r\n    VideoTrackList* impl = V8VideoTrackList::toImpl(holder);\r\n    EventListener* cppValue(impl-\u003eonaddtrack());\r\n    v8SetReturnValue(info, cppValue ? v8::Local\u003cv8::Value\u003e(V8AbstractEventListener::cast(cppValue)-\u003egetListenerObject(impl-\u003eexecutionContext())) : v8::Local\u003cv8::Value\u003e(v8::Null(info.GetIsolate())));\r\n}\r\n\r\nstatic void onaddtrackAttributeGetterCallback(const v8::FunctionCallbackInfo\u003cv8::Value\u003e\u0026 info)\r\n{\r\n    TRACE_EVENT_SET_SAMPLING_STATE(\"blink\", \"DOMGetter\");\r\n    VideoTrackListV8Internal::onaddtrackAttributeGetter(info);\r\n    TRACE_EVENT_SET_SAMPLING_STATE(\"v8\", \"V8Execution\");\r\n}\r\n\r\nstatic void onaddtrackAttributeSetter(v8::Local\u003cv8::Value\u003e v8Value, const v8::FunctionCallbackInfo\u003cv8::Value\u003e\u0026 info)\r\n{\r\n    v8::Local\u003cv8::Object\u003e holder = info.Holder();\r\n    VideoTrackList* impl = V8VideoTrackList::toImpl(holder);\r\n    moveEventListenerToNewWrapper(info.GetIsolate(), holder, impl-\u003eonaddtrack(), v8Value, V8VideoTrackList::eventListenerCacheIndex);\r\n    impl-\u003esetOnaddtrack(V8EventListenerList::getEventListener(ScriptState::current(info.GetIsolate()), v8Value, true, ListenerFindOrCreate));\r\n}\r\n\r\nstatic void onaddtrackAttributeSetterCallback(const v8::FunctionCallbackInfo\u003cv8::Value\u003e\u0026 info)\r\n{\r\n    v8::Local\u003cv8::Value\u003e v8Value = info[0];\r\n    TRACE_EVENT_SET_SAMPLING_STATE(\"blink\", \"DOMSetter\");\r\n    VideoTrackListV8Internal::onaddtrackAttributeSetter(v8Value, info);\r\n    TRACE_EVENT_SET_SAMPLING_STATE(\"v8\", \"V8Execution\");\r\n}\r\n\r\nstatic void onremovetrackAttributeGetter(const v8::FunctionCallbackInfo\u003cv8::Value\u003e\u0026 info)\r\n{\r\n    v8::Local\u003cv8::Object\u003e holder = info.Holder();\r\n    VideoTrackList* impl = V8VideoTrackList::toImpl(holder);\r\n    EventListener* cppValue(impl-\u003eonremovetrack());\r\n    v8SetReturnValue(info, cppValue ? v8::Local\u003cv8::Value\u003e(V8AbstractEventListener::cast(cppValue)-\u003egetListenerObject(impl-\u003eexecutionContext())) : v8::Local\u003cv8::Value\u003e(v8::Null(info.GetIsolate())));\r\n}\r\n\r\nstatic void onremovetrackAttributeGetterCallback(const v8::FunctionCallbackInfo\u003cv8::Value\u003e\u0026 info)\r\n{\r\n    TRACE_EVENT_SET_SAMPLING_STATE(\"blink\", \"DOMGetter\");\r\n    VideoTrackListV8Internal::onremovetrackAttributeGetter(info);\r\n    TRACE_EVENT_SET_SAMPLING_STATE(\"v8\", \"V8Execution\");\r\n}\r\n\r\nstatic void onremovetrackAttributeSetter(v8::Local\u003cv8::Value\u003e v8Value, const v8::FunctionCallbackInfo\u003cv8::Value\u003e\u0026 info)\r\n{\r\n    v8::Local\u003cv8::Object\u003e holder = info.Holder();\r\n    VideoTrackList* impl = V8VideoTrackList::toImpl(holder);\r\n    moveEventListenerToNewWrapper(info.GetIsolate(), holder, impl-\u003eonremovetrack(), v8Value, V8VideoTrackList::eventListenerCacheIndex);\r\n    impl-\u003esetOnremovetrack(V8EventListenerList::getEventListener(ScriptState::current(info.GetIsolate()), v8Value, true, ListenerFindOrCreate));\r\n}\r\n\r\nstatic void onremovetrackAttributeSetterCallback(const v8::FunctionCallbackInfo\u003cv8::Value\u003e\u0026 info)\r\n{\r\n    v8::Local\u003cv8::Value\u003e v8Value = info[0];\r\n    TRACE_EVENT_SET_SAMPLING_STATE(\"blink\", \"DOMSetter\");\r\n    VideoTrackListV8Internal::onremovetrackAttributeSetter(v8Value, info);\r\n    TRACE_EVENT_SET_SAMPLING_STATE(\"v8\", \"V8Execution\");\r\n}\r\n\r\nstatic void getTrackByIdMethod(const v8::FunctionCallbackInfo\u003cv8::Value\u003e\u0026 info)\r\n{\r\n    if (UNLIKELY(info.Length() \u003c 1)) {\r\n        V8ThrowException::throwException(createMinimumArityTypeErrorForMethod(info.GetIsolate(), \"getTrackById\", \"VideoTrackList\", 1, info.Length()), info.GetIsolate());\r\n        return;\r\n    }\r\n    VideoTrackList* impl = V8VideoTrackList::toImpl(info.Holder());\r\n    V8StringResource\u003c\u003e id;\r\n    {\r\n        id = info[0];\r\n        if (!id.prepare())\r\n            return;\r\n    }\r\n    v8SetReturnValue(info, impl-\u003egetTrackById(id));\r\n}\r\n\r\nstatic void getTrackByIdMethodCallback(const v8::FunctionCallbackInfo\u003cv8::Value\u003e\u0026 info)\r\n{\r\n    TRACE_EVENT_SET_SAMPLING_STATE(\"blink\", \"DOMMethod\");\r\n    VideoTrackListV8Internal::getTrackByIdMethod(info);\r\n    TRACE_EVENT_SET_SAMPLING_STATE(\"v8\", \"V8Execution\");\r\n}\r\n\r\nstatic void indexedPropertyGetter(uint32_t index, const v8::PropertyCallbackInfo\u003cv8::Value\u003e\u0026 info)\r\n{\r\n    VideoTrackList* impl = V8VideoTrackList::toImpl(info.Holder());\r\n    RefPtrWillBeRawPtr\u003cVideoTrack\u003e result = impl-\u003eanonymousIndexedGetter(index);\r\n    if (!result)\r\n        return;\r\n    v8SetReturnValueFast(info, WTF::getPtr(result.release()), impl);\r\n}\r\n\r\nstatic void indexedPropertyGetterCallback(uint32_t index, const v8::PropertyCallbackInfo\u003cv8::Value\u003e\u0026 info)\r\n{\r\n    TRACE_EVENT_SET_SAMPLING_STATE(\"blink\", \"DOMIndexedProperty\");\r\n    VideoTrackListV8Internal::indexedPropertyGetter(index, info);\r\n    TRACE_EVENT_SET_SAMPLING_STATE(\"v8\", \"V8Execution\");\r\n}\r\n\r\n} // namespace VideoTrackListV8Internal\r\n\r\nvoid V8VideoTrackList::visitDOMWrapper(v8::Isolate* isolate, ScriptWrappable* scriptWrappable, const v8::Persistent\u003cv8::Object\u003e\u0026 wrapper)\r\n{\r\n    VideoTrackList* impl = scriptWrappable-\u003etoImpl\u003cVideoTrackList\u003e();\r\n    // The owner() method may return a reference or a pointer.\r\n    if (Node* owner = WTF::getPtr(impl-\u003eowner())) {\r\n        Node* root = V8GCController::opaqueRootForGC(isolate, owner);\r\n        isolate-\u003eSetReferenceFromGroup(v8::UniqueId(reinterpret_cast\u003cintptr_t\u003e(root)), wrapper);\r\n        return;\r\n    }\r\n}\r\n\r\nstatic const V8DOMConfiguration::AccessorConfiguration V8VideoTrackListAccessors[] = {\r\n    {\"length\", VideoTrackListV8Internal::lengthAttributeGetterCallback, 0, 0, 0, 0, static_cast\u003cv8::AccessControl\u003e(v8::DEFAULT), static_cast\u003cv8::PropertyAttribute\u003e(v8::None), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},\r\n    {\"selectedIndex\", VideoTrackListV8Internal::selectedIndexAttributeGetterCallback, 0, 0, 0, 0, static_cast\u003cv8::AccessControl\u003e(v8::DEFAULT), static_cast\u003cv8::PropertyAttribute\u003e(v8::None), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},\r\n    {\"onchange\", VideoTrackListV8Internal::onchangeAttributeGetterCallback, VideoTrackListV8Internal::onchangeAttributeSetterCallback, 0, 0, 0, static_cast\u003cv8::AccessControl\u003e(v8::DEFAULT), static_cast\u003cv8::PropertyAttribute\u003e(v8::None), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},\r\n    {\"onaddtrack\", VideoTrackListV8Internal::onaddtrackAttributeGetterCallback, VideoTrackListV8Internal::onaddtrackAttributeSetterCallback, 0, 0, 0, static_cast\u003cv8::AccessControl\u003e(v8::DEFAULT), static_cast\u003cv8::PropertyAttribute\u003e(v8::None), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},\r\n    {\"onremovetrack\", VideoTrackListV8Internal::onremovetrackAttributeGetterCallback, VideoTrackListV8Internal::onremovetrackAttributeSetterCallback, 0, 0, 0, static_cast\u003cv8::AccessControl\u003e(v8::DEFAULT), static_cast\u003cv8::PropertyAttribute\u003e(v8::None), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},\r\n};\r\n\r\nstatic const V8DOMConfiguration::MethodConfiguration V8VideoTrackListMethods[] = {\r\n    {\"getTrackById\", VideoTrackListV8Internal::getTrackByIdMethodCallback, 0, 1, V8DOMConfiguration::ExposedToAllScripts},\r\n};\r\n\r\nstatic void installV8VideoTrackListTemplate(v8::Local\u003cv8::FunctionTemplate\u003e functionTemplate, v8::Isolate* isolate)\r\n{\r\n    functionTemplate-\u003eReadOnlyPrototype();\r\n\r\n    v8::Local\u003cv8::Signature\u003e defaultSignature;\r\n    if (!RuntimeEnabledFeatures::audioVideoTracksEnabled())\r\n        defaultSignature = V8DOMConfiguration::installDOMClassTemplate(isolate, functionTemplate, \"VideoTrackList\", V8EventTarget::domTemplate(isolate), V8VideoTrackList::internalFieldCount, 0, 0, 0, 0, 0, 0);\r\n    else\r\n        defaultSignature = V8DOMConfiguration::installDOMClassTemplate(isolate, functionTemplate, \"VideoTrackList\", V8EventTarget::domTemplate(isolate), V8VideoTrackList::internalFieldCount,\r\n            0, 0,\r\n            V8VideoTrackListAccessors, WTF_ARRAY_LENGTH(V8VideoTrackListAccessors),\r\n            V8VideoTrackListMethods, WTF_ARRAY_LENGTH(V8VideoTrackListMethods));\r\n    v8::Local\u003cv8::ObjectTemplate\u003e instanceTemplate = functionTemplate-\u003eInstanceTemplate();\r\n    ALLOW_UNUSED_LOCAL(instanceTemplate);\r\n    v8::Local\u003cv8::ObjectTemplate\u003e prototypeTemplate = functionTemplate-\u003ePrototypeTemplate();\r\n    ALLOW_UNUSED_LOCAL(prototypeTemplate);\r\n    {\r\n        v8::IndexedPropertyHandlerConfiguration config(VideoTrackListV8Internal::indexedPropertyGetterCallback, 0, 0, 0, indexedPropertyEnumerator\u003cVideoTrackList\u003e);\r\n        functionTemplate-\u003eInstanceTemplate()-\u003eSetHandler(config);\r\n    }\r\n\r\n    // Custom toString template\r\n    functionTemplate-\u003eSet(v8AtomicString(isolate, \"toString\"), V8PerIsolateData::from(isolate)-\u003etoStringTemplate());\r\n}\r\n\r\nv8::Local\u003cv8::FunctionTemplate\u003e V8VideoTrackList::domTemplate(v8::Isolate* isolate)\r\n{\r\n    return V8DOMConfiguration::domClassTemplate(isolate, const_cast\u003cWrapperTypeInfo*\u003e(\u0026wrapperTypeInfo), installV8VideoTrackListTemplate);\r\n}\r\n\r\nbool V8VideoTrackList::hasInstance(v8::Local\u003cv8::Value\u003e v8Value, v8::Isolate* isolate)\r\n{\r\n    return V8PerIsolateData::from(isolate)-\u003ehasInstance(\u0026wrapperTypeInfo, v8Value);\r\n}\r\n\r\nv8::Local\u003cv8::Object\u003e V8VideoTrackList::findInstanceInPrototypeChain(v8::Local\u003cv8::Value\u003e v8Value, v8::Isolate* isolate)\r\n{\r\n    return V8PerIsolateData::from(isolate)-\u003efindInstanceInPrototypeChain(\u0026wrapperTypeInfo, v8Value);\r\n}\r\n\r\nVideoTrackList* V8VideoTrackList::toImplWithTypeCheck(v8::Isolate* isolate, v8::Local\u003cv8::Value\u003e value)\r\n{\r\n    return hasInstance(value, isolate) ? toImpl(v8::Local\u003cv8::Object\u003e::Cast(value)) : 0;\r\n}\r\n\r\nvoid V8VideoTrackList::refObject(ScriptWrappable* scriptWrappable)\r\n{\r\n#if !ENABLE(OILPAN)\r\n    scriptWrappable-\u003etoImpl\u003cVideoTrackList\u003e()-\u003eref();\r\n#endif\r\n}\r\n\r\nvoid V8VideoTrackList::derefObject(ScriptWrappable* scriptWrappable)\r\n{\r\n#if !ENABLE(OILPAN)\r\n    scriptWrappable-\u003etoImpl\u003cVideoTrackList\u003e()-\u003ederef();\r\n#endif\r\n}\r\n\r\n} // namespace blink\r\n"}
{"repo_name":"gavoski/audacity","ref":"refs/heads/master","path":"lib-src/taglib/tests/test_map.cpp","copies":"31","language":"C++","content":"#include \u003ccppunit/extensions/HelperMacros.h\u003e\n#include \u003ctstring.h\u003e\n#include \u003ctmap.h\u003e\n\nusing namespace std;\nusing namespace TagLib;\n\nclass TestMap : public CppUnit::TestFixture\n{\n  CPPUNIT_TEST_SUITE(TestMap);\n  CPPUNIT_TEST(testInsert);\n  CPPUNIT_TEST_SUITE_END();\n\npublic:\n\n  void testInsert()\n  {\n    Map\u003cString, int\u003e m;\n    m.insert(\"foo\", 3);\n    CPPUNIT_ASSERT_EQUAL(3, m[\"foo\"]);\n    m.insert(\"foo\", 7);\n    CPPUNIT_ASSERT_EQUAL(7, m[\"foo\"]);\n  }\n\n};\n\nCPPUNIT_TEST_SUITE_REGISTRATION(TestMap);\n"}
{"repo_name":"tpltnt/uncrustify","ref":"refs/heads/master","path":"tests/output/cpp/30920-indent-off.cpp","copies":"14","language":"C++","content":"struct X\n{\n   void operator-(int);\n   void operator+(int);\n   void operator()();\n};\n/* *INDENT-OFF* */\n  struct Y {\n    void operator-(int){}\n\n\n   void operator+(int){}  \\\n    void operator()(){}\n\n     void func() {\n\t \t\t\tauto x = \"\ttest\\t \t \t \t\t...   ???\";}\n  };\n/* *INDENT-ON* */\nstruct Y\n{\n   void operator-(int){}\n   void operator+(int){}\n   void operator()(){}\n   void func()\n   {\n      auto x = \"\ttest\\t            ...   ???\";\n   }\n};\n\n"}
{"repo_name":"asuradaimao/dolphin","ref":"refs/heads/master","path":"Source/Core/Core/PowerPC/Interpreter/Interpreter_Integer.cpp","copies":"46","language":"C++","content":"// Copyright 2008 Dolphin Emulator Project\n// Licensed under GPLv2+\n// Refer to the license.txt file included.\n\n#include \"Core/PowerPC/Interpreter/Interpreter.h\"\n\nvoid Interpreter::Helper_UpdateCR0(u32 value)\n{\n\ts64 sign_extended = (s64)(s32)value;\n\tu64 cr_val = (u64)sign_extended;\n\tcr_val = (cr_val \u0026 ~(1ull \u003c\u003c 61)) | ((u64)GetXER_SO() \u003c\u003c 61);\n\n\tPowerPC::ppcState.cr_val[0] = cr_val;\n}\n\nvoid Interpreter::Helper_UpdateCRx(int idx, u32 value)\n{\n\ts64 sign_extended = (s64)(s32)value;\n\tu64 cr_val = (u64)sign_extended;\n\tcr_val = (cr_val \u0026 ~(1ull \u003c\u003c 61)) | ((u64)GetXER_SO() \u003c\u003c 61);\n\n\tPowerPC::ppcState.cr_val[idx] = cr_val;\n}\n\nu32 Interpreter::Helper_Carry(u32 _uValue1, u32 _uValue2)\n{\n\treturn _uValue2 \u003e (~_uValue1);\n}\n\nu32 Interpreter::Helper_Mask(int mb, int me)\n{\n\t//first make 001111111111111 part\n\tu32 begin = 0xFFFFFFFF \u003e\u003e mb;\n\t//then make 000000000001111 part, which is used to flip the bits of the first one\n\tu32 end = me \u003c 31 ? (0xFFFFFFFF \u003e\u003e (me + 1)) : 0;\n\t//do the bitflip\n\tu32 mask = begin ^ end;\n\t//and invert if backwards\n\tif (me \u003c mb)\n\t\treturn ~mask;\n\telse\n\t\treturn mask;\n}\n\nvoid Interpreter::addi(UGeckoInstruction _inst)\n{\n\tif (_inst.RA)\n\t\trGPR[_inst.RD] = rGPR[_inst.RA] + _inst.SIMM_16;\n\telse\n\t\trGPR[_inst.RD] = _inst.SIMM_16;\n}\n\nvoid Interpreter::addic(UGeckoInstruction _inst)\n{\n\tu32 a = rGPR[_inst.RA];\n\tu32 imm = (u32)(s32)_inst.SIMM_16;\n\t// TODO(ector): verify this thing\n\trGPR[_inst.RD] = a + imm;\n\tSetCarry(Helper_Carry(a, imm));\n}\n\nvoid Interpreter::addic_rc(UGeckoInstruction _inst)\n{\n\taddic(_inst);\n\tHelper_UpdateCR0(rGPR[_inst.RD]);\n}\n\nvoid Interpreter::addis(UGeckoInstruction _inst)\n{\n\tif (_inst.RA)\n\t\trGPR[_inst.RD] = rGPR[_inst.RA] + (_inst.SIMM_16 \u003c\u003c 16);\n\telse\n\t\trGPR[_inst.RD] = (_inst.SIMM_16 \u003c\u003c 16);\n}\n\nvoid Interpreter::andi_rc(UGeckoInstruction _inst)\n{\n\trGPR[_inst.RA] = rGPR[_inst.RS] \u0026 _inst.UIMM;\n\tHelper_UpdateCR0(rGPR[_inst.RA]);\n}\n\nvoid Interpreter::andis_rc(UGeckoInstruction _inst)\n{\n\trGPR[_inst.RA] = rGPR[_inst.RS] \u0026 ((u32)_inst.UIMM \u003c\u003c 16);\n\tHelper_UpdateCR0(rGPR[_inst.RA]);\n}\n\nvoid Interpreter::cmpi(UGeckoInstruction _inst)\n{\n\tHelper_UpdateCRx(_inst.CRFD, rGPR[_inst.RA] - _inst.SIMM_16);\n}\n\nvoid Interpreter::cmpli(UGeckoInstruction _inst)\n{\n\tu32 a = rGPR[_inst.RA];\n\tu32 b = _inst.UIMM;\n\tint f;\n\n\tif (a \u003c b)\n\t\tf = 0x8;\n\telse if (a \u003e b)\n\t\tf = 0x4;\n\telse\n\t\tf = 0x2; //equals\n\n\tif (GetXER_SO())\n\t\tf |= 0x1;\n\n\tSetCRField(_inst.CRFD, f);\n}\n\nvoid Interpreter::mulli(UGeckoInstruction _inst)\n{\n\trGPR[_inst.RD] = (s32)rGPR[_inst.RA] * _inst.SIMM_16;\n}\n\nvoid Interpreter::ori(UGeckoInstruction _inst)\n{\n\trGPR[_inst.RA] = rGPR[_inst.RS] | _inst.UIMM;\n}\n\nvoid Interpreter::oris(UGeckoInstruction _inst)\n{\n\trGPR[_inst.RA] = rGPR[_inst.RS] | (_inst.UIMM \u003c\u003c 16);\n}\n\nvoid Interpreter::subfic(UGeckoInstruction _inst)\n{\n/*\tu32 rra = ~rGPR[_inst.RA];\n\ts32 immediate = (s16)_inst.SIMM_16 + 1;\n\n//\t#define CALC_XER_CA(X,Y) (((X) + (Y) \u003c X) ? SET_XER_CA : CLEAR_XER_CA)\n\tif ((rra + immediate) \u003c rra)\n\t\tSetCarry(1);\n\telse\n\t\tSetCarry(0);\n\n\trGPR[_inst.RD] = rra - immediate;\n*/\n\n\ts32 immediate = _inst.SIMM_16;\n\trGPR[_inst.RD] = immediate - (int)rGPR[_inst.RA];\n\tSetCarry((rGPR[_inst.RA] == 0) || (Helper_Carry(0 - rGPR[_inst.RA], immediate)));\n}\n\nvoid Interpreter::twi(UGeckoInstruction _inst)\n{\n\ts32 a = rGPR[_inst.RA];\n\ts32 b = _inst.SIMM_16;\n\ts32 TO = _inst.TO;\n\n\tDEBUG_LOG(POWERPC, \"twi rA %x SIMM %x TO %0x\", a, b, TO);\n\n\tif (((a \u003c b) \u0026\u0026 (TO \u0026 0x10)) ||\n\t    ((a \u003e b) \u0026\u0026 (TO \u0026 0x08)) ||\n\t    ((a ==b) \u0026\u0026 (TO \u0026 0x04)) ||\n\t    (((u32)a \u003c(u32)b) \u0026\u0026 (TO \u0026 0x02)) ||\n\t    (((u32)a \u003e(u32)b) \u0026\u0026 (TO \u0026 0x01)))\n\t{\n\t\tPowerPC::ppcState.Exceptions |= EXCEPTION_PROGRAM;\n\t\tPowerPC::CheckExceptions();\n\t\tm_EndBlock = true; // Dunno about this\n\t}\n}\n\nvoid Interpreter::xori(UGeckoInstruction _inst)\n{\n\trGPR[_inst.RA] = rGPR[_inst.RS] ^ _inst.UIMM;\n}\n\nvoid Interpreter::xoris(UGeckoInstruction _inst)\n{\n\trGPR[_inst.RA] = rGPR[_inst.RS] ^ (_inst.UIMM \u003c\u003c 16);\n}\n\nvoid Interpreter::rlwimix(UGeckoInstruction _inst)\n{\n\tu32 mask = Helper_Mask(_inst.MB,_inst.ME);\n\trGPR[_inst.RA] = (rGPR[_inst.RA] \u0026 ~mask) | (_rotl(rGPR[_inst.RS],_inst.SH) \u0026 mask);\n\n\tif (_inst.Rc)\n\t\tHelper_UpdateCR0(rGPR[_inst.RA]);\n}\n\nvoid Interpreter::rlwinmx(UGeckoInstruction _inst)\n{\n\tu32 mask = Helper_Mask(_inst.MB,_inst.ME);\n\trGPR[_inst.RA] = _rotl(rGPR[_inst.RS],_inst.SH) \u0026 mask;\n\n\tif (_inst.Rc)\n\t\tHelper_UpdateCR0(rGPR[_inst.RA]);\n}\n\nvoid Interpreter::rlwnmx(UGeckoInstruction _inst)\n{\n\tu32 mask = Helper_Mask(_inst.MB,_inst.ME);\n\trGPR[_inst.RA] = _rotl(rGPR[_inst.RS], rGPR[_inst.RB] \u0026 0x1F) \u0026 mask;\n\n\tif (_inst.Rc)\n\t\tHelper_UpdateCR0(rGPR[_inst.RA]);\n}\n\nvoid Interpreter::andx(UGeckoInstruction _inst)\n{\n\trGPR[_inst.RA] = rGPR[_inst.RS] \u0026 rGPR[_inst.RB];\n\n\tif (_inst.Rc)\n\t\tHelper_UpdateCR0(rGPR[_inst.RA]);\n}\n\nvoid Interpreter::andcx(UGeckoInstruction _inst)\n{\n\trGPR[_inst.RA] = rGPR[_inst.RS] \u0026 ~rGPR[_inst.RB];\n\n\tif (_inst.Rc)\n\t\tHelper_UpdateCR0(rGPR[_inst.RA]);\n}\n\nvoid Interpreter::cmp(UGeckoInstruction _inst)\n{\n\ts32 a = (s32)rGPR[_inst.RA];\n\ts32 b = (s32)rGPR[_inst.RB];\n\tint fTemp;\n\n\tif (a \u003c b)\n\t\tfTemp = 0x8;\n\telse if (a \u003e b)\n\t\tfTemp = 0x4;\n\telse // Equals\n\t\tfTemp = 0x2;\n\n\tif (GetXER_SO())\n\t\tfTemp |= 0x1;\n\n\tSetCRField(_inst.CRFD, fTemp);\n}\n\nvoid Interpreter::cmpl(UGeckoInstruction _inst)\n{\n\tu32 a = rGPR[_inst.RA];\n\tu32 b = rGPR[_inst.RB];\n\tu32 fTemp;\n\n\tif (a \u003c b)\n\t\tfTemp = 0x8;\n\telse if (a \u003e b)\n\t\tfTemp = 0x4;\n\telse // Equals\n\t\tfTemp = 0x2;\n\n\tif (GetXER_SO())\n\t\tfTemp |= 0x1;\n\n\tSetCRField(_inst.CRFD, fTemp);\n}\n\nvoid Interpreter::cntlzwx(UGeckoInstruction _inst)\n{\n\tu32 val = rGPR[_inst.RS];\n\tu32 mask = 0x80000000;\n\n\tint i = 0;\n\tfor (; i \u003c 32; i++, mask \u003e\u003e= 1)\n\t{\n\t\tif (val \u0026 mask)\n\t\t\tbreak;\n\t}\n\n\trGPR[_inst.RA] = i;\n\n\tif (_inst.Rc)\n\t\tHelper_UpdateCR0(rGPR[_inst.RA]);\n}\n\nvoid Interpreter::eqvx(UGeckoInstruction _inst)\n{\n\trGPR[_inst.RA] = ~(rGPR[_inst.RS] ^ rGPR[_inst.RB]);\n\n\tif (_inst.Rc)\n\t\tHelper_UpdateCR0(rGPR[_inst.RA]);\n}\n\nvoid Interpreter::extsbx(UGeckoInstruction _inst)\n{\n\trGPR[_inst.RA] = (u32)(s32)(s8)rGPR[_inst.RS];\n\n\tif (_inst.Rc)\n\t\tHelper_UpdateCR0(rGPR[_inst.RA]);\n}\n\nvoid Interpreter::extshx(UGeckoInstruction _inst)\n{\n\trGPR[_inst.RA] = (u32)(s32)(s16)rGPR[_inst.RS];\n\n\tif (_inst.Rc)\n\t\tHelper_UpdateCR0(rGPR[_inst.RA]);\n}\n\nvoid Interpreter::nandx(UGeckoInstruction _inst)\n{\n\trGPR[_inst.RA] = ~(rGPR[_inst.RS] \u0026 rGPR[_inst.RB]);\n\n\tif (_inst.Rc)\n\t\tHelper_UpdateCR0(rGPR[_inst.RA]);\n}\n\nvoid Interpreter::norx(UGeckoInstruction _inst)\n{\n\trGPR[_inst.RA] = ~(rGPR[_inst.RS] | rGPR[_inst.RB]);\n\n\tif (_inst.Rc)\n\t\tHelper_UpdateCR0(rGPR[_inst.RA]);\n}\n\nvoid Interpreter::orx(UGeckoInstruction _inst)\n{\n\trGPR[_inst.RA] = rGPR[_inst.RS] | rGPR[_inst.RB];\n\n\tif (_inst.Rc)\n\t\tHelper_UpdateCR0(rGPR[_inst.RA]);\n}\n\nvoid Interpreter::orcx(UGeckoInstruction _inst)\n{\n\trGPR[_inst.RA] = rGPR[_inst.RS] | (~rGPR[_inst.RB]);\n\n\tif (_inst.Rc)\n\t\tHelper_UpdateCR0(rGPR[_inst.RA]);\n}\n\nvoid Interpreter::slwx(UGeckoInstruction _inst)\n{\n\tu32 amount = rGPR[_inst.RB];\n\trGPR[_inst.RA] = (amount \u0026 0x20) ? 0 : rGPR[_inst.RS] \u003c\u003c (amount \u0026 0x1f);\n\n\tif (_inst.Rc)\n\t\tHelper_UpdateCR0(rGPR[_inst.RA]);\n}\n\nvoid Interpreter::srawx(UGeckoInstruction _inst)\n{\n\tint rb = rGPR[_inst.RB];\n\n\tif (rb \u0026 0x20)\n\t{\n\t\tif (rGPR[_inst.RS] \u0026 0x80000000)\n\t\t{\n\t\t\trGPR[_inst.RA] = 0xFFFFFFFF;\n\t\t\tSetCarry(1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\trGPR[_inst.RA] = 0x00000000;\n\t\t\tSetCarry(0);\n\t\t}\n\t}\n\telse\n\t{\n\t\tint amount = rb \u0026 0x1f;\n\t\tif (amount == 0)\n\t\t{\n\t\t\trGPR[_inst.RA] = rGPR[_inst.RS];\n\t\t\tSetCarry(0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ts32 rrs = rGPR[_inst.RS];\n\t\t\trGPR[_inst.RA] = rrs \u003e\u003e amount;\n\n\t\t\tif ((rrs \u003c 0) \u0026\u0026 (rrs \u003c\u003c (32 - amount)))\n\t\t\t\tSetCarry(1);\n\t\t\telse\n\t\t\t\tSetCarry(0);\n\t\t}\n\t}\n\n\tif (_inst.Rc)\n\t\tHelper_UpdateCR0(rGPR[_inst.RA]);\n}\n\nvoid Interpreter::srawix(UGeckoInstruction _inst)\n{\n\tint amount = _inst.SH;\n\n\tif (amount != 0)\n\t{\n\t\ts32 rrs = rGPR[_inst.RS];\n\t\trGPR[_inst.RA] = rrs \u003e\u003e amount;\n\n\t\tif ((rrs \u003c 0) \u0026\u0026 (rrs \u003c\u003c (32 - amount)))\n\t\t\tSetCarry(1);\n\t\telse\n\t\t\tSetCarry(0);\n\t}\n\telse\n\t{\n\t\tSetCarry(0);\n\t\trGPR[_inst.RA] = rGPR[_inst.RS];\n\t}\n\n\tif (_inst.Rc)\n\t\tHelper_UpdateCR0(rGPR[_inst.RA]);\n}\n\nvoid Interpreter::srwx(UGeckoInstruction _inst)\n{\n\tu32 amount = rGPR[_inst.RB];\n\trGPR[_inst.RA] = (amount \u0026 0x20) ? 0 : (rGPR[_inst.RS] \u003e\u003e (amount \u0026 0x1f));\n\n\tif (_inst.Rc)\n\t\tHelper_UpdateCR0(rGPR[_inst.RA]);\n}\n\nvoid Interpreter::tw(UGeckoInstruction _inst)\n{\n\ts32 a = rGPR[_inst.RA];\n\ts32 b = rGPR[_inst.RB];\n\ts32 TO = _inst.TO;\n\n\tDEBUG_LOG(POWERPC, \"tw rA %0x rB %0x TO %0x\", a, b, TO);\n\n\tif (((a \u003c b) \u0026\u0026 (TO \u0026 0x10)) ||\n\t    ((a \u003e b) \u0026\u0026 (TO \u0026 0x08)) ||\n\t    ((a ==b) \u0026\u0026 (TO \u0026 0x04)) ||\n\t    (((u32)a \u003c(u32)b) \u0026\u0026 (TO \u0026 0x02)) ||\n\t    (((u32)a \u003e(u32)b) \u0026\u0026 (TO \u0026 0x01)))\n\t{\n\t\tPowerPC::ppcState.Exceptions |= EXCEPTION_PROGRAM;\n\t\tPowerPC::CheckExceptions();\n\t\tm_EndBlock = true; // Dunno about this\n\t}\n}\n\nvoid Interpreter::xorx(UGeckoInstruction _inst)\n{\n\trGPR[_inst.RA] = rGPR[_inst.RS] ^ rGPR[_inst.RB];\n\n\tif (_inst.Rc)\n\t\tHelper_UpdateCR0(rGPR[_inst.RA]);\n}\n\nvoid Interpreter::addx(UGeckoInstruction _inst)\n{\n\trGPR[_inst.RD] = rGPR[_inst.RA] + rGPR[_inst.RB];\n\n\tif (_inst.OE)\n\t\tPanicAlert(\"OE: addx\");\n\n\tif (_inst.Rc)\n\t\tHelper_UpdateCR0(rGPR[_inst.RD]);\n}\n\nvoid Interpreter::addcx(UGeckoInstruction _inst)\n{\n\tu32 a = rGPR[_inst.RA];\n\tu32 b = rGPR[_inst.RB];\n\trGPR[_inst.RD] = a + b;\n\tSetCarry(Helper_Carry(a,b));\n\n\tif (_inst.OE)\n\t\tPanicAlert(\"OE: addcx\");\n\n\tif (_inst.Rc)\n\t\tHelper_UpdateCR0(rGPR[_inst.RD]);\n}\n\nvoid Interpreter::addex(UGeckoInstruction _inst)\n{\n\tint carry = GetCarry();\n\tint a = rGPR[_inst.RA];\n\tint b = rGPR[_inst.RB];\n\trGPR[_inst.RD] = a + b + carry;\n\tSetCarry(Helper_Carry(a, b) || (carry != 0 \u0026\u0026 Helper_Carry(a + b, carry)));\n\n\tif (_inst.OE)\n\t\tPanicAlert(\"OE: addex\");\n\n\tif (_inst.Rc)\n\t\tHelper_UpdateCR0(rGPR[_inst.RD]);\n}\n\nvoid Interpreter::addmex(UGeckoInstruction _inst)\n{\n\tint carry = GetCarry();\n\tint a = rGPR[_inst.RA];\n\trGPR[_inst.RD] = a + carry - 1;\n\tSetCarry(Helper_Carry(a, carry - 1));\n\n\tif (_inst.OE)\n\t\tPanicAlert(\"OE: addmex\");\n\n\tif (_inst.Rc)\n\t\tHelper_UpdateCR0(rGPR[_inst.RD]);\n}\n\nvoid Interpreter::addzex(UGeckoInstruction _inst)\n{\n\tint carry = GetCarry();\n\tint a = rGPR[_inst.RA];\n\trGPR[_inst.RD] = a + carry;\n\tSetCarry(Helper_Carry(a, carry));\n\n\tif (_inst.OE)\n\t\tPanicAlert(\"OE: addzex\");\n\n\tif (_inst.Rc)\n\t\tHelper_UpdateCR0(rGPR[_inst.RD]);\n}\n\nvoid Interpreter::divwx(UGeckoInstruction _inst)\n{\n\ts32 a = rGPR[_inst.RA];\n\ts32 b = rGPR[_inst.RB];\n\n\tif (b == 0 || ((u32)a == 0x80000000 \u0026\u0026 b == -1))\n\t{\n\t\tif (_inst.OE)\n\t\t{\n\t\t\t// should set OV\n\t\t\tPanicAlert(\"OE: divwx\");\n\t\t}\n\n\t\tif (((u32)a \u0026 0x80000000) \u0026\u0026 b == 0)\n\t\t\trGPR[_inst.RD] = -1;\n\t\telse\n\t\t\trGPR[_inst.RD] = 0;\n\t}\n\telse\n\t{\n\t\trGPR[_inst.RD] = (u32)(a / b);\n\t}\n\n\tif (_inst.Rc)\n\t\tHelper_UpdateCR0(rGPR[_inst.RD]);\n}\n\n\nvoid Interpreter::divwux(UGeckoInstruction _inst)\n{\n\tu32 a = rGPR[_inst.RA];\n\tu32 b = rGPR[_inst.RB];\n\n\tif (b == 0)\n\t{\n\t\tif (_inst.OE)\n\t\t{\n\t\t\t// should set OV\n\t\t\tPanicAlert(\"OE: divwux\");\n\t\t}\n\n\t\trGPR[_inst.RD] = 0;\n\t}\n\telse\n\t{\n\t\trGPR[_inst.RD] = a / b;\n\t}\n\n\tif (_inst.Rc)\n\t\tHelper_UpdateCR0(rGPR[_inst.RD]);\n}\n\nvoid Interpreter::mulhwx(UGeckoInstruction _inst)\n{\n\tu32 a = rGPR[_inst.RA];\n\tu32 b = rGPR[_inst.RB];\n\tu32 d = (u32)((u64)(((s64)(s32)a * (s64)(s32)b) ) \u003e\u003e 32);  // This can be done better. Not in plain C/C++ though.\n\trGPR[_inst.RD] = d;\n\n\tif (_inst.Rc)\n\t\tHelper_UpdateCR0(rGPR[_inst.RD]);\n}\n\nvoid Interpreter::mulhwux(UGeckoInstruction _inst)\n{\n\tu32 a = rGPR[_inst.RA];\n\tu32 b = rGPR[_inst.RB];\n\tu32 d = (u32)(((u64)a * (u64)b) \u003e\u003e 32);\n\trGPR[_inst.RD] = d;\n\n\tif (_inst.Rc)\n\t\tHelper_UpdateCR0(rGPR[_inst.RD]);\n}\n\nvoid Interpreter::mullwx(UGeckoInstruction _inst)\n{\n\tu32 a = rGPR[_inst.RA];\n\tu32 b = rGPR[_inst.RB];\n\tu32 d = (u32)((s32)a * (s32)b);\n\trGPR[_inst.RD] = d;\n\n\tif (_inst.OE)\n\t\tPanicAlert(\"OE: mullwx\");\n\n\tif (_inst.Rc)\n\t\tHelper_UpdateCR0(rGPR[_inst.RD]);\n}\n\nvoid Interpreter::negx(UGeckoInstruction _inst)\n{\n\trGPR[_inst.RD] = (~rGPR[_inst.RA]) + 1;\n\n\tif (rGPR[_inst.RD] == 0x80000000)\n\t{\n\t\tif (_inst.OE)\n\t\t\tPanicAlert(\"OE: negx\");\n\t}\n\n\tif (_inst.Rc)\n\t\tHelper_UpdateCR0(rGPR[_inst.RD]);\n}\n\nvoid Interpreter::subfx(UGeckoInstruction _inst)\n{\n\trGPR[_inst.RD] = rGPR[_inst.RB] - rGPR[_inst.RA];\n\n\tif (_inst.OE)\n\t\tPanicAlert(\"OE: subfx\");\n\n\tif (_inst.Rc)\n\t\tHelper_UpdateCR0(rGPR[_inst.RD]);\n}\n\nvoid Interpreter::subfcx(UGeckoInstruction _inst)\n{\n\tu32 a = rGPR[_inst.RA];\n\tu32 b = rGPR[_inst.RB];\n\trGPR[_inst.RD] = b - a;\n\tSetCarry(a == 0 || Helper_Carry(b, 0-a));\n\n\tif (_inst.OE)\n\t\tPanicAlert(\"OE: subfcx\");\n\n\tif (_inst.Rc)\n\t\tHelper_UpdateCR0(rGPR[_inst.RD]);\n}\n\nvoid Interpreter::subfex(UGeckoInstruction _inst)\n{\n\tu32 a = rGPR[_inst.RA];\n\tu32 b = rGPR[_inst.RB];\n\tint carry = GetCarry();\n\trGPR[_inst.RD] = (~a) + b + carry;\n\tSetCarry(Helper_Carry(~a, b) || Helper_Carry((~a) + b, carry));\n\n\tif (_inst.OE)\n\t\tPanicAlert(\"OE: subfex\");\n\n\tif (_inst.Rc)\n\t\tHelper_UpdateCR0(rGPR[_inst.RD]);\n}\n\n// sub from minus one\nvoid Interpreter::subfmex(UGeckoInstruction _inst)\n{\n\tu32 a = rGPR[_inst.RA];\n\tint carry = GetCarry();\n\trGPR[_inst.RD] = (~a) + carry - 1;\n\tSetCarry(Helper_Carry(~a, carry - 1));\n\n\tif (_inst.OE)\n\t\tPanicAlert(\"OE: subfmex\");\n\n\tif (_inst.Rc)\n\t\tHelper_UpdateCR0(rGPR[_inst.RD]);\n}\n\n// sub from zero\nvoid Interpreter::subfzex(UGeckoInstruction _inst)\n{\n\tu32 a = rGPR[_inst.RA];\n\tint carry = GetCarry();\n\trGPR[_inst.RD] = (~a) + carry;\n\tSetCarry(Helper_Carry(~a, carry));\n\n\tif (_inst.OE)\n\t\tPanicAlert(\"OE: subfzex\");\n\n\tif (_inst.Rc)\n\t\tHelper_UpdateCR0(rGPR[_inst.RD]);\n}\n"}
{"repo_name":"brunolauze/MonoNative","ref":"refs/heads/master","path":"MonoNative/mscorlib/System/Runtime/Remoting/Metadata/W3cXsd2001/mscorlib_System_Runtime_Remoting_Metadata_W3cXsd2001_SoapNmtoken.cpp","copies":"1","language":"C++","content":"#include \u003cmscorlib/System/Runtime/Remoting/Metadata/W3cXsd2001/mscorlib_System_Runtime_Remoting_Metadata_W3cXsd2001_SoapNmtoken.h\u003e\n#include \u003cmscorlib/System/mscorlib_System_Type.h\u003e\n\n\n\nnamespace mscorlib\n{\n\tnamespace System\n\t{\n\t\tnamespace Runtime\n\t\t{\n\t\t\tnamespace Remoting\n\t\t\t{\n\t\t\t\tnamespace Metadata\n\t\t\t\t{\n\t\t\t\t\tnamespace W3cXsd2001\n\t\t\t\t\t{\n\n\t\t\t\t\t\tProperty\u003cmscorlib::System::String , mscorlib::System::Runtime::Remoting::Metadata::W3cXsd2001::SoapNmtoken\u003e mscorlib::System::Runtime::Remoting::Metadata::W3cXsd2001::SoapNmtoken::XsdType(\u0026mscorlib::System::Runtime::Remoting::Metadata::W3cXsd2001::SoapNmtoken::get_XsdType, \u0026mscorlib::System::Runtime::Remoting::Metadata::W3cXsd2001::SoapNmtoken::set_XsdType);\n\t\t\t\t\t\t//Public Methods\n\t\t\t\t\t\tmscorlib::System::String SoapNmtoken::GetXsdType()\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tMonoObject *__result__ = Global::InvokeMethod(\"mscorlib\", \"System.Runtime.Remoting.Metadata.W3cXsd2001\", \"SoapNmtoken\", 0, NULL, \"GetXsdType\", __native_object__, 0, NULL, NULL, NULL);\n\t\t\t\t\t\t\t\treturn mscorlib::System::String(__result__);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmscorlib::System::Runtime::Remoting::Metadata::W3cXsd2001::SoapNmtoken SoapNmtoken::Parse(mscorlib::System::String value)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tMonoType *__parameter_types__[1];\n\t\t\t\t\t\t\t\tvoid *__parameters__[1];\n\t\t\t\t\t\t\t\t__parameter_types__[0] = Global::GetType(typeid(value).name());\n\t\t\t\t\t\t\t\t__parameters__[0] = (MonoObject*)value;\n\t\t\t\t\t\t\t\tMonoObject *__result__ = Global::InvokeMethod(\"mscorlib\", \"System.Runtime.Remoting.Metadata.W3cXsd2001\", \"SoapNmtoken\", 0, NULL, \"Parse\", NullMonoObject, 1, __parameter_types__, __parameters__, NULL);\n\t\t\t\t\t\t\t\treturn mscorlib::System::Runtime::Remoting::Metadata::W3cXsd2001::SoapNmtoken(__result__);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmscorlib::System::Runtime::Remoting::Metadata::W3cXsd2001::SoapNmtoken SoapNmtoken::Parse(const char *value)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tMonoType *__parameter_types__[1];\n\t\t\t\t\t\t\t\tvoid *__parameters__[1];\n\t\t\t\t\t\t\t\t__parameter_types__[0] = Global::GetType(\"mscorlib\", \"System\", \"String\");\n\t\t\t\t\t\t\t\t__parameters__[0] = mono_string_new(Global::GetDomain(), value);\n\t\t\t\t\t\t\t\tMonoObject *__result__ = Global::InvokeMethod(\"mscorlib\", \"System.Runtime.Remoting.Metadata.W3cXsd2001\", \"SoapNmtoken\", 0, NULL, \"Parse\", NullMonoObject, 1, __parameter_types__, __parameters__, NULL);\n\t\t\t\t\t\t\t\treturn mscorlib::System::Runtime::Remoting::Metadata::W3cXsd2001::SoapNmtoken(__result__);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmscorlib::System::String SoapNmtoken::ToString()\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tMonoObject *__result__ = Global::InvokeMethod(\"mscorlib\", \"System.Runtime.Remoting.Metadata.W3cXsd2001\", \"SoapNmtoken\", 0, NULL, \"ToString\", __native_object__, 0, NULL, NULL, NULL);\n\t\t\t\t\t\t\t\treturn mscorlib::System::String(__result__);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//Get Set Properties Methods\n\t\t\t\t\t\t//\tGet/Set:Value\n\t\t\t\t\t\tmscorlib::System::String  SoapNmtoken::get_Value() const\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tMonoObject *__result__ = Global::InvokeMethod(\"mscorlib\", \"System.Runtime.Remoting.Metadata.W3cXsd2001\", \"SoapNmtoken\", 0, NULL, \"get_Value\", __native_object__, 0, NULL, NULL, NULL);\n\t\t\t\t\t\t\treturn mscorlib::System::String(__result__);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvoid SoapNmtoken::set_Value(mscorlib::System::String  value)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tMonoType *__parameter_types__[1];\n\t\t\t\t\t\t\tvoid *__parameters__[1];\n\t\t\t\t\t\t\t__parameter_types__[0] = Global::GetType(typeid(value).name());\n\t\t\t\t\t\t\t__parameters__[0] = (MonoObject*)value;\n\t\t\t\t\t\t\tGlobal::InvokeMethod(\"mscorlib\", \"System.Runtime.Remoting.Metadata.W3cXsd2001\", \"SoapNmtoken\", 0, NULL, \"set_Value\", __native_object__, 1, __parameter_types__, __parameters__, NULL);\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\t//Get Set Static Properties Methods\n\t\t\t\t\t\t//\tGet:XsdType\n\t\t\t\t\t\tmscorlib::System::String  SoapNmtoken::get_XsdType()\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tMonoObject *__result__ = Global::InvokeMethod(\"mscorlib\", \"System.Runtime.Remoting.Metadata.W3cXsd2001\", \"SoapNmtoken\", 0, NULL, \"get_XsdType\", NullMonoObject, 0, NULL, NULL, NULL);\n\t\t\t\t\t\t\treturn mscorlib::System::String(__result__);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvoid SoapNmtoken::set_XsdType(mscorlib::System::String  value)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthrow;\n\t\t\t\t\t\t}\n\n\n\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n"}
{"repo_name":"cesarmarinhorj/phantomjs","ref":"refs/heads/master","path":"src/qt/qtwebkit/Source/WTF/wtf/text/Base64.cpp","copies":"124","language":"C++","content":"/*\n   Copyright (C) 2000-2001 Dawit Alemayehu \u003cadawit@kde.org\u003e\n   Copyright (C) 2006 Alexey Proskuryakov \u003cap@webkit.org\u003e\n   Copyright (C) 2007, 2008 Apple Inc. All rights reserved.\n   Copyright (C) 2010 Patrick Gansterer \u003cparoga@paroga.com\u003e\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU Lesser General Public License (LGPL)\n   version 2 as published by the Free Software Foundation.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU Library General Public\n   License along with this program; if not, write to the Free Software\n   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n\n   This code is based on the java implementation in HTTPClient\n   package by Ronald Tschalär Copyright (C) 1996-1999.\n*/\n\n#include \"config.h\"\n#include \"Base64.h\"\n\n#include \u003climits.h\u003e\n#include \u003cwtf/StringExtras.h\u003e\n#include \u003cwtf/text/WTFString.h\u003e\n\nnamespace WTF {\n\nstatic const char base64EncMap[64] = {\n    0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48,\n    0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50,\n    0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58,\n    0x59, 0x5A, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66,\n    0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E,\n    0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76,\n    0x77, 0x78, 0x79, 0x7A, 0x30, 0x31, 0x32, 0x33,\n    0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x2B, 0x2F\n};\n\nstatic const char base64DecMap[128] = {\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x3E, 0x00, 0x00, 0x00, 0x3F,\n    0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B,\n    0x3C, 0x3D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06,\n    0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E,\n    0x0F, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16,\n    0x17, 0x18, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20,\n    0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28,\n    0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30,\n    0x31, 0x32, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00\n};\n\nString base64Encode(const char* data, unsigned length, Base64EncodePolicy policy)\n{\n    Vector\u003cchar\u003e result;\n    base64Encode(data, length, result, policy);\n    return String(result.data(), result.size());\n}\n\nvoid base64Encode(const char* data, unsigned len, Vector\u003cchar\u003e\u0026 out, Base64EncodePolicy policy)\n{\n    out.clear();\n    if (!len)\n        return;\n\n    // If the input string is pathologically large, just return nothing.\n    // Note: Keep this in sync with the \"outLength\" computation below.\n    // Rather than being perfectly precise, this is a bit conservative.\n    const unsigned maxInputBufferSize = UINT_MAX / 77 * 76 / 4 * 3 - 2;\n    if (len \u003e maxInputBufferSize)\n        return;\n\n    unsigned sidx = 0;\n    unsigned didx = 0;\n\n    unsigned outLength = ((len + 2) / 3) * 4;\n\n    // Deal with the 76 character per line limit specified in RFC 2045.\n    bool insertLFs = (policy == Base64InsertLFs \u0026\u0026 outLength \u003e 76);\n    if (insertLFs)\n        outLength += ((outLength - 1) / 76);\n\n    int count = 0;\n    out.grow(outLength);\n\n    // 3-byte to 4-byte conversion + 0-63 to ascii printable conversion\n    if (len \u003e 1) {\n        while (sidx \u003c len - 2) {\n            if (insertLFs) {\n                if (count \u0026\u0026 !(count % 76))\n                    out[didx++] = '\\n';\n                count += 4;\n            }\n            out[didx++] = base64EncMap[(data[sidx] \u003e\u003e 2) \u0026 077];\n            out[didx++] = base64EncMap[((data[sidx + 1] \u003e\u003e 4) \u0026 017) | ((data[sidx] \u003c\u003c 4) \u0026 077)];\n            out[didx++] = base64EncMap[((data[sidx + 2] \u003e\u003e 6) \u0026 003) | ((data[sidx + 1] \u003c\u003c 2) \u0026 077)];\n            out[didx++] = base64EncMap[data[sidx + 2] \u0026 077];\n            sidx += 3;\n        }\n    }\n\n    if (sidx \u003c len) {\n        if (insertLFs \u0026\u0026 (count \u003e 0) \u0026\u0026 !(count % 76))\n           out[didx++] = '\\n';\n\n        out[didx++] = base64EncMap[(data[sidx] \u003e\u003e 2) \u0026 077];\n        if (sidx \u003c len - 1) {\n            out[didx++] = base64EncMap[((data[sidx + 1] \u003e\u003e 4) \u0026 017) | ((data[sidx] \u003c\u003c 4) \u0026 077)];\n            out[didx++] = base64EncMap[(data[sidx + 1] \u003c\u003c 2) \u0026 077];\n        } else\n            out[didx++] = base64EncMap[(data[sidx] \u003c\u003c 4) \u0026 077];\n    }\n\n    // Add padding\n    while (didx \u003c out.size()) {\n        out[didx] = '=';\n        ++didx;\n    }\n}\n\nbool base64Decode(const Vector\u003cchar\u003e\u0026 in, Vector\u003cchar\u003e\u0026 out, Base64DecodePolicy policy)\n{\n    out.clear();\n\n    // If the input string is pathologically large, just return nothing.\n    if (in.size() \u003e UINT_MAX)\n        return false;\n\n    return base64Decode(in.data(), in.size(), out, policy);\n}\n\ntemplate\u003ctypename T\u003e\nstatic inline bool base64DecodeInternal(const T* data, unsigned len, Vector\u003cchar\u003e\u0026 out, Base64DecodePolicy policy)\n{\n    out.clear();\n    if (!len)\n        return true;\n\n    out.grow(len);\n\n    bool sawEqualsSign = false;\n    unsigned outLength = 0;\n    for (unsigned idx = 0; idx \u003c len; ++idx) {\n        unsigned ch = data[idx];\n        if (ch == '=')\n            sawEqualsSign = true;\n        else if (('0' \u003c= ch \u0026\u0026 ch \u003c= '9') || ('A' \u003c= ch \u0026\u0026 ch \u003c= 'Z') || ('a' \u003c= ch \u0026\u0026 ch \u003c= 'z') || ch == '+' || ch == '/') {\n            if (sawEqualsSign)\n                return false;\n            out[outLength] = base64DecMap[ch];\n            ++outLength;\n        } else if (policy == Base64FailOnInvalidCharacter || (policy == Base64IgnoreWhitespace \u0026\u0026 !isSpaceOrNewline(ch)))\n            return false;\n    }\n\n    if (!outLength)\n        return !sawEqualsSign;\n\n    // Valid data is (n * 4 + [0,2,3]) characters long.\n    if ((outLength % 4) == 1)\n        return false;\n    \n    // 4-byte to 3-byte conversion\n    outLength -= (outLength + 3) / 4;\n    if (!outLength)\n        return false;\n\n    unsigned sidx = 0;\n    unsigned didx = 0;\n    if (outLength \u003e 1) {\n        while (didx \u003c outLength - 2) {\n            out[didx] = (((out[sidx] \u003c\u003c 2) \u0026 255) | ((out[sidx + 1] \u003e\u003e 4) \u0026 003));\n            out[didx + 1] = (((out[sidx + 1] \u003c\u003c 4) \u0026 255) | ((out[sidx + 2] \u003e\u003e 2) \u0026 017));\n            out[didx + 2] = (((out[sidx + 2] \u003c\u003c 6) \u0026 255) | (out[sidx + 3] \u0026 077));\n            sidx += 4;\n            didx += 3;\n        }\n    }\n\n    if (didx \u003c outLength)\n        out[didx] = (((out[sidx] \u003c\u003c 2) \u0026 255) | ((out[sidx + 1] \u003e\u003e 4) \u0026 003));\n\n    if (++didx \u003c outLength)\n        out[didx] = (((out[sidx + 1] \u003c\u003c 4) \u0026 255) | ((out[sidx + 2] \u003e\u003e 2) \u0026 017));\n\n    if (outLength \u003c out.size())\n        out.shrink(outLength);\n\n    return true;\n}\n\nbool base64Decode(const char* data, unsigned len, Vector\u003cchar\u003e\u0026 out, Base64DecodePolicy policy)\n{\n    return base64DecodeInternal\u003cchar\u003e(data, len, out, policy);\n}\n\nbool base64Decode(const String\u0026 in, Vector\u003cchar\u003e\u0026 out, Base64DecodePolicy policy)\n{\n    return base64DecodeInternal\u003cUChar\u003e(in.characters(), in.length(), out, policy);\n}\n\n} // namespace WTF\n"}
{"repo_name":"SuperHex/psychic-aero","ref":"refs/heads/master","path":"base/HAL.cpp","copies":"1","language":"C++","content":"/* Hardware Abstract Layer */\n\n#ifndef __HAL__\n#define __HAL__\n\n#include ../config/config.h\n#include \u003cavr/io.h\u003e\n\nnamespace base\n{\n    template\u003c class init_traits, class rw_traits \u003e\n    struct hal\n    {\n        typedef init_traits I;\n        typedef rw_traits   RW;\n    public:\n        hal(){ I::init(); }\n        virtual ~hal();\n        virtual void write(const unsigned char data)\n        {\n            RW::write(data);\n        }\n        virtual unsigned char read ()\n        {\n            return RW::read();\n        }\n    };\n\n    struct skip_init{ static void init() {} };\n\n    struct USART_default_init\n    {\n        static void init(const long baudRate)\n        {\n            long ubrr = F_CPU / 16 / baudRate - 1;\n\n            // Set baud rate\n            UBRR0H = ubrr \u003e\u003e 8;\n            UBRR0L = ubrr;\n\n            // Enable receiver and transmitter\n            UCSR0B = (1 \u003c\u003c RXEN0) | (1 \u003c\u003c TXEN0);\n\n            // Set frame format: 8 data, 1 stop bit, no parity check.\n            // For a custom setting, please refer Atmel Datasheet page 195\n            UCSR0C = (3 \u003c\u003c UCSZ00);\n        }\n    };\n\n    struct USART_8N1_RW\n    {\n    public:\n        static void write(const unsigned char data)\n        {\n            // Wait until buffer empty\n            while (!(UCSR0A \u0026 (1 \u003c\u003c UDRE0)));\n            // load and send\n            UDR0 = data;\n        }\n\n        static unsigned char read()\n        {\n            // Wait until buffer empty\n            while (!(UCSR0A \u0026 (1 \u003c\u003c RXC0)));\n            return UDR0;\n        }\n    };\n\n    struct SPI_RW\n    {\n        static void write(unsigned char data)\n        {\n            // To start a SPI transmission, simply feed data into SPI Data Register\n            SPDR = data;\n            // Wait until transmission complete\n            while (!(SPSR \u0026 (1 \u003c\u003c SPIF)));\n        }\n\n        static unsigned char read()\n        {\n            // Wait until receive complete\n            while (!(SPSR \u0026 (1 \u003c\u003c SPIF)));\n            return SPDR;\n        }\n    };\n\n    struct SPI_master_init\n    {\n        static void init()\n        {\n            DDRB |= (1 \u003c\u003c PB3)   // set MOSI as output\n                 |  (1 \u003c\u003c PB5)   // set SCK  as output\n                 |  (1 \u003c\u003c PB2);  // set SS'  as output since we have only one slave\n            SPCR  = (1 \u003c\u003c SPE)   // enable SPI\n                 |  (1 \u003c\u003c MSTR)  // set SPI as master\n                 |  (1 \u003c\u003c SPR0); // set clock as F_CPU / 16\n        }\n    };\n\n    struct SPI_slave_init\n    {\n        static void init()\n        {\n            DDRB |= (1 \u003c\u003c PB4);  // set MISO as output, all other as input\n            SPCR  = (1 \u003c\u003c SPE);  // enable SPI\n        }\n    };\n\n    template\u003c class T = USART_default_init \u003e\n    struct USART : public hal\u003c skip_init, USART_8N1_RW \u003e\n    {\n    public:\n        USART(const long Rate){ T::init(Rate); }\n        virtual ~USART();\n    };\n    typedef USART\u003c \u003e Serial;\n\n    template\u003c class T \u003e\n    struct SPI : public hal\u003c T, SPI_RW \u003e {};\n    typedef SPI\u003c SPI_master_init \u003e SPIMaster;\n    typedef SPI\u003c SPI_slave_init \u003e  SPISlave;\n\n}\n\n#endif\n"}
{"repo_name":"kingvuplus/enigma2","ref":"refs/heads/master","path":"lib/gui/einputstring.cpp","copies":"170","language":"C++","content":"#include \u003clib/gui/einputstring.h\u003e\n\nDEFINE_REF(eInputContentString);\n\neInputContentString::eInputContentString()\n{\n\tm_string = \"bla\";\n\tm_cursor = 0;\n\tm_input = 0;\n\tm_len = m_string.size();\n}\n\nvoid eInputContentString::getDisplay(std::string \u0026res, int \u0026cursor)\n{\n\tres = m_string;\n\tcursor = m_cursor;\n}\n\nvoid eInputContentString::moveCursor(int dir)\n{\n\tint old_cursor = m_cursor;\n\n\tswitch (dir)\n\t{\n\tcase dirLeft:\n\t\t--m_cursor;\n\t\tbreak;\n\tcase dirRight:\n\t\t++m_cursor;\n\t\tbreak;\n\tcase dirHome:\n\t\tm_cursor = 0;\n\t\tbreak;\n\tcase dirEnd:\n\t\tm_cursor = m_len;\n\t\tbreak;\n\t}\n\n\tif (m_cursor \u003c 0)\n\t\tm_cursor = 0;\n\tif (m_cursor \u003e m_len)\n\t\tm_cursor = m_len;\n\n\tif (m_cursor != old_cursor)\n\t\tif (m_input)\n\t\t\tm_input-\u003einvalidate();\n}\n\nint eInputContentString::haveKey(int code, int overwrite)\n{\n\tint have_char = -1;\n\n\tif (code \u003e= 0x8020)\n\t\thave_char = code \u0026~ 0x8000;\n\n\tif (have_char != -1)\n\t{\n\t\tif (overwrite \u0026\u0026 m_cursor \u003c m_len)\n\t\t\tm_string[m_cursor] = have_char;\n\t\telse\n\t\t{\n\t\t\tm_string.insert(m_cursor, 1, have_char);\n\t\t\t++m_len;\n\t\t}\n\n\t\tm_cursor++;\n\n\t\tASSERT(m_cursor \u003c= m_len);\n\n\t\tif (m_input)\n\t\t\tm_input-\u003einvalidate();\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nvoid eInputContentString::deleteChar(int dir)\n{\n\tif (dir == deleteForward)\n\t{\n\t\teDebug(\"forward\");\n\t\tif (m_cursor != m_len)\n\t\t\t++m_cursor;\n\t\telse\n\t\t\treturn;\n\t}\n\t\t/* backward delete at begin */\n\tif (!m_cursor)\n\t\treturn;\n\n\tif (!m_len)\n\t\treturn;\n\n\tm_string.erase(m_cursor - 1, m_cursor);\n\n\tm_len--;\n\tm_cursor--;\n\n\tif (m_input)\n\t\tm_input-\u003einvalidate();\n}\n\nint eInputContentString::isValid()\n{\n\treturn 1;\n}\n\nvoid eInputContentString::validate()\n{\n}\n\nvoid eInputContentString::setText(const std::string \u0026str)\n{\n\tm_string = str;\n\tm_len = m_string.size();\n\tif (m_cursor \u003e m_len)\n\t\tm_cursor = m_len;\n\n\tif (m_input)\n\t\tm_input-\u003einvalidate();\n}\n\nstd::string eInputContentString::getText()\n{\n\treturn m_string;\n}\n"}
{"repo_name":"CharlieMarshall/xbmc","ref":"refs/heads/master","path":"xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitleTagMicroDVD.cpp","copies":"9","language":"C++","content":"/*\n *      Copyright (C) 2005-2013 Team XBMC\n *      http://xbmc.org\n *\n *  This Program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  This Program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with XBMC; see the file COPYING.  If not, see\n *  \u003chttp://www.gnu.org/licenses/\u003e.\n *\n */\n\n#include \"DVDSubtitleTagMicroDVD.h\"\n#include \"DVDCodecs/Overlay/DVDOverlayText.h\"\n#include \"utils/StdString.h\"\n#include \"utils/StringUtils.h\"\n\nvoid CDVDSubtitleTagMicroDVD::ConvertLine(CDVDOverlayText* pOverlay, const char* line, int len)\n{\n  CStdString strUTF8;\n  strUTF8.assign(line, len);\n\n  m_flag[FLAG_BOLD] = 0;\n  m_flag[FLAG_ITALIC] = 0;\n  m_flag[FLAG_COLOR] = 0;\n\n  int machine_status = 1;\n  size_t pos = 0;\n\n  while (machine_status \u003e 0)\n  {\n    if (machine_status == 1)\n    {\n      if (strUTF8[pos] == '{')\n      {\n        size_t pos2, pos3;\n        if (((pos2 = strUTF8.find(':', pos)) != CStdString::npos) \u0026\u0026 \\\n           ((pos3 = strUTF8.find('}', pos2)) != CStdString::npos))\n        {\n          CStdString tagName = strUTF8.substr(pos + 1, pos2 - pos - 1);\n          CStdString tagValue = strUTF8.substr(pos2 + 1, pos3 - pos2 - 1);\n          StringUtils::ToLower(tagValue);\n          strUTF8.erase(pos, pos3 - pos + 1);\n          if ((tagName == \"Y\") || (tagName == \"y\"))\n          {\n            if ((tagValue == \"b\") \u0026\u0026 (m_flag[FLAG_BOLD] == 0))\n            {\n              m_flag[FLAG_BOLD] = (tagName == \"Y\")?TAG_ALL_LINE:TAG_ONE_LINE;\n              strUTF8.insert(pos, \"[B]\");\n              pos += 3;\n            }\n            else if ((tagValue == \"i\") \u0026\u0026 (m_flag[FLAG_ITALIC] == 0))\n            {\n              m_flag[FLAG_ITALIC] = (tagName == \"Y\")?TAG_ALL_LINE:TAG_ONE_LINE;\n              strUTF8.insert(pos, \"[I]\");\n              pos += 3;\n            }\n          }\n          else if ((tagName == \"C\") || (tagName == \"c\"))\n          {\n            if ((tagValue[0] == '$') \u0026\u0026 (tagValue.size() == 7))\n            {\n              bool bHex = true;\n              for( int i=1 ; i\u003c7 ; i++ )\n              {\n                char temp = tagValue[i];\n                if( !(('0' \u003c= temp \u0026\u0026 temp \u003c= '9') ||\n                  ('a' \u003c= temp \u0026\u0026 temp \u003c= 'f') ||\n                  ('A' \u003c= temp \u0026\u0026 temp \u003c= 'F') ))\n                {\n                  bHex = false;\n                  break;\n                }\n              }\n              if( bHex \u0026\u0026 (m_flag[FLAG_COLOR] == 0))\n              {\n                CStdString tempColorTag = \"[COLOR \";\n                tempColorTag += \"FF\";\n                tempColorTag += tagValue.substr(1, 6);\n                tempColorTag += \"]\";\n                m_flag[FLAG_COLOR] = (tagName == \"C\")?TAG_ALL_LINE:TAG_ONE_LINE;\n                strUTF8.insert(pos, tempColorTag);\n                pos += tempColorTag.length();\n              }\n            }\n          }\n        }\n        else\n          machine_status = 2;\n      }\n      else if (strUTF8[pos] == '/')\n      {\n        if (m_flag[FLAG_ITALIC] == 0)\n        {\n          m_flag[FLAG_ITALIC] = TAG_ONE_LINE;\n          strUTF8.replace(pos, 1, \"[I]\");\n          pos += 3;\n        }\n        else\n          strUTF8.erase(pos, 1);\n      }\n      else\n        machine_status = 2;\n    }\n    else if (machine_status == 2)\n    {\n      size_t pos4;\n      if ((pos4= strUTF8.find('|', pos)) != CStdString::npos)\n      {\n        pos = pos4;\n        if (m_flag[FLAG_BOLD] == TAG_ONE_LINE)\n        {\n          m_flag[FLAG_BOLD] = 0;\n          strUTF8.insert(pos, \"[/B]\");\n          pos += 4;\n        }\n        if (m_flag[FLAG_ITALIC] == TAG_ONE_LINE)\n        {\n          m_flag[FLAG_ITALIC] = 0;\n          strUTF8.insert(pos, \"[/I]\");\n          pos += 4;\n        }\n        if (m_flag[FLAG_COLOR] == TAG_ONE_LINE)\n        {\n          m_flag[FLAG_COLOR] = 0;\n          strUTF8.insert(pos, \"[/COLOR]\");\n          pos += 8;\n        }\n        strUTF8.replace(pos, 1, \"[CR]\");\n        pos += 4;\n        machine_status = 1;\n      }\n      else\n      {\n        if (m_flag[FLAG_BOLD] != 0)\n          strUTF8.append(\"[/B]\");\n        if (m_flag[FLAG_ITALIC] != 0)\n          strUTF8.append(\"[/I]\");\n        if (m_flag[FLAG_COLOR] != 0)\n          strUTF8.append(\"[/COLOR]\");\n        machine_status = 0;\n      }\n    }\n  }\n    \n  if (strUTF8.empty())\n    return;\n\n  if( strUTF8[strUTF8.size()-1] == '\\n' )\n    strUTF8.erase(strUTF8.size()-1);\n\n  // add a new text element to our container\n  pOverlay-\u003eAddElement(new CDVDOverlayText::CElementText(strUTF8.c_str()));\n}\n\n"}
{"repo_name":"dodamn/pkg-dosbox","ref":"refs/heads/master","path":"src/hardware/mixer.cpp","copies":"1","language":"C++","content":"/*\n *  Copyright (C) 2002-2009  The DOSBox Team\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Library General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n */\n\n/* $Id: mixer.cpp,v 1.53 2009/04/28 21:48:24 harekiet Exp $ */\n\n/* \n\tRemove the sdl code from here and have it handeld in the sdlmain.\n\tThat should call the mixer start from there or something.\n*/\n\n#include \u003cstring.h\u003e\n#include \u003csys/types.h\u003e\n#include \u003cmath.h\u003e\n\n#if defined (WIN32)\n//Midi listing\n#ifndef WIN32_LEAN_AND_MEAN\n#define WIN32_LEAN_AND_MEAN\n#endif\n#include \u003cwindows.h\u003e\n#include \u003cmmsystem.h\u003e\n#endif\n\n#include \"SDL.h\"\n#include \"mem.h\"\n#include \"pic.h\"\n#include \"dosbox.h\"\n#include \"mixer.h\"\n#include \"timer.h\"\n#include \"setup.h\"\n#include \"cross.h\"\n#include \"support.h\"\n#include \"mapper.h\"\n#include \"hardware.h\"\n#include \"programs.h\"\n\n#define MIXER_SSIZE 4\n#define MIXER_SHIFT 14\n#define MIXER_REMAIN ((1\u003c\u003cMIXER_SHIFT)-1)\n#define MIXER_VOLSHIFT 13\n\nstatic INLINE Bit16s MIXER_CLIP(Bits SAMP) {\n\tif (SAMP \u003c MAX_AUDIO) {\n\t\tif (SAMP \u003e MIN_AUDIO)\n\t\t\treturn SAMP;\n\t\telse return MIN_AUDIO;\n\t} else return MAX_AUDIO;\n}\n\nstatic struct {\n\tBit32s work[MIXER_BUFSIZE][2];\n\tBitu pos,done;\n\tBitu needed, min_needed, max_needed;\n\tBit32u tick_add,tick_remain;\n\tfloat mastervol[2];\n\tMixerChannel * channels;\n\tbool nosound;\n\tBit32u freq;\n\tBit32u blocksize;\n} mixer;\n\nBit8u MixTemp[MIXER_BUFSIZE];\n\nMixerChannel * MIXER_AddChannel(MIXER_Handler handler,Bitu freq,const char * name) {\n\tMixerChannel * chan=new MixerChannel();\n\tchan-\u003escale = 1.0;\n\tchan-\u003ehandler=handler;\n\tchan-\u003ename=name;\n\tchan-\u003eSetFreq(freq);\n\tchan-\u003enext=mixer.channels;\n\tchan-\u003eSetVolume(1,1);\n\tchan-\u003eenabled=false;\n\tmixer.channels=chan;\n\treturn chan;\n}\n\nMixerChannel * MIXER_FindChannel(const char * name) {\n\tMixerChannel * chan=mixer.channels;\n\twhile (chan) {\n\t\tif (!strcasecmp(chan-\u003ename,name)) break;\n\t\tchan=chan-\u003enext;\n\t}\n\treturn chan;\n}\n\nvoid MIXER_DelChannel(MixerChannel* delchan) {\n\tMixerChannel * chan=mixer.channels;\n\tMixerChannel * * where=\u0026mixer.channels;\n\twhile (chan) {\n\t\tif (chan==delchan) {\n\t\t\t*where=chan-\u003enext;\n\t\t\tdelete delchan;\n\t\t\treturn;\n\t\t}\n\t\twhere=\u0026chan-\u003enext;\n\t\tchan=chan-\u003enext;\n\t}\n}\n\nvoid MixerChannel::UpdateVolume(void) {\n\tvolmul[0]=(Bits)((1 \u003c\u003c MIXER_VOLSHIFT)*scale*volmain[0]*mixer.mastervol[0]);\n\tvolmul[1]=(Bits)((1 \u003c\u003c MIXER_VOLSHIFT)*scale*volmain[1]*mixer.mastervol[1]);\n}\n\nvoid MixerChannel::SetVolume(float _left,float _right) {\n\tvolmain[0]=_left;\n\tvolmain[1]=_right;\n\tUpdateVolume();\n}\n\nvoid MixerChannel::SetScale( float f ) {\n\tscale = f;\n\tUpdateVolume();\n}\n\nvoid MixerChannel::Enable(bool _yesno) {\n\tif (_yesno==enabled) return;\n\tenabled=_yesno;\n\tif (enabled) {\n\t\tfreq_index=MIXER_REMAIN;\n\t\tSDL_LockAudio();\n\t\tif (done\u003cmixer.done) done=mixer.done;\n\t\tSDL_UnlockAudio();\n\t}\n}\n\nvoid MixerChannel::SetFreq(Bitu _freq) {\n\tfreq_add=(_freq\u003c\u003cMIXER_SHIFT)/mixer.freq;\n}\n\nvoid MixerChannel::Mix(Bitu _needed) {\n\tneeded=_needed;\n\twhile (enabled \u0026\u0026 needed\u003edone) {\n\t\tBitu todo=needed-done;\n\t\ttodo*=freq_add;\n\t\tif (todo \u0026 MIXER_REMAIN) {\n\t\t\ttodo=(todo \u003e\u003e MIXER_SHIFT) + 1;\n\t\t} else {\n\t\t\ttodo=(todo \u003e\u003e MIXER_SHIFT);\n\t\t}\n\t\thandler(todo);\n\t}\n}\n\nvoid MixerChannel::AddSilence(void) {\n\tif (done\u003cneeded) {\n\t\tdone=needed;\n\t\tlast[0]=last[1]=0;\n\t\tfreq_index=MIXER_REMAIN;\n\t}\n}\n\ntemplate\u003cclass Type,bool stereo,bool signeddata,bool nativeorder\u003e\ninline void MixerChannel::AddSamples(Bitu len, const Type* data) {\n\tBits diff[2];\n\tBitu mixpos=mixer.pos+done;\n\tfreq_index\u0026=MIXER_REMAIN;\n\tBitu pos=0;Bitu new_pos;\n\n\tgoto thestart;\n\tfor (;;) {\n\t\tnew_pos=freq_index \u003e\u003e MIXER_SHIFT;\n\t\tif (pos\u003cnew_pos) {\n\t\t\tlast[0]+=diff[0];\n\t\t\tif (stereo) last[1]+=diff[1];\n\t\t\tpos=new_pos;\nthestart:\n\t\t\tif (pos\u003e=len) return;\n\t\t\tif ( sizeof( Type) == 1) {\n\t\t\t\tif (!signeddata) {\n\t\t\t\t\tif (stereo) {\n\t\t\t\t\t\tdiff[0]=(((Bit8s)(data[pos*2+0] ^ 0x80)) \u003c\u003c 8)-last[0];\n\t\t\t\t\t\tdiff[1]=(((Bit8s)(data[pos*2+1] ^ 0x80)) \u003c\u003c 8)-last[1];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdiff[0]=(((Bit8s)(data[pos] ^ 0x80)) \u003c\u003c 8)-last[0];\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (stereo) {\n\t\t\t\t\t\tdiff[0]=(data[pos*2+0] \u003c\u003c 8)-last[0];\n\t\t\t\t\t\tdiff[1]=(data[pos*2+1] \u003c\u003c 8)-last[1];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdiff[0]=(data[pos] \u003c\u003c 8)-last[0];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t//16bit and 32bit both contain 16bit data internally\n\t\t\t} else  {\n\t\t\t\tif (signeddata) {\n\t\t\t\t\tif (stereo) {\n\t\t\t\t\t\tif (nativeorder) {\n\t\t\t\t\t\t\tdiff[0]=data[pos*2+0]-last[0];\n\t\t\t\t\t\t\tdiff[1]=data[pos*2+1]-last[1];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif ( sizeof( Type) == 2) {\n\t\t\t\t\t\t\t\tdiff[0]=(Bit16s)host_readw((HostPt)\u0026data[pos*2+0])-last[0];\n\t\t\t\t\t\t\t\tdiff[1]=(Bit16s)host_readw((HostPt)\u0026data[pos*2+1])-last[1];\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdiff[0]=(Bit32s)host_readd((HostPt)\u0026data[pos*2+0])-last[0];\n\t\t\t\t\t\t\t\tdiff[1]=(Bit32s)host_readd((HostPt)\u0026data[pos*2+1])-last[1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (nativeorder) {\n\t\t\t\t\t\t\tdiff[0]=data[pos]-last[0];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif ( sizeof( Type) == 2) {\n\t\t\t\t\t\t\t\tdiff[0]=(Bit16s)host_readw((HostPt)\u0026data[pos])-last[0];\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdiff[0]=(Bit32s)host_readd((HostPt)\u0026data[pos])-last[0];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (stereo) {\n\t\t\t\t\t\tif (nativeorder) {\n\t\t\t\t\t\t\tdiff[0]=(Bits)data[pos*2+0]-32768-last[0];\n\t\t\t\t\t\t\tdiff[1]=(Bits)data[pos*2+1]-32768-last[1];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif ( sizeof( Type) == 2) {\n\t\t\t\t\t\t\t\tdiff[0]=(Bits)host_readw((HostPt)\u0026data[pos*2+0])-32768-last[0];\n\t\t\t\t\t\t\t\tdiff[1]=(Bits)host_readw((HostPt)\u0026data[pos*2+1])-32768-last[1];\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdiff[0]=(Bits)host_readd((HostPt)\u0026data[pos*2+0])-32768-last[0];\n\t\t\t\t\t\t\t\tdiff[1]=(Bits)host_readd((HostPt)\u0026data[pos*2+1])-32768-last[1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (nativeorder) {\n\t\t\t\t\t\t\tdiff[0]=(Bits)data[pos]-32768-last[0];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif ( sizeof( Type) == 2) {\n\t\t\t\t\t\t\t\tdiff[0]=(Bits)host_readw((HostPt)\u0026data[pos])-32768-last[0];\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdiff[0]=(Bits)host_readd((HostPt)\u0026data[pos])-32768-last[0];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tBits diff_mul=freq_index \u0026 MIXER_REMAIN;\n\t\tfreq_index+=freq_add;\n\t\tmixpos\u0026=MIXER_BUFMASK;\n\t\tBits sample=last[0]+((diff[0]*diff_mul) \u003e\u003e MIXER_SHIFT);\n\t\tmixer.work[mixpos][0]+=sample*volmul[0];\n\t\tif (stereo) sample=last[1]+((diff[1]*diff_mul) \u003e\u003e MIXER_SHIFT);\n\t\tmixer.work[mixpos][1]+=sample*volmul[1];\n\t\tmixpos++;done++;\n\t}\n}\n\nvoid MixerChannel::AddStretched(Bitu len,Bit16s * data) {\n\tif (done\u003e=needed) {\n\t\tLOG_MSG(\"Can't add, buffer full\");\t\n\t\treturn;\n\t}\n\tBitu outlen=needed-done;Bits diff;\n\tfreq_index=0;\n\tBitu temp_add=(len \u003c\u003c MIXER_SHIFT)/outlen;\n\tBitu mixpos=mixer.pos+done;done=needed;\n\tBitu pos=0;\n\tdiff=data[0]-last[0];\n\twhile (outlen--) {\n\t\tBitu new_pos=freq_index \u003e\u003e MIXER_SHIFT;\n\t\tif (pos\u003cnew_pos) {\n\t\t\tpos=new_pos;\n\t\t\tlast[0]+=diff;\n\t\t\tdiff=data[pos]-last[0];\n\t\t}\n\t\tBits diff_mul=freq_index \u0026 MIXER_REMAIN;\n\t\tfreq_index+=temp_add;\n\t\tmixpos\u0026=MIXER_BUFMASK;\n\t\tBits sample=last[0]+((diff*diff_mul) \u003e\u003e MIXER_SHIFT);\n\t\tmixer.work[mixpos][0]+=sample*volmul[0];\n\t\tmixer.work[mixpos][1]+=sample*volmul[1];\n\t\tmixpos++;\n\t}\n}\n\nvoid MixerChannel::AddSamples_m8(Bitu len, const Bit8u * data) {\n\tAddSamples\u003cBit8u,false,false,true\u003e(len,data);\n}\nvoid MixerChannel::AddSamples_s8(Bitu len,const Bit8u * data) {\n\tAddSamples\u003cBit8u,true,false,true\u003e(len,data);\n}\nvoid MixerChannel::AddSamples_m8s(Bitu len,const Bit8s * data) {\n\tAddSamples\u003cBit8s,false,true,true\u003e(len,data);\n}\nvoid MixerChannel::AddSamples_s8s(Bitu len,const Bit8s * data) {\n\tAddSamples\u003cBit8s,true,true,true\u003e(len,data);\n}\nvoid MixerChannel::AddSamples_m16(Bitu len,const Bit16s * data) {\n\tAddSamples\u003cBit16s,false,true,true\u003e(len,data);\n}\nvoid MixerChannel::AddSamples_s16(Bitu len,const Bit16s * data) {\n\tAddSamples\u003cBit16s,true,true,true\u003e(len,data);\n}\nvoid MixerChannel::AddSamples_m16u(Bitu len,const Bit16u * data) {\n\tAddSamples\u003cBit16u,false,false,true\u003e(len,data);\n}\nvoid MixerChannel::AddSamples_s16u(Bitu len,const Bit16u * data) {\n\tAddSamples\u003cBit16u,true,false,true\u003e(len,data);\n}\nvoid MixerChannel::AddSamples_m32(Bitu len,const Bit32s * data) {\n\tAddSamples\u003cBit32s,false,true,true\u003e(len,data);\n}\nvoid MixerChannel::AddSamples_s32(Bitu len,const Bit32s * data) {\n\tAddSamples\u003cBit32s,true,true,true\u003e(len,data);\n}\nvoid MixerChannel::AddSamples_m16_nonnative(Bitu len,const Bit16s * data) {\n\tAddSamples\u003cBit16s,false,true,false\u003e(len,data);\n}\nvoid MixerChannel::AddSamples_s16_nonnative(Bitu len,const Bit16s * data) {\n\tAddSamples\u003cBit16s,true,true,false\u003e(len,data);\n}\nvoid MixerChannel::AddSamples_m16u_nonnative(Bitu len,const Bit16u * data) {\n\tAddSamples\u003cBit16u,false,false,false\u003e(len,data);\n}\nvoid MixerChannel::AddSamples_s16u_nonnative(Bitu len,const Bit16u * data) {\n\tAddSamples\u003cBit16u,true,false,false\u003e(len,data);\n}\nvoid MixerChannel::AddSamples_m32_nonnative(Bitu len,const Bit32s * data) {\n\tAddSamples\u003cBit32s,false,true,false\u003e(len,data);\n}\nvoid MixerChannel::AddSamples_s32_nonnative(Bitu len,const Bit32s * data) {\n\tAddSamples\u003cBit32s,true,true,false\u003e(len,data);\n}\n\nvoid MixerChannel::FillUp(void) {\n\tSDL_LockAudio();\n\tif (!enabled || done\u003cmixer.done) {\n\t\tSDL_UnlockAudio();\n\t\treturn;\n\t}\n\tfloat index=PIC_TickIndex();\n\tMix((Bitu)(index*mixer.needed));\n\tSDL_UnlockAudio();\n}\n\nextern bool ticksLocked;\nstatic inline bool Mixer_irq_important(void) {\n\t/* In some states correct timing of the irqs is more important then \n\t * non stuttering audo */\n\treturn (ticksLocked || (CaptureState \u0026 (CAPTURE_WAVE|CAPTURE_VIDEO)));\n}\n\n/* Mix a certain amount of new samples */\nstatic void MIXER_MixData(Bitu needed) {\n\tMixerChannel * chan=mixer.channels;\n\twhile (chan) {\n\t\tchan-\u003eMix(needed);\n\t\tchan=chan-\u003enext;\n\t}\n\tif (CaptureState \u0026 (CAPTURE_WAVE|CAPTURE_VIDEO)) {\n\t\tBit16s convert[1024][2];\n\t\tBitu added=needed-mixer.done;\n\t\tif (added\u003e1024) \n\t\t\tadded=1024;\n\t\tBitu readpos=(mixer.pos+mixer.done)\u0026MIXER_BUFMASK;\n\t\tfor (Bitu i=0;i\u003cadded;i++) {\n\t\t\tBits sample=mixer.work[readpos][0] \u003e\u003e MIXER_VOLSHIFT;\n\t\t\tconvert[i][0]=MIXER_CLIP(sample);\n\t\t\tsample=mixer.work[readpos][1] \u003e\u003e MIXER_VOLSHIFT;\n\t\t\tconvert[i][1]=MIXER_CLIP(sample);\n\t\t\treadpos=(readpos+1)\u0026MIXER_BUFMASK;\n\t\t}\n\t\tCAPTURE_AddWave( mixer.freq, added, (Bit16s*)convert );\n\t}\n\t//Reset the the tick_add for constant speed\n\tif( Mixer_irq_important() )\n\t\tmixer.tick_add = ((mixer.freq) \u003c\u003c MIXER_SHIFT)/1000;\n\tmixer.done = needed;\n}\n\nstatic void MIXER_Mix(void) {\n\tSDL_LockAudio();\n\tMIXER_MixData(mixer.needed);\n\tmixer.tick_remain+=mixer.tick_add;\n\tmixer.needed+=(mixer.tick_remain\u003e\u003eMIXER_SHIFT);\n\tmixer.tick_remain\u0026=MIXER_REMAIN;\n\tSDL_UnlockAudio();\n}\n\nstatic void MIXER_Mix_NoSound(void) {\n\tMIXER_MixData(mixer.needed);\n\t/* Clear piece we've just generated */\n\tfor (Bitu i=0;i\u003cmixer.needed;i++) {\n\t\tmixer.work[mixer.pos][0]=0;\n\t\tmixer.work[mixer.pos][1]=0;\n\t\tmixer.pos=(mixer.pos+1)\u0026MIXER_BUFMASK;\n\t}\n\t/* Reduce count in channels */\n\tfor (MixerChannel * chan=mixer.channels;chan;chan=chan-\u003enext) {\n\t\tif (chan-\u003edone\u003emixer.needed) chan-\u003edone-=mixer.needed;\n\t\telse chan-\u003edone=0;\n\t}\n\t/* Set values for next tick */\n\tmixer.tick_remain+=mixer.tick_add;\n\tmixer.needed=mixer.tick_remain\u003e\u003eMIXER_SHIFT;\n\tmixer.tick_remain\u0026=MIXER_REMAIN;\n\tmixer.done=0;\n}\n\nstatic void MIXER_CallBack(void * userdata, Uint8 *stream, int len) {\n\tBitu need=(Bitu)len/MIXER_SSIZE;\n\tBit16s * output=(Bit16s *)stream;\n\tBitu reduce;\n\tBitu pos, index, index_add;\n\tBits sample;\n\t/* Enough room in the buffer ? */\n\tif (mixer.done \u003c need) {\n//\t\tLOG_MSG(\"Full underrun need %d, have %d, min %d\", need, mixer.done, mixer.min_needed);\n\t\tif((need - mixer.done) \u003e (need \u003e\u003e7) ) //Max 1 procent stretch.\n\t\t\treturn;\n\t\treduce = mixer.done;\n\t\tindex_add = (reduce \u003c\u003c MIXER_SHIFT) / need;\n\t\tmixer.tick_add = ((mixer.freq+mixer.min_needed) \u003c\u003c MIXER_SHIFT)/1000;\n\t} else if (mixer.done \u003c mixer.max_needed) {\n\t\tBitu left = mixer.done - need;\n\t\tif (left \u003c mixer.min_needed) {\n\t\t\tif( !Mixer_irq_important() ) {\n\t\t\t\tBitu needed = mixer.needed - need;\n\t\t\t\tBitu diff = (mixer.min_needed\u003eneeded?mixer.min_needed:needed) - left;\n\t\t\t\tmixer.tick_add = ((mixer.freq+(diff*3)) \u003c\u003c MIXER_SHIFT)/1000;\n\t\t\t\tleft = 0; //No stretching as we compensate with the tick_add value\n\t\t\t} else {\n\t\t\t\tleft = (mixer.min_needed - left);\n\t\t\t\tleft = 1 + (2*left) / mixer.min_needed; //left=1,2,3\n\t\t\t}\n//\t\t\tLOG_MSG(\"needed underrun need %d, have %d, min %d, left %d\", need, mixer.done, mixer.min_needed, left);\n\t\t\treduce = need - left;\n\t\t\tindex_add = (reduce \u003c\u003c MIXER_SHIFT) / need;\n\t\t} else {\n\t\t\treduce = need;\n\t\t\tindex_add = (1 \u003c\u003c MIXER_SHIFT);\n//\t\t\tLOG_MSG(\"regular run need %d, have %d, min %d, left %d\", need, mixer.done, mixer.min_needed, left);\n\n\t\t\t/* Mixer tick value being updated:\n\t\t\t * 3 cases:\n\t\t\t * 1) A lot too high. \u003edivision by 5. but maxed by 2* min to prevent too fast drops.\n\t\t\t * 2) A little too high \u003e division by 8\n\t\t\t * 3) A little to nothing above the min_needed buffer \u003e go to default value\n\t\t\t */\n\t\t\tBitu diff = left - mixer.min_needed;\n\t\t\tif(diff \u003e (mixer.min_needed\u003c\u003c1)) diff = mixer.min_needed\u003c\u003c1;\n\t\t\tif(diff \u003e (mixer.min_needed\u003e\u003e1))\n\t\t\t\tmixer.tick_add = ((mixer.freq-(diff/5)) \u003c\u003c MIXER_SHIFT)/1000;\n\t\t\telse if (diff \u003e (mixer.min_needed\u003e\u003e4))\n\t\t\t\tmixer.tick_add = ((mixer.freq-(diff\u003e\u003e3)) \u003c\u003c MIXER_SHIFT)/1000;\n\t\t\telse\n\t\t\t\tmixer.tick_add = (mixer.freq\u003c\u003c MIXER_SHIFT)/1000;\n\t\t}\n\t} else {\n\t\t/* There is way too much data in the buffer */\n//\t\tLOG_MSG(\"overflow run need %d, have %d, min %d\", need, mixer.done, mixer.min_needed);\n\t\tif (mixer.done \u003e MIXER_BUFSIZE)\n\t\t\tindex_add = MIXER_BUFSIZE - 2*mixer.min_needed;\n\t\telse \n\t\t\tindex_add = mixer.done - 2*mixer.min_needed;\n\t\tindex_add = (index_add \u003c\u003c MIXER_SHIFT) / need;\n\t\treduce = mixer.done - 2* mixer.min_needed;\n\t\tmixer.tick_add = ((mixer.freq-(mixer.min_needed/5)) \u003c\u003c MIXER_SHIFT)/1000;\n\t}\n\t/* Reduce done count in all channels */\n\tfor (MixerChannel * chan=mixer.channels;chan;chan=chan-\u003enext) {\n\t\tif (chan-\u003edone\u003ereduce) chan-\u003edone-=reduce;\n\t\telse chan-\u003edone=0;\n\t}\n   \n\t// Reset mixer.tick_add when irqs are important\n\tif( Mixer_irq_important() )\n\t\tmixer.tick_add=(mixer.freq\u003c\u003c MIXER_SHIFT)/1000;\n\n\tmixer.done -= reduce;\n\tmixer.needed -= reduce;\n\tpos = mixer.pos;\n\tmixer.pos = (mixer.pos + reduce) \u0026 MIXER_BUFMASK;\n\tindex = 0;\n\tif(need != reduce) {\n\t\twhile (need--) {\n\t\t\tBitu i = (pos + (index \u003e\u003e MIXER_SHIFT )) \u0026 MIXER_BUFMASK;\n\t\t\tindex += index_add;\n\t\t\tsample=mixer.work[i][0]\u003e\u003eMIXER_VOLSHIFT;\n\t\t\t*output++=MIXER_CLIP(sample);\n\t\t\tsample=mixer.work[i][1]\u003e\u003eMIXER_VOLSHIFT;\n\t\t\t*output++=MIXER_CLIP(sample);\n\t\t}\n\t\t/* Clean the used buffer */\n\t\twhile (reduce--) {\n\t\t\tpos \u0026= MIXER_BUFMASK;\n\t\t\tmixer.work[pos][0]=0;\n\t\t\tmixer.work[pos][1]=0;\n\t\t\tpos++;\n\t\t}\n\t} else {\n\t\twhile (reduce--) {\n\t\t\tpos \u0026= MIXER_BUFMASK;\n\t\t\tsample=mixer.work[pos][0]\u003e\u003eMIXER_VOLSHIFT;\n\t\t\t*output++=MIXER_CLIP(sample);\n\t\t\tsample=mixer.work[pos][1]\u003e\u003eMIXER_VOLSHIFT;\n\t\t\t*output++=MIXER_CLIP(sample);\n\t\t\tmixer.work[pos][0]=0;\n\t\t\tmixer.work[pos][1]=0;\n\t\t\tpos++;\n\t\t}\n\t}\n}\n\nstatic void MIXER_Stop(Section* sec) {\n}\n\nclass MIXER : public Program {\npublic:\n\tvoid MakeVolume(char * scan,float \u0026 vol0,float \u0026 vol1) {\n\t\tBitu w=0;\n\t\tbool db=(toupper(*scan)=='D');\n\t\tif (db) scan++;\n\t\twhile (*scan) {\n\t\t\tif (*scan==':') {\n\t\t\t\t++scan;w=1;\n\t\t\t}\n\t\t\tchar * before=scan;\n\t\t\tfloat val=(float)strtod(scan,\u0026scan);\n\t\t\tif (before==scan) {\n\t\t\t\t++scan;continue;\n\t\t\t}\n\t\t\tif (!db) val/=100;\n\t\t\telse val=powf(10.0f,(float)val/20.0f);\n\t\t\tif (val\u003c0) val=1.0f;\n\t\t\tif (!w) {\n\t\t\t\tvol0=val;\n\t\t\t} else {\n\t\t\t\tvol1=val;\n\t\t\t}\n\t\t}\n\t\tif (!w) vol1=vol0;\n\t}\n\n\tvoid Run(void) {\n\t\tif(cmd-\u003eFindExist(\"/LISTMIDI\")) {\n\t\t\tListMidi();\n\t\t\treturn;\n\t\t}\n\t\tif (cmd-\u003eFindString(\"MASTER\",temp_line,false)) {\n\t\t\tMakeVolume((char *)temp_line.c_str(),mixer.mastervol[0],mixer.mastervol[1]);\n\t\t}\n\t\tMixerChannel * chan=mixer.channels;\n\t\twhile (chan) {\n\t\t\tif (cmd-\u003eFindString(chan-\u003ename,temp_line,false)) {\n\t\t\t\tMakeVolume((char *)temp_line.c_str(),chan-\u003evolmain[0],chan-\u003evolmain[1]);\n\t\t\t}\n\t\t\tchan-\u003eUpdateVolume();\n\t\t\tchan=chan-\u003enext;\n\t\t}\n\t\tif (cmd-\u003eFindExist(\"/NOSHOW\")) return;\n\t\tchan=mixer.channels;\n\t\tWriteOut(\"Channel  Main    Main(dB)\\n\");\n\t\tShowVolume(\"MASTER\",mixer.mastervol[0],mixer.mastervol[1]);\n\t\tfor (chan=mixer.channels;chan;chan=chan-\u003enext) \n\t\t\tShowVolume(chan-\u003ename,chan-\u003evolmain[0],chan-\u003evolmain[1]);\n\t}\nprivate:\n\tvoid ShowVolume(const char * name,float vol0,float vol1) {\n\t\tWriteOut(\"%-8s %3.0f:%-3.0f  %+3.2f:%-+3.2f \\n\",name,\n\t\t\tvol0*100,vol1*100,\n\t\t\t20*log(vol0)/log(10.0f),20*log(vol1)/log(10.0f)\n\t\t);\n\t}\n\n\tvoid ListMidi(){\n#if defined (WIN32)\n\t\tunsigned int total = midiOutGetNumDevs();\t\n\t\tfor(unsigned int i=0;i\u003ctotal;i++) {\n\t\t\tMIDIOUTCAPS mididev;\n\t\t\tmidiOutGetDevCaps(i, \u0026mididev, sizeof(MIDIOUTCAPS));\n\t\t\tWriteOut(\"%2d\\t \\\"%s\\\"\\n\",i,mididev.szPname);\n\t\t}\n#endif\n\treturn;\n\t};\n\n};\n\nstatic void MIXER_ProgramStart(Program * * make) {\n\t*make=new MIXER;\n}\n\nMixerChannel* MixerObject::Install(MIXER_Handler handler,Bitu freq,const char * name){\n\tif(!installed) {\n\t\tif(strlen(name) \u003e 31) E_Exit(\"Too long mixer channel name\");\n\t\tsafe_strncpy(m_name,name,32);\n\t\tinstalled = true;\n\t\treturn MIXER_AddChannel(handler,freq,name);\n\t} else {\n\t\tE_Exit(\"allready added mixer channel.\");\n\t\treturn 0; //Compiler happy\n\t}\n}\n\nMixerObject::~MixerObject(){\n\tif(!installed) return;\n\tMIXER_DelChannel(MIXER_FindChannel(m_name));\n}\n\n\nvoid MIXER_Init(Section* sec) {\n\tsec-\u003eAddDestroyFunction(\u0026MIXER_Stop);\n\n\tSection_prop * section=static_cast\u003cSection_prop *\u003e(sec);\n\t/* Read out config section */\n\tmixer.freq=section-\u003eGet_int(\"rate\");\n\tmixer.nosound=section-\u003eGet_bool(\"nosound\");\n\tmixer.blocksize=section-\u003eGet_int(\"blocksize\");\n\n\t/* Initialize the internal stuff */\n\tmixer.channels=0;\n\tmixer.pos=0;\n\tmixer.done=0;\n\tmemset(mixer.work,0,sizeof(mixer.work));\n\tmixer.mastervol[0]=1.0f;\n\tmixer.mastervol[1]=1.0f;\n\n\t/* Start the Mixer using SDL Sound at 22 khz */\n\tSDL_AudioSpec spec;\n\tSDL_AudioSpec obtained;\n\n\tspec.freq=mixer.freq;\n\tspec.format=AUDIO_S16SYS;\n\tspec.channels=2;\n\tspec.callback=MIXER_CallBack;\n\tspec.userdata=NULL;\n\tspec.samples=(Uint16)mixer.blocksize;\n\n\tmixer.tick_remain=0;\n\tif (mixer.nosound) {\n\t\tLOG_MSG(\"MIXER:No Sound Mode Selected.\");\n\t\tmixer.tick_add=((mixer.freq) \u003c\u003c MIXER_SHIFT)/1000;\n\t\tTIMER_AddTickHandler(MIXER_Mix_NoSound);\n\t} else if (SDL_OpenAudio(\u0026spec, \u0026obtained) \u003c0 ) {\n\t\tmixer.nosound = true;\n\t\tLOG_MSG(\"MIXER:Can't open audio: %s , running in nosound mode.\",SDL_GetError());\n\t\tmixer.tick_add=((mixer.freq) \u003c\u003c MIXER_SHIFT)/1000;\n\t\tTIMER_AddTickHandler(MIXER_Mix_NoSound);\n\t} else {\n\t\tmixer.freq=obtained.freq;\n\t\tmixer.blocksize=obtained.samples;\n\t\tmixer.tick_add=(mixer.freq \u003c\u003c MIXER_SHIFT)/1000;\n\t\tTIMER_AddTickHandler(MIXER_Mix);\n\t\tSDL_PauseAudio(0);\n\t}\n\tmixer.min_needed=section-\u003eGet_int(\"prebuffer\");\n\tif (mixer.min_needed\u003e100) mixer.min_needed=100;\n\tmixer.min_needed=(mixer.freq*mixer.min_needed)/1000;\n\tmixer.max_needed=mixer.blocksize * 2 + 2*mixer.min_needed;\n\tmixer.needed=mixer.min_needed+1;\n\tPROGRAMS_MakeFile(\"MIXER.COM\",MIXER_ProgramStart);\n}\n"}
{"repo_name":"jeppeter/mysql56","ref":"refs/heads/master","path":"storage/ndb/src/cw/cpcd/Monitor.cpp","copies":"89","language":"C++","content":"/*\n   Copyright (C) 2003-2006 MySQL AB, 2009 Sun Microsystems, Inc.\n    All rights reserved. Use is subject to license terms.\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; version 2 of the License.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA\n*/\n\n#include \u003cndb_global.h\u003e\n\n#include \u003cNdbThread.h\u003e\n#include \u003cNdbOut.hpp\u003e\n#include \u003cNdbSleep.h\u003e\n\n#include \"CPCD.hpp\"\n#include \"common.hpp\"\n\nstatic void *\nmonitor_thread_create_wrapper(void * arg) {\n  CPCD::Monitor *mon = (CPCD::Monitor *)arg;\n  mon-\u003erun();\n  return NULL;\n}\n\nCPCD::Monitor::Monitor(CPCD *cpcd, int poll) {\n  m_cpcd = cpcd;\n  m_pollingInterval = poll;\n  m_changeCondition = NdbCondition_Create();\n  m_changeMutex = NdbMutex_Create();\n  m_monitorThread = NdbThread_Create(monitor_thread_create_wrapper,\n\t\t\t\t     (NDB_THREAD_ARG*) this,\n                                     0, // default stack size\n\t\t\t\t     \"ndb_cpcd_monitor\",\n\t\t\t\t     NDB_THREAD_PRIO_MEAN);\n  m_monitorThreadQuitFlag = false;\n}\n\nCPCD::Monitor::~Monitor() {\n  NdbThread_Destroy(\u0026m_monitorThread);\n  NdbCondition_Destroy(m_changeCondition);\n  NdbMutex_Destroy(m_changeMutex);\n}\n\nvoid\nCPCD::Monitor::run() {\n  while(1) {\n    NdbMutex_Lock(m_changeMutex);\n    NdbCondition_WaitTimeout(m_changeCondition,\n\t\t\t     m_changeMutex,\n\t\t\t     m_pollingInterval * 1000);\n\n    MutexVector\u003cCPCD::Process *\u003e \u0026proc = *m_cpcd-\u003egetProcessList();\n\n    proc.lock();\n\n    for(size_t i = 0; i \u003c proc.size(); i++) {\n      proc[i]-\u003emonitor();\n    }\n\n    proc.unlock();\n\n    NdbMutex_Unlock(m_changeMutex);\n  }\n}\n\nvoid\nCPCD::Monitor::signal() {\n  NdbCondition_Signal(m_changeCondition);\n}\n\ntemplate class MutexVector\u003cCPCD::Process*\u003e;\n"}
{"repo_name":"mur47x111/JDK8-concurrent-tagging","ref":"refs/heads/master","path":"src/share/vm/gc_implementation/concurrentMarkSweep/vmCMSOperations.cpp","copies":"19","language":"C++","content":"/*\n * Copyright (c) 2005, 2013, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n *\n */\n\n#include \"precompiled.hpp\"\n#include \"gc_implementation/concurrentMarkSweep/concurrentMarkSweepGeneration.inline.hpp\"\n#include \"gc_implementation/concurrentMarkSweep/concurrentMarkSweepThread.hpp\"\n#include \"gc_implementation/concurrentMarkSweep/vmCMSOperations.hpp\"\n#include \"gc_implementation/shared/gcTimer.hpp\"\n#include \"gc_implementation/shared/gcTraceTime.hpp\"\n#include \"gc_implementation/shared/isGCActiveMark.hpp\"\n#include \"memory/gcLocker.inline.hpp\"\n#include \"runtime/interfaceSupport.hpp\"\n#include \"runtime/os.hpp\"\n#include \"utilities/dtrace.hpp\"\n\n\n#ifndef USDT2\nHS_DTRACE_PROBE_DECL(hs_private, cms__initmark__begin);\nHS_DTRACE_PROBE_DECL(hs_private, cms__initmark__end);\n\nHS_DTRACE_PROBE_DECL(hs_private, cms__remark__begin);\nHS_DTRACE_PROBE_DECL(hs_private, cms__remark__end);\n#endif /* !USDT2 */\n\n//////////////////////////////////////////////////////////\n// Methods in abstract class VM_CMS_Operation\n//////////////////////////////////////////////////////////\nvoid VM_CMS_Operation::acquire_pending_list_lock() {\n  // The caller may block while communicating\n  // with the SLT thread in order to acquire/release the PLL.\n  ConcurrentMarkSweepThread::slt()-\u003e\n    manipulatePLL(SurrogateLockerThread::acquirePLL);\n}\n\nvoid VM_CMS_Operation::release_and_notify_pending_list_lock() {\n  // The caller may block while communicating\n  // with the SLT thread in order to acquire/release the PLL.\n  ConcurrentMarkSweepThread::slt()-\u003e\n    manipulatePLL(SurrogateLockerThread::releaseAndNotifyPLL);\n}\n\nvoid VM_CMS_Operation::verify_before_gc() {\n  if (VerifyBeforeGC \u0026\u0026\n      GenCollectedHeap::heap()-\u003etotal_collections() \u003e= VerifyGCStartAt) {\n    GCTraceTime tm(\"Verify Before\", false, false, _collector-\u003e_gc_timer_cm);\n    HandleMark hm;\n    FreelistLocker x(_collector);\n    MutexLockerEx  y(_collector-\u003ebitMapLock(), Mutex::_no_safepoint_check_flag);\n    Universe::heap()-\u003eprepare_for_verify();\n    Universe::verify();\n  }\n}\n\nvoid VM_CMS_Operation::verify_after_gc() {\n  if (VerifyAfterGC \u0026\u0026\n      GenCollectedHeap::heap()-\u003etotal_collections() \u003e= VerifyGCStartAt) {\n    GCTraceTime tm(\"Verify After\", false, false, _collector-\u003e_gc_timer_cm);\n    HandleMark hm;\n    FreelistLocker x(_collector);\n    MutexLockerEx  y(_collector-\u003ebitMapLock(), Mutex::_no_safepoint_check_flag);\n    Universe::verify();\n  }\n}\n\nbool VM_CMS_Operation::lost_race() const {\n  if (CMSCollector::abstract_state() == CMSCollector::Idling) {\n    // We lost a race to a foreground collection\n    // -- there's nothing to do\n    return true;\n  }\n  assert(CMSCollector::abstract_state() == legal_state(),\n         \"Inconsistent collector state?\");\n  return false;\n}\n\nbool VM_CMS_Operation::doit_prologue() {\n  assert(Thread::current()-\u003eis_ConcurrentGC_thread(), \"just checking\");\n  assert(!CMSCollector::foregroundGCShouldWait(), \"Possible deadlock\");\n  assert(!ConcurrentMarkSweepThread::cms_thread_has_cms_token(),\n         \"Possible deadlock\");\n\n  if (needs_pll()) {\n    acquire_pending_list_lock();\n  }\n  // Get the Heap_lock after the pending_list_lock.\n  Heap_lock-\u003elock();\n  if (lost_race()) {\n    assert(_prologue_succeeded == false, \"Initialized in c'tor\");\n    Heap_lock-\u003eunlock();\n    if (needs_pll()) {\n      release_and_notify_pending_list_lock();\n    }\n  } else {\n    _prologue_succeeded = true;\n  }\n  return _prologue_succeeded;\n}\n\nvoid VM_CMS_Operation::doit_epilogue() {\n  assert(Thread::current()-\u003eis_ConcurrentGC_thread(), \"just checking\");\n  assert(!CMSCollector::foregroundGCShouldWait(), \"Possible deadlock\");\n  assert(!ConcurrentMarkSweepThread::cms_thread_has_cms_token(),\n         \"Possible deadlock\");\n\n  // Release the Heap_lock first.\n  Heap_lock-\u003eunlock();\n  if (needs_pll()) {\n    release_and_notify_pending_list_lock();\n  }\n}\n\n//////////////////////////////////////////////////////////\n// Methods in class VM_CMS_Initial_Mark\n//////////////////////////////////////////////////////////\nvoid VM_CMS_Initial_Mark::doit() {\n  if (lost_race()) {\n    // Nothing to do.\n    return;\n  }\n#ifndef USDT2\n  HS_DTRACE_PROBE(hs_private, cms__initmark__begin);\n#else /* USDT2 */\n  HS_PRIVATE_CMS_INITMARK_BEGIN(\n                                );\n#endif /* USDT2 */\n\n  _collector-\u003e_gc_timer_cm-\u003eregister_gc_pause_start(\"Initial Mark\");\n\n  GenCollectedHeap* gch = GenCollectedHeap::heap();\n  GCCauseSetter gccs(gch, GCCause::_cms_initial_mark);\n\n  VM_CMS_Operation::verify_before_gc();\n\n  IsGCActiveMark x; // stop-world GC active\n  _collector-\u003edo_CMS_operation(CMSCollector::CMS_op_checkpointRootsInitial, gch-\u003egc_cause());\n\n  VM_CMS_Operation::verify_after_gc();\n\n  _collector-\u003e_gc_timer_cm-\u003eregister_gc_pause_end();\n\n#ifndef USDT2\n  HS_DTRACE_PROBE(hs_private, cms__initmark__end);\n#else /* USDT2 */\n  HS_PRIVATE_CMS_INITMARK_END(\n                                );\n#endif /* USDT2 */\n}\n\n//////////////////////////////////////////////////////////\n// Methods in class VM_CMS_Final_Remark_Operation\n//////////////////////////////////////////////////////////\nvoid VM_CMS_Final_Remark::doit() {\n  if (lost_race()) {\n    // Nothing to do.\n    return;\n  }\n#ifndef USDT2\n  HS_DTRACE_PROBE(hs_private, cms__remark__begin);\n#else /* USDT2 */\n  HS_PRIVATE_CMS_REMARK_BEGIN(\n                                );\n#endif /* USDT2 */\n\n  _collector-\u003e_gc_timer_cm-\u003eregister_gc_pause_start(\"Final Mark\");\n\n  GenCollectedHeap* gch = GenCollectedHeap::heap();\n  GCCauseSetter gccs(gch, GCCause::_cms_final_remark);\n\n  VM_CMS_Operation::verify_before_gc();\n\n  IsGCActiveMark x; // stop-world GC active\n  _collector-\u003edo_CMS_operation(CMSCollector::CMS_op_checkpointRootsFinal, gch-\u003egc_cause());\n\n  VM_CMS_Operation::verify_after_gc();\n\n  _collector-\u003esave_heap_summary();\n  _collector-\u003e_gc_timer_cm-\u003eregister_gc_pause_end();\n\n#ifndef USDT2\n  HS_DTRACE_PROBE(hs_private, cms__remark__end);\n#else /* USDT2 */\n  HS_PRIVATE_CMS_REMARK_END(\n                                );\n#endif /* USDT2 */\n}\n\n// VM operation to invoke a concurrent collection of a\n// GenCollectedHeap heap.\nvoid VM_GenCollectFullConcurrent::doit() {\n  assert(Thread::current()-\u003eis_VM_thread(), \"Should be VM thread\");\n  assert(GCLockerInvokesConcurrent || ExplicitGCInvokesConcurrent, \"Unexpected\");\n\n  GenCollectedHeap* gch = GenCollectedHeap::heap();\n  if (_gc_count_before == gch-\u003etotal_collections()) {\n    // The \"full\" of do_full_collection call below \"forces\"\n    // a collection; the second arg, 0, below ensures that\n    // only the young gen is collected. XXX In the future,\n    // we'll probably need to have something in this interface\n    // to say do this only if we are sure we will not bail\n    // out to a full collection in this attempt, but that's\n    // for the future.\n    assert(SafepointSynchronize::is_at_safepoint(),\n      \"We can only be executing this arm of if at a safepoint\");\n    GCCauseSetter gccs(gch, _gc_cause);\n    gch-\u003edo_full_collection(gch-\u003emust_clear_all_soft_refs(),\n                            0 /* collect only youngest gen */);\n  } // Else no need for a foreground young gc\n  assert((_gc_count_before \u003c gch-\u003etotal_collections()) ||\n         (GC_locker::is_active() /* gc may have been skipped */\n          \u0026\u0026 (_gc_count_before == gch-\u003etotal_collections())),\n         \"total_collections() should be monotonically increasing\");\n\n  MutexLockerEx x(FullGCCount_lock, Mutex::_no_safepoint_check_flag);\n  assert(_full_gc_count_before \u003c= gch-\u003etotal_full_collections(), \"Error\");\n  if (gch-\u003etotal_full_collections() == _full_gc_count_before) {\n    // Disable iCMS until the full collection is done, and\n    // remember that we did so.\n    CMSCollector::disable_icms();\n    _disabled_icms = true;\n    // In case CMS thread was in icms_wait(), wake it up.\n    CMSCollector::start_icms();\n    // Nudge the CMS thread to start a concurrent collection.\n    CMSCollector::request_full_gc(_full_gc_count_before, _gc_cause);\n  } else {\n    assert(_full_gc_count_before \u003c gch-\u003etotal_full_collections(), \"Error\");\n    FullGCCount_lock-\u003enotify_all();  // Inform the Java thread its work is done\n  }\n}\n\nbool VM_GenCollectFullConcurrent::evaluate_at_safepoint() const {\n  Thread* thr = Thread::current();\n  assert(thr != NULL, \"Unexpected tid\");\n  if (!thr-\u003eis_Java_thread()) {\n    assert(thr-\u003eis_VM_thread(), \"Expected to be evaluated by VM thread\");\n    GenCollectedHeap* gch = GenCollectedHeap::heap();\n    if (_gc_count_before != gch-\u003etotal_collections()) {\n      // No need to do a young gc, we'll just nudge the CMS thread\n      // in the doit() method above, to be executed soon.\n      assert(_gc_count_before \u003c gch-\u003etotal_collections(),\n             \"total_collections() should be monotnically increasing\");\n      return false;  // no need for foreground young gc\n    }\n  }\n  return true;       // may still need foreground young gc\n}\n\n\nvoid VM_GenCollectFullConcurrent::doit_epilogue() {\n  Thread* thr = Thread::current();\n  assert(thr-\u003eis_Java_thread(), \"just checking\");\n  JavaThread* jt = (JavaThread*)thr;\n  // Release the Heap_lock first.\n  Heap_lock-\u003eunlock();\n  release_and_notify_pending_list_lock();\n\n  // It is fine to test whether completed collections has\n  // exceeded our request count without locking because\n  // the completion count is monotonically increasing;\n  // this will break for very long-running apps when the\n  // count overflows and wraps around. XXX fix me !!!\n  // e.g. at the rate of 1 full gc per ms, this could\n  // overflow in about 1000 years.\n  GenCollectedHeap* gch = GenCollectedHeap::heap();\n  if (_gc_cause != GCCause::_gc_locker \u0026\u0026\n      gch-\u003etotal_full_collections_completed() \u003c= _full_gc_count_before) {\n    // maybe we should change the condition to test _gc_cause ==\n    // GCCause::_java_lang_system_gc, instead of\n    // _gc_cause != GCCause::_gc_locker\n    assert(_gc_cause == GCCause::_java_lang_system_gc,\n           \"the only way to get here if this was a System.gc()-induced GC\");\n    assert(ExplicitGCInvokesConcurrent, \"Error\");\n    // Now, wait for witnessing concurrent gc cycle to complete,\n    // but do so in native mode, because we want to lock the\n    // FullGCEvent_lock, which may be needed by the VM thread\n    // or by the CMS thread, so we do not want to be suspended\n    // while holding that lock.\n    ThreadToNativeFromVM native(jt);\n    MutexLockerEx ml(FullGCCount_lock, Mutex::_no_safepoint_check_flag);\n    // Either a concurrent or a stop-world full gc is sufficient\n    // witness to our request.\n    while (gch-\u003etotal_full_collections_completed() \u003c= _full_gc_count_before) {\n      FullGCCount_lock-\u003ewait(Mutex::_no_safepoint_check_flag);\n    }\n  }\n  // Enable iCMS back if we disabled it earlier.\n  if (_disabled_icms) {\n    CMSCollector::enable_icms();\n  }\n}\n"}
{"repo_name":"afoksha/OpenGL","ref":"refs/heads/master","path":"demos/100_Player/player_5.cpp","copies":"1","language":"C++","content":"#include \u003ciostream\u003e\n#include \u003cstring\u003e\n#include \u003cthread\u003e\n#include \u003cmutex\u003e\n#include \u003ccondition_variable\u003e\n\nstd::mutex m;\nstd::condition_variable cv;\nstd::string data;\nbool ready = false;\nbool processed = false;\n\nvoid worker_thread()\n{\n    // Wait until main() sends data\n    std::unique_lock\u003cstd::mutex\u003e lk(m);\n    cv.wait(lk, []{return ready;});\n\n    // after the wait, we own the lock.\n    std::cout \u003c\u003c \"Worker thread is processing data\\n\";\n    data += \" after processing\";\n\n    // Send data back to main()\n    processed = true;\n    std::cout \u003c\u003c \"Worker thread signals data processing completed\\n\";\n\n    // Manual unlocking is done before notifying, to avoid waking up\n    // the waiting thread only to block again (see notify_one for details)\n    lk.unlock();\n    cv.notify_one();\n}\n\nint main(int argc, char* argv[])\n{\n    std::thread worker(worker_thread);\n\n    data = \"Example data\";\n    // send data to the worker thread\n    {\n        std::lock_guard\u003cstd::mutex\u003e lk(m);\n        ready = true;\n        std::cout \u003c\u003c \"main() signals data ready for processing\\n\";\n    }\n    cv.notify_one();\n\n    // wait for the worker\n    {\n        std::unique_lock\u003cstd::mutex\u003e lk(m);\n        cv.wait(lk, []{return processed;});\n    }\n    std::cout \u003c\u003c \"Back in main(), data = \" \u003c\u003c data \u003c\u003c '\\n';\n\n    worker.join();\n}\n"}
{"repo_name":"basic60/ARCUS","ref":"refs/heads/master","path":"source/kernel/interruption/idt.cpp","copies":"1","language":"C++","content":"#include \"types.h\"\n#include \"idt.h\"\n#include \"string.h\"\n#include \"print_charmode.h\"\n#include \"port.h\"\n#include \"keyboard.h\"\nidtEntry idtEntries[256];   // 中断描述符表\ninterruptHandler_t interruptHandler[256];\nidtPtr iptr;                // IDTR\nextern \"C\" void idtFlush(uint64 addr);\n\nvoid initIDT(){\n    memset((uint8*)idtEntries,0,sizeof(idtEntries));\n    iptr.limit=sizeof(idtEntries)-1;\n    iptr.base=(uint64)\u0026idtEntries;\n\n\n    /* ICW1 - begin initialization */\n\twritePort(0x20 , 0x11);\n\twritePort(0xA0 , 0x11);\n \n\n    // 设置主片 IRQ 从 0x20(32) 号中断开始\n\twritePort(0x21 , 0x20);\n    // 设置从片 IRQ 从 0x28(40) 号中断开始\n\twritePort(0xA1 , 0x28);\n \n    // 设置主片和从片按照 8086 的方式工作\n\twritePort(0x21 , 0x01);\n\twritePort(0xA1 , 0x01);\n\n    // 设置主从片允许中断\n\twritePort(0x21 , 0x00);  \n\twritePort(0xA1 , 0x00);  \n\n    idtSetEntity(0,(uint64)isr0,0x08,0x8E);\n    idtSetEntity(1,(uint64)isr1,0x08,0x8E);\n    idtSetEntity(2,(uint64)isr2,0x08,0x8E);\n    idtSetEntity(3,(uint64)isr3,0x08,0x8E);\n    idtSetEntity(4,(uint64)isr4,0x08,0x8E);\n    idtSetEntity(5,(uint64)isr5,0x08,0x8E);\n    idtSetEntity(6,(uint64)isr6,0x08,0x8E);\n    idtSetEntity(7,(uint64)isr7,0x08,0x8E);\n    idtSetEntity(8,(uint64)isr8,0x08,0x8E);\n    idtSetEntity(9,(uint64)isr9,0x08,0x8E);\n    idtSetEntity(10,(uint64)isr10,0x08,0x8E);\n    idtSetEntity(11,(uint64)isr11,0x08,0x8E);\n    idtSetEntity(12,(uint64)isr12,0x08,0x8E);\n    idtSetEntity(13,(uint64)isr13,0x08,0x8E);\n    idtSetEntity(14,(uint64)isr14,0x08,0x8E);\n    idtSetEntity(15,(uint64)isr15,0x08,0x8E);\n    idtSetEntity(16,(uint64)isr16,0x08,0x8E);\n    idtSetEntity(17,(uint64)isr17,0x08,0x8E);\n    idtSetEntity(18,(uint64)isr18,0x08,0x8E);\n    idtSetEntity(19,(uint64)isr19,0x08,0x8E);\n    idtSetEntity(20,(uint64)isr20,0x08,0x8E);\n    idtSetEntity(21,(uint64)isr21,0x08,0x8E);\n    idtSetEntity(22,(uint64)isr22,0x08,0x8E);\n    idtSetEntity(23,(uint64)isr23,0x08,0x8E);\n    idtSetEntity(24,(uint64)isr24,0x08,0x8E);\n    idtSetEntity(25,(uint64)isr25,0x08,0x8E);\n    idtSetEntity(26,(uint64)isr26,0x08,0x8E);\n    idtSetEntity(27,(uint64)isr27,0x08,0x8E);\n    idtSetEntity(28,(uint64)isr27,0x08,0x8E);\n    idtSetEntity(29,(uint64)isr29,0x08,0x8E);\n    idtSetEntity(30,(uint64)isr30,0x08,0x8E);\n    idtSetEntity(31,(uint64)isr31,0x08,0x8E);\n\n    idtSetEntity(32,(uint64)irq0,0x08,0x8E);\n    idtSetEntity(33,(uint64)irq1,0x08,0x8E);\n    idtSetEntity(34,(uint64)irq2,0x08,0x8E);\n    idtSetEntity(35,(uint64)irq3,0x08,0x8E);\n    idtSetEntity(36,(uint64)irq4,0x08,0x8E);\n    idtSetEntity(37,(uint64)irq5,0x08,0x8E);\n    idtSetEntity(38,(uint64)irq6,0x08,0x8E);\n    idtSetEntity(39,(uint64)irq7,0x08,0x8E);\n    idtSetEntity(40,(uint64)irq8,0x08,0x8E);\n    idtSetEntity(41,(uint64)irq9,0x08,0x8E);\n    idtSetEntity(42,(uint64)irq10,0x08,0x8E);\n    idtSetEntity(43,(uint64)irq11,0x08,0x8E);\n    idtSetEntity(44,(uint64)irq12,0x08,0x8E);\n    idtSetEntity(45,(uint64)irq13,0x08,0x8E);\n    idtSetEntity(46,(uint64)irq14,0x08,0x8E);\n    idtSetEntity(47,(uint64)irq15,0x08,0x8E);\n   \n    idtFlush((uint64)\u0026iptr);\n    printStr(\"Initializing interruption finished.\\n\",color_white);\n}\n\nvoid isrHandler(ptRegs* regs){\n    // printDecimal(regs-\u003eintNum,color_red);\n    if(interruptHandler[regs-\u003eintNum])\n        interruptHandler[regs-\u003eintNum](regs);\n    else{\n        // printStr(\"Handeler not exist!\",color_lightwhite);\n        // printNum(regs-\u003erip,color_lightwhite);\n    }\n}\n\nvoid irqHandler(ptRegs* regs){\n    if(regs-\u003eintNum\u003e40){\n        writePort(0xA0,0x20);// 发送重设信号给从片\n    }\n    // 发送重设信号给主片\n    writePort(0x20, 0x20);\n\n    if (interruptHandler[regs-\u003eintNum]) {\n        interruptHandler[regs-\u003eintNum](regs);\n    }\n}\n\nvoid registerInterruptHandler(uint8 n,interruptHandler_t h){\n    interruptHandler[n]=h;\n}\n\nvoid idtSetEntity(uint8 num,uint64 base,uint16 selector,uint8 flags){\n    idtEntries[num].offset1=base\u00260xffff;\n    idtEntries[num].offset2=(base\u003e\u003e16)\u00260xffff;\n    idtEntries[num].offset3=(base\u003e\u003e32)\u00260xffffffff;\n    idtEntries[num].selector=selector;\n    idtEntries[num].typeAttr=flags;\n}\n\n"}
{"repo_name":"sofa-framework/sofa","ref":"refs/heads/master","path":"applications/plugins/SofaPython/PythonScriptController.cpp","copies":"6","language":"C++","content":"/******************************************************************************\n*       SOFA, Simulation Open-Framework Architecture, development version     *\n*                (c) 2006-2019 INRIA, USTL, UJF, CNRS, MGH                    *\n*                                                                             *\n* This program is free software; you can redistribute it and/or modify it     *\n* under the terms of the GNU Lesser General Public License as published by    *\n* the Free Software Foundation; either version 2.1 of the License, or (at     *\n* your option) any later version.                                             *\n*                                                                             *\n* This program is distributed in the hope that it will be useful, but WITHOUT *\n* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or       *\n* FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License *\n* for more details.                                                           *\n*                                                                             *\n* You should have received a copy of the GNU Lesser General Public License    *\n* along with this program. If not, see \u003chttp://www.gnu.org/licenses/\u003e.        *\n*******************************************************************************\n* Authors: The SOFA Team and external contributors (see Authors.txt)          *\n*                                                                             *\n* Contact information: contact@sofa-framework.org                             *\n******************************************************************************/\n#include \"PythonMacros.h\"\n#include \"PythonScriptController.h\"\n#include \u003csofa/core/ObjectFactory.h\u003e\n#include \u003csofa/helper/AdvancedTimer.h\u003e\nusing sofa::helper::AdvancedTimer;\n\n\nusing sofa::core::objectmodel::Base;\nusing sofa::simulation::Node;\n\n#include \"Binding_PythonScriptController.h\"\nusing sofa::simulation::PythonEnvironment;\n\n#include \"PythonScriptEvent.h\"\nusing sofa::core::objectmodel::PythonScriptEvent;\n\n#include \u003csofa/helper/system/FileMonitor.h\u003e\nusing sofa::helper::system::FileMonitor ;\nusing sofa::helper::system::FileEventListener ;\n\n#include \u003csofa/core/objectmodel/IdleEvent.h\u003e\nusing sofa::core::objectmodel::IdleEvent ;\n\n#include \"PythonFactory.h\"\n\n//TODO(dmarchal): This have to be merged with the ScopedAdvancedTimer\nstruct ActivableScopedAdvancedTimer {\n    const char* message;\n    bool m_active ;\n    Base* m_base;\n    ActivableScopedAdvancedTimer(bool active, const char* message, Base* base)\n        : message( message ), m_active(active), m_base(base)\n    {\n        if(m_active)\n            AdvancedTimer::stepBegin(message, m_base);\n    }\n\n    ~ActivableScopedAdvancedTimer()\n    {\n        if(m_active)\n            AdvancedTimer::stepEnd(message, m_base);\n    }\n};\n\nnamespace sofa\n{\n\nnamespace component\n{\n\nnamespace controller\n{\n\n\nclass MyFileEventListener : public FileEventListener\n{\n    PythonScriptController* m_controller ;\npublic:\n    MyFileEventListener(PythonScriptController* psc){\n        m_controller = psc ;\n    }\n\n    ~MyFileEventListener() override{}\n\n    virtual void fileHasChanged(const std::string\u0026 filepath) override\n    {\n        PythonEnvironment::gil lock {__func__} ;\n\n        /// This function is called when the file has changed. Two cases have\n        /// to be considered if the script was already loaded once or not.\n        if(!m_controller-\u003escriptControllerInstance()){\n            m_controller-\u003edoLoadScript();\n        }else{\n            PythonEnvironment::gil state {__func__ } ;\n            std::string file=filepath;\n            SP_CALL_FILEFUNC(const_cast\u003cchar*\u003e(\"onReimpAFile\"),\n                             const_cast\u003cchar*\u003e(\"s\"),\n                             const_cast\u003cchar*\u003e(file.data()));\n\n            m_controller-\u003erefreshBinding();\n        }\n    }\n};\n\n\n\nint PythonScriptControllerClass = core::RegisterObject(\"A Sofa controller scripted in python\")\n        .add\u003c PythonScriptController \u003e()\n        ;\n\nPythonScriptController::PythonScriptController()\n    : ScriptController()\n    , m_filename(initData(\u0026m_filename, \"filename\",\n                          \"Python script filename\"))\n    , m_classname(initData(\u0026m_classname, \"classname\",\n                           \"Python class implemented in the script to instanciate for the controller\"))\n    , m_variables(initData(\u0026m_variables, \"variables\",\n                           \"Array of string variables (equivalent to a c-like argv)\" ) )\n    , m_timingEnabled(initData(\u0026m_timingEnabled, true, \"timingEnabled\",\n                               \"Set this attribute to true or false to activate/deactivate the gathering\"\n                               \" of timing statistics on the python execution time. Default value is set\"\n                               \"to true.\" ))\n    , m_doAutoReload( initData( \u0026m_doAutoReload, false, \"autoreload\",\n                                \"Automatically reload the file when the source code is changed. \"\n                                \"Default value is set to false\" ) )\n    , m_ScriptControllerClass(nullptr)\n    , m_ScriptControllerInstance(nullptr)\n{\n    m_filelistener = new MyFileEventListener(this) ;\n}\n\nPythonScriptController::~PythonScriptController()\n{\n    if(m_filelistener)\n    {\n        FileMonitor::removeListener(m_filelistener) ;\n        delete m_filelistener ;\n    }\n}\n\n\nvoid PythonScriptController::setInstance(PyObject* instance) {\n    PythonEnvironment::gil lock(__func__);\n    \n    // \"trust me i'm an engineer\"\n    if( m_ScriptControllerInstance ) {\n        Py_DECREF( m_ScriptControllerInstance );\n    }\n\n    m_ScriptControllerInstance = instance;\n\n    // note: we don't use PyObject_Type as it returns a new reference which is\n    // not handled correctly in loadScript\n    m_ScriptControllerClass = (PyObject*)instance-\u003eob_type;\n\n    Py_INCREF( instance );\n\n    refreshBinding();\n}\n\n\nvoid PythonScriptController::refreshBinding()\n{\n    BIND_OBJECT_METHOD(onLoaded)\n            BIND_OBJECT_METHOD(createGraph)\n            BIND_OBJECT_METHOD(initGraph)\n            BIND_OBJECT_METHOD(bwdInitGraph)\n            BIND_OBJECT_METHOD(onKeyPressed)\n            BIND_OBJECT_METHOD(onKeyReleased)\n            BIND_OBJECT_METHOD(onMouseMove)\n            BIND_OBJECT_METHOD(onMouseButtonLeft)\n            BIND_OBJECT_METHOD(onMouseButtonRight)\n            BIND_OBJECT_METHOD(onMouseButtonMiddle)\n            BIND_OBJECT_METHOD(onMouseWheel)\n            BIND_OBJECT_METHOD(onBeginAnimationStep)\n            BIND_OBJECT_METHOD(onEndAnimationStep)\n            BIND_OBJECT_METHOD(storeResetState)\n            BIND_OBJECT_METHOD(reset)\n            BIND_OBJECT_METHOD(cleanup)\n            BIND_OBJECT_METHOD(onGUIEvent)\n            BIND_OBJECT_METHOD(onScriptEvent)\n            BIND_OBJECT_METHOD(draw)\n            BIND_OBJECT_METHOD(onIdle)\n}\n\nbool PythonScriptController::isDerivedFrom(const std::string\u0026 name, const std::string\u0026 module)\n{\n    PythonEnvironment::gil lock(__func__);    \n    PyObject* moduleDict = PyModule_GetDict(PyImport_AddModule(module.c_str()));\n    PyObject* controllerClass = PyDict_GetItemString(moduleDict, name.c_str());\n\n    return 1 == PyObject_IsInstance(m_ScriptControllerInstance, controllerClass);\n}\n\nvoid PythonScriptController::loadScript()\n{\n    PythonEnvironment::gil lock(__func__);        \n    if(m_doAutoReload.getValue())\n    {\n        FileMonitor::addFile(m_filename.getFullPath(), m_filelistener) ;\n    }\n\n    // if the filename is empty, the controller is supposed to be in an already loaded file\n    // otherwise load the controller's file\n    if( m_filename.isSet() \u0026\u0026 !m_filename.getRelativePath().empty() \u0026\u0026 !PythonEnvironment::runFile(m_filename.getFullPath().c_str()) )\n    {\n        msg_error() \u003c\u003c \" load error (file '\"\u003c\u003cm_filename.getFullPath().c_str()\u003c\u003c\"' not parsable)\" ;\n        return;\n    }\n\n    // classe\n    PyObject* pDict = PyModule_GetDict(PyImport_AddModule(\"__main__\"));\n    m_ScriptControllerClass = PyDict_GetItemString(pDict,m_classname.getValueString().c_str());\n    if (!m_ScriptControllerClass)\n    {\n        msg_error() \u003c\u003c \" load error (class '\"\u003c\u003cm_classname.getValueString()\u003c\u003c\"' not found).\" ;\n        return;\n    }\n\n    // verify that the class is a subclass of PythonScriptController\n    if (1!=PyObject_IsSubclass(m_ScriptControllerClass,(PyObject*)\u0026SP_SOFAPYTYPEOBJECT(PythonScriptController)))\n    {\n\n        msg_error() \u003c\u003c \" load error (class '\"\u003c\u003cm_classname.getValueString()\u003c\u003c\"' does not inherit from 'Sofa.PythonScriptController').\" ;\n        return;\n    }\n\n    // créer l'instance de la classe\n    m_ScriptControllerInstance = BuildPySPtr\u003cBase\u003e(this,(PyTypeObject*)m_ScriptControllerClass);\n\n    if (!m_ScriptControllerInstance)\n    {\n        msg_error() \u003c\u003c \" load error (class '\" \u003c\u003cm_classname.getValueString()\u003c\u003c\"' instanciation error).\" ;\n        return;\n    }\n\n    refreshBinding();\n}\n\nvoid PythonScriptController::doLoadScript()\n{\n    loadScript() ;\n}\n\nvoid PythonScriptController::script_onIdleEvent(const IdleEvent* /*event*/)\n{\n    FileMonitor::updates(0);\n\n    {\n        PythonEnvironment::gil lock(__func__);\n        SP_CALL_MODULEFUNC_NOPARAM(m_Func_onIdle) ;\n    }\n\n    /// Flush the console to avoid the sys.stdout.flush() in each script function.\n    std::cout.flush() ;\n    std::cerr.flush() ;\n}\n\nvoid PythonScriptController::script_onLoaded(Node *node)\n{\n    PythonEnvironment::gil lock(__func__);    \n    SP_CALL_MODULEFUNC(m_Func_onLoaded, \"(O)\", sofa::PythonFactory::toPython(node))\n}\n\nvoid PythonScriptController::script_createGraph(Node *node)\n{\n    PythonEnvironment::gil lock(__func__);    \n    SP_CALL_MODULEFUNC(m_Func_createGraph, \"(O)\", sofa::PythonFactory::toPython(node))\n}\n\nvoid PythonScriptController::script_initGraph(Node *node)\n{\n    PythonEnvironment::gil lock(__func__);    \n    SP_CALL_MODULEFUNC(m_Func_initGraph, \"(O)\", sofa::PythonFactory::toPython(node))\n}\n\nvoid PythonScriptController::script_bwdInitGraph(Node *node)\n{\n    PythonEnvironment::gil lock(__func__);    \n    SP_CALL_MODULEFUNC(m_Func_bwdInitGraph, \"(O)\", sofa::PythonFactory::toPython(node))\n}\n\nbool PythonScriptController::script_onKeyPressed(const char c)\n{\n    ActivableScopedAdvancedTimer advancedTimer(m_timingEnabled.getValue(), \n                                               \"PythonScriptController_onKeyPressed\", this);\n    bool b = false;\n    PythonEnvironment::gil lock(__func__);    \n    SP_CALL_MODULEBOOLFUNC(m_Func_onKeyPressed,\"(c)\", c);\n    return b;\n}\n\nbool PythonScriptController::script_onKeyReleased(const char c)\n{\n\n    ActivableScopedAdvancedTimer advancedTimer(m_timingEnabled.getValue(),\n                                               \"PythonScriptController_onKeyReleased\", this);\n    bool b = false;\n    PythonEnvironment::gil lock(__func__);    \n    SP_CALL_MODULEBOOLFUNC(m_Func_onKeyReleased,\"(c)\", c);\n    return b;\n}\n\nvoid PythonScriptController::script_onMouseMove(const int posX,const int posY)\n{\n     ActivableScopedAdvancedTimer advancedTimer(m_timingEnabled.getValue(),\n                                                \"PythonScriptController_onMouseMove\",this);\n\n     PythonEnvironment::gil lock(__func__);\n     SP_CALL_MODULEFUNC(m_Func_onMouseMove, \"(ii)\", posX, posY);\n}\n\nvoid PythonScriptController::script_onMouseButtonLeft(const int posX,const int posY,const bool pressed)\n{\n    ActivableScopedAdvancedTimer advancedTimer(m_timingEnabled.getValue(), \n                                               \"PythonScriptController_onMouseButtonLeft\",this);\n    PythonEnvironment::gil lock(__func__);    \n    PyObject *pyPressed = pressed? Py_True : Py_False;\n    SP_CALL_MODULEFUNC(m_Func_onMouseButtonLeft, \"(iiO)\", posX,posY,pyPressed)\n}\n\nvoid PythonScriptController::script_onMouseButtonRight(const int posX,const int posY,const bool pressed)\n{\n    ActivableScopedAdvancedTimer advancedTimer(m_timingEnabled.getValue(), \n                                               \"PythonScriptController_onMouseButtonRight\", this);\n    PythonEnvironment::gil lock(__func__);\n    PyObject *pyPressed = pressed? Py_True : Py_False;\n    SP_CALL_MODULEFUNC(m_Func_onMouseButtonRight, \"(iiO)\", posX,posY,pyPressed)\n}\n\nvoid PythonScriptController::script_onMouseButtonMiddle(const int posX,const int posY,const bool pressed)\n{\n    ActivableScopedAdvancedTimer advancedTimer(m_timingEnabled.getValue(), \n                                               \"PythonScriptController_onMouseButtonMiddle\", this);\n    PythonEnvironment::gil lock(__func__);\n    PyObject *pyPressed = pressed? Py_True : Py_False;\n    SP_CALL_MODULEFUNC(m_Func_onMouseButtonMiddle, \"(iiO)\", posX,posY,pyPressed)\n}\n\nvoid PythonScriptController::script_onMouseWheel(const int posX,const int posY,const int delta)\n{\n    ActivableScopedAdvancedTimer advancedTimer(m_timingEnabled.getValue(),\n                                               \"PythonScriptController_onMouseWheel\", this);\n    PythonEnvironment::gil lock(__func__);\n    SP_CALL_MODULEFUNC(m_Func_onMouseWheel, \"(iii)\", posX,posY,delta)\n}\n\n\nvoid PythonScriptController::script_onBeginAnimationStep(const double dt)\n{\n    ActivableScopedAdvancedTimer advancedTimer(m_timingEnabled.getValue(),\n                                               \"PythonScriptController_onBeginAnimationStep\", this);\n    PythonEnvironment::gil lock(__func__);\n    SP_CALL_MODULEFUNC(m_Func_onBeginAnimationStep, \"(d)\", dt)\n}\n\nvoid PythonScriptController::script_onEndAnimationStep(const double dt)\n{\n    ActivableScopedAdvancedTimer advancedTimer(m_timingEnabled.getValue(),\n                                               \"PythonScriptController_onEndAnimationStep\", this);\n    PythonEnvironment::gil lock(__func__);    \n    SP_CALL_MODULEFUNC(m_Func_onEndAnimationStep, \"(d)\", dt)\n}\n\nvoid PythonScriptController::script_storeResetState()\n{\n    PythonEnvironment::gil lock(__func__);\n    SP_CALL_MODULEFUNC_NOPARAM(m_Func_storeResetState)\n}\n\nvoid PythonScriptController::script_reset()\n{\n    PythonEnvironment::gil lock(__func__);    \n    SP_CALL_MODULEFUNC_NOPARAM(m_Func_reset)\n}\n\nvoid PythonScriptController::script_cleanup()\n{\n    PythonEnvironment::gil lock(__func__);    \n    SP_CALL_MODULEFUNC_NOPARAM(m_Func_cleanup)\n}\n\nvoid PythonScriptController::script_onGUIEvent(const char* controlID, const char* valueName, const char* value)\n{\n    ActivableScopedAdvancedTimer advancedTimer(m_timingEnabled.getValue(),\n                                               \"PythonScriptController_onGUIEvent\", this);\n    PythonEnvironment::gil lock(__func__);\n    SP_CALL_MODULEFUNC(m_Func_onGUIEvent,\"(sss)\",controlID,valueName,value);\n}\n\nvoid PythonScriptController::script_onScriptEvent(core::objectmodel::ScriptEvent* event)\n{\n    ActivableScopedAdvancedTimer advancedTimer(m_timingEnabled.getValue(), \n                                               \"PythonScriptController_onScriptEvent\", this);\n    PythonEnvironment::gil lock(__func__);\n    PythonScriptEvent *pyEvent = static_cast\u003cPythonScriptEvent*\u003e(event);\n    SP_CALL_MODULEFUNC(m_Func_onScriptEvent,\"(OsO)\",\n                       sofa::PythonFactory::toPython(pyEvent-\u003egetSender().get()),\n                       pyEvent-\u003egetEventName().c_str(),pyEvent-\u003egetUserData());\n}\n\n\n\nvoid PythonScriptController::script_draw(const core::visual::VisualParams*)\n{\n    ActivableScopedAdvancedTimer advancedTimer(m_timingEnabled.getValue(), \n                                               \"PythonScriptController_draw\", this);\n    PythonEnvironment::gil lock(__func__);\n    SP_CALL_MODULEFUNC_NOPARAM(m_Func_draw);\n}\n\nvoid PythonScriptController::handleEvent(core::objectmodel::Event *event)\n{\n    if (PythonScriptEvent::checkEventType(event)) {\n        script_onScriptEvent(static_cast\u003cPythonScriptEvent *\u003e (event));\n    } else {\n        ScriptController::handleEvent(event);\n    }\n}\n\n\n} // namespace controller\n\n} // namespace component\n\n} // namespace sofa\n\n"}
{"repo_name":"verybadsoldier/xbmc","ref":"refs/heads/master","path":"xbmc/visualizations/Vortex/angelscript/angelscript/source/as_scriptengine.cpp","copies":"96","language":"C++","content":"/*\n   AngelCode Scripting Library\n   Copyright (c) 2003-2009 Andreas Jonsson\n\n   This software is provided 'as-is', without any express or implied\n   warranty. In no event will the authors be held liable for any\n   damages arising from the use of this software.\n\n   Permission is granted to anyone to use this software for any\n   purpose, including commercial applications, and to alter it and\n   redistribute it freely, subject to the following restrictions:\n\n   1. The origin of this software must not be misrepresented; you\n      must not claim that you wrote the original software. If you use\n      this software in a product, an acknowledgment in the product\n      documentation would be appreciated but is not required.\n\n   2. Altered source versions must be plainly marked as such, and\n      must not be misrepresented as being the original software.\n\n   3. This notice may not be removed or altered from any source\n      distribution.\n\n   The original version of this library can be located at:\n   http://www.angelcode.com/angelscript/\n\n   Andreas Jonsson\n   andreas@angelcode.com\n*/\n\n\n//\n// as_scriptengine.cpp\n//\n// The implementation of the script engine interface\n//\n\n\n#include \u003cstdlib.h\u003e\n\n#include \"as_config.h\"\n#include \"as_scriptengine.h\"\n#include \"as_builder.h\"\n#include \"as_context.h\"\n#include \"as_string_util.h\"\n#include \"as_tokenizer.h\"\n#include \"as_texts.h\"\n#include \"as_module.h\"\n#include \"as_callfunc.h\"\n#include \"as_arrayobject.h\"\n#include \"as_generic.h\"\n#include \"as_scriptobject.h\"\n#include \"as_compiler.h\"\n\nBEGIN_AS_NAMESPACE\n\nextern \"C\"\n{\n\nAS_API const char * asGetLibraryVersion()\n{\n#ifdef _DEBUG\n\treturn ANGELSCRIPT_VERSION_STRING \" DEBUG\";\n#else\n\treturn ANGELSCRIPT_VERSION_STRING;\n#endif\n}\n\nAS_API const char * asGetLibraryOptions()\n{\n\tconst char *string = \" \"\n\n\t// Options\n#ifdef AS_MAX_PORTABILITY\n\t\t\"AS_MAX_PORTABILITY \"\n#endif\n#ifdef AS_DEBUG\n\t\t\"AS_DEBUG \"\n#endif\n#ifdef AS_NO_CLASS_METHODS\n\t\t\"AS_NO_CLASS_METHODS \"\n#endif\n#ifdef AS_USE_DOUBLE_AS_FLOAT\n\t\t\"AS_USE_DOUBLE_AS_FLOAT \"\n#endif\n#ifdef AS_64BIT_PTR\n\t\t\"AS_64BIT_PTR \"\n#endif\n#ifdef AS_NO_THREADS\n\t\t\"AS_NO_THREADS \"\n#endif\n#ifdef AS_NO_ATOMIC\n\t\t\"AS_NO_ATOMIC \"\n#endif\n\n\t// Target system\n#ifdef AS_WIN\n\t\t\"AS_WIN \"\n#endif\n#ifdef AS_LINUX\n\t\t\"AS_LINUX \"\n#endif\n#ifdef AS_MAC\n\t\t\"AS_MAC \"\n#endif\n#ifdef AS_BSD\n\t\t\"AS_BSD \"\n#endif\n#ifdef AS_XBOX\n\t\t\"AS_XBOX \"\n#endif\n#ifdef AS_XBOX360\n\t\t\"AS_XBOX360 \"\n#endif\n#ifdef AS_PSP\n\t\t\"AS_PSP \"\n#endif\n#ifdef AS_PS2\n\t\t\"AS_PS2 \"\n#endif\n#ifdef AS_PS3\n\t\t\"AS_PS3 \"\n#endif\n#ifdef AS_DC\n\t\t\"AS_DC \"\n#endif\n#ifdef AS_GC\n\t\t\"AS_GC \"\n#endif\n#ifdef AS_WII\n\t\t\"AS_WII \"\n#endif\n#ifdef AS_IPHONE\n\t\t\"AS_IPHONE \"\n#endif\n#ifdef AS_ANDROID\n\t\t\"AS_ANDROID \"\n#endif\n\n\t// CPU family\n#ifdef AS_PPC\n\t\t\"AS_PPC \"\n#endif\n#ifdef AS_PPC_64\n\t\t\"AS_PPC_64 \"\n#endif\n#ifdef AS_X86\n\t\t\"AS_X86 \"\n#endif\n#ifdef AS_MIPS\n\t\t\"AS_MIPS \"\n#endif\n#ifdef AS_SH4\n\t\t\"AS_SH4 \"\n#endif\n#ifdef AS_XENON\n\t\t\"AS_XENON \"\n#endif\n#ifdef AS_ARM\n\t\t\"AS_ARM \"\n#endif\n\t;\n\n\treturn string;\n}\n\nAS_API asIScriptEngine *asCreateScriptEngine(asDWORD version)\n{\n\t// Verify the version that the application expects\n\tif( (version/10000) != (ANGELSCRIPT_VERSION/10000) )\n\t\treturn 0;\n\n\tif( (version/100)%100 != (ANGELSCRIPT_VERSION/100)%100 )\n\t\treturn 0;\n\n\tif( (version%100) \u003e (ANGELSCRIPT_VERSION%100) )\n\t\treturn 0;\n\n\t// Verify the size of the types\n\tasASSERT( sizeof(asBYTE)  == 1 );\n\tasASSERT( sizeof(asWORD)  == 2 );\n\tasASSERT( sizeof(asDWORD) == 4 );\n\tasASSERT( sizeof(asQWORD) == 8 );\n\tasASSERT( sizeof(asPWORD) == sizeof(void*) );\n\n\t// Verify the boolean type\n\tasASSERT( sizeof(bool) == AS_SIZEOF_BOOL );\n\tasASSERT( true == VALUE_OF_BOOLEAN_TRUE );\n\n\t// Verify endianess\n#ifdef AS_BIG_ENDIAN\n\tasASSERT( *(asDWORD*)\"\\x00\\x01\\x02\\x03\" == 0x00010203 );\n\tasASSERT( *(asQWORD*)\"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\" == I64(0x0001020304050607) );\n#else\n\tasASSERT( *(asDWORD*)\"\\x00\\x01\\x02\\x03\" == 0x03020100 );\n\tasASSERT( *(asQWORD*)\"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\" == I64(0x0706050403020100) );\n#endif\n\n\treturn asNEW(asCScriptEngine)();\n}\n\nint asCScriptEngine::SetEngineProperty(asEEngineProp property, asPWORD value)\n{\n\tswitch( property )\n\t{\n\tcase asEP_ALLOW_UNSAFE_REFERENCES:\n\t\tep.allowUnsafeReferences = value ? true : false;\n\t\tbreak;\n\n\tcase asEP_OPTIMIZE_BYTECODE:\n\t\tep.optimizeByteCode = value ? true : false;\n\t\tbreak;\n\n\tcase asEP_COPY_SCRIPT_SECTIONS:\n\t\tep.copyScriptSections = value ? true : false;\n\t\tbreak;\n\n\tcase asEP_MAX_STACK_SIZE:\n\t\t// The size is given in bytes, but we only store dwords\n\t\tep.maximumContextStackSize = (int)value/4;\n\t\tif( initialContextStackSize \u003e ep.maximumContextStackSize )\n\t\t\tinitialContextStackSize = ep.maximumContextStackSize;\n\t\tbreak;\n\n\tcase asEP_USE_CHARACTER_LITERALS:\n\t\tep.useCharacterLiterals = value ? true : false;\n\t\tbreak;\n\n\tcase asEP_ALLOW_MULTILINE_STRINGS:\n\t\tep.allowMultilineStrings = value ? true : false;\n\t\tbreak;\n\n\tcase asEP_ALLOW_IMPLICIT_HANDLE_TYPES:\n\t\tep.allowImplicitHandleTypes = value ? true : false;\n\t\tbreak;\n\n\tcase asEP_BUILD_WITHOUT_LINE_CUES:\n\t\tep.buildWithoutLineCues = value ? true : false;\n\t\tbreak;\n\n\tcase asEP_INIT_GLOBAL_VARS_AFTER_BUILD:\n\t\tep.initGlobalVarsAfterBuild = value ? true : false;\n\t\tbreak;\n\n\tcase asEP_REQUIRE_ENUM_SCOPE:\n\t\tep.requireEnumScope = value ? true : false;\n\t\tbreak;\n\n\tcase asEP_SCRIPT_SCANNER:\n\t\tif( value \u003c= 1 )\n\t\t\tep.scanner = (int)value;\n\t\telse\n\t\t\treturn asINVALID_ARG;\n\t\tbreak;\n\n\tcase asEP_INCLUDE_JIT_INSTRUCTIONS:\n\t\tep.includeJitInstructions = value ? true : false;\n\t\tbreak;\n\n\tcase asEP_STRING_ENCODING:\n\t\tif( value \u003c= 1 )\n\t\t\tep.stringEncoding = (int)value;\n\t\telse\n\t\t\treturn asINVALID_ARG;\n\t\tbreak;\n\n\tdefault:\n\t\treturn asINVALID_ARG;\n\t}\n\n\treturn asSUCCESS;\n}\n\nasPWORD asCScriptEngine::GetEngineProperty(asEEngineProp property)\n{\n\tswitch( property )\n\t{\n\tcase asEP_ALLOW_UNSAFE_REFERENCES:\n\t\treturn ep.allowUnsafeReferences;\n\n\tcase asEP_OPTIMIZE_BYTECODE:\n\t\treturn ep.optimizeByteCode;\n\n\tcase asEP_COPY_SCRIPT_SECTIONS:\n\t\treturn ep.copyScriptSections;\n\n\tcase asEP_MAX_STACK_SIZE:\n\t\treturn ep.maximumContextStackSize*4;\n\n\tcase asEP_USE_CHARACTER_LITERALS:\n\t\treturn ep.useCharacterLiterals;\n\n\tcase asEP_ALLOW_MULTILINE_STRINGS:\n\t\treturn ep.allowMultilineStrings;\n\n\tcase asEP_ALLOW_IMPLICIT_HANDLE_TYPES:\n\t\treturn ep.allowImplicitHandleTypes;\n\n\tcase asEP_BUILD_WITHOUT_LINE_CUES:\n\t\treturn ep.buildWithoutLineCues;\n\n\tcase asEP_INIT_GLOBAL_VARS_AFTER_BUILD:\n\t\treturn ep.initGlobalVarsAfterBuild;\n\n\tcase asEP_REQUIRE_ENUM_SCOPE:\n\t\treturn ep.requireEnumScope;\n\n\tcase asEP_SCRIPT_SCANNER:\n\t\treturn ep.scanner;\n\n\tcase asEP_INCLUDE_JIT_INSTRUCTIONS:\n\t\treturn ep.includeJitInstructions;\n\n\tcase asEP_STRING_ENCODING:\n\t\treturn ep.stringEncoding;\n\t}\n\n\treturn 0;\n}\n\n} // extern \"C\"\n\n\n\n\n\nasCScriptEngine::asCScriptEngine()\n{\n\t// Instanciate the thread manager\n\tif( threadManager == 0 )\n\t\tthreadManager = asNEW(asCThreadManager);\n\telse\n\t\tthreadManager-\u003eAddRef();\n\n\t// Engine properties\n\tep.allowUnsafeReferences    = false;\n\tep.optimizeByteCode         = true;\n\tep.copyScriptSections       = true;\n\tep.maximumContextStackSize  = 0;         // no limit\n\tep.useCharacterLiterals     = false;\n\tep.allowMultilineStrings    = false;\n\tep.allowImplicitHandleTypes = false;\n\tep.buildWithoutLineCues     = false;\n\tep.initGlobalVarsAfterBuild = true;\n\tep.requireEnumScope         = false;\n\tep.scanner                  = 1;         // utf8. 0 = ascii\n\tep.includeJitInstructions   = false;\n\tep.stringEncoding           = 0;         // utf8. 1 = utf16\n\n\tgc.engine = this;\n\n\trefCount.set(1);\n\tstringFactory = 0;\n\tconfigFailed = false;\n\tisPrepared = false;\n\tisBuilding = false;\n\tlastModule = 0;\n\n\n\tuserData = 0;\n\n\tinitialContextStackSize = 1024;      // 1 KB\n\n\n\ttypeIdSeqNbr = 0;\n\tcurrentGroup = \u0026defaultGroup;\n\n\tmsgCallback = 0;\n    jitCompiler = 0;\n\n\t// Reserve function id 0 for no function\n\tscriptFunctions.PushLast(0);\n\n\t// Make sure typeId for the built-in primitives are defined according to asETypeIdFlags\n\tint id;\n\tid = GetTypeIdFromDataType(asCDataType::CreatePrimitive(ttVoid,   false)); asASSERT( id == asTYPEID_VOID   );\n\tid = GetTypeIdFromDataType(asCDataType::CreatePrimitive(ttBool,   false)); asASSERT( id == asTYPEID_BOOL   );\n\tid = GetTypeIdFromDataType(asCDataType::CreatePrimitive(ttInt8,   false)); asASSERT( id == asTYPEID_INT8   );\n\tid = GetTypeIdFromDataType(asCDataType::CreatePrimitive(ttInt16,  false)); asASSERT( id == asTYPEID_INT16  );\n\tid = GetTypeIdFromDataType(asCDataType::CreatePrimitive(ttInt,    false)); asASSERT( id == asTYPEID_INT32  );\n\tid = GetTypeIdFromDataType(asCDataType::CreatePrimitive(ttInt64,  false)); asASSERT( id == asTYPEID_INT64  );\n\tid = GetTypeIdFromDataType(asCDataType::CreatePrimitive(ttUInt8,  false)); asASSERT( id == asTYPEID_UINT8  );\n\tid = GetTypeIdFromDataType(asCDataType::CreatePrimitive(ttUInt16, false)); asASSERT( id == asTYPEID_UINT16 );\n\tid = GetTypeIdFromDataType(asCDataType::CreatePrimitive(ttUInt,   false)); asASSERT( id == asTYPEID_UINT32 );\n\tid = GetTypeIdFromDataType(asCDataType::CreatePrimitive(ttUInt64, false)); asASSERT( id == asTYPEID_UINT64 );\n\tid = GetTypeIdFromDataType(asCDataType::CreatePrimitive(ttFloat,  false)); asASSERT( id == asTYPEID_FLOAT  );\n\tid = GetTypeIdFromDataType(asCDataType::CreatePrimitive(ttDouble, false)); asASSERT( id == asTYPEID_DOUBLE );\n\n\tdefaultArrayObjectType = 0;\n\n\tRegisterArrayObject(this);\n\tRegisterScriptObject(this);\n\tRegisterScriptFunction(this);\n\tRegisterObjectTypeGCBehaviours(this);\n}\n\nasCScriptEngine::~asCScriptEngine()\n{\n\tasASSERT(refCount.get() == 0);\n\tasUINT n;\n\n\t// The modules must be deleted first, as they may use\n\t// object types from the config groups\n\tfor( n = (asUINT)scriptModules.GetLength(); n-- \u003e 0; )\n\t{\n\t\tif( scriptModules[n] )\n\t\t{\n\t\t\tasDELETE(scriptModules[n],asCModule);\n\t\t}\n\t}\n\tscriptModules.SetLength(0);\n\n\tGarbageCollect(asGC_FULL_CYCLE);\n\n\t// Delete the functions for template types that may references object types\n\tfor( n = 0; n \u003c templateTypes.GetLength(); n++ )\n\t{\n\t\tif( templateTypes[n] )\n\t\t{\n\t\t\tasUINT f;\n\n\t\t\t// Delete the factory stubs first\n\t\t\tfor( f = 0; f \u003c templateTypes[n]-\u003ebeh.factories.GetLength(); f++ )\n\t\t\t{\n\t\t\t\tscriptFunctions[templateTypes[n]-\u003ebeh.factories[f]]-\u003eRelease();\n\t\t\t}\n\t\t\ttemplateTypes[n]-\u003ebeh.factories.Allocate(0, false);\n\n\t\t\t// Delete the specialized functions\n\t\t\tfor( f = 1; f \u003c templateTypes[n]-\u003ebeh.operators.GetLength(); f += 2 )\n\t\t\t{\n\t\t\t\tif( scriptFunctions[templateTypes[n]-\u003ebeh.operators[f]]-\u003eobjectType == templateTypes[n] )\n\t\t\t\t{\n\t\t\t\t\tscriptFunctions[templateTypes[n]-\u003ebeh.operators[f]]-\u003eRelease();\n\t\t\t\t\ttemplateTypes[n]-\u003ebeh.operators[f] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Do one more garbage collect to free gc objects that were global variables\n\tGarbageCollect(asGC_FULL_CYCLE);\n\tFreeUnusedGlobalProperties();\n\tClearUnusedTypes();\n\n\t// Break all relationship between remaining class types and functions\n\tfor( n = 0; n \u003c classTypes.GetLength(); n++ )\n\t{\n\t\tif( classTypes[n] )\n\t\t\tclassTypes[n]-\u003eReleaseAllFunctions();\n\n\t\tif( classTypes[n]-\u003ederivedFrom )\n\t\t{\n\t\t\tclassTypes[n]-\u003ederivedFrom-\u003eRelease();\n\t\t\tclassTypes[n]-\u003ederivedFrom = 0;\n\t\t}\n\t}\n\n\tGarbageCollect(asGC_FULL_CYCLE);\n\tFreeUnusedGlobalProperties();\n\tClearUnusedTypes();\n\n\tasSMapNode\u003cint,asCDataType*\u003e *cursor = 0;\n\twhile( mapTypeIdToDataType.MoveFirst(\u0026cursor) )\n\t{\n\t\tasDELETE(mapTypeIdToDataType.GetValue(cursor),asCDataType);\n\t\tmapTypeIdToDataType.Erase(cursor);\n\t}\n\n\tdefaultGroup.RemoveConfiguration(this);\n\twhile( configGroups.GetLength() )\n\t{\n\t\t// Delete config groups in the right order\n\t\tasCConfigGroup *grp = configGroups.PopLast();\n\t\tif( grp )\n\t\t{\n\t\t\tasDELETE(grp,asCConfigGroup);\n\t\t}\n\t}\n\n\tfor( n = 0; n \u003c registeredGlobalProps.GetLength(); n++ )\n\t{\n\t\tif( registeredGlobalProps[n] )\n\t\t{\n\t\t\tasDELETE(registeredGlobalProps[n],asCGlobalProperty);\n\t\t}\n\t}\n\tregisteredGlobalProps.SetLength(0);\n\tFreeUnusedGlobalProperties();\n\n\tfor( n = 0; n \u003c templateTypes.GetLength(); n++ )\n\t{\n\t\tif( templateTypes[n] )\n\t\t{\n\t\t\t// Clear the sub type before deleting the template type so that the sub type isn't freed to soon\n\t\t\ttemplateTypes[n]-\u003etemplateSubType = asCDataType::CreateNullHandle();\n\t\t\tasDELETE(templateTypes[n],asCObjectType);\n\t\t}\n\t}\n\ttemplateTypes.SetLength(0);\n\n\tfor( n = 0; n \u003c objectTypes.GetLength(); n++ )\n\t{\n\t\tif( objectTypes[n] )\n\t\t{\n\t\t\t// Clear the sub type before deleting the template type so that the sub type isn't freed to soon\n\t\t\tobjectTypes[n]-\u003etemplateSubType = asCDataType::CreateNullHandle();\n\t\t\tasDELETE(objectTypes[n],asCObjectType);\n\t\t}\n\t}\n\tobjectTypes.SetLength(0);\n\tfor( n = 0; n \u003c templateSubTypes.GetLength(); n++ )\n\t{\n\t\tif( templateSubTypes[n] )\n\t\t{\n\t\t\tasDELETE(templateSubTypes[n], asCObjectType);\n\t\t}\n\t}\n\ttemplateSubTypes.SetLength(0);\n\tregisteredTypeDefs.SetLength(0);\n\tregisteredEnums.SetLength(0);\n\tregisteredObjTypes.SetLength(0);\n\n\tfor( n = 0; n \u003c registeredGlobalFuncs.GetLength(); n++ )\n\t{\n\t\tif( registeredGlobalFuncs[n] )\n\t\t\tregisteredGlobalFuncs[n]-\u003eRelease();\n\t}\n\tregisteredGlobalFuncs.SetLength(0);\n\n\tscriptTypeBehaviours.ReleaseAllFunctions();\n\tfunctionBehaviours.ReleaseAllFunctions();\n\tobjectTypeBehaviours.ReleaseAllFunctions();\n\n\t// Free string constants\n\tfor( n = 0; n \u003c stringConstants.GetLength(); n++ )\n\t{\n\t\tasDELETE(stringConstants[n],asCString);\n\t}\n\tstringConstants.SetLength(0);\n\n\t// Free the script section names\n\tfor( n = 0; n \u003c scriptSectionNames.GetLength(); n++ )\n\t{\n\t\tasDELETE(scriptSectionNames[n],asCString);\n\t}\n\tscriptSectionNames.SetLength(0);\n\n\t// Release the thread manager\n\tthreadManager-\u003eRelease();\n}\n\n// interface\nint asCScriptEngine::AddRef()\n{\n\treturn refCount.atomicInc();\n}\n\n// interface\nint asCScriptEngine::Release()\n{\n\tint r = refCount.atomicDec();\n\n\tif( r == 0 )\n\t{\n\t\tasDELETE(this,asCScriptEngine);\n\t\treturn 0;\n\t}\n\n\treturn r;\n}\n\n// interface\nvoid *asCScriptEngine::SetUserData(void *data)\n{\n\tvoid *old = userData;\n\tuserData = data;\n\treturn old;\n}\n\n// interface\nvoid *asCScriptEngine::GetUserData()\n{\n\treturn userData;\n}\n\n// interface\nint asCScriptEngine::SetMessageCallback(const asSFuncPtr \u0026callback, void *obj, asDWORD callConv)\n{\n\tmsgCallback = true;\n\tmsgCallbackObj = obj;\n\tbool isObj = false;\n\tif( (unsigned)callConv == asCALL_GENERIC )\n\t{\n\t\tmsgCallback = false;\n\t\treturn asNOT_SUPPORTED;\n\t}\n\tif( (unsigned)callConv \u003e= asCALL_THISCALL )\n\t{\n\t\tisObj = true;\n\t\tif( obj == 0 )\n\t\t{\n\t\t\tmsgCallback = false;\n\t\t\treturn asINVALID_ARG;\n\t\t}\n\t}\n\tint r = DetectCallingConvention(isObj, callback, callConv, \u0026msgCallbackFunc);\n\tif( r \u003c 0 ) msgCallback = false;\n\treturn r;\n}\n\n// interface\nint asCScriptEngine::ClearMessageCallback()\n{\n\tmsgCallback = false;\n\treturn 0;\n}\n\n// interface\nint asCScriptEngine::WriteMessage(const char *section, int row, int col, asEMsgType type, const char *message)\n{\n\t// Validate input parameters\n\tif( section == 0 ||\n\t\tmessage == 0 )\n\t\treturn asINVALID_ARG;\n\n\t// If there is no callback then there's nothing to do\n\tif( !msgCallback )\n\t\treturn 0;\n\n\tasSMessageInfo msg;\n\tmsg.section = section;\n\tmsg.row     = row;\n\tmsg.col     = col;\n\tmsg.type    = type;\n\tmsg.message = message;\n\n\tif( msgCallbackFunc.callConv \u003c ICC_THISCALL )\n\t\tCallGlobalFunction(\u0026msg, msgCallbackObj, \u0026msgCallbackFunc, 0);\n\telse\n\t\tCallObjectMethod(msgCallbackObj, \u0026msg, \u0026msgCallbackFunc, 0);\n\n\treturn 0;\n}\n\nint asCScriptEngine::SetJITCompiler(asIJITCompiler *compiler)\n{\n    jitCompiler = compiler;\n    return asSUCCESS;\n}\n\nasIJITCompiler *asCScriptEngine::GetJITCompiler()\n{\n    return jitCompiler;\n}\n\n// interface\nasETokenClass asCScriptEngine::ParseToken(const char *string, size_t stringLength, int *tokenLength)\n{\n\tif( stringLength == 0 )\n\t\tstringLength = strlen(string);\n\n\tsize_t len;\n\tasCTokenizer t;\n\tasETokenClass tc;\n\tt.GetToken(string, stringLength, \u0026len, \u0026tc);\n\n\tif( tokenLength )\n\t\t*tokenLength = (int)len;\n\n\treturn tc;\n}\n\n// interface\nasIScriptModule *asCScriptEngine::GetModule(const char *module, asEGMFlags flag)\n{\n\tasCModule *mod = GetModule(module, false);\n\n\tif( flag == asGM_ALWAYS_CREATE )\n\t{\n\t\tif( mod != 0 )\n\t\t{\n\t\t\tasDELETE(mod, asCModule);\n\t\t}\n\t\treturn GetModule(module, true);\n\t}\n\n\tif( mod == 0 \u0026\u0026 flag == asGM_CREATE_IF_NOT_EXISTS )\n\t{\n\t\treturn GetModule(module, true);\n\t}\n\n\treturn mod;\n}\n\n// interface\nint asCScriptEngine::DiscardModule(const char *module)\n{\n\tasCModule *mod = GetModule(module, false);\n\tif( mod == 0 ) return asNO_MODULE;\n\n\tasDELETE(mod, asCModule);\n\n\tFreeUnusedGlobalProperties();\n\tClearUnusedTypes();\n\n\treturn 0;\n}\n\nvoid asCScriptEngine::ClearUnusedTypes()\n{\n\t// Build a list of all types to check for\n\tasCArray\u003casCObjectType*\u003e types;\n\ttypes = classTypes;\n\ttypes.Concatenate(templateInstanceTypes);\n\n\t// Go through all modules\n\tasUINT n;\n\tfor( n = 0; n \u003c scriptModules.GetLength() \u0026\u0026 types.GetLength(); n++ )\n\t{\n\t\tasCModule *mod = scriptModules[n];\n\t\tif( mod )\n\t\t{\n\t\t\t// Functions/Methods/Globals are handled after this\n\n\t\t\t// Go through all type declarations\n\t\t\tasUINT m;\n\t\t\tfor( m = 0; m \u003c mod-\u003eclassTypes.GetLength() \u0026\u0026 types.GetLength(); m++ )\n\t\t\t\tRemoveTypeAndRelatedFromList(types, mod-\u003eclassTypes[m]);\n\t\t\tfor( m = 0; m \u003c mod-\u003eenumTypes.GetLength() \u0026\u0026 types.GetLength(); m++ )\n\t\t\t\tRemoveTypeAndRelatedFromList(types, mod-\u003eenumTypes[m]);\n\t\t\tfor( m = 0; m \u003c mod-\u003etypeDefs.GetLength() \u0026\u0026 types.GetLength(); m++ )\n\t\t\t\tRemoveTypeAndRelatedFromList(types, mod-\u003etypeDefs[m]);\n\t\t}\n\t}\n\n\t// Go through all function parameters and remove used types\n\tfor( n = 0; n \u003c scriptFunctions.GetLength() \u0026\u0026 types.GetLength(); n++ )\n\t{\n\t\tasCScriptFunction *func = scriptFunctions[n];\n\t\tif( func )\n\t\t{\n\t\t\t// Ignore factory stubs\n\t\t\tif( func-\u003ename == \"factstub\" )\n\t\t\t\tcontinue;\n\n\t\t\tasCObjectType *ot = func-\u003ereturnType.GetObjectType();\n\t\t\tif( ot != 0 \u0026\u0026 ot != func-\u003eobjectType )\n\t\t\t\tif( func-\u003ename != ot-\u003ename )\n\t\t\t\t\tRemoveTypeAndRelatedFromList(types, ot);\n\n\t\t\tfor( asUINT p = 0; p \u003c func-\u003eparameterTypes.GetLength(); p++ )\n\t\t\t{\n\t\t\t\tot = func-\u003eparameterTypes[p].GetObjectType();\n\t\t\t\tif( ot != 0 \u0026\u0026 ot != func-\u003eobjectType )\n\t\t\t\t\tif( func-\u003ename != ot-\u003ename )\n\t\t\t\t\t\tRemoveTypeAndRelatedFromList(types, ot);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Go through all global properties\n\tfor( n = 0; n \u003c globalProperties.GetLength() \u0026\u0026 types.GetLength(); n++ )\n\t{\n\t\tif( globalProperties[n] \u0026\u0026 globalProperties[n]-\u003etype.GetObjectType() )\n\t\t\tRemoveTypeAndRelatedFromList(types, globalProperties[n]-\u003etype.GetObjectType());\n\t}\n\n\t// All that remains in the list after this can be discarded, since they are no longer used\n\tfor(;;)\n\t{\n\t\tbool didClearTemplateInstanceType = false;\n\n\t\tfor( n = 0; n \u003c types.GetLength(); n++ )\n\t\t{\n\t\t\t// Template types and script classes will have two references for each factory stub\n\t\t\tint refCount = ((types[n]-\u003eflags \u0026 asOBJ_TEMPLATE) || (types[n]-\u003eflags \u0026 asOBJ_SCRIPT_OBJECT)) ? 2*(int)types[n]-\u003ebeh.factories.GetLength() : 0;\n\n\t\t\tif( types[n]-\u003eGetRefCount() == refCount )\n\t\t\t{\n\t\t\t\tif( types[n]-\u003eflags \u0026 asOBJ_TEMPLATE )\n\t\t\t\t{\n\t\t\t\t\tdidClearTemplateInstanceType = true;\n\t\t\t\t\tRemoveTemplateInstanceType(types[n]);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tRemoveFromTypeIdMap(types[n]);\n\t\t\t\t\tasDELETE(types[n],asCObjectType);\n\n\t\t\t\t\tint i = classTypes.IndexOf(types[n]);\n\t\t\t\t\tif( i == (signed)classTypes.GetLength() - 1 )\n\t\t\t\t\t\tclassTypes.PopLast();\n\t\t\t\t\telse\n\t\t\t\t\t\tclassTypes[i] = classTypes.PopLast();\n\t\t\t\t}\n\n\t\t\t\t// Remove the type from the array\n\t\t\t\tif( n \u003c types.GetLength() - 1 )\n\t\t\t\t\ttypes[n] = types.PopLast();\n\t\t\t\telse\n\t\t\t\t\ttypes.PopLast();\n\t\t\t\tn--;\n\t\t\t}\n\t\t}\n\n\t\tif( didClearTemplateInstanceType == false )\n\t\t\tbreak;\n\t}\n}\n\nvoid asCScriptEngine::RemoveTypeAndRelatedFromList(asCArray\u003casCObjectType*\u003e \u0026types, asCObjectType *ot)\n{\n\t// Remove the type from the list\n\tint i = types.IndexOf(ot);\n\tif( i == -1 ) return;\n\n\tif( i == (signed)types.GetLength() - 1 )\n\t\ttypes.PopLast();\n\telse\n\t\ttypes[i] = types.PopLast();\n\n\t// If the type is an template type, then remove all sub types as well\n\tif( ot-\u003etemplateSubType.GetObjectType() )\n\t{\n\t\twhile( ot-\u003etemplateSubType.GetObjectType() )\n\t\t{\n\t\t\tot = ot-\u003etemplateSubType.GetObjectType();\n\t\t\tRemoveTypeAndRelatedFromList(types, ot);\n\t\t}\n\t\treturn;\n\t}\n\n\t// If the type is a class, then remove all properties types as well\n\tif( ot-\u003eproperties.GetLength() )\n\t{\n\t\tfor( asUINT n = 0; n \u003c ot-\u003eproperties.GetLength(); n++ )\n\t\t\tRemoveTypeAndRelatedFromList(types, ot-\u003eproperties[n]-\u003etype.GetObjectType());\n\t}\n}\n\n\n// internal\nint asCScriptEngine::GetFactoryIdByDecl(const asCObjectType *ot, const char *decl)\n{\n\tasCModule *mod = 0;\n\n\t// Is this a script class?\n\tif( ot-\u003eflags \u0026 asOBJ_SCRIPT_OBJECT \u0026\u0026 ot-\u003esize \u003e 0 )\n\t\tmod = scriptFunctions[ot-\u003ebeh.factory]-\u003emodule;\n\n\tasCBuilder bld(this, mod);\n\n\tasCScriptFunction func(this, mod,-1);\n\tint r = bld.ParseFunctionDeclaration(0, decl, \u0026func, false);\n\tif( r \u003c 0 )\n\t\treturn asINVALID_DECLARATION;\n\n\t// Search for matching factory function\n\tint id = -1;\n\tfor( size_t n = 0; n \u003c ot-\u003ebeh.factories.GetLength(); n++ )\n\t{\n\t\tasCScriptFunction *f = scriptFunctions[ot-\u003ebeh.factories[n]];\n\t\tif( f-\u003eIsSignatureEqual(\u0026func) )\n\t\t{\n\t\t\tid = ot-\u003ebeh.factories[n];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif( id == -1 ) return asNO_FUNCTION;\n\n\treturn id;\n}\n\n\n// internal\nint asCScriptEngine::GetMethodIdByDecl(const asCObjectType *ot, const char *decl, asCModule *mod)\n{\n\tasCBuilder bld(this, mod);\n\n\tasCScriptFunction func(this, mod, -1);\n\tint r = bld.ParseFunctionDeclaration(0, decl, \u0026func, false);\n\tif( r \u003c 0 )\n\t\treturn asINVALID_DECLARATION;\n\n\t// Set the object type so that the signature can be properly compared\n\t// This cast is OK, it will only be used for comparison\n\tfunc.objectType = const_cast\u003casCObjectType*\u003e(ot);\n\n\t// Search script functions for matching interface\n\tint id = -1;\n\tfor( size_t n = 0; n \u003c ot-\u003emethods.GetLength(); ++n )\n\t{\n\t\tif( func.IsSignatureEqual(scriptFunctions[ot-\u003emethods[n]]) )\n\t\t{\n\t\t\tif( id == -1 )\n\t\t\t\tid = ot-\u003emethods[n];\n\t\t\telse\n\t\t\t\treturn asMULTIPLE_FUNCTIONS;\n\t\t}\n\t}\n\n\tif( id == -1 ) return asNO_FUNCTION;\n\n\treturn id;\n}\n\n\n// Internal\nasCString asCScriptEngine::GetFunctionDeclaration(int funcID)\n{\n\tasCString str;\n\tasCScriptFunction *func = GetScriptFunction(funcID);\n\tif( func )\n\t\tstr = func-\u003eGetDeclarationStr();\n\n\treturn str;\n}\n\nasCScriptFunction *asCScriptEngine::GetScriptFunction(int funcId)\n{\n\tif( funcId \u003c 0 || funcId \u003e= (int)scriptFunctions.GetLength() )\n\t\treturn 0;\n\n\treturn scriptFunctions[funcId];\n}\n\n\n\nasIScriptContext *asCScriptEngine::CreateContext()\n{\n\tasIScriptContext *ctx = 0;\n\tCreateContext(\u0026ctx, false);\n\treturn ctx;\n}\n\nint asCScriptEngine::CreateContext(asIScriptContext **context, bool isInternal)\n{\n\t*context = asNEW(asCContext)(this, !isInternal);\n\n\t// We need to make sure the engine has been \n\t// prepared before any context is executed\n\tPrepareEngine();\n\n\treturn 0;\n}\n\n\nint asCScriptEngine::RegisterObjectProperty(const char *obj, const char *declaration, int byteOffset)\n{\n\tint r;\n\tasCDataType dt;\n\tasCBuilder bld(this, 0);\n\tr = bld.ParseDataType(obj, \u0026dt);\n\tif( r \u003c 0 )\n\t\treturn ConfigError(r);\n\n\t// Verify that the correct config group is used\n\tif( currentGroup-\u003eFindType(dt.GetObjectType()-\u003ename.AddressOf()) == 0 )\n\t\treturn ConfigError(asWRONG_CONFIG_GROUP);\n\n\tasCDataType type;\n\tasCString name;\n\n\tif( (r = bld.VerifyProperty(\u0026dt, declaration, name, type)) \u003c 0 )\n\t\treturn ConfigError(r);\n\n\t// Store the property info\n\tif( dt.GetObjectType() == 0 )\n\t\treturn ConfigError(asINVALID_OBJECT);\n\n\tasCObjectProperty *prop = asNEW(asCObjectProperty);\n\tprop-\u003ename       = name;\n\tprop-\u003etype       = type;\n\tprop-\u003ebyteOffset = byteOffset;\n\n\tdt.GetObjectType()-\u003eproperties.PushLast(prop);\n\n\tcurrentGroup-\u003eRefConfigGroup(FindConfigGroupForObjectType(type.GetObjectType()));\n\n\treturn asSUCCESS;\n}\n\nint asCScriptEngine::RegisterInterface(const char *name)\n{\n\tif( name == 0 ) return ConfigError(asINVALID_NAME);\n\n\t// Verify if the name has been registered as a type already\n\tasUINT n;\n\tfor( n = 0; n \u003c objectTypes.GetLength(); n++ )\n\t{\n\t\tif( objectTypes[n] \u0026\u0026 objectTypes[n]-\u003ename == name )\n\t\t\treturn asALREADY_REGISTERED;\n\t}\n\n\t// Use builder to parse the datatype\n\tasCDataType dt;\n\tasCBuilder bld(this, 0);\n\tbool oldMsgCallback = msgCallback; msgCallback = false;\n\tint r = bld.ParseDataType(name, \u0026dt);\n\tmsgCallback = oldMsgCallback;\n\tif( r \u003e= 0 ) return ConfigError(asERROR);\n\n\t// Make sure the name is not a reserved keyword\n\tasCTokenizer t;\n\tsize_t tokenLen;\n\tint token = t.GetToken(name, strlen(name), \u0026tokenLen);\n\tif( token != ttIdentifier || strlen(name) != tokenLen )\n\t\treturn ConfigError(asINVALID_NAME);\n\n\tr = bld.CheckNameConflict(name, 0, 0);\n\tif( r \u003c 0 )\n\t\treturn ConfigError(asNAME_TAKEN);\n\n\t// Don't have to check against members of object\n\t// types as they are allowed to use the names\n\n\t// Register the object type for the interface\n\tasCObjectType *st = asNEW(asCObjectType)(this);\n\tst-\u003eflags = asOBJ_REF | asOBJ_SCRIPT_OBJECT;\n\tst-\u003esize = 0; // Cannot be instanciated\n\tst-\u003ename = name;\n\n\t// Use the default script class behaviours\n\tst-\u003ebeh.factory = 0;\n\tst-\u003ebeh.addref = scriptTypeBehaviours.beh.addref;\n\tscriptFunctions[st-\u003ebeh.addref]-\u003eAddRef();\n\tst-\u003ebeh.release = scriptTypeBehaviours.beh.release;\n\tscriptFunctions[st-\u003ebeh.release]-\u003eAddRef();\n\tst-\u003ebeh.copy = 0;\n\n\tobjectTypes.PushLast(st);\n\tregisteredObjTypes.PushLast(st);\n\n\tcurrentGroup-\u003eobjTypes.PushLast(st);\n\n\treturn asSUCCESS;\n}\n\nint asCScriptEngine::RegisterInterfaceMethod(const char *intf, const char *declaration)\n{\n\t// Verify that the correct config group is set.\n\tif( currentGroup-\u003eFindType(intf) == 0 )\n\t\treturn ConfigError(asWRONG_CONFIG_GROUP);\n\n\tasCDataType dt;\n\tasCBuilder bld(this, 0);\n\tint r = bld.ParseDataType(intf, \u0026dt);\n\tif( r \u003c 0 )\n\t\treturn ConfigError(r);\n\n\tasCScriptFunction *func = asNEW(asCScriptFunction)(this, 0, asFUNC_INTERFACE);\n\tfunc-\u003eobjectType = dt.GetObjectType();\n\n\tr = bld.ParseFunctionDeclaration(func-\u003eobjectType, declaration, func, false);\n\tif( r \u003c 0 )\n\t{\n\t\tasDELETE(func,asCScriptFunction);\n\t\treturn ConfigError(asINVALID_DECLARATION);\n\t}\n\n\t// Check name conflicts\n\tr = bld.CheckNameConflictMember(dt, func-\u003ename.AddressOf(), 0, 0);\n\tif( r \u003c 0 )\n\t{\n\t\tasDELETE(func,asCScriptFunction);\n\t\treturn ConfigError(asNAME_TAKEN);\n\t}\n\n\tfunc-\u003eid = GetNextScriptFunctionId();\n\tSetScriptFunction(func);\n\tfunc-\u003eobjectType-\u003emethods.PushLast(func-\u003eid);\n\t// The refCount was already set to 1\n\n\tfunc-\u003eComputeSignatureId();\n\n\t// If parameter type from other groups are used, add references\n\t// TODO: The code for adding references to config groups is repeated in a lot of places\n\tif( func-\u003ereturnType.GetObjectType() )\n\t{\n\t\tasCConfigGroup *group = FindConfigGroupForObjectType(func-\u003ereturnType.GetObjectType());\n\t\tcurrentGroup-\u003eRefConfigGroup(group);\n\t}\n\tfor( asUINT n = 0; n \u003c func-\u003eparameterTypes.GetLength(); n++ )\n\t{\n\t\tif( func-\u003eparameterTypes[n].GetObjectType() )\n\t\t{\n\t\t\tasCConfigGroup *group = FindConfigGroupForObjectType(func-\u003eparameterTypes[n].GetObjectType());\n\t\t\tcurrentGroup-\u003eRefConfigGroup(group);\n\t\t}\n\t}\n\n\t// Return function id as success\n\treturn func-\u003eid;\n}\n\nint asCScriptEngine::RegisterObjectType(const char *name, int byteSize, asDWORD flags)\n{\n\tint r;\n\n\tisPrepared = false;\n\n\t// Verify flags\n\t//   Must have either asOBJ_REF or asOBJ_VALUE\n\tif( flags \u0026 asOBJ_REF )\n\t{\n\t\t// Can optionally have the asOBJ_GC, asOBJ_NOHANDLE, asOBJ_SCOPED, or asOBJ_TEMPLATE flag set, but nothing else\n\t\tif( flags \u0026 ~(asOBJ_REF | asOBJ_GC | asOBJ_NOHANDLE | asOBJ_SCOPED | asOBJ_TEMPLATE) )\n\t\t\treturn ConfigError(asINVALID_ARG);\n\n\t\t// flags are exclusive\n\t\tif( (flags \u0026 asOBJ_GC) \u0026\u0026 (flags \u0026 (asOBJ_NOHANDLE|asOBJ_SCOPED)) )\n\t\t\treturn ConfigError(asINVALID_ARG);\n\t\tif( (flags \u0026 asOBJ_NOHANDLE) \u0026\u0026 (flags \u0026 (asOBJ_GC|asOBJ_SCOPED)) )\n\t\t\treturn ConfigError(asINVALID_ARG);\n\t\tif( (flags \u0026 asOBJ_SCOPED) \u0026\u0026 (flags \u0026 (asOBJ_GC|asOBJ_NOHANDLE)) )\n\t\t\treturn ConfigError(asINVALID_ARG);\n\t}\n\telse if( flags \u0026 asOBJ_VALUE )\n\t{\n\t\t// Cannot use reference flags\n\t\t// TODO: template: Should be possible to register a value type as template type\n\t\tif( flags \u0026 (asOBJ_REF | asOBJ_GC | asOBJ_SCOPED) )\n\t\t\treturn ConfigError(asINVALID_ARG);\n\n\t\t// If the app type is given, we must validate the flags\n\t\tif( flags \u0026 asOBJ_APP_CLASS )\n\t\t{\n\t\t\t// Must not set the primitive or float flag\n\t\t\tif( flags \u0026 (asOBJ_APP_PRIMITIVE |\n\t\t\t\t         asOBJ_APP_FLOAT) )\n\t\t\t\treturn ConfigError(asINVALID_ARG);\n\t\t}\n\t\telse if( flags \u0026 asOBJ_APP_PRIMITIVE )\n\t\t{\n\t\t\t// Must not set the class flags nor the float flag\n\t\t\tif( flags \u0026 (asOBJ_APP_CLASS             |\n\t\t\t\t         asOBJ_APP_CLASS_CONSTRUCTOR |\n\t\t\t\t\t\t asOBJ_APP_CLASS_DESTRUCTOR  |\n\t\t\t\t\t\t asOBJ_APP_CLASS_ASSIGNMENT  |\n\t\t\t\t\t\t asOBJ_APP_FLOAT) )\n\t\t\t\treturn ConfigError(asINVALID_ARG);\n\t\t}\n\t\telse if( flags \u0026 asOBJ_APP_FLOAT )\n\t\t{\n\t\t\t// Must not set the class flags nor the primitive flag\n\t\t\tif( flags \u0026 (asOBJ_APP_CLASS             |\n\t\t\t\t         asOBJ_APP_CLASS_CONSTRUCTOR |\n\t\t\t\t\t\t asOBJ_APP_CLASS_DESTRUCTOR  |\n\t\t\t\t\t\t asOBJ_APP_CLASS_ASSIGNMENT  |\n\t\t\t\t\t\t asOBJ_APP_PRIMITIVE) )\n\t\t\t\treturn ConfigError(asINVALID_ARG);\n\t\t}\n\t\telse if( flags \u0026 (asOBJ_APP_CLASS_CONSTRUCTOR |\n\t\t                  asOBJ_APP_CLASS_DESTRUCTOR  |\n\t\t                  asOBJ_APP_CLASS_ASSIGNMENT) )\n\t\t{\n\t\t\t// Must not set the class properties, without the class flag\n\t\t\treturn ConfigError(asINVALID_ARG);\n\t\t}\n\t}\n\telse\n\t\treturn ConfigError(asINVALID_ARG);\n\n\t// Don't allow anything else than the defined flags\n\tif( flags - (flags \u0026 asOBJ_MASK_VALID_FLAGS) )\n\t\treturn ConfigError(asINVALID_ARG);\n\n\t// Value types must have a defined size\n\tif( (flags \u0026 asOBJ_VALUE) \u0026\u0026 byteSize == 0 )\n\t{\n\t\tWriteMessage(\"\", 0, 0, asMSGTYPE_ERROR, TXT_VALUE_TYPE_MUST_HAVE_SIZE);\n\t\treturn ConfigError(asINVALID_ARG);\n\t}\n\n\t// Verify type name\n\tif( name == 0 )\n\t\treturn ConfigError(asINVALID_NAME);\n\n\tasCString typeName;\n\tasCBuilder bld(this, 0);\n\tif( flags \u0026 asOBJ_TEMPLATE )\n\t{\n\t\tasCString subtypeName;\n\t\tr = bld.ParseTemplateDecl(name, \u0026typeName, \u0026subtypeName);\n\t\tif( r \u003c 0 )\n\t\t\treturn r;\n\n\t\t// Verify that the template name hasn't been registered as a type already\n\t\tasUINT n;\n\t\tfor( n = 0; n \u003c objectTypes.GetLength(); n++ )\n\t\t{\n\t\t\tif( objectTypes[n] \u0026\u0026 objectTypes[n]-\u003ename == typeName )\n\t\t\t\treturn asALREADY_REGISTERED;\n\t\t}\n\n\t\tasCObjectType *type = asNEW(asCObjectType)(this);\n\t\ttype-\u003ename      = typeName;\n\t\ttype-\u003esize      = byteSize;\n\t\ttype-\u003eflags     = flags;\n\n\t\t// Store it in the object types\n\t\tobjectTypes.PushLast(type);\n\n\t\t// Define a template subtype\n\t\tasCObjectType *subtype = 0;\n\t\tfor( n = 0; n \u003c templateSubTypes.GetLength(); n++ )\n\t\t{\n\t\t\tif( templateSubTypes[n]-\u003ename == subtypeName )\n\t\t\t{\n\t\t\t\tsubtype = templateSubTypes[n];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif( subtype == 0 )\n\t\t{\n\t\t\t// Create the new subtype if not already existing\n\t\t\tsubtype = asNEW(asCObjectType)(this);\n\t\t\tsubtype-\u003ename      = subtypeName;\n\t\t\tsubtype-\u003esize      = 0;\n\t\t\tsubtype-\u003eflags     = asOBJ_TEMPLATE_SUBTYPE;\n\t\t\ttemplateSubTypes.PushLast(subtype);\n\t\t\tsubtype-\u003eAddRef();\n\t\t}\n\t\ttype-\u003etemplateSubType = asCDataType::CreateObject(subtype, false);\n\t\tsubtype-\u003eAddRef();\n\n\t\tcurrentGroup-\u003eobjTypes.PushLast(type);\n\n\t\tif( defaultArrayObjectType == 0 )\n\t\t{\n\t\t\t// TODO: The default array object type should be defined by the application\n\t\t\t// The default array object type is registered by the engine itself\n\t\t\tdefaultArrayObjectType = type;\n\t\t\ttype-\u003eAddRef();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tregisteredObjTypes.PushLast(type);\n\t\t}\n\t}\n\telse\n\t{\n\t\ttypeName = name;\n\n\t\t// Verify if the name has been registered as a type already\n\t\tasUINT n;\n\t\tfor( n = 0; n \u003c objectTypes.GetLength(); n++ )\n\t\t{\n\t\t\tif( objectTypes[n] \u0026\u0026 objectTypes[n]-\u003ename == typeName )\n\t\t\t\treturn asALREADY_REGISTERED;\n\t\t}\n\n\t\tfor( n = 0; n \u003c templateTypes.GetLength(); n++ )\n\t\t{\n\t\t\tif( templateTypes[n] \u0026\u0026 templateTypes[n]-\u003ename == typeName )\n\t\t\t\treturn asALREADY_REGISTERED;\n\t\t}\n\n\t\t// Verify the most recently created template instance type\n\t\tasCObjectType *mostRecentTemplateInstanceType = 0;\n\t\tif( templateInstanceTypes.GetLength() )\n\t\t\tmostRecentTemplateInstanceType = templateInstanceTypes[templateInstanceTypes.GetLength()-1];\n\n\t\t// Use builder to parse the datatype\n\t\tasCDataType dt;\n\t\tbool oldMsgCallback = msgCallback; msgCallback = false;\n\t\tr = bld.ParseDataType(name, \u0026dt);\n\t\tmsgCallback = oldMsgCallback;\n\n\t\t// If the builder fails, then the type name\n\t\t// is new and it should be registered\n\t\tif( r \u003c 0 )\n\t\t{\n\t\t\t// Make sure the name is not a reserved keyword\n\t\t\tasCTokenizer t;\n\t\t\tsize_t tokenLen;\n\t\t\tint token = t.GetToken(name, typeName.GetLength(), \u0026tokenLen);\n\t\t\tif( token != ttIdentifier || typeName.GetLength() != tokenLen )\n\t\t\t\treturn ConfigError(asINVALID_NAME);\n\n\t\t\tint r = bld.CheckNameConflict(name, 0, 0);\n\t\t\tif( r \u003c 0 )\n\t\t\t\treturn ConfigError(asNAME_TAKEN);\n\n\t\t\t// Don't have to check against members of object\n\t\t\t// types as they are allowed to use the names\n\n\t\t\t// Put the data type in the list\n\t\t\tasCObjectType *type = asNEW(asCObjectType)(this);\n\t\t\ttype-\u003ename      = typeName;\n\t\t\ttype-\u003esize      = byteSize;\n\t\t\ttype-\u003eflags     = flags;\n\n\t\t\tobjectTypes.PushLast(type);\n\t\t\tregisteredObjTypes.PushLast(type);\n\n\t\t\tcurrentGroup-\u003eobjTypes.PushLast(type);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// The application is registering a template specialization so we\n\t\t\t// need to replace the template instance type with the new type.\n\n\t\t\t// TODO: Template: We don't require the lower dimensions to be registered first for registered template types\n\t\t\t// int[][] must not be allowed to be registered\n\t\t\t// if int[] hasn't been registered first\n\t\t\tif( dt.GetSubType().IsTemplate() )\n\t\t\t\treturn ConfigError(asLOWER_ARRAY_DIMENSION_NOT_REGISTERED);\n\n\t\t\tif( dt.IsReadOnly() ||\n\t\t\t\tdt.IsReference() )\n\t\t\t\treturn ConfigError(asINVALID_TYPE);\n\n\t\t\t// Was the template instance type created before?\n\t\t\tif( templateInstanceTypes[templateInstanceTypes.GetLength()-1] == mostRecentTemplateInstanceType ||\n\t\t\t\tmostRecentTemplateInstanceType == dt.GetObjectType() )\n\t\t\t\t// TODO: Should have a better error message\n\t\t\t\treturn ConfigError(asNOT_SUPPORTED);\n\n\t\t\t// TODO: Add this again. The type is used by the factory stubs so we need to discount that\n\t\t\t// Is the template instance type already being used?\n//\t\t\tif( dt.GetObjectType()-\u003eGetRefCount() \u003e 1 )\n//\t\t\t\treturn ConfigError(asNOT_SUPPORTED);\n\n\t\t\t// Put the data type in the list\n\t\t\tasCObjectType *type = asNEW(asCObjectType)(this);\n\t\t\ttype-\u003ename      = dt.GetObjectType()-\u003ename;\n\t\t\ttype-\u003etemplateSubType = dt.GetSubType();\n\t\t\tif( type-\u003etemplateSubType.GetObjectType() ) type-\u003etemplateSubType.GetObjectType()-\u003eAddRef();\n\t\t\ttype-\u003esize      = byteSize;\n\t\t\ttype-\u003eflags     = flags;\n\n\t\t\ttemplateTypes.PushLast(type);\n\n\t\t\tcurrentGroup-\u003eobjTypes.PushLast(type);\n\n\t\t\t// Remove the template instance type, which will no longer be used.\n\t\t\tRemoveTemplateInstanceType(dt.GetObjectType());\n\t\t}\n\t}\n\n\treturn asSUCCESS;\n}\n\n// interface\nint asCScriptEngine::RegisterObjectBehaviour(const char *datatype, asEBehaviours behaviour, const char *decl, const asSFuncPtr \u0026funcPointer, asDWORD callConv)\n{\n\tif( datatype == 0 ) return ConfigError(asINVALID_ARG);\n\n\t// Determine the object type\n\tasCBuilder bld(this, 0);\n\tasCDataType type;\n\tint r = bld.ParseDataType(datatype, \u0026type);\n\tif( r \u003c 0 )\n\t\treturn ConfigError(r);\n\n\tif( type.GetObjectType() == 0 )\n\t\treturn ConfigError(asINVALID_TYPE);\n\n\tif( type.IsReadOnly() || type.IsReference() )\n\t\treturn ConfigError(asINVALID_TYPE);\n\n\treturn RegisterBehaviourToObjectType(type.GetObjectType(), behaviour, decl, funcPointer, callConv);\n}\n\n// internal\nint asCScriptEngine::RegisterBehaviourToObjectType(asCObjectType *objectType, asEBehaviours behaviour, const char *decl, const asSFuncPtr \u0026funcPointer, asDWORD callConv)\n{\n\tasSSystemFunctionInterface internal;\n\tif( behaviour == asBEHAVE_FACTORY ||\n\t\tbehaviour == asBEHAVE_TEMPLATE_CALLBACK )\n\t{\n#ifdef AS_MAX_PORTABILITY\n\t\tif( callConv != asCALL_GENERIC )\n\t\t\treturn ConfigError(asNOT_SUPPORTED);\n#endif\n\t\tint r = DetectCallingConvention(false, funcPointer, callConv, \u0026internal);\n\t\tif( r \u003c 0 )\n\t\t\treturn ConfigError(r);\n\t}\n\telse\n\t{\n#ifdef AS_MAX_PORTABILITY\n\t\tif( callConv != asCALL_GENERIC )\n\t\t\treturn ConfigError(asNOT_SUPPORTED);\n#else\n\t\tif( callConv != asCALL_THISCALL \u0026\u0026\n\t\t\tcallConv != asCALL_CDECL_OBJLAST \u0026\u0026\n\t\t\tcallConv != asCALL_CDECL_OBJFIRST \u0026\u0026\n\t\t\tcallConv != asCALL_GENERIC )\n\t\t\treturn ConfigError(asNOT_SUPPORTED);\n#endif\n\n\t\tint r = DetectCallingConvention(true, funcPointer, callConv, \u0026internal);\n\t\tif( r \u003c 0 )\n\t\t\treturn ConfigError(r);\n\t}\n\n\tisPrepared = false;\n\n\tasSTypeBehaviour *beh = \u0026objectType-\u003ebeh;\n\n\t// Verify function declaration\n\tasCScriptFunction func(this, 0, -1);\n\n\tasCBuilder bld(this, 0);\n\tint r = bld.ParseFunctionDeclaration(objectType, decl, \u0026func, true, \u0026internal.paramAutoHandles, \u0026internal.returnAutoHandle);\n\tif( r \u003c 0 )\n\t\treturn ConfigError(asINVALID_DECLARATION);\n\tfunc.name.Format(\"_beh_%d_\", behaviour);\n\n\tif( behaviour != asBEHAVE_FACTORY )\n\t\tfunc.objectType = objectType;\n\n\t// Check if the method restricts that use of the template to value types or reference types\n\tif( objectType-\u003eflags \u0026 asOBJ_TEMPLATE )\n\t{\n\t\tif( func.returnType.GetObjectType() == objectType-\u003etemplateSubType.GetObjectType() )\n\t\t{\n\t\t\tif( func.returnType.IsObjectHandle() )\n\t\t\t\tobjectType-\u003eacceptValueSubType = false;\n\t\t\telse if( !func.returnType.IsReference() )\n\t\t\t\tobjectType-\u003eacceptRefSubType = false;\n\t\t}\n\n\t\tfor( asUINT n = 0; n \u003c func.parameterTypes.GetLength(); n++ )\n\t\t{\n\t\t\tif( func.parameterTypes[n].GetObjectType() == objectType-\u003etemplateSubType.GetObjectType() )\n\t\t\t{\n\t\t\t\t// TODO: If unsafe references are allowed, then inout references allow value types\n\t\t\t\tif( func.parameterTypes[n].IsObjectHandle() || (func.parameterTypes[n].IsReference() \u0026\u0026 func.inOutFlags[n] == asTM_INOUTREF) )\n\t\t\t\t\tobjectType-\u003eacceptValueSubType = false;\n\t\t\t\telse if( !func.parameterTypes[n].IsReference() )\n\t\t\t\t\tobjectType-\u003eacceptRefSubType = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tif( behaviour == asBEHAVE_CONSTRUCT )\n\t{\n\t\t// TODO: Add asBEHAVE_IMPLICIT_CONSTRUCT\n\n\t\t// Verify that the return type is void\n\t\tif( func.returnType != asCDataType::CreatePrimitive(ttVoid, false) )\n\t\t\treturn ConfigError(asINVALID_DECLARATION);\n\n\t\tif( objectType-\u003eflags \u0026 asOBJ_SCRIPT_OBJECT )\n\t\t{\n\t\t\t// The script object is a special case\n\t\t\tasASSERT(func.parameterTypes.GetLength() == 1);\n\n\t\t\tbeh-\u003econstruct = AddBehaviourFunction(func, internal);\n\t\t\tbeh-\u003efactory   = beh-\u003econstruct;\n\t\t\tscriptFunctions[beh-\u003efactory]-\u003eAddRef();\n\t\t\tbeh-\u003econstructors.PushLast(beh-\u003econstruct);\n\t\t\tbeh-\u003efactories.PushLast(beh-\u003efactory);\n\t\t\tfunc.id = beh-\u003econstruct;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Verify that it is a value type\n\t\t\tif( !(func.objectType-\u003eflags \u0026 asOBJ_VALUE) )\n\t\t\t{\n\t\t\t\tWriteMessage(\"\", 0, 0, asMSGTYPE_ERROR, TXT_ILLEGAL_BEHAVIOUR_FOR_TYPE);\n\t\t\t\treturn ConfigError(asILLEGAL_BEHAVIOUR_FOR_TYPE);\n\t\t\t}\n\n\t\t\t// Implicit constructors must take one and only one parameter\n\t/*\t\tif( behaviour == asBEHAVE_IMPLICIT_CONSTRUCT \u0026\u0026\n\t\t\t\tfunc.parameterTypes.GetLength() != 1 )\n\t\t\t\treturn ConfigError(asINVALID_DECLARATION);\n\t*/\n\t\t\t// TODO: Verify that the same constructor hasn't been registered already\n\n\t\t\t// Store all constructors in a list\n\t\t\tif( func.parameterTypes.GetLength() == 0 )\n\t\t\t{\n\t\t\t\tfunc.id = beh-\u003econstruct = AddBehaviourFunction(func, internal);\n\t\t\t\tbeh-\u003econstructors.PushLast(beh-\u003econstruct);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfunc.id = AddBehaviourFunction(func, internal);\n\t\t\t\tbeh-\u003econstructors.PushLast(func.id);\n\t/*\n\t\t\t\tif( behaviour == asBEHAVE_IMPLICIT_CONSTRUCT )\n\t\t\t\t{\n\t\t\t\t\tbeh-\u003eoperators.PushLast(behaviour);\n\t\t\t\t\tbeh-\u003eoperators.PushLast(func.id);\n\t\t\t\t}\n\t*/\t\t}\n\t\t}\n\t}\n\telse if( behaviour == asBEHAVE_DESTRUCT )\n\t{\n\t\t// Must be a value type\n\t\tif( !(func.objectType-\u003eflags \u0026 asOBJ_VALUE) )\n\t\t{\n\t\t\tWriteMessage(\"\", 0, 0, asMSGTYPE_ERROR, TXT_ILLEGAL_BEHAVIOUR_FOR_TYPE);\n\t\t\treturn ConfigError(asILLEGAL_BEHAVIOUR_FOR_TYPE);\n\t\t}\n\n\t\tif( beh-\u003edestruct )\n\t\t\treturn ConfigError(asALREADY_REGISTERED);\n\n\t\t// Verify that the return type is void\n\t\tif( func.returnType != asCDataType::CreatePrimitive(ttVoid, false) )\n\t\t\treturn ConfigError(asINVALID_DECLARATION);\n\n\t\t// Verify that there are no parameters\n\t\tif( func.parameterTypes.GetLength() \u003e 0 )\n\t\t\treturn ConfigError(asINVALID_DECLARATION);\n\n\t\tfunc.id = beh-\u003edestruct = AddBehaviourFunction(func, internal);\n\t}\n\telse if( behaviour == asBEHAVE_FACTORY )\n\t{\n\t\t// TODO: Add asBEHAVE_IMPLICIT_FACTORY\n\n\t\t// Must be a ref type and must not have asOBJ_NOHANDLE\n\t\tif( !(objectType-\u003eflags \u0026 asOBJ_REF) || (objectType-\u003eflags \u0026 asOBJ_NOHANDLE) )\n\t\t{\n\t\t\tWriteMessage(\"\", 0, 0, asMSGTYPE_ERROR, TXT_ILLEGAL_BEHAVIOUR_FOR_TYPE);\n\t\t\treturn ConfigError(asILLEGAL_BEHAVIOUR_FOR_TYPE);\n\t\t}\n\n\t\t// Verify that the return type is a handle to the type\n\t\tif( func.returnType != asCDataType::CreateObjectHandle(objectType, false) )\n\t\t\treturn ConfigError(asINVALID_DECLARATION);\n\n\t\t// Implicit factories must take one and only one parameter\n/*\t\tif( behaviour == asBEHAVE_IMPLICIT_FACTORY \u0026\u0026\n\t\t\tfunc.parameterTypes.GetLength() != 1 )\n\t\t\treturn ConfigError(asINVALID_DECLARATION);\n*/\n\t\t// TODO: Verify that the same factory function hasn't been registered already\n\n\t\t// The templates take a hidden parameter with the object type\n\t\tif( (objectType-\u003eflags \u0026 asOBJ_TEMPLATE) \u0026\u0026\n\t\t\t(func.parameterTypes.GetLength() == 0 ||\n\t\t\t !func.parameterTypes[0].IsReference()) )\n\t\t{\n\t\t\treturn ConfigError(asINVALID_DECLARATION);\n\t\t}\n\n\t\t// Store all factory functions in a list\n\t\tif( (func.parameterTypes.GetLength() == 0) ||\n\t\t\t(func.parameterTypes.GetLength() == 1 \u0026\u0026 (objectType-\u003eflags \u0026 asOBJ_TEMPLATE)) )\n\t\t{\n\t\t\tfunc.id = beh-\u003efactory = AddBehaviourFunction(func, internal);\n\t\t\tbeh-\u003efactories.PushLast(beh-\u003efactory);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfunc.id = AddBehaviourFunction(func, internal);\n\t\t\tbeh-\u003efactories.PushLast(func.id);\n/*\n\t\t\tif( behaviour == asBEHAVE_IMPLICIT_FACTORY )\n\t\t\t{\n\t\t\t\tbeh-\u003eoperators.PushLast(behaviour);\n\t\t\t\tbeh-\u003eoperators.PushLast(func.id);\n\t\t\t}\n*/\t\t}\n\t}\n\telse if( behaviour == asBEHAVE_ADDREF )\n\t{\n\t\t// Must be a ref type and must not have asOBJ_NOHANDLE, nor asOBJ_SCOPED\n\t\tif( !(func.objectType-\u003eflags \u0026 asOBJ_REF) ||\n\t\t\t(func.objectType-\u003eflags \u0026 asOBJ_NOHANDLE) ||\n\t\t\t(func.objectType-\u003eflags \u0026 asOBJ_SCOPED) )\n\t\t{\n\t\t\tWriteMessage(\"\", 0, 0, asMSGTYPE_ERROR, TXT_ILLEGAL_BEHAVIOUR_FOR_TYPE);\n\t\t\treturn ConfigError(asILLEGAL_BEHAVIOUR_FOR_TYPE);\n\t\t}\n\n\t\tif( beh-\u003eaddref )\n\t\t\treturn ConfigError(asALREADY_REGISTERED);\n\n\t\t// Verify that the return type is void\n\t\tif( func.returnType != asCDataType::CreatePrimitive(ttVoid, false) )\n\t\t\treturn ConfigError(asINVALID_DECLARATION);\n\n\t\t// Verify that there are no parameters\n\t\tif( func.parameterTypes.GetLength() \u003e 0 )\n\t\t\treturn ConfigError(asINVALID_DECLARATION);\n\n\t\tfunc.id = beh-\u003eaddref = AddBehaviourFunction(func, internal);\n\t}\n\telse if( behaviour == asBEHAVE_RELEASE )\n\t{\n\t\t// Must be a ref type and must not have asOBJ_NOHANDLE\n\t\tif( !(func.objectType-\u003eflags \u0026 asOBJ_REF) || (func.objectType-\u003eflags \u0026 asOBJ_NOHANDLE) )\n\t\t{\n\t\t\tWriteMessage(\"\", 0, 0, asMSGTYPE_ERROR, TXT_ILLEGAL_BEHAVIOUR_FOR_TYPE);\n\t\t\treturn ConfigError(asILLEGAL_BEHAVIOUR_FOR_TYPE);\n\t\t}\n\n\t\tif( beh-\u003erelease )\n\t\t\treturn ConfigError(asALREADY_REGISTERED);\n\n\t\t// Verify that the return type is void\n\t\tif( func.returnType != asCDataType::CreatePrimitive(ttVoid, false) )\n\t\t\treturn ConfigError(asINVALID_DECLARATION);\n\n\t\t// Verify that there are no parameters\n\t\tif( func.parameterTypes.GetLength() \u003e 0 )\n\t\t\treturn ConfigError(asINVALID_DECLARATION);\n\n\t\tfunc.id = beh-\u003erelease = AddBehaviourFunction(func, internal);\n\t}\n\telse if( behaviour == asBEHAVE_TEMPLATE_CALLBACK )\n\t{\n\t\t// Must be a template type \n\t\tif( !(func.objectType-\u003eflags \u0026 asOBJ_TEMPLATE) )\n\t\t{\n\t\t\tWriteMessage(\"\", 0, 0, asMSGTYPE_ERROR, TXT_ILLEGAL_BEHAVIOUR_FOR_TYPE);\n\t\t\treturn ConfigError(asILLEGAL_BEHAVIOUR_FOR_TYPE);\n\t\t}\n\n\t\tif( beh-\u003etemplateCallback )\n\t\t\treturn ConfigError(asALREADY_REGISTERED);\n\n\t\t// Verify that the return type is bool\n\t\tif( func.returnType != asCDataType::CreatePrimitive(ttBool, false) )\n\t\t\treturn ConfigError(asINVALID_DECLARATION);\n\n\t\t// Verify that there is one parameters\n\t\tif( func.parameterTypes.GetLength() != 1 )\n\t\t\treturn ConfigError(asINVALID_DECLARATION);\n\n\t\tfunc.id = beh-\u003etemplateCallback = AddBehaviourFunction(func, internal);\n\t}\n\telse if( behaviour == asBEHAVE_INDEX )\n\t{\n\t\t// Verify that the var type is not used\n\t\tif( VerifyVarTypeNotInFunction(\u0026func) \u003c 0 )\n\t\t\treturn ConfigError(asINVALID_DECLARATION);\n\n\t\t// Verify that there is only one parameter\n\t\tif( func.parameterTypes.GetLength() != 1 )\n\t\t\treturn ConfigError(asINVALID_DECLARATION);\n\n\t\t// Verify that the return type is not void\n\t\tif( func.returnType.GetTokenType() == ttVoid )\n\t\t\treturn ConfigError(asINVALID_DECLARATION);\n\n\t\t// TODO: Verify that the operator hasn't been registered already\n\n\t\tbeh-\u003eoperators.PushLast(behaviour);\n\t\tfunc.id = AddBehaviourFunction(func, internal);\n\t\tbeh-\u003eoperators.PushLast(func.id);\n\t}\n\telse if( behaviour \u003e= asBEHAVE_FIRST_GC \u0026\u0026\n\t\t     behaviour \u003c= asBEHAVE_LAST_GC )\n\t{\n\t\t// Only allow GC behaviours for types registered to be garbage collected\n\t\tif( !(func.objectType-\u003eflags \u0026 asOBJ_GC) )\n\t\t{\n\t\t\tWriteMessage(\"\", 0, 0, asMSGTYPE_ERROR, TXT_ILLEGAL_BEHAVIOUR_FOR_TYPE);\n\t\t\treturn ConfigError(asILLEGAL_BEHAVIOUR_FOR_TYPE);\n\t\t}\n\n\t\t// Verify parameter count\n\t\tif( (behaviour == asBEHAVE_GETREFCOUNT ||\n\t\t\t behaviour == asBEHAVE_SETGCFLAG   ||\n\t\t\t behaviour == asBEHAVE_GETGCFLAG) \u0026\u0026\n\t\t\tfunc.parameterTypes.GetLength() != 0 )\n\t\t\treturn ConfigError(asINVALID_DECLARATION);\n\n\t\tif( (behaviour == asBEHAVE_ENUMREFS ||\n\t\t\t behaviour == asBEHAVE_RELEASEREFS) \u0026\u0026\n\t\t\tfunc.parameterTypes.GetLength() != 1 )\n\t\t\treturn ConfigError(asINVALID_DECLARATION);\n\n\t\t// Verify return type\n\t\tif( behaviour == asBEHAVE_GETREFCOUNT \u0026\u0026\n\t\t\tfunc.returnType != asCDataType::CreatePrimitive(ttInt, false) )\n\t\t\treturn ConfigError(asINVALID_DECLARATION);\n\n\t\tif( behaviour == asBEHAVE_GETGCFLAG \u0026\u0026\n\t\t\tfunc.returnType != asCDataType::CreatePrimitive(ttBool, false) )\n\t\t\treturn ConfigError(asINVALID_DECLARATION);\n\n\t\tif( (behaviour == asBEHAVE_SETGCFLAG ||\n\t\t\t behaviour == asBEHAVE_ENUMREFS  ||\n\t\t\t behaviour == asBEHAVE_RELEASEREFS) \u0026\u0026\n\t\t\tfunc.returnType != asCDataType::CreatePrimitive(ttVoid, false) )\n\t\t\treturn ConfigError(asINVALID_DECLARATION);\n\n\t\tif( behaviour == asBEHAVE_GETREFCOUNT )\n\t\t\tfunc.id = beh-\u003egcGetRefCount = AddBehaviourFunction(func, internal);\n\t\telse if( behaviour == asBEHAVE_SETGCFLAG )\n\t\t\tfunc.id = beh-\u003egcSetFlag = AddBehaviourFunction(func, internal);\n\t\telse if( behaviour == asBEHAVE_GETGCFLAG )\n\t\t\tfunc.id = beh-\u003egcGetFlag = AddBehaviourFunction(func, internal);\n\t\telse if( behaviour == asBEHAVE_ENUMREFS )\n\t\t\tfunc.id = beh-\u003egcEnumReferences = AddBehaviourFunction(func, internal);\n\t\telse if( behaviour == asBEHAVE_RELEASEREFS )\n\t\t\tfunc.id = beh-\u003egcReleaseAllReferences = AddBehaviourFunction(func, internal);\n\t}\n\telse if( behaviour == asBEHAVE_IMPLICIT_VALUE_CAST ||\n\t\t     behaviour == asBEHAVE_VALUE_CAST )\n\t{\n\t\t// Verify parameter count\n\t\tif( func.parameterTypes.GetLength() != 0 )\n\t\t\treturn ConfigError(asINVALID_DECLARATION);\n\n\t\t// Verify return type\n\t\tif( func.returnType.IsEqualExceptRefAndConst(asCDataType::CreatePrimitive(ttBool, false)) )\n\t\t\treturn ConfigError(asNOT_SUPPORTED);\n\n\t\tif( func.returnType.IsEqualExceptRefAndConst(asCDataType::CreatePrimitive(ttVoid, false)) )\n\t\t\treturn ConfigError(asINVALID_DECLARATION);\n\n\t\t// TODO: verify that the same cast is not registered already (const or non-const is treated the same for the return type)\n\n\t\tbeh-\u003eoperators.PushLast(behaviour);\n\t\tfunc.id = AddBehaviourFunction(func, internal);\n\t\tbeh-\u003eoperators.PushLast(func.id);\n\t}\n\telse if( behaviour == asBEHAVE_REF_CAST ||\n\t         behaviour == asBEHAVE_IMPLICIT_REF_CAST )\n\t{\n\t\t// Verify parameter count\n\t\tif( func.parameterTypes.GetLength() != 0 )\n\t\t\treturn ConfigError(asINVALID_DECLARATION);\n\n\t\t// Verify return type\n\t\tif( !func.returnType.IsObjectHandle() )\n\t\t\treturn ConfigError(asINVALID_DECLARATION);\n\n\t\t// TODO: verify that the same cast is not registered already (cosnt or non-const is treated the same for the return type)\n\n\t\tbeh-\u003eoperators.PushLast(behaviour);\n\t\tfunc.id = AddBehaviourFunction(func, internal);\n\t\tbeh-\u003eoperators.PushLast(func.id);\n\t}\n\telse\n\t{\n\t\tasASSERT(false);\n\n\t\treturn ConfigError(asINVALID_ARG);\n\t}\n\n\t// Return function id as success\n\treturn func.id;\n}\n\n\nint asCScriptEngine::VerifyVarTypeNotInFunction(asCScriptFunction *func)\n{\n\t// Don't allow var type in this function\n\tif( func-\u003ereturnType.GetTokenType() == ttQuestion )\n\t\treturn asINVALID_DECLARATION;\n\n\tfor( unsigned int n = 0; n \u003c func-\u003eparameterTypes.GetLength(); n++ )\n\t\tif( func-\u003eparameterTypes[n].GetTokenType() == ttQuestion )\n\t\t\treturn asINVALID_DECLARATION;\n\n\treturn 0;\n}\n\nint asCScriptEngine::AddBehaviourFunction(asCScriptFunction \u0026func, asSSystemFunctionInterface \u0026internal)\n{\n\tasUINT n;\n\n\tint id = GetNextScriptFunctionId();\n\n\tasSSystemFunctionInterface *newInterface = asNEW(asSSystemFunctionInterface);\n\tnewInterface-\u003efunc               = internal.func;\n\tnewInterface-\u003ebaseOffset         = internal.baseOffset;\n\tnewInterface-\u003ecallConv           = internal.callConv;\n\tnewInterface-\u003escriptReturnSize   = internal.scriptReturnSize;\n\tnewInterface-\u003ehostReturnInMemory = internal.hostReturnInMemory;\n\tnewInterface-\u003ehostReturnFloat    = internal.hostReturnFloat;\n\tnewInterface-\u003ehostReturnSize     = internal.hostReturnSize;\n\tnewInterface-\u003eparamSize          = internal.paramSize;\n\tnewInterface-\u003etakesObjByVal      = internal.takesObjByVal;\n\tnewInterface-\u003eparamAutoHandles   = internal.paramAutoHandles;\n\tnewInterface-\u003ereturnAutoHandle   = internal.returnAutoHandle;\n\tnewInterface-\u003ehasAutoHandles     = internal.hasAutoHandles;\n\n\tasCScriptFunction *f = asNEW(asCScriptFunction)(this, 0, asFUNC_SYSTEM);\n\tasASSERT(func.name != \"\" \u0026\u0026 func.name != \"f\");\n\tf-\u003ename        = func.name;\n\tf-\u003esysFuncIntf = newInterface;\n\tf-\u003ereturnType  = func.returnType;\n\tf-\u003eobjectType  = func.objectType;\n\tf-\u003eid          = id;\n\tf-\u003eisReadOnly  = func.isReadOnly;\n\tfor( n = 0; n \u003c func.parameterTypes.GetLength(); n++ )\n\t{\n\t\tf-\u003eparameterTypes.PushLast(func.parameterTypes[n]);\n\t\tf-\u003einOutFlags.PushLast(func.inOutFlags[n]);\n\t}\n\n\tSetScriptFunction(f);\n\n\t// If parameter type from other groups are used, add references\n\tif( f-\u003ereturnType.GetObjectType() )\n\t{\n\t\tasCConfigGroup *group = FindConfigGroupForObjectType(f-\u003ereturnType.GetObjectType());\n\t\tcurrentGroup-\u003eRefConfigGroup(group);\n\t}\n\tfor( n = 0; n \u003c f-\u003eparameterTypes.GetLength(); n++ )\n\t{\n\t\tif( f-\u003eparameterTypes[n].GetObjectType() )\n\t\t{\n\t\t\tasCConfigGroup *group = FindConfigGroupForObjectType(f-\u003eparameterTypes[n].GetObjectType());\n\t\t\tcurrentGroup-\u003eRefConfigGroup(group);\n\t\t}\n\t}\n\n\treturn id;\n}\n\n// interface\nint asCScriptEngine::RegisterGlobalProperty(const char *declaration, void *pointer)\n{\n\tasCDataType type;\n\tasCString name;\n\n\tint r;\n\tasCBuilder bld(this, 0);\n\tif( (r = bld.VerifyProperty(0, declaration, name, type)) \u003c 0 )\n\t\treturn ConfigError(r);\n\n\t// Don't allow registering references as global properties\n\tif( type.IsReference() )\n\t\treturn ConfigError(asINVALID_TYPE);\n\n\t// Store the property info\n\tasCGlobalProperty *prop = AllocateGlobalProperty();\n\tprop-\u003ename        = name;\n\tprop-\u003etype        = type;\n\n\tprop-\u003eSetRegisteredAddress(pointer);\n\t\n\tregisteredGlobalProps.PushLast(prop);\n\tcurrentGroup-\u003eglobalProps.PushLast(prop);\n\n\t// If from another group add reference\n\tif( type.GetObjectType() )\n\t{\n\t\tasCConfigGroup *group = FindConfigGroupForObjectType(type.GetObjectType());\n\t\tcurrentGroup-\u003eRefConfigGroup(group);\n\t}\n\n\treturn asSUCCESS;\n}\n\n// internal\nasCGlobalProperty *asCScriptEngine::AllocateGlobalProperty()\n{\n\tasCGlobalProperty *prop = asNEW(asCGlobalProperty);\n\n\t// First check the availability of a free slot\n\tif( freeGlobalPropertyIds.GetLength() )\n\t{\n\t\tprop-\u003eid = freeGlobalPropertyIds.PopLast();\n\t\tglobalProperties[prop-\u003eid] = prop;\n\t\treturn prop;\n\t}\n\n\tprop-\u003eid = (asUINT)globalProperties.GetLength();\n\tglobalProperties.PushLast(prop);\n\treturn prop;\n}\n\n// internal\nvoid asCScriptEngine::FreeUnusedGlobalProperties()\n{\n\tfor( asUINT n = 0; n \u003c globalProperties.GetLength(); n++ )\n\t{\n\t\tif( globalProperties[n] \u0026\u0026 globalProperties[n]-\u003erefCount.get() == 0 )\n\t\t{\n\t\t\tfreeGlobalPropertyIds.PushLast(n);\n\t\t\tasDELETE(globalProperties[n], asCGlobalProperty);\n\t\t\tglobalProperties[n] = 0;\n\t\t}\n\t}\n}\n\n// interface\nint asCScriptEngine::GetGlobalPropertyCount()\n{\n\treturn (int)registeredGlobalProps.GetLength();\n}\n\n// interface\n// TODO: If the typeId ever encodes the const flag, then the isConst parameter should be removed\nint asCScriptEngine::GetGlobalPropertyByIndex(asUINT index, const char **name, int *typeId, bool *isConst, const char **configGroup, void **pointer)\n{\n\tif( index \u003e= registeredGlobalProps.GetLength() )\n\t\treturn asINVALID_ARG;\n\n\tif( name )\n\t\t*name = registeredGlobalProps[index]-\u003ename.AddressOf();\n\n\tif( configGroup )\n\t{\n\t\tasCConfigGroup *group = FindConfigGroupForGlobalVar(index);\n\t\tif( group )\n\t\t\t*configGroup = group-\u003egroupName.AddressOf();\n\t\telse\n\t\t\t*configGroup = 0;\n\t}\n\n\tif( typeId )\n\t\t*typeId = GetTypeIdFromDataType(registeredGlobalProps[index]-\u003etype);\n\n\tif( isConst )\n\t\t*isConst = registeredGlobalProps[index]-\u003etype.IsReadOnly();\n\n\tif( pointer )\n\t\t*pointer = registeredGlobalProps[index]-\u003erealAddress;\n\n\treturn asSUCCESS;\n}\n\n// interface\nint asCScriptEngine::RegisterObjectMethod(const char *obj, const char *declaration, const asSFuncPtr \u0026funcPointer, asDWORD callConv)\n{\n\tif( obj == 0 )\n\t\treturn ConfigError(asINVALID_ARG);\n\n\t// Determine the object type\n\tasCDataType dt;\n\tasCBuilder bld(this, 0);\n\tint r = bld.ParseDataType(obj, \u0026dt);\n\tif( r \u003c 0 )\n\t\treturn ConfigError(r);\n\n\tif( dt.GetObjectType() == 0 )\n\t\treturn ConfigError(asINVALID_ARG);\n\n\treturn RegisterMethodToObjectType(dt.GetObjectType(), declaration, funcPointer, callConv);\n}\n\n// internal\nint asCScriptEngine::RegisterMethodToObjectType(asCObjectType *objectType, const char *declaration, const asSFuncPtr \u0026funcPointer, asDWORD callConv)\n{\n\tasSSystemFunctionInterface internal;\n\tint r = DetectCallingConvention(true, funcPointer, callConv, \u0026internal);\n\tif( r \u003c 0 )\n\t\treturn ConfigError(r);\n\n\t// We only support these calling conventions for object methods\n#ifdef AS_MAX_PORTABILITY\n\tif( callConv != asCALL_GENERIC )\n\t\treturn ConfigError(asNOT_SUPPORTED);\n#else\n\tif( callConv != asCALL_THISCALL \u0026\u0026\n\t\tcallConv != asCALL_CDECL_OBJLAST \u0026\u0026\n\t\tcallConv != asCALL_CDECL_OBJFIRST \u0026\u0026\n\t\tcallConv != asCALL_GENERIC )\n\t\treturn ConfigError(asNOT_SUPPORTED);\n#endif\n\n\tisPrepared = false;\n\n\t// Put the system function in the list of system functions\n\tasSSystemFunctionInterface *newInterface = asNEW(asSSystemFunctionInterface)(internal);\n\n\tasCScriptFunction *func = asNEW(asCScriptFunction)(this, 0, asFUNC_SYSTEM);\n\tfunc-\u003esysFuncIntf = newInterface;\n\tfunc-\u003eobjectType  = objectType;\n\n\tasCBuilder bld(this, 0);\n\tr = bld.ParseFunctionDeclaration(func-\u003eobjectType, declaration, func, true, \u0026newInterface-\u003eparamAutoHandles, \u0026newInterface-\u003ereturnAutoHandle);\n\tif( r \u003c 0 )\n\t{\n\t\t// Set as dummy function before deleting\n\t\tfunc-\u003efuncType = -1;\n\t\tasDELETE(func,asCScriptFunction);\n\t\treturn ConfigError(asINVALID_DECLARATION);\n\t}\n\n\t// Check name conflicts\n\tasCDataType x = asCDataType::CreateObject(objectType, false);\n\tr = bld.CheckNameConflictMember(x, func-\u003ename.AddressOf(), 0, 0);\n\tif( r \u003c 0 )\n\t{\n\t\tasDELETE(func,asCScriptFunction);\n\t\treturn ConfigError(asNAME_TAKEN);\n\t}\n\n\tfunc-\u003eid = GetNextScriptFunctionId();\n\tfunc-\u003eobjectType-\u003emethods.PushLast(func-\u003eid);\n\tSetScriptFunction(func);\n\n\t// TODO: This code is repeated in many places\n\t// If parameter type from other groups are used, add references\n\tif( func-\u003ereturnType.GetObjectType() )\n\t{\n\t\tasCConfigGroup *group = FindConfigGroupForObjectType(func-\u003ereturnType.GetObjectType());\n\t\tcurrentGroup-\u003eRefConfigGroup(group);\n\t}\n\tfor( asUINT n = 0; n \u003c func-\u003eparameterTypes.GetLength(); n++ )\n\t{\n\t\tif( func-\u003eparameterTypes[n].GetObjectType() )\n\t\t{\n\t\t\tasCConfigGroup *group = FindConfigGroupForObjectType(func-\u003eparameterTypes[n].GetObjectType());\n\t\t\tcurrentGroup-\u003eRefConfigGroup(group);\n\t\t}\n\t}\n\n\t// Check if the method restricts that use of the template to value types or reference types\n\tif( func-\u003eobjectType-\u003eflags \u0026 asOBJ_TEMPLATE )\n\t{\n\t\tif( func-\u003ereturnType.GetObjectType() == func-\u003eobjectType-\u003etemplateSubType.GetObjectType() )\n\t\t{\n\t\t\tif( func-\u003ereturnType.IsObjectHandle() )\n\t\t\t\tfunc-\u003eobjectType-\u003eacceptValueSubType = false;\n\t\t\telse if( !func-\u003ereturnType.IsReference() )\n\t\t\t\tfunc-\u003eobjectType-\u003eacceptRefSubType = false;\n\t\t}\n\n\t\tfor( asUINT n = 0; n \u003c func-\u003eparameterTypes.GetLength(); n++ )\n\t\t{\n\t\t\tif( func-\u003eparameterTypes[n].GetObjectType() == func-\u003eobjectType-\u003etemplateSubType.GetObjectType() )\n\t\t\t{\n\t\t\t\t// TODO: If unsafe references are allowed, then inout references allow value types\n\t\t\t\tif( func-\u003eparameterTypes[n].IsObjectHandle() || (func-\u003eparameterTypes[n].IsReference() \u0026\u0026 func-\u003einOutFlags[n] == asTM_INOUTREF) )\n\t\t\t\t\tfunc-\u003eobjectType-\u003eacceptValueSubType = false;\n\t\t\t\telse if( !func-\u003eparameterTypes[n].IsReference() )\n\t\t\t\t\tfunc-\u003eobjectType-\u003eacceptRefSubType = false;\n\t\t\t}\n\t\t}\n\t}\n\n\t// TODO: beh.copy member will be removed, so this is not necessary\n\t// Is this the default copy behaviour?\n\tif( func-\u003ename == \"opAssign\" \u0026\u0026 func-\u003eparameterTypes.GetLength() == 1 \u0026\u0026 func-\u003eisReadOnly == false \u0026\u0026\n\t\t(objectType-\u003eflags \u0026 asOBJ_SCRIPT_OBJECT || func-\u003eparameterTypes[0].IsEqualExceptRefAndConst(asCDataType::CreateObject(func-\u003eobjectType, false))) )\n\t{\n\t\tfunc-\u003eobjectType-\u003ebeh.copy = func-\u003eid;\n\t\tfunc-\u003eAddRef();\n\t}\n\n\t// Return the function id as success\n\treturn func-\u003eid;\n}\n\n// interface\nint asCScriptEngine::RegisterGlobalFunction(const char *declaration, const asSFuncPtr \u0026funcPointer, asDWORD callConv)\n{\n\tasSSystemFunctionInterface internal;\n\tint r = DetectCallingConvention(false, funcPointer, callConv, \u0026internal);\n\tif( r \u003c 0 )\n\t\treturn ConfigError(r);\n\n#ifdef AS_MAX_PORTABILITY\n\tif( callConv != asCALL_GENERIC )\n\t\treturn ConfigError(asNOT_SUPPORTED);\n#else\n\tif( callConv != asCALL_CDECL \u0026\u0026\n\t\tcallConv != asCALL_STDCALL \u0026\u0026\n\t\tcallConv != asCALL_GENERIC )\n\t\treturn ConfigError(asNOT_SUPPORTED);\n#endif\n\n\tisPrepared = false;\n\n\t// Put the system function in the list of system functions\n\tasSSystemFunctionInterface *newInterface = asNEW(asSSystemFunctionInterface)(internal);\n\n\tasCScriptFunction *func = asNEW(asCScriptFunction)(this, 0, asFUNC_SYSTEM);\n\tfunc-\u003esysFuncIntf = newInterface;\n\n\tasCBuilder bld(this, 0);\n\tr = bld.ParseFunctionDeclaration(0, declaration, func, true, \u0026newInterface-\u003eparamAutoHandles, \u0026newInterface-\u003ereturnAutoHandle);\n\tif( r \u003c 0 )\n\t{\n\t\t// Set as dummy function before deleting\n\t\tfunc-\u003efuncType = -1;\n\t\tasDELETE(func,asCScriptFunction);\n\t\treturn ConfigError(asINVALID_DECLARATION);\n\t}\n\n\t// Check name conflicts\n\tr = bld.CheckNameConflict(func-\u003ename.AddressOf(), 0, 0);\n\tif( r \u003c 0 )\n\t{\n\t\tasDELETE(func,asCScriptFunction);\n\t\treturn ConfigError(asNAME_TAKEN);\n\t}\n\n\tfunc-\u003eid = GetNextScriptFunctionId();\n\tSetScriptFunction(func);\n\n\tcurrentGroup-\u003escriptFunctions.PushLast(func);\n\tregisteredGlobalFuncs.PushLast(func);\n\n\t// If parameter type from other groups are used, add references\n\tif( func-\u003ereturnType.GetObjectType() )\n\t{\n\t\tasCConfigGroup *group = FindConfigGroupForObjectType(func-\u003ereturnType.GetObjectType());\n\t\tcurrentGroup-\u003eRefConfigGroup(group);\n\t}\n\tfor( asUINT n = 0; n \u003c func-\u003eparameterTypes.GetLength(); n++ )\n\t{\n\t\tif( func-\u003eparameterTypes[n].GetObjectType() )\n\t\t{\n\t\t\tasCConfigGroup *group = FindConfigGroupForObjectType(func-\u003eparameterTypes[n].GetObjectType());\n\t\t\tcurrentGroup-\u003eRefConfigGroup(group);\n\t\t}\n\t}\n\n\t// Return the function id as success\n\treturn func-\u003eid;\n}\n\n// interface\nint asCScriptEngine::GetGlobalFunctionCount()\n{\n\treturn (int)registeredGlobalFuncs.GetLength();\n}\n\n// interface\nint asCScriptEngine::GetGlobalFunctionIdByIndex(asUINT index)\n{\n\tif( index \u003e= registeredGlobalFuncs.GetLength() )\n\t\treturn asINVALID_ARG;\n\n\treturn registeredGlobalFuncs[index]-\u003eid;\n}\n\n\n\n\n\nasCObjectType *asCScriptEngine::GetObjectType(const char *type)\n{\n\t// TODO: optimize: Improve linear search\n\tfor( asUINT n = 0; n \u003c objectTypes.GetLength(); n++ )\n\t\tif( objectTypes[n] \u0026\u0026\n\t\t\tobjectTypes[n]-\u003ename == type ) // TODO: template: Should we check the subtype in case of template instances?\n\t\t\treturn objectTypes[n];\n\n\treturn 0;\n}\n\n\n\n\nvoid asCScriptEngine::PrepareEngine()\n{\n\tif( isPrepared ) return;\n\tif( configFailed ) return;\n\n\tasUINT n;\n\tfor( n = 0; n \u003c scriptFunctions.GetLength(); n++ )\n\t{\n\t\t// Determine the host application interface\n\t\tif( scriptFunctions[n] \u0026\u0026 scriptFunctions[n]-\u003efuncType == asFUNC_SYSTEM )\n\t\t{\n\t\t\tif( scriptFunctions[n]-\u003esysFuncIntf-\u003ecallConv == ICC_GENERIC_FUNC ||\n\t\t\t\tscriptFunctions[n]-\u003esysFuncIntf-\u003ecallConv == ICC_GENERIC_METHOD )\n\t\t\t\tPrepareSystemFunctionGeneric(scriptFunctions[n], scriptFunctions[n]-\u003esysFuncIntf, this);\n\t\t\telse\n\t\t\t\tPrepareSystemFunction(scriptFunctions[n], scriptFunctions[n]-\u003esysFuncIntf, this);\n\t\t}\n\t}\n\n\t// Validate object type registrations\n\tfor( n = 0; n \u003c objectTypes.GetLength(); n++ )\n\t{\n\t\tif( objectTypes[n] \u0026\u0026 !(objectTypes[n]-\u003eflags \u0026 asOBJ_SCRIPT_OBJECT) )\n\t\t{\n\t\t\tbool missingBehaviour = false;\n\t\t\tconst char *infoMsg = 0;\n\n\t\t\t// Verify that GC types have all behaviours\n\t\t\tif( objectTypes[n]-\u003eflags \u0026 asOBJ_GC )\n\t\t\t{\n\t\t\t\tif( objectTypes[n]-\u003ebeh.addref                 == 0 ||\n\t\t\t\t\tobjectTypes[n]-\u003ebeh.release                == 0 ||\n\t\t\t\t\tobjectTypes[n]-\u003ebeh.gcGetRefCount          == 0 ||\n\t\t\t\t\tobjectTypes[n]-\u003ebeh.gcSetFlag              == 0 ||\n\t\t\t\t\tobjectTypes[n]-\u003ebeh.gcGetFlag              == 0 ||\n\t\t\t\t\tobjectTypes[n]-\u003ebeh.gcEnumReferences       == 0 ||\n\t\t\t\t\tobjectTypes[n]-\u003ebeh.gcReleaseAllReferences == 0 )\n\t\t\t\t{\n\t\t\t\t\tinfoMsg = TXT_GC_REQUIRE_ADD_REL_GC_BEHAVIOUR;\n\t\t\t\t\tmissingBehaviour = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Verify that scoped ref types have the release behaviour\n\t\t\telse if( objectTypes[n]-\u003eflags \u0026 asOBJ_SCOPED )\n\t\t\t{\n\t\t\t\tif( objectTypes[n]-\u003ebeh.release == 0 )\n\t\t\t\t{\n\t\t\t\t\tinfoMsg = TXT_SCOPE_REQUIRE_REL_BEHAVIOUR;\n\t\t\t\t\tmissingBehaviour = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Verify that ref types have add ref and release behaviours\n\t\t\telse if( (objectTypes[n]-\u003eflags \u0026 asOBJ_REF) \u0026\u0026\n\t\t\t\t     !(objectTypes[n]-\u003eflags \u0026 asOBJ_NOHANDLE) )\n\t\t\t{\n\t\t\t\tif( objectTypes[n]-\u003ebeh.addref  == 0 ||\n\t\t\t\t\tobjectTypes[n]-\u003ebeh.release == 0 )\n\t\t\t\t{\n\t\t\t\t\tinfoMsg = TXT_REF_REQUIRE_ADD_REL_BEHAVIOUR;\n\t\t\t\t\tmissingBehaviour = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Verify that non-pod value types have the constructor and destructor registered\n\t\t\telse if( (objectTypes[n]-\u003eflags \u0026 asOBJ_VALUE) \u0026\u0026\n\t\t\t\t     !(objectTypes[n]-\u003eflags \u0026 asOBJ_POD) )\n\t\t\t{\n\t\t\t\tif( objectTypes[n]-\u003ebeh.construct == 0 ||\n\t\t\t\t\tobjectTypes[n]-\u003ebeh.destruct  == 0 )\n\t\t\t\t{\n\t\t\t\t\tinfoMsg = TXT_NON_POD_REQUIRE_CONSTR_DESTR_BEHAVIOUR;\n\t\t\t\t\tmissingBehaviour = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif( missingBehaviour )\n\t\t\t{\n\t\t\t\tasCString str;\n\t\t\t\tstr.Format(TXT_TYPE_s_IS_MISSING_BEHAVIOURS, objectTypes[n]-\u003ename.AddressOf());\n\t\t\t\tWriteMessage(\"\", 0, 0, asMSGTYPE_ERROR, str.AddressOf());\n\t\t\t\tWriteMessage(\"\", 0, 0, asMSGTYPE_INFORMATION, infoMsg);\n\t\t\t\tConfigError(asINVALID_CONFIGURATION);\n\t\t\t}\n\t\t}\n\t}\n\n\tisPrepared = true;\n}\n\nint asCScriptEngine::ConfigError(int err)\n{\n\tconfigFailed = true;\n\treturn err;\n}\n\n\n// interface\nint asCScriptEngine::RegisterStringFactory(const char *datatype, const asSFuncPtr \u0026funcPointer, asDWORD callConv)\n{\n\tasSSystemFunctionInterface internal;\n\tint r = DetectCallingConvention(false, funcPointer, callConv, \u0026internal);\n\tif( r \u003c 0 )\n\t\treturn ConfigError(r);\n\n#ifdef AS_MAX_PORTABILITY\n\tif( callConv != asCALL_GENERIC )\n\t\treturn ConfigError(asNOT_SUPPORTED);\n#else\n\tif( callConv != asCALL_CDECL \u0026\u0026\n\t\tcallConv != asCALL_STDCALL \u0026\u0026\n\t\tcallConv != asCALL_GENERIC )\n\t\treturn ConfigError(asNOT_SUPPORTED);\n#endif\n\n\t// Put the system function in the list of system functions\n\tasSSystemFunctionInterface *newInterface = asNEW(asSSystemFunctionInterface)(internal);\n\n\tasCScriptFunction *func = asNEW(asCScriptFunction)(this, 0, asFUNC_SYSTEM);\n\tfunc-\u003ename        = \"_string_factory_\";\n\tfunc-\u003esysFuncIntf = newInterface;\n\n\tasCBuilder bld(this, 0);\n\n\tasCDataType dt;\n\tr = bld.ParseDataType(datatype, \u0026dt);\n\tif( r \u003c 0 )\n\t{\n\t\t// Set as dummy before deleting\n\t\tfunc-\u003efuncType = -1;\n\t\tasDELETE(func,asCScriptFunction);\n\t\treturn ConfigError(asINVALID_TYPE);\n\t}\n\n\tfunc-\u003ereturnType = dt;\n\tfunc-\u003eparameterTypes.PushLast(asCDataType::CreatePrimitive(ttInt, true));\n\tasCDataType parm1 = asCDataType::CreatePrimitive(ttUInt8, true);\n\tparm1.MakeReference(true);\n\tfunc-\u003eparameterTypes.PushLast(parm1);\n\tfunc-\u003eid = GetNextScriptFunctionId();\n\tSetScriptFunction(func);\n\n\tstringFactory = func;\n\n\tif( func-\u003ereturnType.GetObjectType() )\n\t{\n\t\tasCConfigGroup *group = FindConfigGroupForObjectType(func-\u003ereturnType.GetObjectType());\n\t\tif( group == 0 ) group = \u0026defaultGroup;\n\t\tgroup-\u003escriptFunctions.PushLast(func);\n\t}\n\n\t// Register function id as success\n\treturn func-\u003eid;\n}\n\n// interface\nint asCScriptEngine::GetStringFactoryReturnTypeId()\n{\n\tif( stringFactory == 0 )\n\t\treturn asNO_FUNCTION;\n\n\treturn GetTypeIdFromDataType(stringFactory-\u003ereturnType);\n}\n\n// interface\nasCModule *asCScriptEngine::GetModule(const char *_name, bool create)\n{\n\t// Accept null as well as zero-length string\n\tconst char *name = \"\";\n\tif( _name != 0 ) name = _name;\n\n\tif( lastModule \u0026\u0026 lastModule-\u003ename == name )\n\t\treturn lastModule;\n\n\t// TODO: optimize: Improve linear search\n\tfor( asUINT n = 0; n \u003c scriptModules.GetLength(); ++n )\n\t\tif( scriptModules[n] \u0026\u0026 scriptModules[n]-\u003ename == name )\n\t\t{\n\t\t\tlastModule = scriptModules[n];\n\t\t\treturn lastModule;\n\t\t}\n\n\tif( create )\n\t{\n\t\tasCModule *module = asNEW(asCModule)(name, this);\n\n\t\tscriptModules.PushLast(module);\n\n\t\tlastModule = module;\n\n\t\treturn lastModule;\n\t}\n\n\treturn 0;\n}\n\nasCModule *asCScriptEngine::GetModuleFromFuncId(int id)\n{\n\tif( id \u003c 0 ) return 0;\n\tif( id \u003e= (int)scriptFunctions.GetLength() ) return 0;\n\tasCScriptFunction *func = scriptFunctions[id];\n\tif( func == 0 ) return 0;\n\treturn func-\u003emodule;\n}\n\n// internal\nint asCScriptEngine::RequestBuild()\n{\n\tENTERCRITICALSECTION(engineCritical);\n\tif( isBuilding )\n\t{\n\t\tLEAVECRITICALSECTION(engineCritical);\n\t\treturn asBUILD_IN_PROGRESS;\n\t}\n\tisBuilding = true;\n\tLEAVECRITICALSECTION(engineCritical);\n\n\treturn 0;\n}\n\n// internal\nvoid asCScriptEngine::BuildCompleted()\n{\n\t// Always free up pooled memory after a completed build\n\tmemoryMgr.FreeUnusedMemory();\n\n\tisBuilding = false;\n}\n\n#ifdef AS_DEPRECATED\n// Deprecated since 2009-12-08, 2.18.0\n// interface\nint asCScriptEngine::ExecuteString(const char *module, const char *script, asIScriptContext **ctx, asDWORD flags)\n{\n\tint r;\n\tif( (r = RequestBuild()) \u003c 0 )\n\t\treturn r;\n\n\tPrepareEngine();\n\n\t// Make sure the config worked\n\tif( configFailed )\n\t{\n\t\tif( ctx \u0026\u0026 !(flags \u0026 asEXECSTRING_USE_MY_CONTEXT) )\n\t\t\t*ctx = 0;\n\n\t\tWriteMessage(\"\",0,0,asMSGTYPE_ERROR,TXT_INVALID_CONFIGURATION);\n\t\tisBuilding = false;\n\t\treturn asINVALID_CONFIGURATION;\n\t}\n\n\tasIScriptContext *exec = 0;\n\tif( !(flags \u0026 asEXECSTRING_USE_MY_CONTEXT) )\n\t{\n\t\tint r = CreateContext(\u0026exec, false);\n\t\tif( r \u003c 0 )\n\t\t{\n\t\t\tif( ctx \u0026\u0026 !(flags \u0026 asEXECSTRING_USE_MY_CONTEXT) )\n\t\t\t\t*ctx = 0;\n\t\t\tisBuilding = false;\n\t\t\treturn r;\n\t\t}\n\t\tif( ctx )\n\t\t{\n\t\t\t*ctx = exec;\n\t\t\texec-\u003eAddRef();\n\t\t}\n\t}\n\telse\n\t{\n\t\tif( *ctx == 0 )\n\t\t{\n\t\t\tisBuilding = false;\n\t\t\treturn asINVALID_ARG;\n\t\t}\n\t\texec = *ctx;\n\t\texec-\u003eAddRef();\n\t}\n\n\t// Make sure the context isn't holding a reference to the previous ExecuteString function()\n\texec-\u003eUnprepare();\n\n\t// Get the module to compile the string in\n\tasCModule *mod = GetModule(module, true);\n\n\t// Compile string function\n\tasCBuilder builder(this, mod);\n\tasCString str = script;\n\tstr = \"void ExecuteString(){\\n\" + str + \"\\n;}\";\n\n\tr = builder.BuildString(str.AddressOf(), (asCContext*)exec);\n\t\n\tBuildCompleted();\n\n\tif( r \u003c 0 )\n\t{\n\t\tif( ctx \u0026\u0026 !(flags \u0026 asEXECSTRING_USE_MY_CONTEXT) )\n\t\t{\n\t\t\t(*ctx)-\u003eRelease();\n\t\t\t*ctx = 0;\n\t\t}\n\t\texec-\u003eRelease();\n\t\treturn asERROR;\n\t}\n\n\t// Prepare and execute the context\n\tr = ((asCContext*)exec)-\u003ePrepare(((asCContext*)exec)-\u003estringFunction-\u003eid);\n\tif( r \u003c 0 )\n\t{\n\t\tif( ctx \u0026\u0026 !(flags \u0026 asEXECSTRING_USE_MY_CONTEXT) )\n\t\t{\n\t\t\t(*ctx)-\u003eRelease();\n\t\t\t*ctx = 0;\n\t\t}\n\t\texec-\u003eRelease();\n\t\treturn r;\n\t}\n\n\tif( flags \u0026 asEXECSTRING_ONLY_PREPARE )\n\t\tr = asEXECUTION_PREPARED;\n\telse\n\t\tr = exec-\u003eExecute();\n\n\texec-\u003eRelease();\n\treturn r;\n}\n#endif\n\nvoid asCScriptEngine::RemoveTemplateInstanceType(asCObjectType *t)\n{\n\tint n;\n\n\t// Destroy the factory stubs\n\tfor( n = 0; n \u003c (int)t-\u003ebeh.factories.GetLength(); n++ )\n\t{\n\t\t// Make sure the factory stub isn't referencing this object anymore\n\t\tscriptFunctions[t-\u003ebeh.factories[n]]-\u003eReleaseAllHandles(this);\n\t\tscriptFunctions[t-\u003ebeh.factories[n]]-\u003eRelease();\n\t}\n\tt-\u003ebeh.factories.SetLength(0);\n\n\t// Destroy the specialized functions\n\tfor( n = 1; n \u003c (int)t-\u003ebeh.operators.GetLength(); n += 2 )\n\t{\n\t\tif( t-\u003ebeh.operators[n] \u0026\u0026 scriptFunctions[t-\u003ebeh.operators[n]]-\u003eobjectType == t )\n\t\t{\n\t\t\tscriptFunctions[t-\u003ebeh.operators[n]]-\u003eRelease();\n\t\t}\n\t}\n\tt-\u003ebeh.operators.SetLength(0);\n\n\t// Start searching from the end of the list, as most of\n\t// the time it will be the last two types\n\tfor( n = (int)templateTypes.GetLength()-1; n \u003e= 0; n-- )\n\t{\n\t\tif( templateTypes[n] == t )\n\t\t{\n\t\t\tif( n == (signed)templateTypes.GetLength()-1 )\n\t\t\t\ttemplateTypes.PopLast();\n\t\t\telse\n\t\t\t\ttemplateTypes[n] = templateTypes.PopLast();\n\t\t}\n\t}\n\n\tfor( n = (int)templateInstanceTypes.GetLength()-1; n \u003e= 0; n-- )\n\t{\n\t\tif( templateInstanceTypes[n] == t )\n\t\t{\n\t\t\tif( n == (signed)templateInstanceTypes.GetLength()-1 )\n\t\t\t\ttemplateInstanceTypes.PopLast();\n\t\t\telse\n\t\t\t\ttemplateInstanceTypes[n] = templateInstanceTypes.PopLast();\n\t\t}\n\t}\n\n\tasDELETE(t,asCObjectType);\n}\n\nasCObjectType *asCScriptEngine::GetTemplateInstanceType(asCObjectType *templateType, asCDataType \u0026subType)\n{\n\tasUINT n;\n\n\t// Is there any template instance type or template specialization already with this subtype?\n\tfor( n = 0; n \u003c templateTypes.GetLength(); n++ )\n\t{\n\t\tif( templateTypes[n] \u0026\u0026\n\t\t\ttemplateTypes[n]-\u003ename == templateType-\u003ename \u0026\u0026\n\t\t\ttemplateTypes[n]-\u003etemplateSubType == subType )\n\t\t\treturn templateTypes[n];\n\t}\n\n\t// No previous template instance exists\n\n\t// Make sure this template supports the subtype\n\tif( !templateType-\u003eacceptValueSubType \u0026\u0026 (subType.IsPrimitive() || (subType.GetObjectType()-\u003eflags \u0026 asOBJ_VALUE)) )\n\t\treturn 0;\n\n\tif( !templateType-\u003eacceptRefSubType \u0026\u0026 (subType.IsObject() \u0026\u0026 (subType.GetObjectType()-\u003eflags \u0026 asOBJ_REF)) )\n\t\treturn 0;\n\n\t// Create a new template instance type based on the templateType\n\tasCObjectType *ot = asNEW(asCObjectType)(this);\n\tot-\u003etemplateSubType = subType;\n\tot-\u003eflags     = templateType-\u003eflags;\n\tot-\u003esize      = templateType-\u003esize;\n\tot-\u003ename      = templateType-\u003ename;\n\n\t// Before filling in the methods, call the template instance callback behaviour to validate the type\n\tif( templateType-\u003ebeh.templateCallback )\n\t{\n\t\tasCScriptFunction *callback = scriptFunctions[templateType-\u003ebeh.templateCallback];\n\t\tif( !CallGlobalFunctionRetBool(ot, 0, callback-\u003esysFuncIntf, callback) )\n\t\t{\n\t\t\t// The type cannot be instanciated\n\t\t\tot-\u003etemplateSubType = asCDataType();\n\t\t\tasDELETE(ot, asCObjectType);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tot-\u003emethods   = templateType-\u003emethods;\n\tfor( n = 0; n \u003c ot-\u003emethods.GetLength(); n++ )\n\t\tscriptFunctions[ot-\u003emethods[n]]-\u003eAddRef();\n\t// Store the real factory in the constructor\n\tot-\u003ebeh.construct = templateType-\u003ebeh.factory;\n\tot-\u003ebeh.constructors = templateType-\u003ebeh.factories;\n\tfor( n = 0; n \u003c ot-\u003ebeh.constructors.GetLength(); n++ )\n\t\tscriptFunctions[ot-\u003ebeh.constructors[n]]-\u003eAddRef();\n\n\t// Generate factory stubs for each of the factories\n\tfor( n = 0; n \u003c templateType-\u003ebeh.factories.GetLength(); n++ )\n\t{\n\t\tint factoryId = templateType-\u003ebeh.factories[n];\n\t\tasCScriptFunction *factory = scriptFunctions[factoryId];\n\n\t\tasCScriptFunction *func = asNEW(asCScriptFunction)(this, 0, asFUNC_SCRIPT);\n\t\tfunc-\u003ename             = \"factstub\";\n\t\tfunc-\u003eid               = GetNextScriptFunctionId();\n\t\tfunc-\u003ereturnType       = asCDataType::CreateObjectHandle(ot, false);\n\n\t\t// Skip the first parameter as this is the object type pointer that the stub will add\n\t\tfor( asUINT p = 1; p \u003c factory-\u003eparameterTypes.GetLength(); p++ )\n\t\t{\n\t\t\tfunc-\u003eparameterTypes.PushLast(factory-\u003eparameterTypes[p]);\n\t\t\tfunc-\u003einOutFlags.PushLast(factory-\u003einOutFlags[p]);\n\t\t}\n\n\t\tSetScriptFunction(func);\n\n\t\tasCBuilder builder(this, 0);\n\t\tasCCompiler compiler(this);\n\t\tcompiler.CompileTemplateFactoryStub(\u0026builder, factoryId, ot, func);\n\n\t\t// The function's refCount was already initialized to 1\n\t\tot-\u003ebeh.factories.PushLast(func-\u003eid);\n\t}\n\tif( ot-\u003ebeh.factories.GetLength() )\n\t\tot-\u003ebeh.factory = ot-\u003ebeh.factories[0];\n\telse\n\t{\n\t\tasASSERT(false);\n\t\tot-\u003ebeh.factory = templateType-\u003ebeh.factory;\n\t}\n\n\n\n\tot-\u003ebeh.addref                 = templateType-\u003ebeh.addref;\n\tif( scriptFunctions[ot-\u003ebeh.addref] ) scriptFunctions[ot-\u003ebeh.addref]-\u003eAddRef();\n\tot-\u003ebeh.release                = templateType-\u003ebeh.release;\n\tif( scriptFunctions[ot-\u003ebeh.release] ) scriptFunctions[ot-\u003ebeh.release]-\u003eAddRef();\n\tot-\u003ebeh.copy                   = templateType-\u003ebeh.copy;\n\tif( scriptFunctions[ot-\u003ebeh.copy] ) scriptFunctions[ot-\u003ebeh.copy]-\u003eAddRef();\n\tot-\u003ebeh.operators              = templateType-\u003ebeh.operators;\n\tfor( n = 1; n \u003c ot-\u003ebeh.operators.GetLength(); n += 2 )\n\t{\n\t\tscriptFunctions[ot-\u003ebeh.operators[n]]-\u003eAddRef();\n\t}\n\tot-\u003ebeh.gcGetRefCount          = templateType-\u003ebeh.gcGetRefCount;\n\tif( scriptFunctions[ot-\u003ebeh.gcGetRefCount] ) scriptFunctions[ot-\u003ebeh.gcGetRefCount]-\u003eAddRef();\n\tot-\u003ebeh.gcSetFlag              = templateType-\u003ebeh.gcSetFlag;\n\tif( scriptFunctions[ot-\u003ebeh.gcSetFlag] ) scriptFunctions[ot-\u003ebeh.gcSetFlag]-\u003eAddRef();\n\tot-\u003ebeh.gcGetFlag              = templateType-\u003ebeh.gcGetFlag;\n\tif( scriptFunctions[ot-\u003ebeh.gcGetFlag] ) scriptFunctions[ot-\u003ebeh.gcGetFlag]-\u003eAddRef();\n\tot-\u003ebeh.gcEnumReferences       = templateType-\u003ebeh.gcEnumReferences;\n\tif( scriptFunctions[ot-\u003ebeh.gcEnumReferences] ) scriptFunctions[ot-\u003ebeh.gcEnumReferences]-\u003eAddRef();\n\tot-\u003ebeh.gcReleaseAllReferences = templateType-\u003ebeh.gcReleaseAllReferences;\n\tif( scriptFunctions[ot-\u003ebeh.gcReleaseAllReferences] ) scriptFunctions[ot-\u003ebeh.gcReleaseAllReferences]-\u003eAddRef();\n\n\t// As the new template type is instanciated, the engine should\n\t// generate new functions to substitute the ones with the template subtype.\n\tfor( n = 1; n \u003c ot-\u003ebeh.operators.GetLength(); n += 2 )\n\t{\n\t\tint funcId = ot-\u003ebeh.operators[n];\n\t\tasCScriptFunction *func = scriptFunctions[funcId];\n\n\t\tif( GenerateNewTemplateFunction(templateType, ot, subType, func, \u0026func) )\n\t\t{\n\t\t\t// Release the old function, the new one already has its ref count set to 1\n\t\t\tscriptFunctions[ot-\u003ebeh.operators[n]]-\u003eRelease();\n\t\t\tot-\u003ebeh.operators[n] = func-\u003eid;\n\t\t}\n\t}\n\n\t// As the new template type is instanciated, the engine should\n\t// generate new functions to substitute the ones with the template subtype.\n\tfor( n = 0; n \u003c ot-\u003emethods.GetLength(); n++ )\n\t{\n\t\tint funcId = ot-\u003emethods[n];\n\t\tasCScriptFunction *func = scriptFunctions[funcId];\n\n\t\tif( GenerateNewTemplateFunction(templateType, ot, subType, func, \u0026func) )\n\t\t{\n\t\t\t// Release the old function, the new one already has its ref count set to 1\n\t\t\tscriptFunctions[ot-\u003emethods[n]]-\u003eRelease();\n\t\t\tot-\u003emethods[n] = func-\u003eid;\n\t\t}\n\t}\n\n\t// Increase ref counter for sub type if it is an object type\n\tif( ot-\u003etemplateSubType.GetObjectType() ) ot-\u003etemplateSubType.GetObjectType()-\u003eAddRef();\n\n\t// Verify if the subtype contains a garbage collected object, in which case this template is a potential circular reference\n\t// TODO: We may be a bit smarter here. If we can guarantee that the array type cannot be part of the\n\t//       potential circular reference then we don't need to set the flag\n\n\tif( ot-\u003etemplateSubType.GetObjectType() \u0026\u0026 (ot-\u003etemplateSubType.GetObjectType()-\u003eflags \u0026 asOBJ_GC) )\n\t\tot-\u003eflags |= asOBJ_GC;\n\telse if( ot-\u003ename == defaultArrayObjectType-\u003ename )\n\t\tot-\u003eflags \u0026= ~asOBJ_GC;\n\n\ttemplateTypes.PushLast(ot);\n\n\t// We need to store the object type somewhere for clean-up later\n\t// TODO: Why do we need both templateTypes and templateInstanceTypes? It is possible to differ between template instance and template specialization by checking for the asOBJ_TEMPLATE flag\n\ttemplateInstanceTypes.PushLast(ot);\n\n\treturn ot;\n}\n\nbool asCScriptEngine::GenerateNewTemplateFunction(asCObjectType *templateType, asCObjectType *ot, asCDataType \u0026subType, asCScriptFunction *func, asCScriptFunction **newFunc)\n{\n\tbool needNewFunc = false;\n\tif( func-\u003ereturnType.GetObjectType() == templateType-\u003etemplateSubType.GetObjectType() ||\n\t\tfunc-\u003ereturnType.GetObjectType() == templateType )\n\t\tneedNewFunc = true;\n\telse\n\t{\n\t\tfor( asUINT p = 0; p \u003c func-\u003eparameterTypes.GetLength(); p++ )\n\t\t{\n\t\t\tif( func-\u003eparameterTypes[p].GetObjectType() == templateType-\u003etemplateSubType.GetObjectType() ||\n\t\t\t\tfunc-\u003eparameterTypes[p].GetObjectType() == templateType )\n\t\t\t{\n\t\t\t\tneedNewFunc = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif( needNewFunc )\n\t{\n\t\tasCScriptFunction *func2 = asNEW(asCScriptFunction)(this, 0, func-\u003efuncType);\n\t\tfunc2-\u003ename     = func-\u003ename;\n\t\tfunc2-\u003eid       = GetNextScriptFunctionId();\n\n\t\tif( func-\u003ereturnType.GetObjectType() == templateType-\u003etemplateSubType.GetObjectType() )\n\t\t{\n\t\t\tfunc2-\u003ereturnType = subType;\n\t\t\tif( func-\u003ereturnType.IsObjectHandle() )\n\t\t\t\tfunc2-\u003ereturnType.MakeHandle(true, true);\n\t\t\tfunc2-\u003ereturnType.MakeReference(func-\u003ereturnType.IsReference());\n\t\t\tfunc2-\u003ereturnType.MakeReadOnly(func-\u003ereturnType.IsReadOnly());\n\t\t}\n\t\telse if( func-\u003ereturnType.GetObjectType() == templateType )\n\t\t{\n\t\t\tif( func2-\u003ereturnType.IsObjectHandle() )\n\t\t\t\tfunc2-\u003ereturnType = asCDataType::CreateObjectHandle(ot, false);\n\t\t\telse\n\t\t\t\tfunc2-\u003ereturnType = asCDataType::CreateObject(ot, false);\n\n\t\t\tfunc2-\u003ereturnType.MakeReference(func-\u003ereturnType.IsReference());\n\t\t\tfunc2-\u003ereturnType.MakeReadOnly(func-\u003ereturnType.IsReadOnly());\n\t\t}\n\t\telse\n\t\t\tfunc2-\u003ereturnType = func-\u003ereturnType;\n\n\t\tfunc2-\u003eparameterTypes.SetLength(func-\u003eparameterTypes.GetLength());\n\t\tfor( asUINT p = 0; p \u003c func-\u003eparameterTypes.GetLength(); p++ )\n\t\t{\n\t\t\tif( func-\u003eparameterTypes[p].GetObjectType() == templateType-\u003etemplateSubType.GetObjectType() )\n\t\t\t{\n\t\t\t\tfunc2-\u003eparameterTypes[p] = subType;\n\t\t\t\tif( func-\u003eparameterTypes[p].IsObjectHandle() )\n\t\t\t\t\tfunc2-\u003eparameterTypes[p].MakeHandle(true);\n\t\t\t\tfunc2-\u003eparameterTypes[p].MakeReference(func-\u003eparameterTypes[p].IsReference());\n\t\t\t\tfunc2-\u003eparameterTypes[p].MakeReadOnly(func-\u003eparameterTypes[p].IsReference());\n\t\t\t}\n\t\t\telse if( func-\u003eparameterTypes[p].GetObjectType() == templateType )\n\t\t\t{\n\t\t\t\tif( func2-\u003eparameterTypes[p].IsObjectHandle() )\n\t\t\t\t\tfunc2-\u003eparameterTypes[p] = asCDataType::CreateObjectHandle(ot, false);\n\t\t\t\telse\n\t\t\t\t\tfunc2-\u003eparameterTypes[p] = asCDataType::CreateObject(ot, false);\n\n\t\t\t\tfunc2-\u003eparameterTypes[p].MakeReference(func-\u003eparameterTypes[p].IsReference());\n\t\t\t\tfunc2-\u003eparameterTypes[p].MakeReadOnly(func-\u003eparameterTypes[p].IsReadOnly());\n\t\t\t}\n\t\t\telse\n\t\t\t\tfunc2-\u003eparameterTypes[p] = func-\u003eparameterTypes[p];\n\t\t}\n\n\t\t// TODO: template: Must be careful when instanciating templates for garbage collected types\n\t\t//                 If the template hasn't been registered with the behaviours, it shouldn't\n\t\t//                 permit instanciation of garbage collected types that in turn may refer to\n\t\t//                 this instance.\n\n\t\tfunc2-\u003einOutFlags = func-\u003einOutFlags;\n\t\tfunc2-\u003eisReadOnly = func-\u003eisReadOnly;\n\t\tfunc2-\u003eobjectType = ot;\n\t\tfunc2-\u003estackNeeded = func-\u003estackNeeded;\n\t\tfunc2-\u003esysFuncIntf = asNEW(asSSystemFunctionInterface)(*func-\u003esysFuncIntf);\n\n\t\tSetScriptFunction(func2);\n\n\t\t// Return the new function\n\t\t*newFunc = func2;\n\t}\n\n\treturn needNewFunc;\n}\n\nvoid asCScriptEngine::CallObjectMethod(void *obj, int func)\n{\n\tasCScriptFunction *s = scriptFunctions[func];\n\tCallObjectMethod(obj, s-\u003esysFuncIntf, s);\n}\n\nvoid asCScriptEngine::CallObjectMethod(void *obj, asSSystemFunctionInterface *i, asCScriptFunction *s)\n{\n#ifdef __GNUC__\n\tif( i-\u003ecallConv == ICC_GENERIC_METHOD )\n\t{\n\t\tasCGeneric gen(this, s, obj, 0);\n\t\tvoid (*f)(asIScriptGeneric *) = (void (*)(asIScriptGeneric *))(i-\u003efunc);\n\t\tf(\u0026gen);\n\t}\n\telse if( i-\u003ecallConv == ICC_VIRTUAL_THISCALL )\n\t{\n\t\t// For virtual thiscalls we must call the method as a true class method\n\t\t// so that the compiler will lookup the function address in the vftable\n\t\tunion\n\t\t{\n\t\t\tasSIMPLEMETHOD_t mthd;\n\t\t\tstruct\n\t\t\t{\n\t\t\t\tasFUNCTION_t func;\n\t\t\t\tasPWORD baseOffset;  // Same size as the pointer\n\t\t\t} f;\n\t\t} p;\n\t\tp.f.func = (void (*)())(i-\u003efunc);\n\t\tp.f.baseOffset = asPWORD(i-\u003ebaseOffset);\n\t\tvoid (asCSimpleDummy::*f)() = p.mthd;\n\t\t(((asCSimpleDummy*)obj)-\u003e*f)();\n\t}\n\telse /*if( i-\u003ecallConv == ICC_THISCALL || i-\u003ecallConv == ICC_CDECL_OBJLAST || i-\u003ecallConv == ICC_CDECL_OBJFIRST )*/\n\t{\n\t\t// Non-virtual thiscall can be called just like any global function, passing the object as the first parameter\n\t\tvoid (*f)(void *) = (void (*)(void *))(i-\u003efunc);\n\t\tf(obj);\n\t}\n#else\n#ifndef AS_NO_CLASS_METHODS\n\tif( i-\u003ecallConv == ICC_THISCALL )\n\t{\n\t\tunion\n\t\t{\n\t\t\tasSIMPLEMETHOD_t mthd;\n\t\t\tasFUNCTION_t func;\n\t\t} p;\n\t\tp.func = (void (*)())(i-\u003efunc);\n\t\tvoid (asCSimpleDummy::*f)() = p.mthd;\n\t\t(((asCSimpleDummy*)obj)-\u003e*f)();\n\t}\n\telse\n#endif\n\tif( i-\u003ecallConv == ICC_GENERIC_METHOD )\n\t{\n\t\tasCGeneric gen(this, s, obj, 0);\n\t\tvoid (*f)(asIScriptGeneric *) = (void (*)(asIScriptGeneric *))(i-\u003efunc);\n\t\tf(\u0026gen);\n\t}\n\telse /*if( i-\u003ecallConv == ICC_CDECL_OBJLAST || i-\u003ecallConv == ICC_CDECL_OBJFIRST )*/\n\t{\n\t\tvoid (*f)(void *) = (void (*)(void *))(i-\u003efunc);\n\t\tf(obj);\n\t}\n#endif\n}\n\nbool asCScriptEngine::CallObjectMethodRetBool(void *obj, int func)\n{\n\tasCScriptFunction *s = scriptFunctions[func];\n\tasSSystemFunctionInterface *i = s-\u003esysFuncIntf;\n\n#ifdef __GNUC__\n\tif( i-\u003ecallConv == ICC_GENERIC_METHOD )\n\t{\n\t\tasCGeneric gen(this, s, obj, 0);\n\t\tvoid (*f)(asIScriptGeneric *) = (void (*)(asIScriptGeneric *))(i-\u003efunc);\n\t\tf(\u0026gen);\n\t\treturn *(bool*)gen.GetReturnPointer();\n\t}\n\telse if( i-\u003ecallConv == ICC_VIRTUAL_THISCALL )\n\t{\n\t\t// For virtual thiscalls we must call the method as a true class method so that the compiler will lookup the function address in the vftable\n\t\tunion\n\t\t{\n\t\t\tasSIMPLEMETHOD_t mthd;\n\t\t\tstruct\n\t\t\t{\n\t\t\t\tasFUNCTION_t func;\n\t\t\t\tasDWORD baseOffset;\n\t\t\t} f;\n\t\t} p;\n\t\tp.f.func = (void (*)())(i-\u003efunc);\n\t\tp.f.baseOffset = i-\u003ebaseOffset;\n\t\tbool (asCSimpleDummy::*f)() = (bool (asCSimpleDummy::*)())(p.mthd);\n\t\treturn (((asCSimpleDummy*)obj)-\u003e*f)();\n\t}\n\telse /*if( i-\u003ecallConv == ICC_THISCALL || i-\u003ecallConv == ICC_CDECL_OBJLAST || i-\u003ecallConv == ICC_CDECL_OBJFIRST )*/\n\t{\n\t\t// Non-virtual thiscall can be called just like any global function, passing the object as the first parameter\n\t\tbool (*f)(void *) = (bool (*)(void *))(i-\u003efunc);\n\t\treturn f(obj);\n\t}\n#else\n#ifndef AS_NO_CLASS_METHODS\n\tif( i-\u003ecallConv == ICC_THISCALL )\n\t{\n\t\tunion\n\t\t{\n\t\t\tasSIMPLEMETHOD_t mthd;\n\t\t\tasFUNCTION_t func;\n\t\t} p;\n\t\tp.func = (void (*)())(i-\u003efunc);\n\t\tbool (asCSimpleDummy::*f)() = (bool (asCSimpleDummy::*)())p.mthd;\n\t\treturn (((asCSimpleDummy*)obj)-\u003e*f)();\n\t}\n\telse\n#endif\n\tif( i-\u003ecallConv == ICC_GENERIC_METHOD )\n\t{\n\t\tasCGeneric gen(this, s, obj, 0);\n\t\tvoid (*f)(asIScriptGeneric *) = (void (*)(asIScriptGeneric *))(i-\u003efunc);\n\t\tf(\u0026gen);\n\t\treturn *(bool*)gen.GetReturnPointer();\n\t}\n\telse /*if( i-\u003ecallConv == ICC_CDECL_OBJLAST || i-\u003ecallConv == ICC_CDECL_OBJFIRST )*/\n\t{\n\t\tbool (*f)(void *) = (bool (*)(void *))(i-\u003efunc);\n\t\treturn f(obj);\n\t}\n#endif\n}\n\nint asCScriptEngine::CallObjectMethodRetInt(void *obj, int func)\n{\n\tasCScriptFunction *s = scriptFunctions[func];\n\tasSSystemFunctionInterface *i = s-\u003esysFuncIntf;\n\n#ifdef __GNUC__\n\tif( i-\u003ecallConv == ICC_GENERIC_METHOD )\n\t{\n\t\tasCGeneric gen(this, s, obj, 0);\n\t\tvoid (*f)(asIScriptGeneric *) = (void (*)(asIScriptGeneric *))(i-\u003efunc);\n\t\tf(\u0026gen);\n\t\treturn *(int*)gen.GetReturnPointer();\n\t}\n\telse if( i-\u003ecallConv == ICC_VIRTUAL_THISCALL )\n\t{\n\t\t// For virtual thiscalls we must call the method as a true class method so that the compiler will lookup the function address in the vftable\n\t\tunion\n\t\t{\n\t\t\tasSIMPLEMETHOD_t mthd;\n\t\t\tstruct\n\t\t\t{\n\t\t\t\tasFUNCTION_t func;\n\t\t\t\tasDWORD baseOffset;\n\t\t\t} f;\n\t\t} p;\n\t\tp.f.func = (void (*)())(i-\u003efunc);\n\t\tp.f.baseOffset = i-\u003ebaseOffset;\n\t\tint (asCSimpleDummy::*f)() = (int (asCSimpleDummy::*)())(p.mthd);\n\t\treturn (((asCSimpleDummy*)obj)-\u003e*f)();\n\t}\n\telse /*if( i-\u003ecallConv == ICC_THISCALL || i-\u003ecallConv == ICC_CDECL_OBJLAST || i-\u003ecallConv == ICC_CDECL_OBJFIRST )*/\n\t{\n\t\t// Non-virtual thiscall can be called just like any global function, passing the object as the first parameter\n\t\tint (*f)(void *) = (int (*)(void *))(i-\u003efunc);\n\t\treturn f(obj);\n\t}\n#else\n#ifndef AS_NO_CLASS_METHODS\n\tif( i-\u003ecallConv == ICC_THISCALL )\n\t{\n\t\tunion\n\t\t{\n\t\t\tasSIMPLEMETHOD_t mthd;\n\t\t\tasFUNCTION_t func;\n\t\t} p;\n\t\tp.func = (void (*)())(i-\u003efunc);\n\t\tint (asCSimpleDummy::*f)() = (int (asCSimpleDummy::*)())p.mthd;\n\t\treturn (((asCSimpleDummy*)obj)-\u003e*f)();\n\t}\n\telse\n#endif\n\tif( i-\u003ecallConv == ICC_GENERIC_METHOD )\n\t{\n\t\tasCGeneric gen(this, s, obj, 0);\n\t\tvoid (*f)(asIScriptGeneric *) = (void (*)(asIScriptGeneric *))(i-\u003efunc);\n\t\tf(\u0026gen);\n\t\treturn *(int*)gen.GetReturnPointer();\n\t}\n\telse /*if( i-\u003ecallConv == ICC_CDECL_OBJLAST || i-\u003ecallConv == ICC_CDECL_OBJFIRST )*/\n\t{\n\t\tint (*f)(void *) = (int (*)(void *))(i-\u003efunc);\n\t\treturn f(obj);\n\t}\n#endif\n}\n\nvoid *asCScriptEngine::CallGlobalFunctionRetPtr(int func)\n{\n\tasCScriptFunction *s = scriptFunctions[func];\n\treturn CallGlobalFunctionRetPtr(s-\u003esysFuncIntf, s);\n}\n\nvoid *asCScriptEngine::CallGlobalFunctionRetPtr(int func, void *param1)\n{\n\tasCScriptFunction *s = scriptFunctions[func];\n\treturn CallGlobalFunctionRetPtr(s-\u003esysFuncIntf, s, param1);\n}\n\nvoid *asCScriptEngine::CallGlobalFunctionRetPtr(asSSystemFunctionInterface *i, asCScriptFunction *s)\n{\n\tif( i-\u003ecallConv == ICC_CDECL )\n\t{\n\t\tvoid *(*f)() = (void *(*)())(i-\u003efunc);\n\t\treturn f();\n\t}\n\telse if( i-\u003ecallConv == ICC_STDCALL )\n\t{\n\t\tvoid *(STDCALL *f)() = (void *(STDCALL *)())(i-\u003efunc);\n\t\treturn f();\n\t}\n\telse\n\t{\n\t\tasCGeneric gen(this, s, 0, 0);\n\t\tvoid (*f)(asIScriptGeneric *) = (void (*)(asIScriptGeneric *))(i-\u003efunc);\n\t\tf(\u0026gen);\n\t\treturn *(void**)gen.GetReturnPointer();\n\t}\n}\n\nvoid *asCScriptEngine::CallGlobalFunctionRetPtr(asSSystemFunctionInterface *i, asCScriptFunction *s, void *param1)\n{\n\tif( i-\u003ecallConv == ICC_CDECL )\n\t{\n\t\tvoid *(*f)(void *) = (void *(*)(void *))(i-\u003efunc);\n\t\treturn f(param1);\n\t}\n\telse if( i-\u003ecallConv == ICC_STDCALL )\n\t{\n\t\tvoid *(STDCALL *f)(void *) = (void *(STDCALL *)(void *))(i-\u003efunc);\n\t\treturn f(param1);\n\t}\n\telse\n\t{\n\t\tasCGeneric gen(this, s, 0, (asDWORD*)\u0026param1);\n\t\tvoid (*f)(asIScriptGeneric *) = (void (*)(asIScriptGeneric *))(i-\u003efunc);\n\t\tf(\u0026gen);\n\t\treturn *(void**)gen.GetReturnPointer();\n\t}\n}\n\nvoid asCScriptEngine::CallObjectMethod(void *obj, void *param, int func)\n{\n\tasCScriptFunction *s = scriptFunctions[func];\n\tCallObjectMethod(obj, param, s-\u003esysFuncIntf, s);\n}\n\nvoid asCScriptEngine::CallObjectMethod(void *obj, void *param, asSSystemFunctionInterface *i, asCScriptFunction *s)\n{\n#ifdef __GNUC__\n\tif( i-\u003ecallConv == ICC_CDECL_OBJLAST )\n\t{\n\t\tvoid (*f)(void *, void *) = (void (*)(void *, void *))(i-\u003efunc);\n\t\tf(param, obj);\n\t}\n\telse if( i-\u003ecallConv == ICC_GENERIC_METHOD )\n\t{\n\t\tasCGeneric gen(this, s, obj, (asDWORD*)\u0026param);\n\t\tvoid (*f)(asIScriptGeneric *) = (void (*)(asIScriptGeneric *))(i-\u003efunc);\n\t\tf(\u0026gen);\n\t}\n\telse /*if( i-\u003ecallConv == ICC_CDECL_OBJFIRST || i-\u003ecallConv == ICC_THISCALL )*/\n\t{\n\t\tvoid (*f)(void *, void *) = (void (*)(void *, void *))(i-\u003efunc);\n\t\tf(obj, param);\n\t}\n#else\n#ifndef AS_NO_CLASS_METHODS\n\tif( i-\u003ecallConv == ICC_THISCALL )\n\t{\n\t\tunion\n\t\t{\n\t\t\tasSIMPLEMETHOD_t mthd;\n\t\t\tasFUNCTION_t func;\n\t\t} p;\n\t\tp.func = (void (*)())(i-\u003efunc);\n\t\tvoid (asCSimpleDummy::*f)(void *) = (void (asCSimpleDummy::*)(void *))(p.mthd);\n\t\t(((asCSimpleDummy*)obj)-\u003e*f)(param);\n\t}\n\telse\n#endif\n\tif( i-\u003ecallConv == ICC_CDECL_OBJLAST )\n\t{\n\t\tvoid (*f)(void *, void *) = (void (*)(void *, void *))(i-\u003efunc);\n\t\tf(param, obj);\n\t}\n\telse if( i-\u003ecallConv == ICC_GENERIC_METHOD )\n\t{\n\t\tasCGeneric gen(this, s, obj, (asDWORD*)\u0026param);\n\t\tvoid (*f)(asIScriptGeneric *) = (void (*)(asIScriptGeneric *))(i-\u003efunc);\n\t\tf(\u0026gen);\n\t}\n\telse /*if( i-\u003ecallConv == ICC_CDECL_OBJFIRST )*/\n\t{\n\t\tvoid (*f)(void *, void *) = (void (*)(void *, void *))(i-\u003efunc);\n\t\tf(obj, param);\n\t}\n#endif\n}\n\nvoid asCScriptEngine::CallGlobalFunction(void *param1, void *param2, asSSystemFunctionInterface *i, asCScriptFunction *s)\n{\n\tif( i-\u003ecallConv == ICC_CDECL )\n\t{\n\t\tvoid (*f)(void *, void *) = (void (*)(void *, void *))(i-\u003efunc);\n\t\tf(param1, param2);\n\t}\n\telse if( i-\u003ecallConv == ICC_STDCALL )\n\t{\n\t\tvoid (STDCALL *f)(void *, void *) = (void (STDCALL *)(void *, void *))(i-\u003efunc);\n\t\tf(param1, param2);\n\t}\n\telse\n\t{\n\t\tasCGeneric gen(this, s, 0, (asDWORD*)\u0026param1);\n\t\tvoid (*f)(asIScriptGeneric *) = (void (*)(asIScriptGeneric *))(i-\u003efunc);\n\t\tf(\u0026gen);\n\t}\n}\n\nbool asCScriptEngine::CallGlobalFunctionRetBool(void *param1, void *param2, asSSystemFunctionInterface *i, asCScriptFunction *s)\n{\n\tif( i-\u003ecallConv == ICC_CDECL )\n\t{\n\t\tbool (*f)(void *, void *) = (bool (*)(void *, void *))(i-\u003efunc);\n\t\treturn f(param1, param2);\n\t}\n\telse if( i-\u003ecallConv == ICC_STDCALL )\n\t{\n\t\tbool (STDCALL *f)(void *, void *) = (bool (STDCALL *)(void *, void *))(i-\u003efunc);\n\t\treturn f(param1, param2);\n\t}\n\telse\n\t{\n\t\t// TODO: When simulating a 64bit environment by defining AS_64BIT_PTR on a 32bit platform this code\n\t\t//       fails, because the stack given to asCGeneric is not prepared with two 64bit arguments.\n\t\tasCGeneric gen(this, s, 0, (asDWORD*)\u0026param1);\n\t\tvoid (*f)(asIScriptGeneric *) = (void (*)(asIScriptGeneric *))(i-\u003efunc);\n\t\tf(\u0026gen);\n\t\treturn *(bool*)gen.GetReturnPointer();\n\t}\n}\n\nvoid *asCScriptEngine::CallAlloc(asCObjectType *type)\n{\n    // Allocate 4 bytes as the smallest size. Otherwise CallSystemFunction may try to\n    // copy a DWORD onto a smaller memory block, in case the object type is return in registers.\n#if defined(AS_DEBUG)\n\treturn ((asALLOCFUNCDEBUG_t)(userAlloc))(type-\u003esize \u003c 4 ? 4 : type-\u003esize, __FILE__, __LINE__);\n#else\n\treturn userAlloc(type-\u003esize \u003c 4 ? 4 : type-\u003esize);\n#endif\n}\n\nvoid asCScriptEngine::CallFree(void *obj)\n{\n\tuserFree(obj);\n}\n\n// interface\nvoid asCScriptEngine::NotifyGarbageCollectorOfNewObject(void *obj, int typeId)\n{\n\tasCObjectType *objType = GetObjectTypeFromTypeId(typeId);\n\tgc.AddScriptObjectToGC(obj, objType);\n}\n\n// interface\nint asCScriptEngine::GarbageCollect(asDWORD flags)\n{\n\treturn gc.GarbageCollect(flags);\n}\n\n// interface\nvoid asCScriptEngine::GetGCStatistics(asUINT *currentSize, asUINT *totalDestroyed, asUINT *totalDetected)\n{\n\tgc.GetStatistics(currentSize, totalDestroyed, totalDetected);\n}\n\n// interface\nvoid asCScriptEngine::GCEnumCallback(void *reference)\n{\n\tgc.GCEnumCallback(reference);\n}\n\n\n// TODO: multithread: The mapTypeIdToDataType must be protected with critical sections in all functions that access it\nint asCScriptEngine::GetTypeIdFromDataType(const asCDataType \u0026dt)\n{\n\tif( dt.IsNullHandle() ) return 0;\n\n\t// Find the existing type id\n\tasSMapNode\u003cint,asCDataType*\u003e *cursor = 0;\n\tmapTypeIdToDataType.MoveFirst(\u0026cursor);\n\twhile( cursor )\n\t{\n\t\tif( mapTypeIdToDataType.GetValue(cursor)-\u003eIsEqualExceptRefAndConst(dt) )\n\t\t\treturn mapTypeIdToDataType.GetKey(cursor);\n\n\t\tmapTypeIdToDataType.MoveNext(\u0026cursor, cursor);\n\t}\n\n\t// The type id doesn't exist, create it\n\n\t// Setup the basic type id\n\tint typeId = typeIdSeqNbr++;\n\tif( dt.GetObjectType() )\n\t{\n\t\tif( dt.GetObjectType()-\u003eflags \u0026 asOBJ_SCRIPT_OBJECT ) typeId |= asTYPEID_SCRIPTOBJECT;\n\t\telse if( dt.GetObjectType()-\u003eflags \u0026 asOBJ_TEMPLATE ) typeId |= asTYPEID_SCRIPTARRAY; // TODO: Should be asTYPEID_TEMPLATE\n\t\telse if( dt.GetObjectType()-\u003eflags \u0026 asOBJ_ENUM ); // TODO: Should we have a specific bit for this?\n\t\telse typeId |= asTYPEID_APPOBJECT;\n\t}\n\n\t// Insert the basic object type\n\tasCDataType *newDt = asNEW(asCDataType)(dt);\n\tnewDt-\u003eMakeReference(false);\n\tnewDt-\u003eMakeReadOnly(false);\n\tnewDt-\u003eMakeHandle(false);\n\n\tmapTypeIdToDataType.Insert(typeId, newDt);\n\n\t// If the object type supports object handles then register those types as well\n\t// Note: Don't check for addref, as asOBJ_SCOPED don't have this\n\tif( dt.IsObject() \u0026\u0026 dt.GetObjectType()-\u003ebeh.release )\n\t{\n\t\tnewDt = asNEW(asCDataType)(dt);\n\t\tnewDt-\u003eMakeReference(false);\n\t\tnewDt-\u003eMakeReadOnly(false);\n\t\tnewDt-\u003eMakeHandle(true);\n\t\tnewDt-\u003eMakeHandleToConst(false);\n\n\t\tmapTypeIdToDataType.Insert(typeId | asTYPEID_OBJHANDLE, newDt);\n\n\t\tnewDt = asNEW(asCDataType)(dt);\n\t\tnewDt-\u003eMakeReference(false);\n\t\tnewDt-\u003eMakeReadOnly(false);\n\t\tnewDt-\u003eMakeHandle(true);\n\t\tnewDt-\u003eMakeHandleToConst(true);\n\n\t\tmapTypeIdToDataType.Insert(typeId | asTYPEID_OBJHANDLE | asTYPEID_HANDLETOCONST, newDt);\n\t}\n\n\t// Call the method recursively to get the correct type id\n\treturn GetTypeIdFromDataType(dt);\n}\n\nconst asCDataType *asCScriptEngine::GetDataTypeFromTypeId(int typeId)\n{\n\tasSMapNode\u003cint,asCDataType*\u003e *cursor = 0;\n\tif( mapTypeIdToDataType.MoveTo(\u0026cursor, typeId) )\n\t\treturn mapTypeIdToDataType.GetValue(cursor);\n\n\treturn 0;\n}\n\nasCObjectType *asCScriptEngine::GetObjectTypeFromTypeId(int typeId)\n{\n\tasSMapNode\u003cint,asCDataType*\u003e *cursor = 0;\n\tif( mapTypeIdToDataType.MoveTo(\u0026cursor, typeId) )\n\t\treturn mapTypeIdToDataType.GetValue(cursor)-\u003eGetObjectType();\n\n\treturn 0;\n}\n\nvoid asCScriptEngine::RemoveFromTypeIdMap(asCObjectType *type)\n{\n\tasSMapNode\u003cint,asCDataType*\u003e *cursor = 0;\n\tmapTypeIdToDataType.MoveFirst(\u0026cursor);\n\twhile( cursor )\n\t{\n\t\tasCDataType *dt = mapTypeIdToDataType.GetValue(cursor);\n\t\tasSMapNode\u003cint,asCDataType*\u003e *old = cursor;\n\t\tmapTypeIdToDataType.MoveNext(\u0026cursor, cursor);\n\t\tif( dt-\u003eGetObjectType() == type )\n\t\t{\n\t\t\tasDELETE(dt,asCDataType);\n\t\t\tmapTypeIdToDataType.Erase(old);\n\t\t}\n\t}\n}\n\n// interface\nint asCScriptEngine::GetTypeIdByDecl(const char *decl)\n{\n\tasCDataType dt;\n\tasCBuilder bld(this, 0);\n\tint r = bld.ParseDataType(decl, \u0026dt);\n\tif( r \u003c 0 )\n\t\treturn asINVALID_TYPE;\n\n\treturn GetTypeIdFromDataType(dt);\n}\n\n\n\nconst char *asCScriptEngine::GetTypeDeclaration(int typeId)\n{\n\tconst asCDataType *dt = GetDataTypeFromTypeId(typeId);\n\tif( dt == 0 ) return 0;\n\n\tasASSERT(threadManager);\n\tasCString *tempString = \u0026threadManager-\u003eGetLocalData()-\u003estring;\n\t*tempString = dt-\u003eFormat();\n\n\treturn tempString-\u003eAddressOf();\n}\n\nint asCScriptEngine::GetSizeOfPrimitiveType(int typeId)\n{\n\tconst asCDataType *dt = GetDataTypeFromTypeId(typeId);\n\tif( dt == 0 ) return 0;\n\tif( !dt-\u003eIsPrimitive() ) return 0;\n\n\treturn dt-\u003eGetSizeInMemoryBytes();\n}\n\nvoid *asCScriptEngine::CreateScriptObject(int typeId)\n{\n\t// Make sure the type id is for an object type, and not a primitive or a handle\n\tif( (typeId \u0026 (asTYPEID_MASK_OBJECT | asTYPEID_MASK_SEQNBR)) != typeId ) return 0;\n\tif( (typeId \u0026 asTYPEID_MASK_OBJECT) == 0 ) return 0;\n\n\tconst asCDataType *dt = GetDataTypeFromTypeId(typeId);\n\n\t// Is the type id valid?\n\tif( !dt ) return 0;\n\n\t// Allocate the memory\n\tasCObjectType *objType = dt-\u003eGetObjectType();\n\tvoid *ptr = 0;\n\n\t// Construct the object\n\tif( objType-\u003eflags \u0026 asOBJ_SCRIPT_OBJECT )\n\t\tptr = ScriptObjectFactory(objType, this);\n\telse if( objType-\u003eflags \u0026 asOBJ_TEMPLATE )\n\t\t// The registered factory is moved to the construct behaviour when the type is instanciated\n\t\tptr = CallGlobalFunctionRetPtr(objType-\u003ebeh.construct, objType);\n\telse if( objType-\u003eflags \u0026 asOBJ_REF )\n\t\tptr = CallGlobalFunctionRetPtr(objType-\u003ebeh.factory);\n\telse\n\t{\n\t\tptr = CallAlloc(objType);\n\t\tint funcIndex = objType-\u003ebeh.construct;\n\t\tif( funcIndex )\n\t\t\tCallObjectMethod(ptr, funcIndex);\n\t}\n\n\treturn ptr;\n}\n\nvoid *asCScriptEngine::CreateScriptObjectCopy(void *origObj, int typeId)\n{\n\tvoid *newObj = CreateScriptObject(typeId);\n\tif( newObj == 0 ) return 0;\n\n\tCopyScriptObject(newObj, origObj, typeId);\n\n\treturn newObj;\n}\n\nvoid asCScriptEngine::CopyScriptObject(void *dstObj, void *srcObj, int typeId)\n{\n\t// Make sure the type id is for an object type, and not a primitive or a handle\n\tif( (typeId \u0026 (asTYPEID_MASK_OBJECT | asTYPEID_MASK_SEQNBR)) != typeId ) return;\n\tif( (typeId \u0026 asTYPEID_MASK_OBJECT) == 0 ) return;\n\n\t// Copy the contents from the original object, using the assignment operator\n\tconst asCDataType *dt = GetDataTypeFromTypeId(typeId);\n\n\t// Is the type id valid?\n\tif( !dt ) return;\n\n\tasCObjectType *objType = dt-\u003eGetObjectType();\n\t// TODO: beh.copy will be removed, so we need to find the default opAssign method instead\n\tif( objType-\u003ebeh.copy )\n\t{\n\t\tCallObjectMethod(dstObj, srcObj, objType-\u003ebeh.copy);\n\t}\n\telse if( objType-\u003esize )\n\t{\n\t\tmemcpy(dstObj, srcObj, objType-\u003esize);\n\t}\n}\n\nvoid asCScriptEngine::AddRefScriptObject(void *obj, int typeId)\n{\n\t// Make sure it is not a null pointer\n\tif( obj == 0 ) return;\n\n\t// Make sure the type id is for an object type or a handle\n\tif( (typeId \u0026 asTYPEID_MASK_OBJECT) == 0 ) return;\n\n\tconst asCDataType *dt = GetDataTypeFromTypeId(typeId);\n\n\t// Is the type id valid?\n\tif( !dt ) return;\n\n\tasCObjectType *objType = dt-\u003eGetObjectType();\n\n\tif( objType-\u003ebeh.addref )\n\t{\n\t\t// Call the addref behaviour\n\t\tCallObjectMethod(obj, objType-\u003ebeh.addref);\n\t}\n}\n\nvoid asCScriptEngine::ReleaseScriptObject(void *obj, int typeId)\n{\n\t// Make sure it is not a null pointer\n\tif( obj == 0 ) return;\n\n\t// Make sure the type id is for an object type or a handle\n\tif( (typeId \u0026 asTYPEID_MASK_OBJECT) == 0 ) return;\n\n\tconst asCDataType *dt = GetDataTypeFromTypeId(typeId);\n\n\t// Is the type id valid?\n\tif( !dt ) return;\n\n\tasCObjectType *objType = dt-\u003eGetObjectType();\n\n\tif( objType-\u003ebeh.release )\n\t{\n\t\t// Call the release behaviour\n\t\tCallObjectMethod(obj, objType-\u003ebeh.release);\n\t}\n\telse\n\t{\n\t\t// Call the destructor\n\t\tif( objType-\u003ebeh.destruct )\n\t\t\tCallObjectMethod(obj, objType-\u003ebeh.destruct);\n\n\t\t// Then free the memory\n\t\tCallFree(obj);\n\t}\n}\n\nbool asCScriptEngine::IsHandleCompatibleWithObject(void *obj, int objTypeId, int handleTypeId)\n{\n\t// if equal, then it is obvious they are compatible\n\tif( objTypeId == handleTypeId )\n\t\treturn true;\n\n\t// Get the actual data types from the type ids\n\tconst asCDataType *objDt = GetDataTypeFromTypeId(objTypeId);\n\tconst asCDataType *hdlDt = GetDataTypeFromTypeId(handleTypeId);\n\n\t// A handle to const cannot be passed to a handle that is not referencing a const object\n\tif( objDt-\u003eIsHandleToConst() \u0026\u0026 !hdlDt-\u003eIsHandleToConst() )\n\t\treturn false;\n\n\tif( objDt-\u003eGetObjectType() == hdlDt-\u003eGetObjectType() )\n\t{\n\t\t// The object type is equal\n\t\treturn true;\n\t}\n\telse if( objDt-\u003eIsScriptObject() \u0026\u0026 obj )\n\t{\n\t\t// There's still a chance the object implements the requested interface\n\t\tasCObjectType *objType = ((asCScriptObject*)obj)-\u003eobjType;\n\t\tif( objType-\u003eImplements(hdlDt-\u003eGetObjectType()) )\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n\nint asCScriptEngine::BeginConfigGroup(const char *groupName)\n{\n\t// Make sure the group name doesn't already exist\n\tfor( asUINT n = 0; n \u003c configGroups.GetLength(); n++ )\n\t{\n\t\tif( configGroups[n]-\u003egroupName == groupName )\n\t\t\treturn asNAME_TAKEN;\n\t}\n\n\tif( currentGroup != \u0026defaultGroup )\n\t\treturn asNOT_SUPPORTED;\n\n\tasCConfigGroup *group = asNEW(asCConfigGroup)();\n\tgroup-\u003egroupName = groupName;\n\n\tconfigGroups.PushLast(group);\n\tcurrentGroup = group;\n\n\treturn 0;\n}\n\nint asCScriptEngine::EndConfigGroup()\n{\n\t// Raise error if trying to end the default config\n\tif( currentGroup == \u0026defaultGroup )\n\t\treturn asNOT_SUPPORTED;\n\n\tcurrentGroup = \u0026defaultGroup;\n\n\treturn 0;\n}\n\nint asCScriptEngine::RemoveConfigGroup(const char *groupName)\n{\n\t// It is not allowed to remove a group that is still in use. \n\n\t// It would be possible to change the code in such a way that\n\t// the group could be removed even though it was still in use,\n\t// but that would cause severe negative impact on runtime \n\t// performance, since the VM would then have to be able handle\n\t// situations where the types, functions, and global variables\n\t// can be removed at any time.\n\n\tfor( asUINT n = 0; n \u003c configGroups.GetLength(); n++ )\n\t{\n\t\tif( configGroups[n]-\u003egroupName == groupName )\n\t\t{\n\t\t\tasCConfigGroup *group = configGroups[n];\n\n\t\t\t// Make sure the group isn't referenced by anyone\n\t\t\tif( group-\u003erefCount \u003e 0 )\n\t\t\t\treturn asCONFIG_GROUP_IS_IN_USE;\n\n\t\t\t// Verify if any objects registered in this group is still alive\n\t\t\tif( group-\u003eHasLiveObjects() )\n\t\t\t\treturn asCONFIG_GROUP_IS_IN_USE;\n\n\t\t\t// Remove the group from the list\n\t\t\tif( n == configGroups.GetLength() - 1 )\n\t\t\t\tconfigGroups.PopLast();\n\t\t\telse\n\t\t\t\tconfigGroups[n] = configGroups.PopLast();\n\n\t\t\t// Remove the configurations registered with this group\n\t\t\tgroup-\u003eRemoveConfiguration(this);\n\n\t\t\tasDELETE(group,asCConfigGroup);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nasCConfigGroup *asCScriptEngine::FindConfigGroupForFunction(int funcId)\n{\n\tfor( asUINT n = 0; n \u003c configGroups.GetLength(); n++ )\n\t{\n\t\t// Check global functions\n\t\tasUINT m;\n\t\tfor( m = 0; m \u003c configGroups[n]-\u003escriptFunctions.GetLength(); m++ )\n\t\t{\n\t\t\tif( configGroups[n]-\u003escriptFunctions[m]-\u003eid == funcId )\n\t\t\t\treturn configGroups[n];\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n\nasCConfigGroup *asCScriptEngine::FindConfigGroupForGlobalVar(int gvarId)\n{\n\tfor( asUINT n = 0; n \u003c configGroups.GetLength(); n++ )\n\t{\n\t\tfor( asUINT m = 0; m \u003c configGroups[n]-\u003eglobalProps.GetLength(); m++ )\n\t\t{\n\t\t\tif( configGroups[n]-\u003eglobalProps[m]-\u003eid == gvarId )\n\t\t\t\treturn configGroups[n];\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nasCConfigGroup *asCScriptEngine::FindConfigGroupForObjectType(const asCObjectType *objType)\n{\n\tfor( asUINT n = 0; n \u003c configGroups.GetLength(); n++ )\n\t{\n\t\tfor( asUINT m = 0; m \u003c configGroups[n]-\u003eobjTypes.GetLength(); m++ )\n\t\t{\n\t\t\tif( configGroups[n]-\u003eobjTypes[m] == objType )\n\t\t\t\treturn configGroups[n];\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint asCScriptEngine::SetConfigGroupModuleAccess(const char *groupName, const char *module, bool hasAccess)\n{\n\tasCConfigGroup *group = 0;\n\n\t// Make sure the group name doesn't already exist\n\tfor( asUINT n = 0; n \u003c configGroups.GetLength(); n++ )\n\t{\n\t\tif( configGroups[n]-\u003egroupName == groupName )\n\t\t{\n\t\t\tgroup = configGroups[n];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif( group == 0 )\n\t\treturn asWRONG_CONFIG_GROUP;\n\n\treturn group-\u003eSetModuleAccess(module, hasAccess);\n}\n\nint asCScriptEngine::GetNextScriptFunctionId()\n{\n\tif( freeScriptFunctionIds.GetLength() )\n\t\treturn freeScriptFunctionIds.PopLast();\n\n\tint id = (int)scriptFunctions.GetLength();\n\tscriptFunctions.PushLast(0);\n\treturn id;\n}\n\nvoid asCScriptEngine::SetScriptFunction(asCScriptFunction *func)\n{\n\tscriptFunctions[func-\u003eid] = func;\n}\n\nvoid asCScriptEngine::FreeScriptFunctionId(int id)\n{\n\tif( id \u003c 0 ) return;\n\tid \u0026= 0xFFFF;\n\tif( id \u003e= (int)scriptFunctions.GetLength() ) return;\n\n\tif( scriptFunctions[id] )\n\t{\n\t\tasCScriptFunction *func = scriptFunctions[id];\n\n\t\t// Remove the function from the list of script functions\n\t\tif( id == (int)scriptFunctions.GetLength() - 1 )\n\t\t{\n\t\t\tscriptFunctions.PopLast();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tscriptFunctions[id] = 0;\n\t\t\tfreeScriptFunctionIds.PushLast(id);\n\t\t}\n\n\t\t// Is the function used as signature id?\n\t\tif( func-\u003esignatureId == id )\n\t\t{\n\t\t\t// Remove the signature id\n\t\t\tsignatureIds.RemoveValue(func);\n\n\t\t\t// Update all functions using the signature id\n\t\t\tint newSigId = 0;\n\t\t\tfor( asUINT n = 0; n \u003c scriptFunctions.GetLength(); n++ )\n\t\t\t{\n\t\t\t\tif( scriptFunctions[n] \u0026\u0026 scriptFunctions[n]-\u003esignatureId == id )\n\t\t\t\t{\n\t\t\t\t\tif( newSigId == 0 )\n\t\t\t\t\t{\n\t\t\t\t\t\tnewSigId = scriptFunctions[n]-\u003eid;\n\t\t\t\t\t\tsignatureIds.PushLast(scriptFunctions[n]);\n\t\t\t\t\t}\n\n\t\t\t\t\tscriptFunctions[n]-\u003esignatureId = newSigId;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// interface\n// TODO: typedef: Accept complex types for the typedefs\nint asCScriptEngine::RegisterTypedef(const char *type, const char *decl)\n{\n\tif( type == 0 ) return ConfigError(asINVALID_NAME);\n\n\t// Verify if the name has been registered as a type already\n\tasUINT n;\n\tfor( n = 0; n \u003c objectTypes.GetLength(); n++ )\n\t{\n\t\tif( objectTypes[n] \u0026\u0026 objectTypes[n]-\u003ename == type )\n\t\t\treturn asALREADY_REGISTERED;\n\t}\n\n\t// Grab the data type\n\tasCTokenizer t;\n\tsize_t tokenLen;\n\teTokenType token;\n\tasCDataType dataType;\n\n\t//\tCreate the data type\n\ttoken = t.GetToken(decl, strlen(decl), \u0026tokenLen);\n\tswitch(token)\n\t{\n\tcase ttBool:\n\tcase ttInt:\n\tcase ttInt8:\n\tcase ttInt16:\n\tcase ttInt64:\n\tcase ttUInt:\n\tcase ttUInt8:\n\tcase ttUInt16:\n\tcase ttUInt64:\n\tcase ttFloat:\n\tcase ttDouble:\n\t\tif( strlen(decl) != tokenLen )\n\t\t{\n\t\t\treturn ConfigError(asINVALID_TYPE);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn ConfigError(asINVALID_TYPE);\n\t}\n\n\tdataType = asCDataType::CreatePrimitive(token, false);\n\n\t// Make sure the name is not a reserved keyword\n\ttoken = t.GetToken(type, strlen(type), \u0026tokenLen);\n\tif( token != ttIdentifier || strlen(type) != tokenLen )\n\t\treturn ConfigError(asINVALID_NAME);\n\n\tasCBuilder bld(this, 0);\n\tint r = bld.CheckNameConflict(type, 0, 0);\n\tif( r \u003c 0 )\n\t\treturn ConfigError(asNAME_TAKEN);\n\n\t// Don't have to check against members of object\n\t// types as they are allowed to use the names\n\n\t// Put the data type in the list\n\tasCObjectType *object= asNEW(asCObjectType)(this);\n\tobject-\u003eflags = asOBJ_TYPEDEF;\n\tobject-\u003esize = dataType.GetSizeInMemoryBytes();\n\tobject-\u003ename = type;\n\tobject-\u003etemplateSubType = dataType;\n\n\tobjectTypes.PushLast(object);\n\tregisteredTypeDefs.PushLast(object);\n\n\tcurrentGroup-\u003eobjTypes.PushLast(object);\n\n\treturn asSUCCESS;\n}\n\n// interface\nint asCScriptEngine::GetTypedefCount()\n{\n\treturn (int)registeredTypeDefs.GetLength();\n}\n\n// interface\nconst char *asCScriptEngine::GetTypedefByIndex(asUINT index, int *typeId, const char **configGroup)\n{\n\tif( index \u003e= registeredTypeDefs.GetLength() )\n\t\treturn 0;\n\n\tif( typeId )\n\t\t*typeId = GetTypeIdByDecl(registeredTypeDefs[index]-\u003ename.AddressOf());\n\n\tif( configGroup )\n\t{\n\t\tasCConfigGroup *group = FindConfigGroupForObjectType(registeredTypeDefs[index]);\n\t\tif( group )\n\t\t\t*configGroup = group-\u003egroupName.AddressOf();\n\t\telse\n\t\t\t*configGroup = 0;\n\t}\n\n\treturn registeredTypeDefs[index]-\u003ename.AddressOf();\n}\n\n// interface\nint asCScriptEngine::RegisterEnum(const char *name)\n{\n\t//\tCheck the name\n\tif( NULL == name )\n\t\treturn ConfigError(asINVALID_NAME);\n\n\t// Verify if the name has been registered as a type already\n\tasUINT n;\n\tfor( n = 0; n \u003c objectTypes.GetLength(); n++ )\n\t\tif( objectTypes[n] \u0026\u0026 objectTypes[n]-\u003ename == name )\n\t\t\treturn asALREADY_REGISTERED;\n\n\t// Use builder to parse the datatype\n\tasCDataType dt;\n\tasCBuilder bld(this, 0);\n\tbool oldMsgCallback = msgCallback; msgCallback = false;\n\tint r = bld.ParseDataType(name, \u0026dt);\n\tmsgCallback = oldMsgCallback;\n\tif( r \u003e= 0 )\n\t\treturn ConfigError(asERROR);\n\n\t// Make sure the name is not a reserved keyword\n\tasCTokenizer t;\n\tsize_t tokenLen;\n\tint token = t.GetToken(name, strlen(name), \u0026tokenLen);\n\tif( token != ttIdentifier || strlen(name) != tokenLen )\n\t\treturn ConfigError(asINVALID_NAME);\n\n\tr = bld.CheckNameConflict(name, 0, 0);\n\tif( r \u003c 0 )\n\t\treturn ConfigError(asNAME_TAKEN);\n\n\tasCObjectType *st = asNEW(asCObjectType)(this);\n\n\tasCDataType dataType;\n\tdataType.CreatePrimitive(ttInt, false);\n\n\tst-\u003eflags = asOBJ_ENUM;\n\tst-\u003esize = dataType.GetSizeInMemoryBytes();\n\tst-\u003ename = name;\n\n\tobjectTypes.PushLast(st);\n\tregisteredEnums.PushLast(st);\n\n\tcurrentGroup-\u003eobjTypes.PushLast(st);\n\n\treturn asSUCCESS;\n}\n\n// interface\nint asCScriptEngine::RegisterEnumValue(const char *typeName, const char *valueName, int value)\n{\n\t// Verify that the correct config group is used\n\tif( currentGroup-\u003eFindType(typeName) == 0 )\n\t\treturn asWRONG_CONFIG_GROUP;\n\n\tasCDataType dt;\n\tint r;\n\tasCBuilder bld(this, 0);\n\tr = bld.ParseDataType(typeName, \u0026dt);\n\tif( r \u003c 0 )\n\t\treturn ConfigError(r);\n\n\t// Store the enum value\n\tasCObjectType *ot = dt.GetObjectType();\n\tif( ot == 0 || !(ot-\u003eflags \u0026 asOBJ_ENUM) )\n\t\treturn ConfigError(asINVALID_TYPE);\n\n\tif( NULL == valueName )\n\t\treturn ConfigError(asINVALID_NAME);\n\n\tfor( unsigned int n = 0; n \u003c ot-\u003eenumValues.GetLength(); n++ )\n\t{\n\t\tif( ot-\u003eenumValues[n]-\u003ename == valueName )\n\t\t\treturn ConfigError(asALREADY_REGISTERED);\n\t}\n\n\tasSEnumValue *e = asNEW(asSEnumValue);\n\te-\u003ename = valueName;\n\te-\u003evalue = value;\n\n\tot-\u003eenumValues.PushLast(e);\n\n\treturn asSUCCESS;\n}\n\n// interface\nint asCScriptEngine::GetEnumCount()\n{\n\treturn (int)registeredEnums.GetLength();\n}\n\n// interface\nconst char *asCScriptEngine::GetEnumByIndex(asUINT index, int *enumTypeId, const char **configGroup)\n{\n\tif( index \u003e= registeredEnums.GetLength() )\n\t\treturn 0;\n\n\tif( configGroup )\n\t{\n\t\tasCConfigGroup *group = FindConfigGroupForObjectType(registeredEnums[index]);\n\t\tif( group )\n\t\t\t*configGroup = group-\u003egroupName.AddressOf();\n\t\telse\n\t\t\t*configGroup = 0;\n\t}\n\n\tif( enumTypeId )\n\t\t*enumTypeId = GetTypeIdByDecl(registeredEnums[index]-\u003ename.AddressOf());\n\n\treturn registeredEnums[index]-\u003ename.AddressOf();\n}\n\n// interface\nint asCScriptEngine::GetEnumValueCount(int enumTypeId)\n{\n\tconst asCDataType *dt = GetDataTypeFromTypeId(enumTypeId);\n\tasCObjectType *t = dt-\u003eGetObjectType();\n\tif( t == 0 || !(t-\u003eGetFlags() \u0026 asOBJ_ENUM) )\n\t\treturn asINVALID_TYPE;\n\n\treturn (int)t-\u003eenumValues.GetLength();\n}\n\n// interface\nconst char *asCScriptEngine::GetEnumValueByIndex(int enumTypeId, asUINT index, int *outValue)\n{\n\t// TODO: This same function is implemented in as_module.cpp as well. Perhaps it should be moved to asCObjectType?\n\tconst asCDataType *dt = GetDataTypeFromTypeId(enumTypeId);\n\tasCObjectType *t = dt-\u003eGetObjectType();\n\tif( t == 0 || !(t-\u003eGetFlags() \u0026 asOBJ_ENUM) )\n\t\treturn 0;\n\n\tif( index \u003e= t-\u003eenumValues.GetLength() )\n\t\treturn 0;\n\n\tif( outValue )\n\t\t*outValue = t-\u003eenumValues[index]-\u003evalue;\n\n\treturn t-\u003eenumValues[index]-\u003ename.AddressOf();\n}\n\n// interface\nint asCScriptEngine::GetObjectTypeCount()\n{\n\treturn (int)registeredObjTypes.GetLength();\n}\n\n// interface\nasIObjectType *asCScriptEngine::GetObjectTypeByIndex(asUINT index)\n{\n\tif( index \u003e= registeredObjTypes.GetLength() )\n\t\treturn 0;\n\n\treturn registeredObjTypes[index];\n}\n\n// interface\nasIObjectType *asCScriptEngine::GetObjectTypeById(int typeId)\n{\n\tconst asCDataType *dt = GetDataTypeFromTypeId(typeId);\n\n\t// Is the type id valid?\n\tif( !dt ) return 0;\n\n\t// Enum types are not objects, so we shouldn't return an object type for them\n\tif( dt-\u003eGetObjectType() \u0026\u0026 dt-\u003eGetObjectType()-\u003eGetFlags() \u0026 asOBJ_ENUM )\n\t\treturn 0;\n\n\treturn dt-\u003eGetObjectType();\n}\n\n\nasIScriptFunction *asCScriptEngine::GetFunctionDescriptorById(int funcId)\n{\n\treturn GetScriptFunction(funcId);\n}\n\n\n// internal\nbool asCScriptEngine::IsTemplateType(const char *name)\n{\n\t// TODO: optimize: Improve linear search\n\tfor( unsigned int n = 0; n \u003c objectTypes.GetLength(); n++ )\n\t{\n\t\tif( objectTypes[n] \u0026\u0026 objectTypes[n]-\u003ename == name )\n\t\t{\n\t\t\treturn objectTypes[n]-\u003eflags \u0026 asOBJ_TEMPLATE ? true : false;\n\t\t}\n\t}\n\n\treturn false;\n}\n\n// internal\nint asCScriptEngine::AddConstantString(const char *str, size_t len)\n{\n\t// The str may contain null chars, so we cannot use strlen, or strcmp, or strcpy\n\n\t// TODO: optimize: Improve linear search\n\t// Has the string been registered before?\n\tfor( size_t n = 0; n \u003c stringConstants.GetLength(); n++ )\n\t{\n\t\tif( stringConstants[n]-\u003eCompare(str, len) == 0 )\n\t\t{\n\t\t\treturn (int)n;\n\t\t}\n\t}\n\n\t// No match was found, add the string\n\tasCString *cstr = asNEW(asCString)(str, len);\n\tstringConstants.PushLast(cstr);\n\n\t// The VM currently doesn't handle string ids larger than 65535\n\tasASSERT(stringConstants.GetLength() \u003c= 65536);\n\n\treturn (int)stringConstants.GetLength() - 1;\n}\n\n// internal\nconst asCString \u0026asCScriptEngine::GetConstantString(int id)\n{\n\treturn *stringConstants[id];\n}\n\n// internal\nint asCScriptEngine::GetScriptSectionNameIndex(const char *name)\n{\n\t// TODO: These names are only released when the engine is freed. The assumption is that\n\t//       the same script section names will be reused instead of there always being new\n\t//       names. Is this assumption valid? Do we need to add reference counting?\n\n\t// Store the script section names for future reference\n\tfor( asUINT n = 0; n \u003c scriptSectionNames.GetLength(); n++ )\n\t{\n\t\tif( scriptSectionNames[n]-\u003eCompare(name) == 0 )\n\t\t\treturn n;\n\t}\n\n\tscriptSectionNames.PushLast(asNEW(asCString)(name));\n\treturn int(scriptSectionNames.GetLength()-1);\n}\n\n\nEND_AS_NAMESPACE\n\n"}
{"repo_name":"hacklab-turku/luumuhillo","ref":"refs/heads/master","path":"source/main.cpp","copies":"1","language":"C++","content":"#include \"game.hpp\"\n#include \"server.hpp\"\n\n#ifdef _WIN32\n#include \u003cWindows.h\u003e\n#endif\n\nint main(int argc, char** argv)\n{\n    if (game.start() != 0)\n        return -1;\n\n    int retcode = game.getServer()-\u003estart();\n\n    if (retcode == 0)\n    {\n        // Fix crash-on-exit bug on Windows by calling TerminateProcess manually\n        #ifdef _WIN32\n\t        TerminateProcess(GetCurrentProcess(), EXIT_SUCCESS);\n        #endif\n        return 0;\n    }\n    else\n        return retcode;\n}\n"}
{"repo_name":"Hankuo/color-emoji.skia","ref":"refs/heads/master","path":"src/gpu/gl/unix/GrGLCreateNativeInterface_unix.cpp","copies":"9","language":"C++","content":"\n/*\n * Copyright 2011 Google Inc.\n *\n * Use of this source code is governed by a BSD-style license that can be\n * found in the LICENSE file.\n */\n\n\n#include \"gl/GrGLExtensions.h\"\n#include \"gl/GrGLInterface.h\"\n#include \"../GrGLUtil.h\"\n\n#include \u003cGL/glx.h\u003e\n#include \u003cGL/gl.h\u003e\n#include \u003cGL/glext.h\u003e\n#include \u003cGL/glu.h\u003e\n\n#define GR_GL_GET_PROC(F) interface-\u003ef ## F = (GrGL ## F ## Proc) \\\n        glXGetProcAddress(reinterpret_cast\u003cconst GLubyte*\u003e(\"gl\" #F));\n#define GR_GL_GET_PROC_SUFFIX(F, S) interface-\u003ef ## F = (GrGL ## F ## Proc) \\\n        glXGetProcAddress(reinterpret_cast\u003cconst GLubyte*\u003e(\"gl\" #F #S));\n\nconst GrGLInterface* GrGLCreateNativeInterface() {\n    if (NULL != glXGetCurrentContext()) {\n\n        const char* versionString = (const char*) glGetString(GL_VERSION);\n        GrGLVersion glVer = GrGLGetVersionFromString(versionString);\n\n        // This may or may not succeed depending on the gl version.\n        GrGLGetStringiProc glGetStringi =\n            (GrGLGetStringiProc) glXGetProcAddress(reinterpret_cast\u003cconst GLubyte*\u003e(\"glGetStringi\"));\n\n        GrGLExtensions extensions;\n        if (!extensions.init(kDesktop_GrGLBinding, glGetString, glGetStringi, glGetIntegerv)) {\n            return NULL;\n        }\n\n        if (glVer \u003c GR_GL_VER(1,5)) {\n            // We must have array and element_array buffer objects.\n            return NULL;\n        }\n\n        GrGLInterface* interface = new GrGLInterface();\n\n        interface-\u003efActiveTexture = glActiveTexture;\n        GR_GL_GET_PROC(AttachShader);\n        GR_GL_GET_PROC(BindAttribLocation);\n        GR_GL_GET_PROC(BindBuffer);\n        GR_GL_GET_PROC(BindFragDataLocation);\n        GR_GL_GET_PROC(BeginQuery);\n        interface-\u003efBindTexture = glBindTexture;\n        interface-\u003efBlendFunc = glBlendFunc;\n\n        if (glVer \u003e= GR_GL_VER(1,4) ||\n            extensions.has(\"GL_ARB_imaging\") ||\n            extensions.has(\"GL_EXT_blend_color\")) {\n            GR_GL_GET_PROC(BlendColor);\n        }\n\n        GR_GL_GET_PROC(BufferData);\n        GR_GL_GET_PROC(BufferSubData);\n        interface-\u003efClear = glClear;\n        interface-\u003efClearColor = glClearColor;\n        interface-\u003efClearStencil = glClearStencil;\n        interface-\u003efColorMask = glColorMask;\n        GR_GL_GET_PROC(CompileShader);\n        interface-\u003efCompressedTexImage2D = glCompressedTexImage2D;\n        interface-\u003efCopyTexSubImage2D = glCopyTexSubImage2D;\n        GR_GL_GET_PROC(CreateProgram);\n        GR_GL_GET_PROC(CreateShader);\n        interface-\u003efCullFace = glCullFace;\n        GR_GL_GET_PROC(DeleteBuffers);\n        GR_GL_GET_PROC(DeleteProgram);\n        GR_GL_GET_PROC(DeleteQueries);\n        GR_GL_GET_PROC(DeleteShader);\n        interface-\u003efDeleteTextures = glDeleteTextures;\n        interface-\u003efDepthMask = glDepthMask;\n        interface-\u003efDisable = glDisable;\n        GR_GL_GET_PROC(DisableVertexAttribArray);\n        interface-\u003efDrawArrays = glDrawArrays;\n        interface-\u003efDrawBuffer = glDrawBuffer;\n        GR_GL_GET_PROC(DrawBuffers);\n        interface-\u003efDrawElements = glDrawElements;\n        interface-\u003efEnable = glEnable;\n        GR_GL_GET_PROC(EnableVertexAttribArray);\n        GR_GL_GET_PROC(EndQuery);\n        interface-\u003efFinish = glFinish;\n        interface-\u003efFlush = glFlush;\n        interface-\u003efFrontFace = glFrontFace;\n        GR_GL_GET_PROC(GenBuffers);\n        GR_GL_GET_PROC(GetBufferParameteriv);\n        interface-\u003efGetError = glGetError;\n        interface-\u003efGetIntegerv = glGetIntegerv;\n        GR_GL_GET_PROC(GetQueryObjectiv);\n        GR_GL_GET_PROC(GetQueryObjectuiv);\n        if (glVer \u003e= GR_GL_VER(3,3) || extensions.has(\"GL_ARB_timer_query\")) {\n            GR_GL_GET_PROC(GetQueryObjecti64v);\n            GR_GL_GET_PROC(GetQueryObjectui64v);\n            GR_GL_GET_PROC(QueryCounter);\n        } else if (extensions.has(\"GL_EXT_timer_query\")) {\n            GR_GL_GET_PROC_SUFFIX(GetQueryObjecti64v, EXT);\n            GR_GL_GET_PROC_SUFFIX(GetQueryObjectui64v, EXT);\n        }\n        GR_GL_GET_PROC(GetQueryiv);\n        GR_GL_GET_PROC(GetProgramInfoLog);\n        GR_GL_GET_PROC(GetProgramiv);\n        GR_GL_GET_PROC(GetShaderInfoLog);\n        GR_GL_GET_PROC(GetShaderiv);\n        interface-\u003efGetString = glGetString;\n        GR_GL_GET_PROC(GetStringi);\n        interface-\u003efGetTexLevelParameteriv = glGetTexLevelParameteriv;\n        GR_GL_GET_PROC(GenQueries);\n        interface-\u003efGenTextures = glGenTextures;\n        GR_GL_GET_PROC(GetUniformLocation);\n        interface-\u003efLineWidth = glLineWidth;\n        GR_GL_GET_PROC(LinkProgram);\n        GR_GL_GET_PROC(MapBuffer);\n        interface-\u003efPixelStorei = glPixelStorei;\n        interface-\u003efReadBuffer = glReadBuffer;\n        interface-\u003efReadPixels = glReadPixels;\n        if (extensions.has(\"GL_NV_framebuffer_multisample_coverage\")) {\n            GR_GL_GET_PROC_SUFFIX(RenderbufferStorageMultisampleCoverage, NV);\n        }\n        interface-\u003efScissor = glScissor;\n        GR_GL_GET_PROC(ShaderSource);\n        interface-\u003efStencilFunc = glStencilFunc;\n        GR_GL_GET_PROC(StencilFuncSeparate);\n        interface-\u003efStencilMask = glStencilMask;\n        GR_GL_GET_PROC(StencilMaskSeparate);\n        interface-\u003efStencilOp = glStencilOp;\n        GR_GL_GET_PROC(StencilOpSeparate);\n        interface-\u003efTexImage2D = glTexImage2D;\n        interface-\u003efTexParameteri = glTexParameteri;\n        interface-\u003efTexParameteriv = glTexParameteriv;\n        if (glVer \u003e= GR_GL_VER(4,2) || extensions.has(\"GL_ARB_texture_storage\")) {\n            GR_GL_GET_PROC(TexStorage2D);\n        } else if (extensions.has(\"GL_EXT_texture_storage\")) {\n            GR_GL_GET_PROC_SUFFIX(TexStorage2D, EXT);\n        }\n        interface-\u003efTexSubImage2D = glTexSubImage2D;\n        GR_GL_GET_PROC(Uniform1f);\n        GR_GL_GET_PROC(Uniform1i);\n        GR_GL_GET_PROC(Uniform1fv);\n        GR_GL_GET_PROC(Uniform1iv);\n        GR_GL_GET_PROC(Uniform2f);\n        GR_GL_GET_PROC(Uniform2i);\n        GR_GL_GET_PROC(Uniform2fv);\n        GR_GL_GET_PROC(Uniform2iv);\n        GR_GL_GET_PROC(Uniform3f);\n        GR_GL_GET_PROC(Uniform3i);\n        GR_GL_GET_PROC(Uniform3fv);\n        GR_GL_GET_PROC(Uniform3iv);\n        GR_GL_GET_PROC(Uniform4f);\n        GR_GL_GET_PROC(Uniform4i);\n        GR_GL_GET_PROC(Uniform4fv);\n        GR_GL_GET_PROC(Uniform4iv);\n        GR_GL_GET_PROC(UniformMatrix2fv);\n        GR_GL_GET_PROC(UniformMatrix3fv);\n        GR_GL_GET_PROC(UniformMatrix4fv);\n        GR_GL_GET_PROC(UnmapBuffer);\n        GR_GL_GET_PROC(UseProgram);\n        GR_GL_GET_PROC(VertexAttrib4fv);\n        GR_GL_GET_PROC(VertexAttribPointer);\n        interface-\u003efViewport = glViewport;\n        GR_GL_GET_PROC(BindFragDataLocationIndexed);\n\n        if (glVer \u003e= GR_GL_VER(3,0) || extensions.has(\"GL_ARB_vertex_array_object\")) {\n            // no ARB suffix for GL_ARB_vertex_array_object\n            GR_GL_GET_PROC(BindVertexArray);\n            GR_GL_GET_PROC(GenVertexArrays);\n            GR_GL_GET_PROC(DeleteVertexArrays);\n        }\n\n        // First look for GL3.0 FBO or GL_ARB_framebuffer_object (same since\n        // GL_ARB_framebuffer_object doesn't use ARB suffix.)\n        if (glVer \u003e= GR_GL_VER(3,0) || extensions.has(\"GL_ARB_framebuffer_object\")) {\n            GR_GL_GET_PROC(GenFramebuffers);\n            GR_GL_GET_PROC(GetFramebufferAttachmentParameteriv);\n            GR_GL_GET_PROC(GetRenderbufferParameteriv);\n            GR_GL_GET_PROC(BindFramebuffer);\n            GR_GL_GET_PROC(FramebufferTexture2D);\n            GR_GL_GET_PROC(CheckFramebufferStatus);\n            GR_GL_GET_PROC(DeleteFramebuffers);\n            GR_GL_GET_PROC(RenderbufferStorage);\n            GR_GL_GET_PROC(GenRenderbuffers);\n            GR_GL_GET_PROC(DeleteRenderbuffers);\n            GR_GL_GET_PROC(FramebufferRenderbuffer);\n            GR_GL_GET_PROC(BindRenderbuffer);\n            GR_GL_GET_PROC(RenderbufferStorageMultisample);\n            GR_GL_GET_PROC(BlitFramebuffer);\n        } else if (extensions.has(\"GL_EXT_framebuffer_object\")) {\n            GR_GL_GET_PROC_SUFFIX(GenFramebuffers, EXT);\n            GR_GL_GET_PROC_SUFFIX(GetFramebufferAttachmentParameteriv, EXT);\n            GR_GL_GET_PROC_SUFFIX(GetRenderbufferParameteriv, EXT);\n            GR_GL_GET_PROC_SUFFIX(BindFramebuffer, EXT);\n            GR_GL_GET_PROC_SUFFIX(FramebufferTexture2D, EXT);\n            GR_GL_GET_PROC_SUFFIX(CheckFramebufferStatus, EXT);\n            GR_GL_GET_PROC_SUFFIX(DeleteFramebuffers, EXT);\n            GR_GL_GET_PROC_SUFFIX(RenderbufferStorage, EXT);\n            GR_GL_GET_PROC_SUFFIX(GenRenderbuffers, EXT);\n            GR_GL_GET_PROC_SUFFIX(DeleteRenderbuffers, EXT);\n            GR_GL_GET_PROC_SUFFIX(FramebufferRenderbuffer, EXT);\n            GR_GL_GET_PROC_SUFFIX(BindRenderbuffer, EXT);\n            if (extensions.has(\"GL_EXT_framebuffer_multisample\")) {\n                GR_GL_GET_PROC_SUFFIX(RenderbufferStorageMultisample, EXT);\n            }\n            if (extensions.has(\"GL_EXT_framebuffer_blit\")) {\n                GR_GL_GET_PROC_SUFFIX(BlitFramebuffer, EXT);\n            }\n        } else {\n            // we must have FBOs\n            delete interface;\n            return NULL;\n        }\n        interface-\u003efBindingsExported = kDesktop_GrGLBinding;\n\n        return interface;\n    } else {\n        return NULL;\n    }\n}\n"}
{"repo_name":"Horizon-Blue/playground","ref":"refs/heads/master","path":"Solutions-to-OJs/USACO/Chapter1/1.1/02_your-ride-is-here.cpp","copies":"1","language":"C++","content":"/*\nID: skyline12\nPROG: ride\nLANG: C++11\n*/\n#include \u003ciostream\u003e\n#include \u003cfstream\u003e\n#include \u003cstring\u003e\n\nusing namespace std;\n\nint main() {\n\tofstream fout(\"ride.out\");\n\tifstream fin(\"ride.in\");\n\tstring a, b;\n\tfin \u003e\u003e a \u003e\u003e b;\n\tint anum = 1, bnum = 1;\n\tfor (char c : a)\n\t\tanum *= c - 'A' + 1;\n\tfor (char c : b)\n\t\tbnum *= c - 'A' + 1;\n\tif (anum % 47 == bnum % 47)\n\t\tfout \u003c\u003c \"GO\" \u003c\u003c endl;\n\telse\n\t\tfout \u003c\u003c \"STAY\" \u003c\u003c endl;\n\treturn 0;\n}"}
{"repo_name":"Residentik/TestingRepo","ref":"refs/heads/master","path":"src/server/scripts/EasternKingdoms/BlackrockMountain/BlackrockDepths/boss_high_interrogator_gerstahn.cpp","copies":"10","language":"C++","content":"/*\n * Copyright (C) 2008-2014 TrinityCore \u003chttp://www.trinitycore.org/\u003e\n * Copyright (C) 2006-2009 ScriptDev2 \u003chttps://scriptdev2.svn.sourceforge.net/\u003e\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the\n * Free Software Foundation; either version 2 of the License, or (at your\n * option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n * more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program. If not, see \u003chttp://www.gnu.org/licenses/\u003e.\n */\n\n#include \"ScriptMgr.h\"\n#include \"ScriptedCreature.h\"\n\nenum Spells\n{\n    SPELL_SHADOWWORDPAIN                                   = 10894,\n    SPELL_MANABURN                                         = 10876,\n    SPELL_PSYCHICSCREAM                                    = 8122,\n    SPELL_SHADOWSHIELD                                     = 22417\n};\n\nclass boss_high_interrogator_gerstahn : public CreatureScript\n{\npublic:\n    boss_high_interrogator_gerstahn() : CreatureScript(\"boss_high_interrogator_gerstahn\") { }\n\n    CreatureAI* GetAI(Creature* creature) const OVERRIDE\n    {\n        return new boss_high_interrogator_gerstahnAI(creature);\n    }\n\n    struct boss_high_interrogator_gerstahnAI : public ScriptedAI\n    {\n        boss_high_interrogator_gerstahnAI(Creature* creature) : ScriptedAI(creature) { }\n\n        uint32 ShadowWordPain_Timer;\n        uint32 ManaBurn_Timer;\n        uint32 PsychicScream_Timer;\n        uint32 ShadowShield_Timer;\n\n        void Reset() OVERRIDE\n        {\n            ShadowWordPain_Timer = 4000;\n            ManaBurn_Timer = 14000;\n            PsychicScream_Timer = 32000;\n            ShadowShield_Timer = 8000;\n        }\n\n        void EnterCombat(Unit* /*who*/) OVERRIDE { }\n\n        void UpdateAI(uint32 diff) OVERRIDE\n        {\n            //Return since we have no target\n            if (!UpdateVictim())\n                return;\n\n            //ShadowWordPain_Timer\n            if (ShadowWordPain_Timer \u003c= diff)\n            {\n                if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 0, 100, true))\n                    DoCast(target, SPELL_SHADOWWORDPAIN);\n                ShadowWordPain_Timer = 7000;\n            } else ShadowWordPain_Timer -= diff;\n\n            //ManaBurn_Timer\n            if (ManaBurn_Timer \u003c= diff)\n            {\n                if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 0, 100, true))\n                    DoCast(target, SPELL_MANABURN);\n                ManaBurn_Timer = 10000;\n            } else ManaBurn_Timer -= diff;\n\n            //PsychicScream_Timer\n            if (PsychicScream_Timer \u003c= diff)\n            {\n                DoCastVictim(SPELL_PSYCHICSCREAM);\n                PsychicScream_Timer = 30000;\n            } else PsychicScream_Timer -= diff;\n\n            //ShadowShield_Timer\n            if (ShadowShield_Timer \u003c= diff)\n            {\n                DoCast(me, SPELL_SHADOWSHIELD);\n                ShadowShield_Timer = 25000;\n            } else ShadowShield_Timer -= diff;\n\n            DoMeleeAttackIfReady();\n        }\n    };\n};\n\nvoid AddSC_boss_high_interrogator_gerstahn()\n{\n    new boss_high_interrogator_gerstahn();\n}\n"}
{"repo_name":"sneiiler/ardupilot","ref":"refs/heads/master","path":"libraries/AP_HAL/utility/getopt_cpp.cpp","copies":"128","language":"C++","content":"/*\n * getopt_long() -- long options parser\n *\n * Portions Copyright (c) 1987, 1993, 1994\n * The Regents of the University of California.  All rights reserved.\n *\n * Portions Copyright (c) 2003\n * PostgreSQL Global Development Group\n *\n * Simple conversion to C++ by Andrew Tridgell for ArduPilot. Based on\n * getopt_long.cpp from ccache\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the University nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n#include \"getopt_cpp.h\"\n#include \u003cstdio.h\u003e\n#include \u003cstring.h\u003e\n\n/*\n  constructor\n */\nGetOptLong::GetOptLong(int _argc, char *const _argv[], const char *_optstring, const GetOptLong::option * _longopts) :\n    opterr(0),\n    optind(1),\n    optopt(0),\n    longindex(-1),\n    optarg(NULL),\n    argc(_argc),\n    argv(_argv),\n    optstring(_optstring),\n    longopts(_longopts),\n    place(\"\")\n{}\n\n/*\n  main parse code\n */\nint GetOptLong::getoption(void)\n{\n    const char        *oli;          /* option letter list index */\n\n    if (!*place)\n    { /* update scanning pointer */\n        if (optind \u003e= argc)\n        {\n            place = \"\";\n            return -1;\n        }\n\n        place = argv[optind];\n\n        if (place[0] != '-')\n        {\n            place = \"\";\n            return -1;\n        }\n        \n        place++;\n        \n        if (place[0] \u0026\u0026 place[0] == '-' \u0026\u0026 place[1] == '\\0')\n        { /* found \"--\" */\n            ++optind;\n            place = \"\";\n            return -1;\n        }\n\n        if (place[0] \u0026\u0026 place[0] == '-' \u0026\u0026 place[1])\n        {\n            /* long option */\n            size_t namelen;\n            int    i;\n            \n            place++;\n            \n            namelen = strcspn(place, \"=\");\n            for (i = 0; longopts[i].name != NULL; i++)\n            {\n                if (strlen(longopts[i].name) == namelen\n                    \u0026\u0026 strncmp(place, longopts[i].name, namelen) == 0)\n                {\n                    if (longopts[i].has_arg)\n                    {\n                        if (place[namelen] == '=')\n                            optarg = place + namelen + 1;\n                        else if (optind \u003c argc - 1)\n                        {\n                            optind++;\n                            optarg = argv[optind];\n                        }\n                        else\n                        {\n                            if (optstring[0] == ':')\n                                return BADARG;\n                            if (opterr)\n                                fprintf(stderr,\n                                        \"%s: option requires an argument -- %s\\n\",\n                                        argv[0], place);\n                            place = \"\";\n                            optind++;\n                            return BADCH;\n                        }\n                    }\n                    else\n                    {\n                        optarg = NULL;\n                        if (place[namelen] != 0)\n                        {\n                            /* XXX error? */\n                        }\n                    }\n                    \n                    optind++;\n                    \n                    longindex = i;\n                    \n                    place = \"\";\n                    \n                    if (longopts[i].flag == NULL)\n                        return longopts[i].val;\n                    else\n                    {\n                        *longopts[i].flag = longopts[i].val;\n                        return 0;\n                    }\n                }\n            }\n            \n            if (opterr \u0026\u0026 optstring[0] != ':')\n                fprintf(stderr,\n                        \"%s: illegal option -- %s\\n\", argv[0], place);\n            place = \"\";\n            optind++;\n            return BADCH;\n        }\n    }\n\n    /* short option */\n    optopt = (int) *place++;\n\n    oli = strchr(optstring, optopt);\n    if (!oli)\n    {\n        if (!*place)\n            ++optind;\n        if (opterr \u0026\u0026 *optstring != ':')\n            fprintf(stderr,\n                    \"%s: illegal option -- %c\\n\", argv[0], optopt);\n        return BADCH;\n    }\n    \n    if (oli[1] != ':')\n    { /* don't need argument */\n        optarg = NULL;\n        if (!*place)\n            ++optind;\n    }\n    else\n    { /* need an argument */\n        if (*place) /* no white space */\n            optarg = place;\n        else if (argc \u003c= ++optind)\n        { /* no arg */\n            place = \"\";\n            if (*optstring == ':')\n                return BADARG;\n            if (opterr)\n                fprintf(stderr,\n                        \"%s: option requires an argument -- %c\\n\",\n                        argv[0], optopt);\n            return BADCH;\n        }\n        else\n            /* white space */\n            optarg = argv[optind];\n        place = \"\";\n        ++optind;\n    }\n    return optopt;\n}\n\n"}
{"repo_name":"ricardogsilva/QGIS","ref":"refs/heads/master","path":"src/core/qgsproxyprogresstask.cpp","copies":"9","language":"C++","content":"/***************************************************************************\n                             qgsproxyprogresstask.cpp\n                             ------------------------\n    begin                : August 2018\n    copyright            : (C) 2018 by Nyall Dawson\n    email                : nyall dot dawson at gmail dot com\n ***************************************************************************/\n\n/***************************************************************************\n *                                                                         *\n *   This program is free software; you can redistribute it and/or modify  *\n *   it under the terms of the GNU General Public License as published by  *\n *   the Free Software Foundation; either version 2 of the License, or     *\n *   (at your option) any later version.                                   *\n *                                                                         *\n ***************************************************************************/\n\n#include \"qgsproxyprogresstask.h\"\n\nQgsProxyProgressTask::QgsProxyProgressTask( const QString \u0026description )\n  : QgsTask( description, QgsTask::Flags() )\n{\n}\n\nvoid QgsProxyProgressTask::finalize( bool result )\n{\n  mResult = result;\n  mNotFinishedWaitCondition.wakeAll();\n}\n\nbool QgsProxyProgressTask::run()\n{\n  mNotFinishedMutex.lock();\n  mNotFinishedWaitCondition.wait( \u0026mNotFinishedMutex );\n  mNotFinishedMutex.unlock();\n\n  return mResult;\n}\n\nvoid QgsProxyProgressTask::setProxyProgress( double progress )\n{\n  QMetaObject::invokeMethod( this, \"setProgress\", Qt::AutoConnection, Q_ARG( double, progress ) );\n}\n\n//\n// QgsScopedProxyProgressTask\n//\n\nQgsScopedProxyProgressTask::QgsScopedProxyProgressTask( const QString \u0026description )\n  : mTask( new QgsProxyProgressTask( description ) )\n{\n  QgsApplication::taskManager()-\u003eaddTask( mTask );\n}\n\nQgsScopedProxyProgressTask::~QgsScopedProxyProgressTask()\n{\n  mTask-\u003efinalize( true );\n}\n\nvoid QgsScopedProxyProgressTask::setProgress( double progress )\n{\n  mTask-\u003esetProxyProgress( progress );\n}\n"}
{"repo_name":"dklann/rivendell","ref":"refs/heads/master","path":"lib/rdlist_logs.cpp","copies":"2","language":"C++","content":"// rdlist_logs.cpp\n//\n// Select a Rivendell Log\n//\n//   (C) Copyright 2002-2019 Fred Gleason \u003cfredg@paravelsystems.com\u003e\n//\n//   This program is free software; you can redistribute it and/or modify\n//   it under the terms of the GNU General Public License version 2 as\n//   published by the Free Software Foundation.\n//\n//   This program is distributed in the hope that it will be useful,\n//   but WITHOUT ANY WARRANTY; without even the implied warranty of\n//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//   GNU General Public License for more details.\n//\n//   You should have received a copy of the GNU General Public\n//   License along with this program; if not, write to the Free Software\n//   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n//\n\n#include \"rdapplication.h\"\n#include \"rddb.h\"\n#include \"rdescape_string.h\"\n#include \"rdlist_logs.h\"\n\nRDListLogs::RDListLogs(QString *logname,RDLogFilter::FilterMode mode,\n\t\t       QWidget *parent)\n  : RDDialog(parent)\n{\n  list_logname=logname;\n\n  //\n  // Fix the Window Size\n  //\n  setMinimumSize(sizeHint());\n\n  setWindowTitle(tr(\"Select Log\"));\n\n  //\n  // Log Filter\n  //\n  list_filter_widget=new RDLogFilter(mode,this);\n  connect(list_filter_widget,SIGNAL(filterChanged(const QString \u0026)),\n\t  this,SLOT(filterChangedData(const QString \u0026)));\n\n  //\n  // Log List\n  //\n  list_log_list=new Q3ListView(this);\n  list_log_list-\u003esetAllColumnsShowFocus(true);\n  list_log_list-\u003esetItemMargin(5);\n  list_log_list-\u003esetSelectionMode(Q3ListView::Single);\n  connect(list_log_list,\n\t  SIGNAL(doubleClicked(Q3ListViewItem *,const QPoint \u0026,int)),\n\t  this,\n\t  SLOT(doubleClickedData(Q3ListViewItem *,const QPoint \u0026,int)));\n  list_log_list-\u003eaddColumn(tr(\"Name\"));\n  list_log_list-\u003esetColumnAlignment(0,Qt::AlignLeft);\n  list_log_list-\u003eaddColumn(tr(\"Description\"));\n  list_log_list-\u003esetColumnAlignment(1,Qt::AlignLeft);\n  list_log_list-\u003eaddColumn(tr(\"Service\"));\n  list_log_list-\u003esetColumnAlignment(2,Qt::AlignLeft);\n\n  //\n  // OK Button\n  //\n  list_ok_button=new QPushButton(this);\n  list_ok_button-\u003esetFont(buttonFont());\n  list_ok_button-\u003esetText(tr(\"OK\"));\n  connect(list_ok_button,SIGNAL(clicked()),this,SLOT(okButtonData()));\n\n  //\n  // Cancel Button\n  //\n  list_cancel_button=new QPushButton(this);\n  list_cancel_button-\u003esetFont(buttonFont());\n  list_cancel_button-\u003esetText(tr(\"Cancel\"));\n  list_cancel_button-\u003esetDefault(true);\n  connect(list_cancel_button,SIGNAL(clicked()),this,SLOT(cancelButtonData()));\n\n  RefreshList();\n}\n\n\nQSize RDListLogs::sizeHint() const\n{\n  return QSize(500,300);\n}\n\n\nQSizePolicy RDListLogs::sizePolicy() const\n{\n  return QSizePolicy(QSizePolicy::Fixed,QSizePolicy::Fixed);\n}\n\n\nvoid RDListLogs::closeEvent(QCloseEvent *e)\n{\n  done(1);\n}\n\n\nvoid RDListLogs::filterChangedData(const QString \u0026where_sql)\n{\n  RefreshList();\n}\n\n\nvoid RDListLogs::doubleClickedData(Q3ListViewItem *,const QPoint \u0026,int)\n{\n  okButtonData();\n}\n\n\nvoid RDListLogs::okButtonData()\n{\n  Q3ListViewItem *item=list_log_list-\u003eselectedItem();\n  if(item==NULL) {\n    return;\n  }\n  *list_logname=item-\u003etext(0);\n  done(0);\n}\n\n\nvoid RDListLogs::cancelButtonData()\n{\n  done(1);\n}\n\n\nvoid RDListLogs::resizeEvent(QResizeEvent *e)\n{\n  list_filter_widget-\u003e\n    setGeometry(10,10,size().width()-10,\n\t\tlist_filter_widget-\u003esizeHint().height());\n  list_log_list-\u003e\n    setGeometry(10,list_filter_widget-\u003esizeHint().height(),\n\t\tsize().width()-20,\n\t\tsize().height()-list_filter_widget-\u003esizeHint().height()-70);\n  list_ok_button-\u003e\n    setGeometry(size().width()-190,size().height()-60,80,50);\n  list_cancel_button-\u003e\n    setGeometry(size().width()-90,size().height()-60,80,50);\n}\n\n\nvoid RDListLogs::RefreshList()\n{\n  RDSqlQuery *q;\n  QString sql;\n  Q3ListViewItem *l;\n  Q3ListViewItem *view_item=NULL;\n  QDate current_date=QDate::currentDate();\n\n  list_log_list-\u003eclear();\n  sql=QString(\"select NAME,DESCRIPTION,SERVICE from LOGS \")+\n    \"where (TYPE=0)\u0026\u0026(LOG_EXISTS=\\\"Y\\\")\u0026\u0026\"+\n    \"((START_DATE\u003c=\\\"\"+current_date.toString(\"yyyy-MM-dd\")+\"\\\")||\"+\n    \"(START_DATE=\\\"0000-00-00\\\")||\"+\n    \"(START_DATE is null))\u0026\u0026\"+\n    \"((END_DATE\u003e=\\\"\"+current_date.toString(\"yyyy-MM-dd\")+\"\\\")||\"+\n    \"(END_DATE=\\\"0000-00-00\\\")||\"+\n    \"(END_DATE is null))\"+\n    list_filter_widget-\u003ewhereSql();\n\n  q=new RDSqlQuery(sql);\n  while(q-\u003enext()) {\n    l=new Q3ListViewItem(list_log_list);\n    l-\u003esetText(0,q-\u003evalue(0).toString());\n    l-\u003esetText(1,q-\u003evalue(1).toString());\n    l-\u003esetText(2,q-\u003evalue(2).toString());\n    if(l-\u003etext(0)==*list_logname) {\n      view_item=l;\n    }\n  }\n  delete q;\n  if(view_item!=NULL) {\n    list_log_list-\u003esetCurrentItem(view_item);\n    list_log_list-\u003eensureItemVisible(view_item);\n  }\n}\n"}
{"repo_name":"sacarlson/MultiCoin-exp","ref":"refs/heads/multimergemine2","path":"src/db.cpp","copies":"5","language":"C++","content":"// Copyright (c) 2009-2010 Satoshi Nakamoto\n// Distributed under the MIT/X11 software license, see the accompanying\n// file license.txt or http://www.opensource.org/licenses/mit-license.php.\n\n#include \"headers.h\"\n#include \"db.h\"\n#include \"net.h\"\n#include \"auxpow.h\"\n#include \u003cboost/filesystem.hpp\u003e\n#include \u003cboost/filesystem/fstream.hpp\u003e\n\nusing namespace std;\nusing namespace boost;\n\n\nunsigned int nWalletDBUpdated;\nuint64 nAccountingEntryNumber = 0;\n\n\n\n//\n// CDB\n//\n\nstatic CCriticalSection cs_db;\nstatic bool fDbEnvInit = false;\nDbEnv dbenv(0);\nstatic map\u003cstring, int\u003e mapFileUseCount;\nstatic map\u003cstring, Db*\u003e mapDb;\n\nclass CDBInit\n{\npublic:\n    CDBInit()\n    {\n    }\n    ~CDBInit()\n    {\n        if (fDbEnvInit)\n        {\n            dbenv.close(0);\n            fDbEnvInit = false;\n        }\n    }\n}\ninstance_of_cdbinit;\n\n\nCDB::CDB(const char* pszFile, const char* pszMode) : pdb(NULL)\n{\n    int ret;\n    if (pszFile == NULL)\n        return;\n\n    fReadOnly = (!strchr(pszMode, '+') \u0026\u0026 !strchr(pszMode, 'w'));\n    bool fCreate = strchr(pszMode, 'c');\n    unsigned int nFlags = DB_THREAD;\n    if (fCreate)\n        nFlags |= DB_CREATE;\n\n    CRITICAL_BLOCK(cs_db)\n    {\n        if (!fDbEnvInit)\n        {\n            if (fShutdown)\n                return;\n            string strDataDir = GetDataDir();\n            string strLogDir = strDataDir + \"/database\";\n            filesystem::create_directory(strLogDir.c_str());\n            string strErrorFile = strDataDir + \"/db.log\";\n            printf(\"dbenv.open strLogDir=%s strErrorFile=%s\\n\", strLogDir.c_str(), strErrorFile.c_str());\n\n            dbenv.set_lg_dir(strLogDir.c_str());\n            dbenv.set_lg_max(10000000);\n            dbenv.set_lk_max_locks(10000);\n            dbenv.set_lk_max_objects(10000);\n            dbenv.set_errfile(fopen(strErrorFile.c_str(), \"a\")); /// debug\n            dbenv.set_flags(DB_AUTO_COMMIT, 1);\n            ret = dbenv.open(strDataDir.c_str(),\n                             DB_CREATE     |\n                             DB_INIT_LOCK  |\n                             DB_INIT_LOG   |\n                             DB_INIT_MPOOL |\n                             DB_INIT_TXN   |\n                             DB_THREAD     |\n                             DB_RECOVER,\n                             S_IRUSR | S_IWUSR);\n            if (ret \u003e 0)\n                throw runtime_error(strprintf(\"CDB() : error %d opening database environment\", ret));\n            fDbEnvInit = true;\n        }\n\n        strFile = pszFile;\n        ++mapFileUseCount[strFile];\n        pdb = mapDb[strFile];\n        if (pdb == NULL)\n        {\n            pdb = new Db(\u0026dbenv, 0);\n\n            ret = pdb-\u003eopen(NULL,      // Txn pointer\n                            pszFile,   // Filename\n                            \"main\",    // Logical db name\n                            DB_BTREE,  // Database type\n                            nFlags,    // Flags\n                            0);\n\n            if (ret \u003e 0)\n            {\n                delete pdb;\n                pdb = NULL;\n                CRITICAL_BLOCK(cs_db)\n                    --mapFileUseCount[strFile];\n                strFile = \"\";\n                throw runtime_error(strprintf(\"CDB() : can't open database file %s, error %d\", pszFile, ret));\n            }\n\n            if (fCreate \u0026\u0026 !Exists(string(\"version\")))\n            {\n                bool fTmp = fReadOnly;\n                fReadOnly = false;\n                WriteVersion(VERSION);\n                fReadOnly = fTmp;\n            }\n\n            mapDb[strFile] = pdb;\n        }\n    }\n}\n\nvoid CDB::Close()\n{\n    if (!pdb)\n        return;\n    if (!vTxn.empty())\n        vTxn.front()-\u003eabort();\n    vTxn.clear();\n    pdb = NULL;\n\n    // Flush database activity from memory pool to disk log\n    unsigned int nMinutes = 0;\n    if (fReadOnly)\n        nMinutes = 1;\n    if (strFile == \"addr.dat\")\n        nMinutes = 2;\n    if (strFile == \"blkindex.dat\" \u0026\u0026 IsInitialBlockDownload() \u0026\u0026 nBestHeight % 500 != 0)\n        nMinutes = 1;\n    dbenv.txn_checkpoint(0, nMinutes, 0);\n\n    CRITICAL_BLOCK(cs_db)\n        --mapFileUseCount[strFile];\n}\n\nvoid static CloseDb(const string\u0026 strFile)\n{\n    CRITICAL_BLOCK(cs_db)\n    {\n        if (mapDb[strFile] != NULL)\n        {\n            // Close the database handle\n            Db* pdb = mapDb[strFile];\n            pdb-\u003eclose(0);\n            delete pdb;\n            mapDb[strFile] = NULL;\n        }\n    }\n}\n\nvoid DBFlush(bool fShutdown)\n{\n    // Flush log data to the actual data file\n    //  on all files that are not in use\n    printf(\"DBFlush(%s)%s\\n\", fShutdown ? \"true\" : \"false\", fDbEnvInit ? \"\" : \" db not started\");\n    if (!fDbEnvInit)\n        return;\n    CRITICAL_BLOCK(cs_db)\n    {\n        map\u003cstring, int\u003e::iterator mi = mapFileUseCount.begin();\n        while (mi != mapFileUseCount.end())\n        {\n            string strFile = (*mi).first;\n            int nRefCount = (*mi).second;\n            printf(\"%s refcount=%d\\n\", strFile.c_str(), nRefCount);\n            if (nRefCount == 0)\n            {\n                // Move log data to the dat file\n                CloseDb(strFile);\n                dbenv.txn_checkpoint(0, 0, 0);\n                printf(\"%s flush\\n\", strFile.c_str());\n                dbenv.lsn_reset(strFile.c_str(), 0);\n                mapFileUseCount.erase(mi++);\n            }\n            else\n                mi++;\n        }\n        if (fShutdown)\n        {\n            char** listp;\n            if (mapFileUseCount.empty())\n                dbenv.log_archive(\u0026listp, DB_ARCH_REMOVE);\n            dbenv.close(0);\n            fDbEnvInit = false;\n        }\n    }\n}\n\n\n\n\n\n\n//\n// CTxDB\n//\n\nbool CTxDB::ReadTxIndex(uint256 hash, CTxIndex\u0026 txindex)\n{\n    assert(!fClient);\n    txindex.SetNull();\n    return Read(make_pair(string(\"tx\"), hash), txindex);\n}\n\nbool CTxDB::UpdateTxIndex(uint256 hash, const CTxIndex\u0026 txindex)\n{\n    assert(!fClient);\n    return Write(make_pair(string(\"tx\"), hash), txindex);\n}\n\nbool CTxDB::AddTxIndex(const CTransaction\u0026 tx, const CDiskTxPos\u0026 pos, int nHeight)\n{\n    assert(!fClient);\n\n    // Add to tx index\n    uint256 hash = tx.GetHash();\n    CTxIndex txindex(pos, tx.vout.size());\n    return Write(make_pair(string(\"tx\"), hash), txindex);\n}\n\nbool CTxDB::EraseTxIndex(const CTransaction\u0026 tx)\n{\n    assert(!fClient);\n    uint256 hash = tx.GetHash();\n\n    return Erase(make_pair(string(\"tx\"), hash));\n}\n\nbool CTxDB::ContainsTx(uint256 hash)\n{\n    assert(!fClient);\n    return Exists(make_pair(string(\"tx\"), hash));\n}\n\nbool CTxDB::ReadOwnerTxes(uint160 hash160, int nMinHeight, vector\u003cCTransaction\u003e\u0026 vtx)\n{\n    assert(!fClient);\n    vtx.clear();\n\n    // Get cursor\n    Dbc* pcursor = GetCursor();\n    if (!pcursor)\n        return false;\n\n    unsigned int fFlags = DB_SET_RANGE;\n    loop\n    {\n        // Read next record\n        CDataStream ssKey;\n        if (fFlags == DB_SET_RANGE)\n            ssKey \u003c\u003c string(\"owner\") \u003c\u003c hash160 \u003c\u003c CDiskTxPos(0, 0, 0);\n        CDataStream ssValue;\n        int ret = ReadAtCursor(pcursor, ssKey, ssValue, fFlags);\n        fFlags = DB_NEXT;\n        if (ret == DB_NOTFOUND)\n            break;\n        else if (ret != 0)\n        {\n            pcursor-\u003eclose();\n            return false;\n        }\n\n        // Unserialize\n        string strType;\n        uint160 hashItem;\n        CDiskTxPos pos;\n        ssKey \u003e\u003e strType \u003e\u003e hashItem \u003e\u003e pos;\n        int nItemHeight;\n        ssValue \u003e\u003e nItemHeight;\n\n        // Read transaction\n        if (strType != \"owner\" || hashItem != hash160)\n            break;\n        if (nItemHeight \u003e= nMinHeight)\n        {\n            vtx.resize(vtx.size()+1);\n            if (!vtx.back().ReadFromDisk(pos))\n            {\n                pcursor-\u003eclose();\n                return false;\n            }\n        }\n    }\n\n    pcursor-\u003eclose();\n    return true;\n}\n\nbool CTxDB::ReadDiskTx(uint256 hash, CTransaction\u0026 tx, CTxIndex\u0026 txindex)\n{\n    assert(!fClient);\n    tx.SetNull();\n    if (!ReadTxIndex(hash, txindex))\n        return false;\n    return (tx.ReadFromDisk(txindex.pos));\n}\n\nbool CTxDB::ReadDiskTx(uint256 hash, CTransaction\u0026 tx)\n{\n    CTxIndex txindex;\n    return ReadDiskTx(hash, tx, txindex);\n}\n\nbool CTxDB::ReadDiskTx(COutPoint outpoint, CTransaction\u0026 tx, CTxIndex\u0026 txindex)\n{\n    return ReadDiskTx(outpoint.hash, tx, txindex);\n}\n\nbool CTxDB::ReadDiskTx(COutPoint outpoint, CTransaction\u0026 tx)\n{\n    CTxIndex txindex;\n    return ReadDiskTx(outpoint.hash, tx, txindex);\n}\n\nbool CTxDB::WriteBlockIndex(const CDiskBlockIndex\u0026 blockindex)\n{\n    return Write(make_pair(string(\"blockindex\"), blockindex.GetBlockHash()), blockindex);\n}\n\nbool CTxDB::EraseBlockIndex(uint256 hash)\n{\n    return Erase(make_pair(string(\"blockindex\"), hash));\n}\n\nbool CTxDB::ReadHashBestChain(uint256\u0026 hashBestChain)\n{\n    return Read(string(\"hashBestChain\"), hashBestChain);\n}\n\nbool CTxDB::WriteHashBestChain(uint256 hashBestChain)\n{\n    return Write(string(\"hashBestChain\"), hashBestChain);\n}\n\nbool CTxDB::ReadBestInvalidWork(CBigNum\u0026 bnBestInvalidWork)\n{\n    return Read(string(\"bnBestInvalidWork\"), bnBestInvalidWork);\n}\n\nbool CTxDB::WriteBestInvalidWork(CBigNum bnBestInvalidWork)\n{\n    return Write(string(\"bnBestInvalidWork\"), bnBestInvalidWork);\n}\n\nCBlockIndex static * InsertBlockIndex(uint256 hash)\n{\n    if (hash == 0)\n        return NULL;\n\n    // Return existing\n    map\u003cuint256, CBlockIndex*\u003e::iterator mi = mapBlockIndex.find(hash);\n    if (mi != mapBlockIndex.end())\n        return (*mi).second;\n\n    // Create new\n    CBlockIndex* pindexNew = new CBlockIndex();\n    if (!pindexNew)\n        throw runtime_error(\"LoadBlockIndex() : new CBlockIndex failed\");\n    mi = mapBlockIndex.insert(make_pair(hash, pindexNew)).first;\n    pindexNew-\u003ephashBlock = \u0026((*mi).first);\n\n    return pindexNew;\n}\n\nbool CTxDB::LoadBlockIndex()\n{\n    // Get database cursor\n    Dbc* pcursor = GetCursor();\n    if (!pcursor)\n        return false;\n\n    // Load mapBlockIndex\n    unsigned int fFlags = DB_SET_RANGE;\n    loop\n    {\n        // Read next record\n        CDataStream ssKey;\n        if (fFlags == DB_SET_RANGE)\n            ssKey \u003c\u003c make_pair(string(\"blockindex\"), uint256(0));\n        CDataStream ssValue;\n        int ret = ReadAtCursor(pcursor, ssKey, ssValue, fFlags);\n        fFlags = DB_NEXT;\n        if (ret == DB_NOTFOUND)\n            break;\n        else if (ret != 0)\n            return false;\n\n        // Unserialize\n        string strType;\n        ssKey \u003e\u003e strType;\n        if (strType == \"blockindex\")\n        {\n            CDiskBlockIndex diskindex;\n            ssValue \u003e\u003e diskindex;\n\n            // Construct block index object\n            CBlockIndex* pindexNew = InsertBlockIndex(diskindex.GetBlockHash());\n            pindexNew-\u003epprev          = InsertBlockIndex(diskindex.hashPrev);\n            pindexNew-\u003epnext          = InsertBlockIndex(diskindex.hashNext);\n            pindexNew-\u003enFile          = diskindex.nFile;\n            pindexNew-\u003enBlockPos      = diskindex.nBlockPos;\n            pindexNew-\u003enHeight        = diskindex.nHeight;\n            pindexNew-\u003enVersion       = diskindex.nVersion;\n            pindexNew-\u003ehashMerkleRoot = diskindex.hashMerkleRoot;\n            pindexNew-\u003enTime          = diskindex.nTime;\n            pindexNew-\u003enBits          = diskindex.nBits;\n            pindexNew-\u003enNonce         = diskindex.nNonce;\n            pindexNew-\u003eauxpow         = diskindex.auxpow;\n\n            // Watch for genesis block\n            if (pindexGenesisBlock == NULL \u0026\u0026 diskindex.GetBlockHash() == hashGenesisBlock)\n                pindexGenesisBlock = pindexNew;\n\n            if (!pindexNew-\u003eCheckIndex())\n                return error(\"LoadBlockIndex() : CheckIndex failed at %d\", pindexNew-\u003enHeight);\n        }\n        else\n        {\n            break;\n        }\n    }\n    pcursor-\u003eclose();\n\n    // Calculate bnChainWork\n    vector\u003cpair\u003cint, CBlockIndex*\u003e \u003e vSortedByHeight;\n    vSortedByHeight.reserve(mapBlockIndex.size());\n    BOOST_FOREACH(const PAIRTYPE(uint256, CBlockIndex*)\u0026 item, mapBlockIndex)\n    {\n        CBlockIndex* pindex = item.second;\n        vSortedByHeight.push_back(make_pair(pindex-\u003enHeight, pindex));\n    }\n    sort(vSortedByHeight.begin(), vSortedByHeight.end());\n    BOOST_FOREACH(const PAIRTYPE(int, CBlockIndex*)\u0026 item, vSortedByHeight)\n    {\n        CBlockIndex* pindex = item.second;\n        pindex-\u003ebnChainWork = (pindex-\u003epprev ? pindex-\u003epprev-\u003ebnChainWork : 0) + pindex-\u003eGetBlockWork();\n    }\n\n    // Load hashBestChain pointer to end of best chain\n    if (!ReadHashBestChain(hashBestChain))\n    {\n        if (pindexGenesisBlock == NULL)\n            return true;\n        return error(\"CTxDB::LoadBlockIndex() : hashBestChain not loaded\");\n    }\n    if (!mapBlockIndex.count(hashBestChain))\n        return error(\"CTxDB::LoadBlockIndex() : hashBestChain not found in the block index\");\n    pindexBest = mapBlockIndex[hashBestChain];\n    nBestHeight = pindexBest-\u003enHeight;\n    bnBestChainWork = pindexBest-\u003ebnChainWork;\n    printf(\"LoadBlockIndex(): hashBestChain=%s  height=%d\\n\", hashBestChain.ToString().substr(0,20).c_str(), nBestHeight);\n\n    // Load bnBestInvalidWork, OK if it doesn't exist\n    ReadBestInvalidWork(bnBestInvalidWork);\n\n    // Verify blocks in the best chain\n    CBlockIndex* pindexFork = NULL;\n    for (CBlockIndex* pindex = pindexBest; pindex \u0026\u0026 pindex-\u003epprev; pindex = pindex-\u003epprev)\n    {\n        if (pindex-\u003enHeight \u003c nBestHeight-2500 \u0026\u0026 !mapArgs.count(\"-checkblocks\"))\n            break;\n        CBlock block;\n        if (!block.ReadFromDisk(pindex))\n            return error(\"LoadBlockIndex() : block.ReadFromDisk failed\");\n        if (!block.CheckBlock(pindex-\u003enHeight))\n        {\n            printf(\"LoadBlockIndex() : *** found bad block at %d, hash=%s\\n\", pindex-\u003enHeight, pindex-\u003eGetBlockHash().ToString().c_str());\n            pindexFork = pindex-\u003epprev;\n        }\n    }\n    if (pindexFork)\n    {\n        // Reorg back to the fork\n        printf(\"LoadBlockIndex() : *** moving best chain pointer back to block %d\\n\", pindexFork-\u003enHeight);\n        CBlock block;\n        if (!block.ReadFromDisk(pindexFork))\n            return error(\"LoadBlockIndex() : block.ReadFromDisk failed\");\n        CTxDB txdb;\n        block.SetBestChain(txdb, pindexFork);\n    }\n\n    return true;\n}\n\n\n\n\n\n//\n// CAddrDB\n//\n\nbool CAddrDB::WriteAddress(const CAddress\u0026 addr)\n{\n    return Write(make_pair(string(\"addr\"), addr.GetKey()), addr);\n}\n\nbool CAddrDB::EraseAddress(const CAddress\u0026 addr)\n{\n    return Erase(make_pair(string(\"addr\"), addr.GetKey()));\n}\n\nbool CAddrDB::LoadAddresses()\n{\n    CRITICAL_BLOCK(cs_mapAddresses)\n    {\n        // Load user provided addresses\n        CAutoFile filein = fopen((GetDataDir() + \"/addr.txt\").c_str(), \"rt\");\n        if (filein)\n        {\n            try\n            {\n                char psz[1000];\n                while (fgets(psz, sizeof(psz), filein))\n                {\n                    CAddress addr(psz, NODE_NETWORK);\n                    addr.nTime = 0; // so it won't relay unless successfully connected\n                    if (addr.IsValid())\n                        AddAddress(addr);\n                }\n            }\n            catch (...) { }\n        }\n\n        // Get cursor\n        Dbc* pcursor = GetCursor();\n        if (!pcursor)\n            return false;\n\n        loop\n        {\n            // Read next record\n            CDataStream ssKey;\n            CDataStream ssValue;\n            int ret = ReadAtCursor(pcursor, ssKey, ssValue);\n            if (ret == DB_NOTFOUND)\n                break;\n            else if (ret != 0)\n                return false;\n\n            // Unserialize\n            string strType;\n            ssKey \u003e\u003e strType;\n            if (strType == \"addr\")\n            {\n                CAddress addr;\n                ssValue \u003e\u003e addr;\n                mapAddresses.insert(make_pair(addr.GetKey(), addr));\n            }\n        }\n        pcursor-\u003eclose();\n\n        printf(\"Loaded %d addresses\\n\", mapAddresses.size());\n    }\n\n    return true;\n}\n\nbool LoadAddresses()\n{\n    return CAddrDB(\"cr+\").LoadAddresses();\n}\n\n\n\n\n//\n// CWalletDB\n//\n\nbool CWalletDB::WriteName(const string\u0026 strAddress, const string\u0026 strName)\n{\n    nWalletDBUpdated++;\n    return Write(make_pair(string(\"name\"), strAddress), strName);\n}\n\nbool CWalletDB::EraseName(const string\u0026 strAddress)\n{\n    // This should only be used for sending addresses, never for receiving addresses,\n    // receiving addresses must always have an address book entry if they're not change return.\n    nWalletDBUpdated++;\n    return Erase(make_pair(string(\"name\"), strAddress));\n}\n\nbool CWalletDB::ReadAccount(const string\u0026 strAccount, CAccount\u0026 account)\n{\n    account.SetNull();\n    return Read(make_pair(string(\"acc\"), strAccount), account);\n}\n\nbool CWalletDB::WriteAccount(const string\u0026 strAccount, const CAccount\u0026 account)\n{\n    return Write(make_pair(string(\"acc\"), strAccount), account);\n}\n\nbool CWalletDB::WriteAccountingEntry(const CAccountingEntry\u0026 acentry)\n{\n    return Write(make_tuple(string(\"acentry\"), acentry.strAccount, ++nAccountingEntryNumber), acentry);\n}\n\nint64 CWalletDB::GetAccountCreditDebit(const string\u0026 strAccount)\n{\n    list\u003cCAccountingEntry\u003e entries;\n    ListAccountCreditDebit(strAccount, entries);\n\n    int64 nCreditDebit = 0;\n    BOOST_FOREACH (const CAccountingEntry\u0026 entry, entries)\n        nCreditDebit += entry.nCreditDebit;\n\n    return nCreditDebit;\n}\n\nvoid CWalletDB::ListAccountCreditDebit(const string\u0026 strAccount, list\u003cCAccountingEntry\u003e\u0026 entries)\n{\n    int64 nCreditDebit = 0;\n\n    bool fAllAccounts = (strAccount == \"*\");\n\n    Dbc* pcursor = GetCursor();\n    if (!pcursor)\n        throw runtime_error(\"CWalletDB::ListAccountCreditDebit() : cannot create DB cursor\");\n    unsigned int fFlags = DB_SET_RANGE;\n    loop\n    {\n        // Read next record\n        CDataStream ssKey;\n        if (fFlags == DB_SET_RANGE)\n            ssKey \u003c\u003c make_tuple(string(\"acentry\"), (fAllAccounts? string(\"\") : strAccount), uint64(0));\n        CDataStream ssValue;\n        int ret = ReadAtCursor(pcursor, ssKey, ssValue, fFlags);\n        fFlags = DB_NEXT;\n        if (ret == DB_NOTFOUND)\n            break;\n        else if (ret != 0)\n        {\n            pcursor-\u003eclose();\n            throw runtime_error(\"CWalletDB::ListAccountCreditDebit() : error scanning DB\");\n        }\n\n        // Unserialize\n        string strType;\n        ssKey \u003e\u003e strType;\n        if (strType != \"acentry\")\n            break;\n        CAccountingEntry acentry;\n        ssKey \u003e\u003e acentry.strAccount;\n        if (!fAllAccounts \u0026\u0026 acentry.strAccount != strAccount)\n            break;\n\n        ssValue \u003e\u003e acentry;\n        entries.push_back(acentry);\n    }\n\n    pcursor-\u003eclose();\n}\n\n\nbool CWalletDB::LoadWallet(CWallet* pwallet)\n{\n    pwallet-\u003evchDefaultKey.clear();\n    int nFileVersion = 0;\n    vector\u003cuint256\u003e vWalletUpgrade;\n\n    // Modify defaults\n#ifndef __WXMSW__\n    // Tray icon sometimes disappears on 9.10 karmic koala 64-bit, leaving no way to access the program\n    fMinimizeToTray = false;\n    fMinimizeOnClose = false;\n#endif\n\n    //// todo: shouldn't we catch exceptions and try to recover and continue?\n    CRITICAL_BLOCK(pwallet-\u003ecs_mapWallet)\n    CRITICAL_BLOCK(pwallet-\u003ecs_mapKeys)\n    {\n        // Get cursor\n        Dbc* pcursor = GetCursor();\n        if (!pcursor)\n            return false;\n\n        loop\n        {\n            // Read next record\n            CDataStream ssKey;\n            CDataStream ssValue;\n            int ret = ReadAtCursor(pcursor, ssKey, ssValue);\n            if (ret == DB_NOTFOUND)\n                break;\n            else if (ret != 0)\n                return false;\n\n            // Unserialize\n            // Taking advantage of the fact that pair serialization\n            // is just the two items serialized one after the other\n            string strType;\n            ssKey \u003e\u003e strType;\n            if (strType == \"name\")\n            {\n                string strAddress;\n                ssKey \u003e\u003e strAddress;\n                ssValue \u003e\u003e pwallet-\u003emapAddressBook[strAddress];\n            }\n            else if (strType == \"tx\")\n            {\n                uint256 hash;\n                ssKey \u003e\u003e hash;\n                CWalletTx\u0026 wtx = pwallet-\u003emapWallet[hash];\n                ssValue \u003e\u003e wtx;\n                wtx.pwallet = pwallet;\n\n                if (wtx.GetHash() != hash)\n                    printf(\"Error in wallet.dat, hash mismatch\\n\");\n\n                // Undo serialize changes in 31600\n                if (31404 \u003c= wtx.fTimeReceivedIsTxTime \u0026\u0026 wtx.fTimeReceivedIsTxTime \u003c= 31703)\n                {\n                    if (!ssValue.empty())\n                    {\n                        char fTmp;\n                        char fUnused;\n                        ssValue \u003e\u003e fTmp \u003e\u003e fUnused \u003e\u003e wtx.strFromAccount;\n                        printf(\"LoadWallet() upgrading tx ver=%d %d '%s' %s\\n\", wtx.fTimeReceivedIsTxTime, fTmp, wtx.strFromAccount.c_str(), hash.ToString().c_str());\n                        wtx.fTimeReceivedIsTxTime = fTmp;\n                    }\n                    else\n                    {\n                        printf(\"LoadWallet() repairing tx ver=%d %s\\n\", wtx.fTimeReceivedIsTxTime, hash.ToString().c_str());\n                        wtx.fTimeReceivedIsTxTime = 0;\n                    }\n                    vWalletUpgrade.push_back(hash);\n                }\n\n                //// debug print\n                //printf(\"LoadWallet  %s\\n\", wtx.GetHash().ToString().c_str());\n                //printf(\" %12I64d  %s  %s  %s\\n\",\n                //    wtx.vout[0].nValue,\n                //    DateTimeStrFormat(\"%x %H:%M:%S\", wtx.GetBlockTime()).c_str(),\n                //    wtx.hashBlock.ToString().substr(0,20).c_str(),\n                //    wtx.mapValue[\"message\"].c_str());\n            }\n            else if (strType == \"acentry\")\n            {\n                string strAccount;\n                ssKey \u003e\u003e strAccount;\n                uint64 nNumber;\n                ssKey \u003e\u003e nNumber;\n                if (nNumber \u003e nAccountingEntryNumber)\n                    nAccountingEntryNumber = nNumber;\n            }\n            else if (strType == \"key\" || strType == \"wkey\")\n            {\n                vector\u003cunsigned char\u003e vchPubKey;\n                ssKey \u003e\u003e vchPubKey;\n                CWalletKey wkey;\n                if (strType == \"key\")\n                    ssValue \u003e\u003e wkey.vchPrivKey;\n                else\n                    ssValue \u003e\u003e wkey;\n\n                pwallet-\u003emapKeys[vchPubKey] = wkey.vchPrivKey;\n                mapPubKeys[Hash160(vchPubKey)] = vchPubKey;\n            }\n            else if (strType == \"defaultkey\")\n            {\n                ssValue \u003e\u003e pwallet-\u003evchDefaultKey;\n            }\n            else if (strType == \"pool\")\n            {\n                int64 nIndex;\n                ssKey \u003e\u003e nIndex;\n                pwallet-\u003esetKeyPool.insert(nIndex);\n            }\n            else if (strType == \"version\")\n            {\n                ssValue \u003e\u003e nFileVersion;\n                if (nFileVersion == 10300)\n                    nFileVersion = 300;\n            }\n            else if (strType == \"setting\")\n            {\n                string strKey;\n                ssKey \u003e\u003e strKey;\n\n                // Options\n#ifndef GUI\n                if (strKey == \"fGenerateBitcoins\")  ssValue \u003e\u003e fGenerateBitcoins;\n#endif\n                if (strKey == \"nTransactionFee\")    ssValue \u003e\u003e nTransactionFee;\n                if (strKey == \"addrIncoming\")       ssValue \u003e\u003e addrIncoming;\n                if (strKey == \"fLimitProcessors\")   ssValue \u003e\u003e fLimitProcessors;\n                if (strKey == \"nLimitProcessors\")   ssValue \u003e\u003e nLimitProcessors;\n                if (strKey == \"fMinimizeToTray\")    ssValue \u003e\u003e fMinimizeToTray;\n                if (strKey == \"fMinimizeOnClose\")   ssValue \u003e\u003e fMinimizeOnClose;\n                if (strKey == \"fUseProxy\")          ssValue \u003e\u003e fUseProxy;\n                if (strKey == \"addrProxy\")          ssValue \u003e\u003e addrProxy;\n                if (fHaveUPnP \u0026\u0026 strKey == \"fUseUPnP\")           ssValue \u003e\u003e fUseUPnP;\n            }\n        }\n        pcursor-\u003eclose();\n    }\n\n    BOOST_FOREACH(uint256 hash, vWalletUpgrade)\n        WriteTx(hash, pwallet-\u003emapWallet[hash]);\n\n    printf(\"nFileVersion = %d\\n\", nFileVersion);\n    printf(\"fGenerateBitcoins = %d\\n\", fGenerateBitcoins);\n    printf(\"nTransactionFee = %\"PRI64d\"\\n\", nTransactionFee);\n    printf(\"addrIncoming = %s\\n\", addrIncoming.ToString().c_str());\n    printf(\"fMinimizeToTray = %d\\n\", fMinimizeToTray);\n    printf(\"fMinimizeOnClose = %d\\n\", fMinimizeOnClose);\n    printf(\"fUseProxy = %d\\n\", fUseProxy);\n    printf(\"addrProxy = %s\\n\", addrProxy.ToString().c_str());\n    if (fHaveUPnP)\n        printf(\"fUseUPnP = %d\\n\", fUseUPnP);\n\n\n    // Upgrade\n    if (nFileVersion \u003c VERSION)\n    {\n        // Get rid of old debug.log file in current directory\n        if (nFileVersion \u003c= 105 \u0026\u0026 !pszSetDataDir[0])\n            unlink(\"debug.log\");\n\n        WriteVersion(VERSION);\n    }\n\n\n    return true;\n}\n\nvoid ThreadFlushWalletDB(void* parg)\n{\n    const string\u0026 strFile = ((const string*)parg)[0];\n    static bool fOneThread;\n    if (fOneThread)\n        return;\n    fOneThread = true;\n    if (mapArgs.count(\"-noflushwallet\"))\n        return;\n\n    unsigned int nLastSeen = nWalletDBUpdated;\n    unsigned int nLastFlushed = nWalletDBUpdated;\n    int64 nLastWalletUpdate = GetTime();\n    while (!fShutdown)\n    {\n        Sleep(500);\n\n        if (nLastSeen != nWalletDBUpdated)\n        {\n            nLastSeen = nWalletDBUpdated;\n            nLastWalletUpdate = GetTime();\n        }\n\n        if (nLastFlushed != nWalletDBUpdated \u0026\u0026 GetTime() - nLastWalletUpdate \u003e= 2)\n        {\n            TRY_CRITICAL_BLOCK(cs_db)\n            {\n                // Don't do this if any databases are in use\n                int nRefCount = 0;\n                map\u003cstring, int\u003e::iterator mi = mapFileUseCount.begin();\n                while (mi != mapFileUseCount.end())\n                {\n                    nRefCount += (*mi).second;\n                    mi++;\n                }\n\n                if (nRefCount == 0 \u0026\u0026 !fShutdown)\n                {\n                    map\u003cstring, int\u003e::iterator mi = mapFileUseCount.find(strFile);\n                    if (mi != mapFileUseCount.end())\n                    {\n                        printf(\"%s \", DateTimeStrFormat(\"%x %H:%M:%S\", GetTime()).c_str());\n                        printf(\"Flushing wallet.dat\\n\");\n                        nLastFlushed = nWalletDBUpdated;\n                        int64 nStart = GetTimeMillis();\n\n                        // Flush wallet.dat so it's self contained\n                        CloseDb(strFile);\n                        dbenv.txn_checkpoint(0, 0, 0);\n                        dbenv.lsn_reset(strFile.c_str(), 0);\n\n                        mapFileUseCount.erase(mi++);\n                        printf(\"Flushed wallet.dat %\"PRI64d\"ms\\n\", GetTimeMillis() - nStart);\n                    }\n                }\n            }\n        }\n    }\n}\n\nbool BackupWallet(const CWallet\u0026 wallet, const string\u0026 strDest)\n{\n    if (!wallet.fFileBacked)\n        return false;\n    while (!fShutdown)\n    {\n        CRITICAL_BLOCK(cs_db)\n        {\n            if (!mapFileUseCount.count(wallet.strWalletFile) || mapFileUseCount[wallet.strWalletFile] == 0)\n            {\n                // Flush log data to the dat file\n                CloseDb(wallet.strWalletFile);\n                dbenv.txn_checkpoint(0, 0, 0);\n                dbenv.lsn_reset(wallet.strWalletFile.c_str(), 0);\n                mapFileUseCount.erase(wallet.strWalletFile);\n\n                // Copy wallet.dat\n                filesystem::path pathSrc(GetDataDir() + \"/\" + wallet.strWalletFile);\n                filesystem::path pathDest(strDest);\n                if (filesystem::is_directory(pathDest))\n                    pathDest = pathDest / wallet.strWalletFile;\n#if BOOST_VERSION \u003e= 104000\n                filesystem::copy_file(pathSrc, pathDest, filesystem::copy_option::overwrite_if_exists);\n#else\n                filesystem::copy_file(pathSrc, pathDest);\n#endif\n                printf(\"copied wallet.dat to %s\\n\", pathDest.string().c_str());\n\n                return true;\n            }\n        }\n        Sleep(100);\n    }\n    return false;\n}\n"}
{"repo_name":"twalpole/selenium","ref":"refs/heads/master","path":"cpp/iedriver/CommandHandlers/MaximizeWindowCommandHandler.cpp","copies":"25","language":"C++","content":"// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements. See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership. The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#include \"MaximizeWindowCommandHandler.h\"\n#include \"errorcodes.h\"\n#include \"../Browser.h\"\n#include \"../IECommandExecutor.h\"\n\nnamespace webdriver {\n\nMaximizeWindowCommandHandler::MaximizeWindowCommandHandler(void) {\n}\n\nMaximizeWindowCommandHandler::~MaximizeWindowCommandHandler(void) {\n}\n\nvoid MaximizeWindowCommandHandler::ExecuteInternal(\n    const IECommandExecutor\u0026 executor,\n    const ParametersMap\u0026 command_parameters,\n    Response* response) {\n  int status_code = WD_SUCCESS;\n\n  BrowserHandle browser_wrapper;\n  status_code = executor.GetCurrentBrowser(\u0026browser_wrapper);\n  if (status_code != WD_SUCCESS) {\n    response-\u003eSetErrorResponse(ERROR_NO_SUCH_WINDOW, \"Error retrieving window\");\n    return;\n  }\n\n  HWND window_handle = browser_wrapper-\u003eGetTopLevelWindowHandle();\n  if (!::IsZoomed(window_handle)) {\n    browser_wrapper-\u003eRestore();\n    ::ShowWindow(window_handle, SW_MAXIMIZE);\n  }\n  RECT window_rect;\n  ::GetWindowRect(window_handle, \u0026window_rect);\n  Json::Value response_value;\n  response_value[\"width\"] = window_rect.right - window_rect.left;\n  response_value[\"height\"] = window_rect.bottom - window_rect.top;\n  response_value[\"x\"] = window_rect.left;\n  response_value[\"y\"] = window_rect.top;\n  response-\u003eSetSuccessResponse(response_value);\n}\n\n} // namespace webdriver\n"}
{"repo_name":"eugene1g/phantomjs","ref":"refs/heads/master","path":"src/qt/qtbase/src/corelib/doc/snippets/code/src_corelib_io_qfile.cpp","copies":"108","language":"C++","content":"/****************************************************************************\n**\n** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies).\n** Contact: http://www.qt-project.org/legal\n**\n** This file is part of the documentation of the Qt Toolkit.\n**\n** $QT_BEGIN_LICENSE:BSD$\n** You may use this file under the terms of the BSD license as follows:\n**\n** \"Redistribution and use in source and binary forms, with or without\n** modification, are permitted provided that the following conditions are\n** met:\n**   * Redistributions of source code must retain the above copyright\n**     notice, this list of conditions and the following disclaimer.\n**   * Redistributions in binary form must reproduce the above copyright\n**     notice, this list of conditions and the following disclaimer in\n**     the documentation and/or other materials provided with the\n**     distribution.\n**   * Neither the name of Digia Plc and its Subsidiary(-ies) nor the names\n**     of its contributors may be used to endorse or promote products derived\n**     from this software without specific prior written permission.\n**\n**\n** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n** \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n** OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n** LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\"\n**\n** $QT_END_LICENSE$\n**\n****************************************************************************/\n\n//! [0]\nQFile file;\nQDir::setCurrent(\"/tmp\");\nfile.setFileName(\"readme.txt\");\nQDir::setCurrent(\"/home\");\nfile.open(QIODevice::ReadOnly);      // opens \"/home/readme.txt\" under Unix\n//! [0]\n\n\n//! [1]\nQByteArray myEncoderFunc(const QString \u0026fileName);\n//! [1]\n\n\n//! [2]\nQString myDecoderFunc(const QByteArray \u0026localFileName);\n//! [2]\n\n\n//! [3]\n#include \u003cstdio.h\u003e\n\nvoid printError(const char* msg)\n{\n    QFile file;\n    file.open(stderr, QIODevice::WriteOnly);\n    file.write(msg, qstrlen(msg));        // write to stderr\n    file.close();\n}\n//! [3]\n\n\n//! [4]\nCONFIG += console\n//! [4]\n"}
{"repo_name":"Soverance/EtherealLegends","ref":"refs/heads/master","path":"Ethereal/Private/Gear/Weapons/Ranged/Annihilator.cpp","copies":"1","language":"C++","content":"// © 2014 - 2017 Soverance Studios\r\n// http://www.soverance.com\r\n\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n\r\n// http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n\r\n#include \"Ethereal.h\"\r\n#include \"Annihilator.h\"\r\n\r\n#define LOCTEXT_NAMESPACE \"EtherealText\"\r\n\r\n// Sets default values\r\nAAnnihilator::AAnnihilator(const FObjectInitializer\u0026 ObjectInitializer)\r\n\t: Super(ObjectInitializer)\r\n{\r\n\t// Get Assets, References Obtained Via Right Click in Editor\r\n\tstatic ConstructorHelpers::FObjectFinder\u003cUSkeletalMesh\u003e SkeletalMeshObject(TEXT(\"SkeletalMesh'/Game/VFX/sphere_skeletal.sphere_skeletal'\"));\r\n\tstatic ConstructorHelpers::FObjectFinder\u003cUStaticMesh\u003e StaticMeshObject(TEXT(\"StaticMesh'/Game/Weapons/Ranged/Anni.Anni'\"));\r\n\tstatic ConstructorHelpers::FObjectFinder\u003cUStaticMesh\u003e OffhandMeshObject(TEXT(\"StaticMesh'/Game/VFX/sphere.sphere'\"));\r\n\tstatic ConstructorHelpers::FObjectFinder\u003cUTexture2D\u003e LargeIconObject(TEXT(\"Texture2D'/Game/Blueprints/Widgets/UI-Images/Icons_Gear/WeaponIcon_Annihilator.WeaponIcon_Annihilator'\"));\r\n\tstatic ConstructorHelpers::FObjectFinder\u003cUTexture2D\u003e SmallIconObject(TEXT(\"Texture2D'/Game/Blueprints/Widgets/UI-Images/Icons_Gear/WeaponIcon_Annihilator-small.WeaponIcon_Annihilator-small'\"));\r\n\r\n\tName = EMasterGearList::GL_Annihilator;\r\n\tNameText = LOCTEXT(\"AnnihilatorName\", \"Annihilator\");\r\n\tType = EMasterGearTypes::GT_Ranged;\r\n\tTypeText = LOCTEXT(\"AnnihilatorType\", \"Ranged\");\r\n\tDescription = \"An embodiment of the Ethereal Virtue: Wrath.\";\r\n\tPrice = 40000;\r\n\tMPCost = 0.0f;\r\n\tATK = 50.0f;\r\n\tDEF = 40.0f;\r\n\tSPD = 20.0f;\r\n\tHP = 500.0f;\r\n\tMP = 250.0f;\r\n\tLargeIcon = LargeIconObject.Object;\r\n\tSmallIcon = SmallIconObject.Object;\r\n\r\n\tSK_WeaponSkeletalMesh = SkeletalMeshObject.Object;\r\n\tSM_WeaponStaticMesh = StaticMeshObject.Object;\r\n\tSM_WeaponOffhandMesh = StaticMeshObject.Object;\r\n\r\n\t// Set Mesh\r\n\tWeaponSkeletalMesh-\u003eSetSkeletalMesh(SK_WeaponSkeletalMesh);\r\n\tWeaponSkeletalMesh-\u003eSetHiddenInGame(true);\r\n\tWeaponStaticMesh-\u003eSetStaticMesh(SM_WeaponStaticMesh);\r\n\tWeaponStaticMesh-\u003eSetWorldScale3D(FVector(0.15f, 0.15f, 0.15f));  // scale correction\r\n\tWeaponStaticMesh-\u003eSetRelativeLocation(FVector(20, -2, -2));  // location correction\r\n\tWeaponStaticMesh-\u003eSetRelativeRotation(FRotator(-12, -90, -75));  // location correction\r\n\tWeaponOffhandMesh-\u003eSetStaticMesh(SM_WeaponOffhandMesh);\r\n\tWeaponOffhandMesh-\u003eSetHiddenInGame(true);\r\n}\r\n\r\n// Called when the game starts or when spawned\r\nvoid AAnnihilator::BeginPlay()\r\n{\r\n\tSuper::BeginPlay();\r\n\r\n\t// Bind this function to the event dispatcher for Bind Gear\r\n\tOnBindGear.AddDynamic(this, \u0026AAnnihilator::BindWeapon);\r\n}\r\n\r\n// Custom code when binding\r\nvoid AAnnihilator::BindWeapon()\r\n{\r\n\t// If this weapon was bound while IsShown is true, set the weapon visible\r\n\tif (IsShown)\r\n\t{\r\n\t\tShowWeapon(false, true, false);\r\n\t}\r\n}\r\n\r\n#undef LOCTEXT_NAMESPACE\r\n"}
{"repo_name":"Dako300/BasicTV","ref":"refs/heads/master","path":"src/math/numbers/math_numbers.cpp","copies":"1","language":"C++","content":"#include \"../../main.h\"\n#include \"../../util.h\"\n#include \"math_numbers.h\"\n#include \"../math.h\"\n#include \"../../id/id_api.h\"\n\n#define MINOR_SPECIES_MULTIPLIER (pow(2, 64)-1)\n\n// proxy functions\n\nstatic void number_sanity_fetch(void *ptr, uint64_t start, uint64_t size, std::vector\u003cuint8_t\u003e *data){\n\tif(data-\u003esize() \u003c start+size){\n\t\tprint(\"can't copy, not enough room\", P_ERR);\n\t}\n\tmemcpy(ptr, data-\u003edata()+start, size);\n\tconvert::nbo::from((uint8_t*)ptr, size);\n}\n\nstatic std::vector\u003cuint8_t\u003e number_sanity_fetch(std::vector\u003cuint8_t\u003e *data){\n\tstd::vector\u003cuint8_t\u003e retval;\n\tif(data-\u003esize() \u003c 4){\n\t\tprint(\"not enough room to possibly encode major/minor size\", P_ERR);\n\t}\n\tuint32_t size;\n\tmemcpy(\u0026size, data-\u003edata(), 4);\n\tsize = NBO_32(size);\n\tif(data-\u003esize() \u003c 4+size){\n\t\tP_V(size, P_WARN);\n\t\tP_V(data-\u003esize(), P_WARN);\n\t\tprint(\"invalid size for current number chunk\", P_ERR);\n\t}\n\tretval =\n\t\tconvert::nbo::from(\n\t\t\tstd::vector\u003cuint8_t\u003e(\n\t\t\t\tdata-\u003ebegin()+4,\n\t\t\t\tdata-\u003ebegin()+4+size));\n\t/*\n\t  Read data needs to be truncated\n\t */\n\tdata-\u003eerase(\n\t\tdata-\u003ebegin(),\n\t\tdata-\u003ebegin()+4+size);\n\treturn retval;\n}\n\nuint64_t math::number::get::unit(std::vector\u003cuint8_t\u003e data){\n\tuint64_t retval;\n\tnumber_sanity_fetch(\u0026retval, 0, sizeof(retval), \u0026data);\n\treturn retval;\n}\n\nstd::pair\u003cstd::vector\u003cuint8_t\u003e,\n\t  std::vector\u003cuint8_t\u003e \u003e math::number::get::raw_species(\n\t\t  std::vector\u003cuint8_t\u003e data){\n\tuint64_t start =\n\t\tsizeof(math_number_unit_t);\n\tif(data.size() \u003c start){\n\t\treturn std::pair\u003cstd::vector\u003cuint8_t\u003e, std::vector\u003cuint8_t\u003e \u003e({}, {});\n\t}\n\tdata.erase(\n\t\tdata.begin(),\n\t\tdata.begin()+start); // truncate unit\n\tstd::pair\u003cstd::vector\u003cuint8_t\u003e, std::vector\u003cuint8_t\u003e \u003e retval;\n\tretval.first =\n\t\tnumber_sanity_fetch(\n\t\t\t\u0026data);\n\tretval.second =\n\t\tnumber_sanity_fetch(\n\t\t\t\u0026data);\n\treturn retval;\n}\n\nlong double math::number::get::number(std::vector\u003cuint8_t\u003e data){\n\tlong double retval;\n\tstd::pair\u003cstd::vector\u003cuint8_t\u003e, std::vector\u003cuint8_t\u003e \u003e species =\n\t\tmath::number::get::raw_species(\n\t\t\tdata);\n\tif(species.first.size() \u003e 8 || species.second.size() \u003e 8){\n\t\tprint(\"I need to expand this beyond 64-bits\", P_ERR);\n\t}\n\tuint64_t major_int = 0, minor_int = 0;\n\tmemcpy(\u0026major_int, species.first.data(), species.first.size());\n\tmemcpy(\u0026minor_int, species.second.data(), species.second.size());\n\tretval = (long double)(major_int) + (long double)((long double)(minor_int/MINOR_SPECIES_MULTIPLIER));\n\treturn retval;\n}\n\n#define NUMBER_CREATE_ADD(x) retval.insert(retval.end(), (uint8_t*)\u0026x, (uint8_t*)\u0026x+sizeof(x))\n\n/*\n  TODO: In order to really optimize the numbers, we need to calculate the min\n  number of bytes needed to represent this (not even in powers of two, which\n  is pretty nice). As of right now, it is stuck at the (somewhat reasonable)\n  max of 8-bytes (64-bit), but slimming that down could help a lot if I choose\n  to optimize math_number_set_simple_t internally (specifically removing overheads\n  with multiple vectors).\n */\n\nstd::vector\u003cuint8_t\u003e math::number::create(long double number,\n\t\t\t\t\t  uint64_t unit){\n\tstd::vector\u003cuint8_t\u003e retval;\n\tint64_t major_int =\n\t\t((uint64_t)(long double)(number));\n\tuint32_t major_size =\n\t\t(8);\n\tuint64_t minor_int =\n\t\t((((long double)number-(long double)major_int)*(long double)MINOR_SPECIES_MULTIPLIER));\n\tuint32_t minor_size =\n\t\t(8);\n\tunit = NBO_64(unit);\n\tmajor_int = NBO_64(major_int);\n\tmajor_size = NBO_32(major_size);\n\tminor_int = NBO_64(minor_int);\n\tminor_size = NBO_32(minor_size);\n\t// doesn't bother with endian stuff, assumed to have been done\n\tNUMBER_CREATE_ADD(unit);\n\tNUMBER_CREATE_ADD(major_size);\n\tNUMBER_CREATE_ADD(major_int);\n\tNUMBER_CREATE_ADD(minor_size);\n\tNUMBER_CREATE_ADD(minor_int);\n\treturn retval;\n}\n\n\nstd::vector\u003cuint8_t\u003e math::number::create(uint64_t number,\n\t\t\t\t\t  uint64_t unit){\n\tstd::vector\u003cuint8_t\u003e retval;\n\tuint64_t major_int =\n\t\tnumber;\n\tuint32_t major_size =\n\t\t8;\n\tuint64_t minor_int =\n\t\t0;\n\tuint32_t minor_size =\n\t\t0;\n\tunit = NBO_64(unit);\n\tmajor_int = NBO_64(major_int);\n\tmajor_size = NBO_32(major_size);\n\tminor_int = NBO_64(minor_int);\n\tminor_size = NBO_32(minor_size);\n\t// doesn't bother with endian stuff, assumed to have been done\n\tNUMBER_CREATE_ADD(unit);\n\tNUMBER_CREATE_ADD(major_size);\n\tNUMBER_CREATE_ADD(major_int);\n\tNUMBER_CREATE_ADD(minor_size);\n\tNUMBER_CREATE_ADD(minor_int);\n\treturn retval;\n}\n\n\nstd::vector\u003cuint8_t\u003e math::number::create(int64_t number,\n\t\t\t\t\t  uint64_t unit){\n\tstd::vector\u003cuint8_t\u003e retval;\n\tint64_t major_int =\n\t\tnumber;\n\tuint32_t major_size =\n\t\t8;\n\tuint64_t minor_int =\n\t\t0;\n\tuint32_t minor_size =\n\t\t0;\n\tunit = NBO_64(unit);\n\tmajor_int = NBO_64(major_int);\n\tmajor_size = NBO_32(major_size);\n\tminor_int = NBO_64(minor_int);\n\tminor_size = NBO_32(minor_size);\n\t// doesn't bother with endian stuff, assumed to have been done\n\tNUMBER_CREATE_ADD(unit);\n\tNUMBER_CREATE_ADD(major_size);\n\tNUMBER_CREATE_ADD(major_int);\n\tNUMBER_CREATE_ADD(minor_size);\n\tNUMBER_CREATE_ADD(minor_int);\n\treturn retval;\n}\n\nstd::vector\u003cuint8_t\u003e math::number::create(std::vector\u003cuint8_t\u003e raw_number_data_major,\n\t\t\t\t\t  std::vector\u003cuint8_t\u003e raw_number_data_minor,\n\t\t\t\t\t  uint64_t unit){\n\tstd::vector\u003cuint8_t\u003e retval;\n\tconvert::nbo::to(\n\t\traw_number_data_major.data(),\n\t\traw_number_data_major.size());\n\tconvert::nbo::to(\n\t\traw_number_data_minor.data(),\n\t\traw_number_data_minor.size());\n\tASSERT(raw_number_data_major.size() \u003c= UINT32_MAX, P_ERR);\n\tASSERT(raw_number_data_minor.size() \u003c= UINT32_MAX, P_ERR);\n\tuint32_t major_size =\n\t\tNBO_32(static_cast\u003cuint32_t\u003e(raw_number_data_major.size()));\n\tuint32_t minor_size =\n\t\tNBO_32(static_cast\u003cuint32_t\u003e(raw_number_data_minor.size()));\n\tNUMBER_CREATE_ADD(unit);\n\tNUMBER_CREATE_ADD(major_size);\n\tretval.insert(retval.end(), raw_number_data_major.begin(), raw_number_data_major.end());\n\tNUMBER_CREATE_ADD(minor_size);\n\tretval.insert(retval.end(), raw_number_data_minor.begin(), raw_number_data_minor.end());\n}\n\t\t\t\t\t  \n\n// simple helper function\n\nvoid math::number::add_data_to_set(\n\tstd::vector\u003cstd::vector\u003cuint8_t\u003e \u003e data,\n\tid_t_ math_number_set_id){\n\tmath_number_set_t *math_number_set_ptr =\n\t\tPTR_DATA(math_number_set_id,\n\t\t\t math_number_set_t);\n\tif(math_number_set_ptr == nullptr){\n\t\tprint(\"math_number_set_ptr is a nullptr\", P_ERR);\n\t}\n\tmath_number_set_ptr-\u003eadd_data(\n\t\tdata);\n}\n"}
