{"repo_name":"mat12/mytest","ref":"refs/heads/master","path":"lib/gdi/sdl.cpp","copies":"79","language":"C++","content":"#include \u003clib/gdi/sdl.h\u003e\n#include \u003clib/actions/action.h\u003e\n#include \u003clib/base/init.h\u003e\n#include \u003clib/base/init_num.h\u003e\n#include \u003clib/driver/input_fake.h\u003e\n#include \u003clib/driver/rcsdl.h\u003e\n\n#include \u003cSDL.h\u003e\n\ngSDLDC::gSDLDC() : m_pump(eApp, 1)\n{\n\tif (SDL_Init(SDL_INIT_VIDEO) \u003c 0) {\n\t\teWarning(\"[gSDLDC] Could not initialize SDL: %s\", SDL_GetError());\n\t\treturn;\n\t}\n\n\tsetResolution(720, 576);\n\n\tCONNECT(m_pump.recv_msg, gSDLDC::pumpEvent);\n\n\tm_surface.type = 0;\n\tm_surface.clut.colors = 256;\n\tm_surface.clut.data = new gRGB[m_surface.clut.colors];\n\n\tm_pixmap = new gPixmap(\u0026m_surface);\n\n\tmemset(m_surface.clut.data, 0, sizeof(*m_surface.clut.data)*m_surface.clut.colors);\n\n\trun();\n}\n\ngSDLDC::~gSDLDC()\n{\n\tpushEvent(EV_QUIT);\n\tkill();\n\tSDL_Quit();\n}\n\nvoid gSDLDC::keyEvent(const SDL_Event \u0026event)\n{\n\teSDLInputDriver *driver = eSDLInputDriver::getInstance();\n\n\teDebug(\"[gSDLDC] Key %s: key=%d\", (event.type == SDL_KEYDOWN) ? \"Down\" : \"Up\", event.key.keysym.sym);\n\n\tif (driver)\n\t\tdriver-\u003ekeyPressed(\u0026event.key);\n}\n\nvoid gSDLDC::pumpEvent(const SDL_Event \u0026event)\n{\n\tswitch (event.type) {\n\tcase SDL_KEYDOWN:\n\tcase SDL_KEYUP:\n\t\tkeyEvent(event);\n\t\tbreak;\n\tcase SDL_QUIT:\n\t\teDebug(\"[gSDLDC] Quit\");\n\t\textern void quitMainloop(int exit_code);\n\t\tquitMainloop(0);\n\t\tbreak;\n\t}\n}\n\nvoid gSDLDC::pushEvent(enum event code, void *data1, void *data2)\n{\n\tSDL_Event event;\n\n\tevent.type = SDL_USEREVENT;\n\tevent.user.code = code;\n\tevent.user.data1 = data1;\n\tevent.user.data2 = data2;\n\n\tSDL_PushEvent(\u0026event);\n}\n\nvoid gSDLDC::exec(const gOpcode *o)\n{\n\tswitch (o-\u003eopcode) {\n\tcase gOpcode::flush:\n\t\tpushEvent(EV_FLIP);\n\t\teDebug(\"[gSDLDC] FLUSH\");\n\t\tbreak;\n\tdefault:\n\t\tgDC::exec(o);\n\t\tbreak;\n\t}\n}\n\nvoid gSDLDC::setResolution(int xres, int yres)\n{\n\tpushEvent(EV_SET_VIDEO_MODE, (void *)xres, (void *)yres);\n}\n\n/*\n * SDL thread below...\n */\n\nvoid gSDLDC::evSetVideoMode(unsigned long xres, unsigned long yres)\n{\n\tm_screen = SDL_SetVideoMode(xres, yres, 32, SDL_HWSURFACE);\n\tif (!m_screen) {\n\t\teFatal(\"[gSDLDC] Could not create SDL surface: %s\", SDL_GetError());\n\t\treturn;\n\t}\n\n\tm_surface.x = m_screen-\u003ew;\n\tm_surface.y = m_screen-\u003eh;\n\tm_surface.bpp = m_screen-\u003eformat-\u003eBitsPerPixel;\n\tm_surface.bypp = m_screen-\u003eformat-\u003eBytesPerPixel;\n\tm_surface.stride = m_screen-\u003epitch;\n\tm_surface.data = m_screen-\u003epixels;\n\n\tSDL_EnableUNICODE(1);\n}\n\nvoid gSDLDC::evFlip()\n{\n\tSDL_Flip(m_screen);\n}\n\nvoid gSDLDC::thread()\n{\n\thasStarted();\n\n\tbool stop = false;\n\twhile (!stop) {\n\t\tSDL_Event event;\n\t\tif (SDL_WaitEvent(\u0026event)) {\n\t\t\tswitch (event.type) {\n\t\t\tcase SDL_KEYDOWN:\n\t\t\tcase SDL_KEYUP:\n\t\t\tcase SDL_QUIT:\n\t\t\t\tm_pump.send(event);\n\t\t\t\tbreak;\n\t\t\tcase SDL_USEREVENT:\n\t\t\t\tswitch (event.user.code) {\n\t\t\t\tcase EV_SET_VIDEO_MODE:\n\t\t\t\t\tevSetVideoMode((unsigned long)event.user.data1, (unsigned long)event.user.data2);\n\t\t\t\t\tbreak;\n\t\t\t\tcase EV_FLIP:\n\t\t\t\t\tevFlip();\n\t\t\t\t\tbreak;\n\t\t\t\tcase EV_QUIT:\n\t\t\t\t\tstop = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\neAutoInitPtr\u003cgSDLDC\u003e init_gSDLDC(eAutoInitNumbers::graphic-1, \"gSDLDC\");\n"}
{"repo_name":"ShiftMediaProject/game-music-emu","ref":"refs/heads/master","path":"gme/Ay_Apu.cpp","copies":"25","language":"C++","content":"// Game_Music_Emu 0.6.0. http://www.slack.net/~ant/\n\n#include \"Ay_Apu.h\"\n\n/* Copyright (C) 2006 Shay Green. This module is free software; you\ncan redistribute it and/or modify it under the terms of the GNU Lesser\nGeneral Public License as published by the Free Software Foundation; either\nversion 2.1 of the License, or (at your option) any later version. This\nmodule is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\nFOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more\ndetails. You should have received a copy of the GNU Lesser General Public\nLicense along with this module; if not, write to the Free Software Foundation,\nInc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA */\n\n#include \"blargg_source.h\"\n\n// Emulation inaccuracies:\n// * Noise isn't run when not in use\n// * Changes to envelope and noise periods are delayed until next reload\n// * Super-sonic tone should attenuate output to about 60%, not 50%\n\n// Tones above this frequency are treated as disabled tone at half volume.\n// Power of two is more efficient (avoids division).\nunsigned const inaudible_freq = 16384;\n\nint const period_factor = 16;\n\nstatic byte const amp_table [16] =\n{\n#define ENTRY( n ) byte (n * Ay_Apu::amp_range + 0.5)\n\t// With channels tied together and 1K resistor to ground (as datasheet recommends),\n\t// output nearly matches logarithmic curve as claimed. Approx. 1.5 dB per step.\n\tENTRY(0.000000),ENTRY(0.007813),ENTRY(0.011049),ENTRY(0.015625),\n\tENTRY(0.022097),ENTRY(0.031250),ENTRY(0.044194),ENTRY(0.062500),\n\tENTRY(0.088388),ENTRY(0.125000),ENTRY(0.176777),ENTRY(0.250000),\n\tENTRY(0.353553),ENTRY(0.500000),ENTRY(0.707107),ENTRY(1.000000),\n\t\n\t/*\n\t// Measured from an AY-3-8910A chip with date code 8611.\n\t\n\t// Direct voltages without any load (very linear)\n\tENTRY(0.000000),ENTRY(0.046237),ENTRY(0.064516),ENTRY(0.089785),\n\tENTRY(0.124731),ENTRY(0.173118),ENTRY(0.225806),ENTRY(0.329032),\n\tENTRY(0.360215),ENTRY(0.494624),ENTRY(0.594624),ENTRY(0.672043),\n\tENTRY(0.766129),ENTRY(0.841935),ENTRY(0.926882),ENTRY(1.000000),\n\t// With only some load\n\tENTRY(0.000000),ENTRY(0.011940),ENTRY(0.017413),ENTRY(0.024876),\n\tENTRY(0.036318),ENTRY(0.054229),ENTRY(0.072637),ENTRY(0.122388),\n\tENTRY(0.174129),ENTRY(0.239303),ENTRY(0.323881),ENTRY(0.410945),\n\tENTRY(0.527363),ENTRY(0.651741),ENTRY(0.832338),ENTRY(1.000000),\n\t*/\n#undef ENTRY\n};\n\nstatic byte const modes [8] =\n{\n#define MODE( a0,a1, b0,b1, c0,c1 ) \\\n\t\t(a0 | a1\u003c\u003c1 | b0\u003c\u003c2 | b1\u003c\u003c3 | c0\u003c\u003c4 | c1\u003c\u003c5)\n\tMODE( 1,0, 1,0, 1,0 ),\n\tMODE( 1,0, 0,0, 0,0 ),\n\tMODE( 1,0, 0,1, 1,0 ),\n\tMODE( 1,0, 1,1, 1,1 ),\n\tMODE( 0,1, 0,1, 0,1 ),\n\tMODE( 0,1, 1,1, 1,1 ),\n\tMODE( 0,1, 1,0, 0,1 ),\n\tMODE( 0,1, 0,0, 0,0 ),\n};\n\nAy_Apu::Ay_Apu()\n{\n\t// build full table of the upper 8 envelope waveforms\n\tfor ( int m = 8; m--; )\n\t{\n\t\tbyte* out = env.modes [m];\n\t\tint flags = modes [m];\n\t\tfor ( int x = 3; --x \u003e= 0; )\n\t\t{\n\t\t\tint amp = flags \u0026 1;\n\t\t\tint end = flags \u003e\u003e 1 \u0026 1;\n\t\t\tint step = end - amp;\n\t\t\tamp *= 15;\n\t\t\tfor ( int y = 16; --y \u003e= 0; )\n\t\t\t{\n\t\t\t\t*out++ = amp_table [amp];\n\t\t\t\tamp += step;\n\t\t\t}\n\t\t\tflags \u003e\u003e= 2;\n\t\t}\n\t}\n\t\n\toutput( 0 );\n\tvolume( 1.0 );\n\treset();\n}\n\nvoid Ay_Apu::reset()\n{\n\tlast_time   = 0;\n\tnoise.delay = 0;\n\tnoise.lfsr  = 1;\n\t\n\tosc_t* osc = \u0026oscs [osc_count];\n\tdo\n\t{\n\t\tosc--;\n\t\tosc-\u003eperiod   = period_factor;\n\t\tosc-\u003edelay    = 0;\n\t\tosc-\u003elast_amp = 0;\n\t\tosc-\u003ephase    = 0;\n\t}\n\twhile ( osc != oscs );\n\t\n\tfor ( int i = sizeof regs; --i \u003e= 0; )\n\t\tregs [i] = 0;\n\tregs [7] = 0xFF;\n\twrite_data_( 13, 0 );\n}\n\nvoid Ay_Apu::write_data_( int addr, int data )\n{\n\tassert( (unsigned) addr \u003c reg_count );\n\t\n\tif ( (unsigned) addr \u003e= 14 )\n\t{\n\t\t#ifdef debug_printf\n\t\t\tdebug_printf( \"Wrote to I/O port %02X\\n\", (int) addr );\n\t\t#endif\n\t}\n\t\n\t// envelope mode\n\tif ( addr == 13 )\n\t{\n\t\tif ( !(data \u0026 8) ) // convert modes 0-7 to proper equivalents\n\t\t\tdata = (data \u0026 4) ? 15 : 9;\n\t\tenv.wave = env.modes [data - 7];\n\t\tenv.pos = -48;\n\t\tenv.delay = 0; // will get set to envelope period in run_until()\n\t}\n\tregs [addr] = data;\n\t\n\t// handle period changes accurately\n\tint i = addr \u003e\u003e 1;\n\tif ( i \u003c osc_count )\n\t{\n\t\tblip_time_t period = (regs [i * 2 + 1] \u0026 0x0F) * (0x100L * period_factor) +\n\t\t\t\tregs [i * 2] * period_factor;\n\t\tif ( !period )\n\t\t\tperiod = period_factor;\n\t\t\n\t\t// adjust time of next timer expiration based on change in period\n\t\tosc_t\u0026 osc = oscs [i];\n\t\tif ( (osc.delay += period - osc.period) \u003c 0 )\n\t\t\tosc.delay = 0;\n\t\tosc.period = period;\n\t}\n\t\n\t// TODO: same as above for envelope timer, and it also has a divide by two after it\n}\n\nint const noise_off = 0x08;\nint const tone_off  = 0x01;\n\nvoid Ay_Apu::run_until( blip_time_t final_end_time )\n{\n\trequire( final_end_time \u003e= last_time );\n\t\n\t// noise period and initial values\n\tblip_time_t const noise_period_factor = period_factor * 2; // verified\n\tblip_time_t noise_period = (regs [6] \u0026 0x1F) * noise_period_factor;\n\tif ( !noise_period )\n\t\tnoise_period = noise_period_factor;\n\tblip_time_t const old_noise_delay = noise.delay;\n\tblargg_ulong const old_noise_lfsr = noise.lfsr;\n\t\n\t// envelope period\n\tblip_time_t const env_period_factor = period_factor * 2; // verified\n\tblip_time_t env_period = (regs [12] * 0x100L + regs [11]) * env_period_factor;\n\tif ( !env_period )\n\t\tenv_period = env_period_factor; // same as period 1 on my AY chip\n\tif ( !env.delay )\n\t\tenv.delay = env_period;\n\t\n\t// run each osc separately\n\tfor ( int index = 0; index \u003c osc_count; index++ )\n\t{\n\t\tosc_t* const osc = \u0026oscs [index];\n\t\tint osc_mode = regs [7] \u003e\u003e index;\n\t\t\n\t\t// output\n\t\tBlip_Buffer* const osc_output = osc-\u003eoutput;\n\t\tif ( !osc_output )\n\t\t\tcontinue;\n\t\tosc_output-\u003eset_modified();\n\t\t\n\t\t// period\n\t\tint half_vol = 0;\n\t\tblip_time_t inaudible_period = (blargg_ulong) (osc_output-\u003eclock_rate() +\n\t\t\t\tinaudible_freq) / (inaudible_freq * 2);\n\t\tif ( osc-\u003eperiod \u003c= inaudible_period \u0026\u0026 !(osc_mode \u0026 tone_off) )\n\t\t{\n\t\t\thalf_vol = 1; // Actually around 60%, but 50% is close enough\n\t\t\tosc_mode |= tone_off;\n\t\t}\n\t\t\n\t\t// envelope\n\t\tblip_time_t start_time = last_time;\n\t\tblip_time_t end_time   = final_end_time;\n\t\tint const vol_mode = regs [0x08 + index];\n\t\tint volume = amp_table [vol_mode \u0026 0x0F] \u003e\u003e half_vol;\n\t\tint osc_env_pos = env.pos;\n\t\tif ( vol_mode \u0026 0x10 )\n\t\t{\n\t\t\tvolume = env.wave [osc_env_pos] \u003e\u003e half_vol;\n\t\t\t// use envelope only if it's a repeating wave or a ramp that hasn't finished\n\t\t\tif ( !(regs [13] \u0026 1) || osc_env_pos \u003c -32 )\n\t\t\t{\n\t\t\t\tend_time = start_time + env.delay;\n\t\t\t\tif ( end_time \u003e= final_end_time )\n\t\t\t\t\tend_time = final_end_time;\n\t\t\t\t\n\t\t\t\t//if ( !(regs [12] | regs [11]) )\n\t\t\t\t//  debug_printf( \"Used envelope period 0\\n\" );\n\t\t\t}\n\t\t\telse if ( !volume )\n\t\t\t{\n\t\t\t\tosc_mode = noise_off | tone_off;\n\t\t\t}\n\t\t}\n\t\telse if ( !volume )\n\t\t{\n\t\t\tosc_mode = noise_off | tone_off;\n\t\t}\n\t\t\n\t\t// tone time\n\t\tblip_time_t const period = osc-\u003eperiod;\n\t\tblip_time_t time = start_time + osc-\u003edelay;\n\t\tif ( osc_mode \u0026 tone_off ) // maintain tone's phase when off\n\t\t{\n\t\t\tblargg_long count = (final_end_time - time + period - 1) / period;\n\t\t\ttime += count * period;\n\t\t\tosc-\u003ephase ^= count \u0026 1;\n\t\t}\n\t\t\n\t\t// noise time\n\t\tblip_time_t ntime = final_end_time;\n\t\tblargg_ulong noise_lfsr = 1;\n\t\tif ( !(osc_mode \u0026 noise_off) )\n\t\t{\n\t\t\tntime = start_time + old_noise_delay;\n\t\t\tnoise_lfsr = old_noise_lfsr;\n\t\t\t//if ( (regs [6] \u0026 0x1F) == 0 )\n\t\t\t//  debug_printf( \"Used noise period 0\\n\" );\n\t\t}\n\t\t\n\t\t// The following efficiently handles several cases (least demanding first):\n\t\t// * Tone, noise, and envelope disabled, where channel acts as 4-bit DAC\n\t\t// * Just tone or just noise, envelope disabled\n\t\t// * Envelope controlling tone and/or noise\n\t\t// * Tone and noise disabled, envelope enabled with high frequency\n\t\t// * Tone and noise together\n\t\t// * Tone and noise together with envelope\n\t\t\n\t\t// This loop only runs one iteration if envelope is disabled. If envelope\n\t\t// is being used as a waveform (tone and noise disabled), this loop will\n\t\t// still be reasonably efficient since the bulk of it will be skipped.\n\t\twhile ( 1 )\n\t\t{\n\t\t\t// current amplitude\n\t\t\tint amp = 0;\n\t\t\tif ( (osc_mode | osc-\u003ephase) \u0026 1 \u0026 (osc_mode \u003e\u003e 3 | noise_lfsr) )\n\t\t\t\tamp = volume;\n\t\t\t{\n\t\t\t\tint delta = amp - osc-\u003elast_amp;\n\t\t\t\tif ( delta )\n\t\t\t\t{\n\t\t\t\t\tosc-\u003elast_amp = amp;\n\t\t\t\t\tsynth_.offset( start_time, delta, osc_output );\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// Run wave and noise interleved with each catching up to the other.\n\t\t\t// If one or both are disabled, their \"current time\" will be past end time,\n\t\t\t// so there will be no significant performance hit.\n\t\t\tif ( ntime \u003c end_time || time \u003c end_time )\n\t\t\t{\n\t\t\t\t// Since amplitude was updated above, delta will always be +/- volume,\n\t\t\t\t// so we can avoid using last_amp every time to calculate the delta.\n\t\t\t\tint delta = amp * 2 - volume;\n\t\t\t\tint delta_non_zero = delta != 0;\n\t\t\t\tint phase = osc-\u003ephase | (osc_mode \u0026 tone_off); assert( tone_off == 0x01 );\n\t\t\t\tdo\n\t\t\t\t{\n\t\t\t\t\t// run noise\n\t\t\t\t\tblip_time_t end = end_time;\n\t\t\t\t\tif ( end_time \u003e time ) end = time;\n\t\t\t\t\tif ( phase \u0026 delta_non_zero )\n\t\t\t\t\t{\n\t\t\t\t\t\twhile ( ntime \u003c= end ) // must advance *past* time to avoid hang\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint changed = noise_lfsr + 1;\n\t\t\t\t\t\t\tnoise_lfsr = (-(noise_lfsr \u0026 1) \u0026 0x12000) ^ (noise_lfsr \u003e\u003e 1);\n\t\t\t\t\t\t\tif ( changed \u0026 2 )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdelta = -delta;\n\t\t\t\t\t\t\t\tsynth_.offset( ntime, delta, osc_output );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tntime += noise_period;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// 20 or more noise periods on average for some music\n\t\t\t\t\t\tblargg_long remain = end - ntime;\n\t\t\t\t\t\tblargg_long count = remain / noise_period;\n\t\t\t\t\t\tif ( remain \u003e= 0 )\n\t\t\t\t\t\t\tntime += noise_period + count * noise_period;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// run tone\n\t\t\t\t\tend = end_time;\n\t\t\t\t\tif ( end_time \u003e ntime ) end = ntime;\n\t\t\t\t\tif ( noise_lfsr \u0026 delta_non_zero )\n\t\t\t\t\t{\n\t\t\t\t\t\twhile ( time \u003c end )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdelta = -delta;\n\t\t\t\t\t\t\tsynth_.offset( time, delta, osc_output );\n\t\t\t\t\t\t\ttime += period;\n\t\t\t\t\t\t\t//phase ^= 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//assert( phase == (delta \u003e 0) );\n\t\t\t\t\t\tphase = unsigned (-delta) \u003e\u003e (CHAR_BIT * sizeof (unsigned) - 1);\n\t\t\t\t\t\t// (delta \u003e 0)\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// loop usually runs less than once\n\t\t\t\t\t\t//SUB_CASE_COUNTER( (time \u003c end) * (end - time + period - 1) / period );\n\t\t\t\t\t\t\n\t\t\t\t\t\twhile ( time \u003c end )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttime += period;\n\t\t\t\t\t\t\tphase ^= 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twhile ( time \u003c end_time || ntime \u003c end_time );\n\t\t\t\t\n\t\t\t\tosc-\u003elast_amp = (delta + volume) \u003e\u003e 1;\n\t\t\t\tif ( !(osc_mode \u0026 tone_off) )\n\t\t\t\t\tosc-\u003ephase = phase;\n\t\t\t}\n\t\t\t\n\t\t\tif ( end_time \u003e= final_end_time )\n\t\t\t\tbreak; // breaks first time when envelope is disabled\n\t\t\t\n\t\t\t// next envelope step\n\t\t\tif ( ++osc_env_pos \u003e= 0 )\n\t\t\t\tosc_env_pos -= 32;\n\t\t\tvolume = env.wave [osc_env_pos] \u003e\u003e half_vol;\n\t\t\t\n\t\t\tstart_time = end_time;\n\t\t\tend_time += env_period;\n\t\t\tif ( end_time \u003e final_end_time )\n\t\t\t\tend_time = final_end_time;\n\t\t}\n\t\tosc-\u003edelay = time - final_end_time;\n\t\t\n\t\tif ( !(osc_mode \u0026 noise_off) )\n\t\t{\n\t\t\tnoise.delay = ntime - final_end_time;\n\t\t\tnoise.lfsr = noise_lfsr;\n\t\t}\n\t}\n\t\n\t// TODO: optimized saw wave envelope?\n\t\n\t// maintain envelope phase\n\tblip_time_t remain = final_end_time - last_time - env.delay;\n\tif ( remain \u003e= 0 )\n\t{\n\t\tblargg_long count = (remain + env_period) / env_period;\n\t\tenv.pos += count;\n\t\tif ( env.pos \u003e= 0 )\n\t\t\tenv.pos = (env.pos \u0026 31) - 32;\n\t\tremain -= count * env_period;\n\t\tassert( -remain \u003c= env_period );\n\t}\n\tenv.delay = -remain;\n\tassert( env.delay \u003e 0 );\n\tassert( env.pos \u003c 0 );\n\t\n\tlast_time = final_end_time;\n}\n"}
{"repo_name":"hyuk-kim-tmax/OFASM-test","ref":"refs/heads/master","path":"Mtest/UNKNOWN/MVI01/main.cpp","copies":"2","language":"C++","content":"#include \u003cstdlib.h\u003e\n#include \u003cstring.h\u003e\n\nextern int MVI01(char* p_0, char* p_1, char* p_2);\n\nint main(){\n    char *p_0 = (char *)malloc(sizeof(char)*7);\n    char *p_1_0 = (char *)malloc(sizeof(char)*7);\n    char *p_1 = (char *)\u0026p_1_0;\n    char *p_2 = (char*) malloc(sizeof(char)*3);\n    strcpy(p_0,\"HELLO \");\n    strcpy(p_1_0,\"WORLD \");\n    strcpy(p_2,\"!!\");\n\n    MVI01(p_0, p_1, p_2);\n    MVI01(p_0, p_1, p_2);\n   \n    return 0;\n}\n"}
{"repo_name":"chirilo/phantomjs","ref":"refs/heads/master","path":"src/qt/qtbase/src/gui/doc/snippets/code/src_gui_painting_qpainter.cpp","copies":"103","language":"C++","content":"/****************************************************************************\n**\n** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies).\n** Contact: http://www.qt-project.org/legal\n**\n** This file is part of the documentation of the Qt Toolkit.\n**\n** $QT_BEGIN_LICENSE:BSD$\n** You may use this file under the terms of the BSD license as follows:\n**\n** \"Redistribution and use in source and binary forms, with or without\n** modification, are permitted provided that the following conditions are\n** met:\n**   * Redistributions of source code must retain the above copyright\n**     notice, this list of conditions and the following disclaimer.\n**   * Redistributions in binary form must reproduce the above copyright\n**     notice, this list of conditions and the following disclaimer in\n**     the documentation and/or other materials provided with the\n**     distribution.\n**   * Neither the name of Digia Plc and its Subsidiary(-ies) nor the names\n**     of its contributors may be used to endorse or promote products derived\n**     from this software without specific prior written permission.\n**\n**\n** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n** \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n** OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n** LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\"\n**\n** $QT_END_LICENSE$\n**\n****************************************************************************/\n\n//! [0]\nvoid SimpleExampleWidget::paintEvent(QPaintEvent *)\n{\n    QPainter painter(this);\n    painter.setPen(Qt::blue);\n    painter.setFont(QFont(\"Arial\", 30));\n    painter.drawText(rect(), Qt::AlignCenter, \"Qt\");\n}\n//! [0]\n\n\n//! [1]\nvoid MyWidget::paintEvent(QPaintEvent *)\n{\n    QPainter p;\n    p.begin(this);\n    p.drawLine(...);        // drawing code\n    p.end();\n}\n//! [1]\n\n\n//! [2]\nvoid MyWidget::paintEvent(QPaintEvent *)\n{\n    QPainter p(this);\n    p.drawLine(...);        // drawing code\n}\n//! [2]\n\n\n//! [3]\npainter-\u003ebegin(0); // impossible - paint device cannot be 0\n\nQPixmap image(0, 0);\npainter-\u003ebegin(\u0026image); // impossible - image.isNull() == true;\n\npainter-\u003ebegin(myWidget);\npainter2-\u003ebegin(myWidget); // impossible - only one painter at a time\n//! [3]\n\n\n//! [4]\nvoid QPainter::rotate(qreal angle)\n{\n    QMatrix matrix;\n    matrix.rotate(angle);\n    setWorldMatrix(matrix, true);\n}\n//! [4]\n\n\n//! [5]\nQPainterPath path;\npath.moveTo(20, 80);\npath.lineTo(20, 30);\npath.cubicTo(80, 0, 50, 50, 80, 80);\n\nQPainter painter(this);\npainter.drawPath(path);\n//! [5]\n\n\n//! [6]\nQLineF line(10.0, 80.0, 90.0, 20.0);\n\nQPainter(this);\npainter.drawLine(line);\n//! [6]\n\n\n//! [7]\nQRectF rectangle(10.0, 20.0, 80.0, 60.0);\n\nQPainter painter(this);\npainter.drawRect(rectangle);\n//! [7]\n\n\n//! [8]\nQRectF rectangle(10.0, 20.0, 80.0, 60.0);\n\nQPainter painter(this);\npainter.drawRoundedRect(rectangle, 20.0, 15.0);\n//! [8]\n\n\n//! [9]\nQRectF rectangle(10.0, 20.0, 80.0, 60.0);\n\nQPainter painter(this);\npainter.drawEllipse(rectangle);\n//! [9]\n\n\n//! [10]\nQRectF rectangle(10.0, 20.0, 80.0, 60.0);\nint startAngle = 30 * 16;\nint spanAngle = 120 * 16;\n\nQPainter painter(this);\npainter.drawArc(rectangle, startAngle, spanAngle);\n//! [10]\n\n\n//! [11]\nQRectF rectangle(10.0, 20.0, 80.0, 60.0);\nint startAngle = 30 * 16;\nint spanAngle = 120 * 16;\n\nQPainter painter(this);\npainter.drawPie(rectangle, startAngle, spanAngle);\n//! [11]\n\n\n//! [12]\nQRectF rectangle(10.0, 20.0, 80.0, 60.0);\nint startAngle = 30 * 16;\nint spanAngle = 120 * 16;\n\nQPainter painter(this);\npainter.drawChord(rect, startAngle, spanAngle);\n//! [12]\n\n\n//! [13]\nstatic const QPointF points[3] = {\n    QPointF(10.0, 80.0),\n    QPointF(20.0, 10.0),\n    QPointF(80.0, 30.0),\n};\n\nQPainter painter(this);\npainter.drawPolyline(points, 3);\n//! [13]\n\n\n//! [14]\nstatic const QPointF points[4] = {\n    QPointF(10.0, 80.0),\n    QPointF(20.0, 10.0),\n    QPointF(80.0, 30.0),\n    QPointF(90.0, 70.0)\n};\n\nQPainter painter(this);\npainter.drawPolygon(points, 4);\n//! [14]\n\n\n//! [15]\nstatic const QPointF points[4] = {\n    QPointF(10.0, 80.0),\n    QPointF(20.0, 10.0),\n    QPointF(80.0, 30.0),\n    QPointF(90.0, 70.0)\n};\n\nQPainter painter(this);\npainter.drawConvexPolygon(points, 4);\n//! [15]\n\n\n//! [16]\nQRectF target(10.0, 20.0, 80.0, 60.0);\nQRectF source(0.0, 0.0, 70.0, 40.0);\nQPixmap pixmap(\":myPixmap.png\");\n\nQPainter(this);\npainter.drawPixmap(target, pixmap, source);\n//! [16]\n\n\n//! [17]\nQPainter painter(this);\npainter.drawText(rect, Qt::AlignCenter, tr(\"Qt\\nProject\"));\n//! [17]\n\n\n//! [18]\nQPicture picture;\nQPointF point(10.0, 20.0)\npicture.load(\"drawing.pic\");\n\nQPainter painter(this);\npainter.drawPicture(0, 0, picture);\n//! [18]\n\n\n//! [19]\nfillRect(rectangle, background()).\n//! [19]\n\n\n//! [20]\nQRectF target(10.0, 20.0, 80.0, 60.0);\nQRectF source(0.0, 0.0, 70.0, 40.0);\nQImage image(\":/images/myImage.png\");\n\nQPainter painter(this);\npainter.drawImage(target, image, source);\n//! [20]\n\n\n//! [21]\nQPainter painter(this);\npainter.fillRect(0, 0, 128, 128, Qt::green);\npainter.beginNativePainting();\n\nglEnable(GL_SCISSOR_TEST);\nglScissor(0, 0, 64, 64);\n\nglClearColor(1, 0, 0, 1);\nglClear(GL_COLOR_BUFFER_BIT);\n\nglDisable(GL_SCISSOR_TEST);\n\npainter.endNativePainting();\n//! [21]\n"}
{"repo_name":"poixen/Cockatrice","ref":"refs/heads/master","path":"cockatrice/src/dlg_edit_user.cpp","copies":"1","language":"C++","content":"#include \u003cQSettings\u003e\n#include \u003cQLabel\u003e\n#include \u003cQGridLayout\u003e\n#include \u003cQHBoxLayout\u003e\n#include \u003cQDialogButtonBox\u003e\n#include \u003cQDebug\u003e\n\n#include \"dlg_edit_user.h\"\n#include \"settingscache.h\"\n\nDlgEditUser::DlgEditUser(QWidget *parent, QString email, int gender, QString country, QString realName)\n    : QDialog(parent)\n{\n    emailLabel = new QLabel(tr(\"Email:\"));\n    emailEdit = new QLineEdit();\n    emailLabel-\u003esetBuddy(emailEdit);\n    emailEdit-\u003esetText(email);\n\n    genderLabel = new QLabel(tr(\"Pronouns:\"));\n    genderEdit = new QComboBox();\n    genderLabel-\u003esetBuddy(genderEdit);\n    genderEdit-\u003einsertItem(0, QIcon(\":/resources/genders/unknown.svg\"), tr(\"Neutral\"));\n    genderEdit-\u003einsertItem(1, QIcon(\":/resources/genders/male.svg\"), tr(\"Masculine\"));\n    genderEdit-\u003einsertItem(2, QIcon(\":/resources/genders/female.svg\"), tr(\"Feminine\"));\n    genderEdit-\u003esetCurrentIndex(gender + 1);\n\n    countryLabel = new QLabel(tr(\"Country:\"));\n    countryEdit = new QComboBox();\n    countryLabel-\u003esetBuddy(countryEdit);\n    countryEdit-\u003einsertItem(0, tr(\"Undefined\"));\n    countryEdit-\u003esetCurrentIndex(0);\n\n    QStringList countries = settingsCache-\u003egetCountries();\n    int i = 1;\n    foreach(QString c, countries)\n    {\n        countryEdit-\u003eaddItem(QPixmap(\":/resources/countries/\" + c + \".svg\"), c);\n        if (c == country)\n            countryEdit-\u003esetCurrentIndex(i);\n\n        ++i;\n    }\n\n    realnameLabel = new QLabel(tr(\"Real name:\"));\n    realnameEdit = new QLineEdit();\n    realnameLabel-\u003esetBuddy(realnameEdit);\n    realnameEdit-\u003esetText(realName);\n    \n    QGridLayout *grid = new QGridLayout;\n    grid-\u003eaddWidget(emailLabel, 0, 0);\n    grid-\u003eaddWidget(emailEdit, 0, 1);\n    grid-\u003eaddWidget(genderLabel, 1, 0);\n    grid-\u003eaddWidget(genderEdit, 1, 1);\n    grid-\u003eaddWidget(countryLabel, 2, 0);\n    grid-\u003eaddWidget(countryEdit, 2, 1);\n    grid-\u003eaddWidget(realnameLabel, 3, 0);\n    grid-\u003eaddWidget(realnameEdit, 3, 1);\n    \n    QDialogButtonBox *buttonBox = new QDialogButtonBox(QDialogButtonBox::Ok | QDialogButtonBox::Cancel);\n    connect(buttonBox, SIGNAL(accepted()), this, SLOT(actOk()));\n    connect(buttonBox, SIGNAL(rejected()), this, SLOT(actCancel()));\n         \n    QVBoxLayout *mainLayout = new QVBoxLayout;\n    mainLayout-\u003eaddLayout(grid);\n    mainLayout-\u003eaddWidget(buttonBox);\n    setLayout(mainLayout);\n\n    setWindowTitle(tr(\"Edit user profile\"));\n    setFixedHeight(sizeHint().height());\n    setMinimumWidth(300);\n}\n\nvoid DlgEditUser::actOk()\n{\n    accept();\n}\n\nvoid DlgEditUser::actCancel()\n{\n    reject();\n}\n"}
{"repo_name":"ondra-novak/blink","ref":"refs/heads/nw","path":"Source/core/svg/SVGFontFaceUriElement.cpp","copies":"2","language":"C++","content":"/*\n * Copyright (C) 2007 Eric Seidel \u003ceric@webkit.org\u003e\n * Copyright (C) 2009 Apple Inc. All rights reserved.\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Library General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Library General Public License for more details.\n *\n * You should have received a copy of the GNU Library General Public License\n * along with this library; see the file COPYING.LIB.  If not, write to\n * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n * Boston, MA 02110-1301, USA.\n */\n\n#include \"config.h\"\n\n#if ENABLE(SVG_FONTS)\n#include \"core/svg/SVGFontFaceUriElement.h\"\n\n#include \"core/XLinkNames.h\"\n#include \"core/css/CSSFontFaceSrcValue.h\"\n#include \"core/dom/Document.h\"\n#include \"core/fetch/FetchRequest.h\"\n#include \"core/fetch/ResourceFetcher.h\"\n#include \"core/svg/SVGFontFaceElement.h\"\n\nnamespace blink {\n\nusing namespace SVGNames;\n\ninline SVGFontFaceUriElement::SVGFontFaceUriElement(Document\u0026 document)\n    : SVGElement(font_face_uriTag, document)\n{\n    ScriptWrappable::init(this);\n}\n\nDEFINE_NODE_FACTORY(SVGFontFaceUriElement)\n\nSVGFontFaceUriElement::~SVGFontFaceUriElement()\n{\n    if (m_resource)\n        m_resource-\u003eremoveClient(this);\n}\n\nPassRefPtrWillBeRawPtr\u003cCSSFontFaceSrcValue\u003e SVGFontFaceUriElement::srcValue() const\n{\n    RefPtrWillBeRawPtr\u003cCSSFontFaceSrcValue\u003e src = CSSFontFaceSrcValue::create(getAttribute(XLinkNames::hrefAttr));\n    AtomicString value(fastGetAttribute(formatAttr));\n    src-\u003esetFormat(value.isEmpty() ? \"svg\" : value); // Default format\n    return src.release();\n}\n\nvoid SVGFontFaceUriElement::parseAttribute(const QualifiedName\u0026 name, const AtomicString\u0026 value)\n{\n    if (name.matches(XLinkNames::hrefAttr))\n        loadFont();\n    else\n        SVGElement::parseAttribute(name, value);\n}\n\nvoid SVGFontFaceUriElement::childrenChanged(const ChildrenChange\u0026 change)\n{\n    SVGElement::childrenChanged(change);\n\n    if (!isSVGFontFaceSrcElement(parentNode()))\n        return;\n\n    ContainerNode* grandparent = parentNode()-\u003eparentNode();\n    if (isSVGFontFaceElement(grandparent))\n        toSVGFontFaceElement(*grandparent).rebuildFontFace();\n}\n\nNode::InsertionNotificationRequest SVGFontFaceUriElement::insertedInto(ContainerNode* rootParent)\n{\n    loadFont();\n    return SVGElement::insertedInto(rootParent);\n}\n\nvoid SVGFontFaceUriElement::loadFont()\n{\n    if (m_resource)\n        m_resource-\u003eremoveClient(this);\n\n    const AtomicString\u0026 href = getAttribute(XLinkNames::hrefAttr);\n    if (!href.isNull()) {\n        ResourceFetcher* fetcher = document().fetcher();\n        FetchRequest request(ResourceRequest(document().completeURL(href)), localName());\n        m_resource = fetcher-\u003efetchFont(request);\n        if (m_resource) {\n            m_resource-\u003eaddClient(this);\n            m_resource-\u003ebeginLoadIfNeeded(fetcher);\n        }\n    } else {\n        m_resource = 0;\n    }\n}\n\n}\n\n#endif // ENABLE(SVG_FONTS)\n"}
{"repo_name":"MobWiMetro/gba10","ref":"refs/heads/master","path":"GBA10/VBAM/gba/gbafilter.cpp","copies":"11","language":"C++","content":"#include \"gbafilter.h\"\n\n#include \u003cmath.h\u003e\n\nextern int systemColorDepth;\nextern int systemRedShift;\nextern int systemGreenShift;\nextern int systemBlueShift;\n\nextern u16 systemColorMap16[0x10000];\nextern u32 systemColorMap32[0x10000];\n\nstatic const unsigned char curve[32] = { 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0e, 0x10, 0x12,\n\t\t\t\t\t\t\t\t\t\t 0x14, 0x16, 0x18, 0x1c, 0x20, 0x28, 0x30, 0x38,\n\t\t\t\t\t\t\t\t\t\t 0x40, 0x48, 0x50, 0x58, 0x60, 0x68, 0x70, 0x80,\n\t\t\t\t\t\t\t\t\t\t 0x88, 0x90, 0xa0, 0xb0, 0xc0, 0xd0, 0xe0, 0xf0};\n\n//\t\t\t\t\t\t\t\toutput           R   G   B\nstatic const unsigned char influence[3 * 3] = { 16,  4,  4, // red\n\t\t\t\t\t\t\t\t\t\t\t\t 8, 16,  8, // green\n\t\t\t\t\t\t\t\t\t\t\t\t 0,  8, 16};// blue\n\ninline void swap(short \u0026 a, short \u0026 b)\n{\n\tshort temp = a;\n\ta = b;\n\tb = temp;\n}\n\nvoid gbafilter_pal(u16 * buf, int count)\n{\n\tshort temp[3 * 3], s;\n\tunsigned pix;\n\tu8 red, green, blue;\n\n\twhile (count--)\n\t{\n\t\tpix = *buf;\n\n\t\ts = curve[(pix \u003e\u003e systemGreenShift) \u0026 0x1f];\n\t\ttemp[3] = s * influence[3];\n\t\ttemp[4] = s * influence[4];\n\t\ttemp[5] = s * influence[5];\n\n\t\ts = curve[(pix \u003e\u003e systemRedShift) \u0026 0x1f];\n\t\ttemp[0] = s * influence[0];\n\t\ttemp[1] = s * influence[1];\n\t\ttemp[2] = s * influence[2];\n\n\t\ts = curve[(pix \u003e\u003e systemBlueShift) \u0026 0x1f];\n\t\ttemp[6] = s * influence[6];\n\t\ttemp[7] = s * influence[7];\n\t\ttemp[8] = s * influence[8];\n\n\t\tif (temp[0] \u003c temp[3]) swap(temp[0], temp[3]);\n\t\tif (temp[0] \u003c temp[6]) swap(temp[0], temp[6]);\n\t\tif (temp[3] \u003c temp[6]) swap(temp[3], temp[6]);\n\t\ttemp[3] \u003c\u003c= 1;\n\t\ttemp[0] \u003c\u003c= 2;\n\t\ttemp[0] += temp[3] + temp[6];\n\n\t\tred = ((int(temp[0]) * 160) \u003e\u003e 17) + 4;\n\t\tif (red \u003e 31) red = 31;\n\n\t\tif (temp[2] \u003c temp[5]) swap(temp[2], temp[5]);\n\t\tif (temp[2] \u003c temp[8]) swap(temp[2], temp[8]);\n\t\tif (temp[5] \u003c temp[8]) swap(temp[5], temp[8]);\n\t\ttemp[5] \u003c\u003c= 1;\n\t\ttemp[2] \u003c\u003c= 2;\n\t\ttemp[2] += temp[5] + temp[8];\n\n\t\tblue = ((int(temp[2]) * 160) \u003e\u003e 17) + 4;\n\t\tif (blue \u003e 31) blue = 31;\n\n\t\tif (temp[1] \u003c temp[4]) swap(temp[1], temp[4]);\n\t\tif (temp[1] \u003c temp[7]) swap(temp[1], temp[7]);\n\t\tif (temp[4] \u003c temp[7]) swap(temp[4], temp[7]);\n\t\ttemp[4] \u003c\u003c= 1;\n\t\ttemp[1] \u003c\u003c= 2;\n\t\ttemp[1] += temp[4] + temp[7];\n\n\t\tgreen = ((int(temp[1]) * 160) \u003e\u003e 17) + 4;\n\t\tif (green \u003e 31) green = 31;\n\n\t\tpix  = red \u003c\u003c systemRedShift;\n\t\tpix += green \u003c\u003c systemGreenShift;\n\t\tpix += blue \u003c\u003c systemBlueShift;\n\n\t\t*buf++ = pix;\n\t}\n}\n\nvoid gbafilter_pal32(u32 * buf, int count)\n{\n\tshort temp[3 * 3], s;\n\tunsigned pix;\n\tu8 red, green, blue;\n\n\twhile (count--)\n\t{\n\t\tpix = *buf;\n\n\t\ts = curve[(pix \u003e\u003e systemGreenShift) \u0026 0x1f];\n\t\ttemp[3] = s * influence[3];\n\t\ttemp[4] = s * influence[4];\n\t\ttemp[5] = s * influence[5];\n\n\t\ts = curve[(pix \u003e\u003e systemRedShift) \u0026 0x1f];\n\t\ttemp[0] = s * influence[0];\n\t\ttemp[1] = s * influence[1];\n\t\ttemp[2] = s * influence[2];\n\n\t\ts = curve[(pix \u003e\u003e systemBlueShift) \u0026 0x1f];\n\t\ttemp[6] = s * influence[6];\n\t\ttemp[7] = s * influence[7];\n\t\ttemp[8] = s * influence[8];\n\n\t\tif (temp[0] \u003c temp[3]) swap(temp[0], temp[3]);\n\t\tif (temp[0] \u003c temp[6]) swap(temp[0], temp[6]);\n\t\tif (temp[3] \u003c temp[6]) swap(temp[3], temp[6]);\n\t\ttemp[3] \u003c\u003c= 1;\n\t\ttemp[0] \u003c\u003c= 2;\n\t\ttemp[0] += temp[3] + temp[6];\n\n\t\t//red = ((int(temp[0]) * 160) \u003e\u003e 17) + 4;\n\t\tred = ((int(temp[0]) * 160) \u003e\u003e 14) + 32;\n\n\t\tif (temp[2] \u003c temp[5]) swap(temp[2], temp[5]);\n\t\tif (temp[2] \u003c temp[8]) swap(temp[2], temp[8]);\n\t\tif (temp[5] \u003c temp[8]) swap(temp[5], temp[8]);\n\t\ttemp[5] \u003c\u003c= 1;\n\t\ttemp[2] \u003c\u003c= 2;\n\t\ttemp[2] += temp[5] + temp[8];\n\n\t\t//blue = ((int(temp[2]) * 160) \u003e\u003e 17) + 4;\n\t\tblue = ((int(temp[2]) * 160) \u003e\u003e 14) + 32;\n\n\t\tif (temp[1] \u003c temp[4]) swap(temp[1], temp[4]);\n\t\tif (temp[1] \u003c temp[7]) swap(temp[1], temp[7]);\n\t\tif (temp[4] \u003c temp[7]) swap(temp[4], temp[7]);\n\t\ttemp[4] \u003c\u003c= 1;\n\t\ttemp[1] \u003c\u003c= 2;\n\t\ttemp[1] += temp[4] + temp[7];\n\n\t\t//green = ((int(temp[1]) * 160) \u003e\u003e 17) + 4;\n\t\tgreen = ((int(temp[1]) * 160) \u003e\u003e 14) + 32;\n\n\t\t//pix  = red \u003c\u003c redshift;\n\t\t//pix += green \u003c\u003c greenshift;\n\t\t//pix += blue \u003c\u003c blueshift;\n\n\t\tpix  = red \u003c\u003c (systemRedShift - 3);\n\t\tpix += green \u003c\u003c (systemGreenShift - 3);\n\t\tpix += blue \u003c\u003c (systemBlueShift - 3);\n\n\t\t*buf++ = pix;\n\t}\n}\n\n// for palette mode to work with the three spoony filters in 32bpp depth\n\nvoid gbafilter_pad(u8 * buf, int count)\n{\n\tunion\n\t{\n\t\tstruct\n\t\t{\n\t\t\tu8 r;\n\t\t\tu8 g;\n\t\t\tu8 b;\n\t\t\tu8 a;\n\t\t} part;\n\t\tunsigned whole;\n\t}\n\tmask;\n\n\tmask.whole  = 0x1f \u003c\u003c systemRedShift;\n\tmask.whole += 0x1f \u003c\u003c systemGreenShift;\n\tmask.whole += 0x1f \u003c\u003c systemBlueShift;\n\n\tswitch (systemColorDepth)\n\t{\n\tcase 24:\n\t\twhile (count--)\n\t\t{\n\t\t\t*buf++ \u0026= mask.part.r;\n\t\t\t*buf++ \u0026= mask.part.g;\n\t\t\t*buf++ \u0026= mask.part.b;\n\t\t}\n\t\tbreak;\n\tcase 32:\n\t\twhile (count--)\n\t\t{\n\t\t\t*((u32*)buf) \u0026= mask.whole;\n\t\t\tbuf += 4;\n\t\t}\n\t}\n}\n\n/*\nvoid UpdateSystemColorMaps(int lcd)\n{\n  switch(systemColorDepth) {\n  case 16:\n    {\n      for(int i = 0; i \u003c 0x10000; i++) {\n        systemColorMap16[i] = ((i \u0026 0x1f) \u003c\u003c systemRedShift) |\n          (((i \u0026 0x3e0) \u003e\u003e 5) \u003c\u003c systemGreenShift) |\n          (((i \u0026 0x7c00) \u003e\u003e 10) \u003c\u003c systemBlueShift);\n      }\n\t  if (lcd == 1) gbafilter_pal(systemColorMap16, 0x10000);\n    }\n    break;\n  case 24:\n  case 32:\n    {\n      for(int i = 0; i \u003c 0x10000; i++) {\n        systemColorMap32[i] = ((i \u0026 0x1f) \u003c\u003c systemRedShift) |\n          (((i \u0026 0x3e0) \u003e\u003e 5) \u003c\u003c systemGreenShift) |\n          (((i \u0026 0x7c00) \u003e\u003e 10) \u003c\u003c systemBlueShift);\n      }\n\t  if (lcd == 1) gbafilter_pal32(systemColorMap32, 0x10000);\n    }\n    break;\n  }\n}\n*/\n"}
{"repo_name":"YelaSeamless/mysql-server","ref":"refs/heads/5.7","path":"storage/ndb/test/ndbapi/testLimits.cpp","copies":"32","language":"C++","content":"/* Copyright (c) 2008, 2014, Oracle and/or its affiliates. All rights reserved.\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; version 2 of the License.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA */\n\n#include \u003cNDBT.hpp\u003e\n#include \u003cNDBT_Test.hpp\u003e\n#include \u003cNdbRestarter.hpp\u003e\n\n#define CHECKNOTNULL(p) if ((p) == NULL) {          \\\n    ndbout \u003c\u003c \"Error at line \" \u003c\u003c __LINE__ \u003c\u003c endl; \\\n    NDB_ERR(trans-\u003egetNdbError());                  \\\n    trans-\u003eclose();                                 \\\n    return NDBT_FAILED; }\n\n#define CHECKEQUAL(v, e) if ((e) != (v)) {            \\\n    ndbout \u003c\u003c \"Error at line \" \u003c\u003c __LINE__ \u003c\u003c         \\\n      \" expected \" \u003c\u003c v \u003c\u003c endl;                      \\\n    NDB_ERR(trans-\u003egetNdbError());                    \\\n    trans-\u003eclose();                                   \\\n    return NDBT_FAILED; }\n\n\n/* Setup memory as a long Varchar with 2 bytes of\n * length information\n */\nUint32 setLongVarchar(char* where, const char* what, Uint32 sz)\n{\n  where[0]=sz \u0026 0xff;\n  where[1]=(sz \u003e\u003e 8) \u0026 0xff;\n  memcpy(\u0026where[2], what, sz);\n  return (sz + 2);\n}\n\n\n/* Activate the given error insert in TC block\n * This is used for error insertion where a TCKEYREQ\n * is required to activate the error\n */\nint activateErrorInsert(NdbTransaction* trans, \n                        const NdbRecord* record,\n                        const NdbDictionary::Table* tab,\n                        const char* buf,\n                        NdbRestarter* restarter, \n                        Uint32 val)\n{\n  /* We insert the error twice to avoid what appear to be\n   * races between the error insert and the subsequent\n   * tests\n   * Alternatively we could sleep here.\n   */\n  if (restarter-\u003einsertErrorInAllNodes(val) != 0){\n    g_err \u003c\u003c \"error insert 1 (\" \u003c\u003c val \u003c\u003c \") failed\" \u003c\u003c endl;\n    return NDBT_FAILED;\n  }\n  if (restarter-\u003einsertErrorInAllNodes(val) != 0){\n    g_err \u003c\u003c \"error insert 2 (\" \u003c\u003c val \u003c\u003c \") failed\" \u003c\u003c endl;\n    return NDBT_FAILED;\n  }\n\n  NdbOperation* insert= trans-\u003egetNdbOperation(tab);\n  \n  CHECKNOTNULL(insert);\n\n  CHECKEQUAL(0, insert-\u003einsertTuple());\n\n  CHECKEQUAL(0, insert-\u003eequal((Uint32) 0, \n                              NdbDictionary::getValuePtr\n                              (record,\n                               buf,\n                               0)));\n  CHECKEQUAL(0, insert-\u003esetValue(1,\n                                 NdbDictionary::getValuePtr\n                                 (record,\n                                  buf,\n                                  1)));\n\n  CHECKEQUAL(0, trans-\u003eexecute(NdbTransaction::NoCommit));\n\n  CHECKEQUAL(0, trans-\u003egetNdbError().code);\n\n  return NDBT_OK;\n}\n    \n/* Test for correct behaviour using primary key operations\n * when an NDBD node's SegmentedSection pool is exhausted.\n */\nint testSegmentedSectionPk(NDBT_Context* ctx, NDBT_Step* step){\n  /*\n   * Signal type       Exhausted @              How\n   * -----------------------------------------------------\n   * Long TCKEYREQ     Initial import           Consume + send\n   * Long TCKEYREQ     Initial import, not first\n   *                     TCKEYREQ in batch      Consume + send\n   * Long TCKEYREQ     Initial import, not last\n   *                     TCKEYREQ in batch      Consume + send\n   * No testing of short TCKEYREQ variants as they cannot be\n   * generated in mysql-5.1-telco-6.4+\n   * TODO : Add short variant testing to testUpgrade.\n   */\n\n  /* We just run on one table */\n  if (strcmp(ctx-\u003egetTab()-\u003egetName(), \"WIDE_2COL\") != 0)\n    return NDBT_OK;\n\n  const Uint32 maxRowBytes= NDB_MAX_TUPLE_SIZE_IN_WORDS * sizeof(Uint32);\n  const Uint32 maxKeyBytes= NDBT_Tables::MaxVarTypeKeyBytes;\n  const Uint32 maxAttrBytes= NDBT_Tables::MaxKeyMaxVarTypeAttrBytes;\n  const Uint32 srcBuffBytes= MAX(maxKeyBytes,maxAttrBytes);\n  char smallKey[50];\n  char srcBuff[srcBuffBytes];\n  char smallRowBuf[maxRowBytes];\n  char bigKeyRowBuf[maxRowBytes];\n  char bigAttrRowBuf[maxRowBytes];\n\n  /* Small key for hinting to same TC */\n  Uint32 smallKeySize= setLongVarchar(\u0026smallKey[0],\n                                      \"ShortKey\",\n                                      8);\n\n  /* Large value source */\n  memset(srcBuff, 'B', srcBuffBytes);\n\n  const NdbRecord* record= ctx-\u003egetTab()-\u003egetDefaultRecord();\n\n  /* Setup buffers\n   * Small row buffer with small key and small data\n   */ \n  setLongVarchar(NdbDictionary::getValuePtr(record,\n                                            smallRowBuf,\n                                            0),\n                 \"ShortKey\",\n                 8);\n  NdbDictionary::setNull(record, smallRowBuf, 0, false);\n\n  setLongVarchar(NdbDictionary::getValuePtr(record,\n                                            smallRowBuf,\n                                            1),\n                 \"ShortData\",\n                 9);\n  NdbDictionary::setNull(record, smallRowBuf, 1, false);\n\n  /* Big key buffer with big key and small data*/\n  setLongVarchar(NdbDictionary::getValuePtr(record,\n                                            bigKeyRowBuf,\n                                            0),\n                 \u0026srcBuff[0],\n                 maxKeyBytes);\n  NdbDictionary::setNull(record, bigKeyRowBuf, 0, false);\n\n  setLongVarchar(NdbDictionary::getValuePtr(record,\n                                            bigKeyRowBuf,\n                                            1),\n                 \"ShortData\",\n                 9);\n  NdbDictionary::setNull(record, bigKeyRowBuf, 1, false);\n\n  /* Big AttrInfo buffer with small key and big data */\n  setLongVarchar(NdbDictionary::getValuePtr(record,\n                                            bigAttrRowBuf,\n                                            0),\n                 \"ShortKey\", \n                 8);\n  NdbDictionary::setNull(record, bigAttrRowBuf, 0, false);\n\n  setLongVarchar(NdbDictionary::getValuePtr(record,\n                                            bigAttrRowBuf,\n                                            1),\n                 \u0026srcBuff[0],\n                 maxAttrBytes);\n  NdbDictionary::setNull(record, bigAttrRowBuf, 1, false);\n\n  NdbRestarter restarter;\n  Ndb* pNdb= GETNDB(step);\n\n  /* Start a transaction on a specific node */\n  NdbTransaction* trans= pNdb-\u003estartTransaction(ctx-\u003egetTab(),\n                                                \u0026smallKey[0],\n                                                smallKeySize);\n  CHECKNOTNULL(trans);\n\n  /* Activate error insert 8065 in this transaction, limits\n   * any single import/append to 1 section\n   */\n  CHECKEQUAL(NDBT_OK, activateErrorInsert(trans, \n                                          record, \n                                          ctx-\u003egetTab(),\n                                          smallRowBuf, \n                                          \u0026restarter, \n                                          8065));\n\n  /* Ok, let's try an insert with a key bigger than 1 section.\n   * Since it's part of the same transaction, it'll go via\n   * the same TC.\n   */\n  const NdbOperation* bigInsert = trans-\u003einsertTuple(record, bigKeyRowBuf);\n\n  CHECKNOTNULL(bigInsert);\n\n  CHECKEQUAL(-1, trans-\u003eexecute(NdbTransaction::NoCommit));\n\n  /* ZGET_DATABUF_ERR expected */\n  CHECKEQUAL(218, trans-\u003egetNdbError().code)\n\n  trans-\u003eclose();\n  \n  /* Ok, now a long TCKEYREQ to the same TC - this\n   * has slightly different abort handling since no other\n   * operations exist in this new transaction.\n   * We also change it so that import overflow occurs \n   * on the AttrInfo section\n   */\n  /* Start transaction on the same node */\n  CHECKNOTNULL(trans= pNdb-\u003estartTransaction(ctx-\u003egetTab(),\n                                             \u0026smallKey[0],\n                                             smallKeySize));\n\n\n  CHECKNOTNULL(bigInsert = trans-\u003einsertTuple(record, bigAttrRowBuf));\n\n  CHECKEQUAL(-1,trans-\u003eexecute(NdbTransaction::NoCommit));\n\n  /* ZGET_DATABUF_ERR expected */\n  CHECKEQUAL(218, trans-\u003egetNdbError().code);\n\n  trans-\u003eclose();\n\n  /* Ok, now a long TCKEYREQ where we run out of SegmentedSections\n   * on the first TCKEYREQ, but there are other TCKEYREQs following\n   * in the same batch.  Check that abort handling is correct\n   */\n    /* Start transaction on the same node */\n  CHECKNOTNULL(trans= pNdb-\u003estartTransaction(ctx-\u003egetTab(),\n                                             \u0026smallKey[0],\n                                             smallKeySize));\n  /* First op in batch, will cause overflow */\n  CHECKNOTNULL(bigInsert = trans-\u003einsertTuple(record, bigAttrRowBuf));\n  \n  /* Second op in batch, what happens to it? */\n  const NdbOperation* secondOp;\n  CHECKNOTNULL(secondOp = trans-\u003einsertTuple(record, bigAttrRowBuf));\n\n\n  CHECKEQUAL(-1,trans-\u003eexecute(NdbTransaction::NoCommit));\n\n  /* ZGET_DATABUF_ERR expected */\n  CHECKEQUAL(218, trans-\u003egetNdbError().code);\n\n  trans-\u003eclose();\n\n  /* Now try with a 'short' TCKEYREQ, generated using the old Api \n   * with a big key value\n   */\n  /* Start transaction on the same node */\n  CHECKNOTNULL(trans= pNdb-\u003estartTransaction(ctx-\u003egetTab(),\n                                             \u0026smallKey[0],\n                                             smallKeySize));\n  \n  NdbOperation* bigInsertOldApi;\n  CHECKNOTNULL(bigInsertOldApi= trans-\u003egetNdbOperation(ctx-\u003egetTab()));\n\n  CHECKEQUAL(0, bigInsertOldApi-\u003einsertTuple());\n  CHECKEQUAL(0, bigInsertOldApi-\u003eequal((Uint32)0, \n                                       NdbDictionary::getValuePtr\n                                       (record,\n                                        bigKeyRowBuf,\n                                        0)));\n  CHECKEQUAL(0, bigInsertOldApi-\u003esetValue(1, \n                                          NdbDictionary::getValuePtr\n                                          (record,\n                                           bigKeyRowBuf,\n                                           1)));\n\n  CHECKEQUAL(-1, trans-\u003eexecute(NdbTransaction::NoCommit));\n\n  /* ZGET_DATABUF_ERR expected */\n  CHECKEQUAL(218, trans-\u003egetNdbError().code)\n\n  trans-\u003eclose();\n\n  /* Now try with a 'short' TCKEYREQ, generated using the old Api \n   * with a big data value\n   */\n  CHECKNOTNULL(trans= pNdb-\u003estartTransaction(ctx-\u003egetTab(),\n                                             \u0026smallKey[0],\n                                             smallKeySize));\n  \n  CHECKNOTNULL(bigInsertOldApi= trans-\u003egetNdbOperation(ctx-\u003egetTab()));\n\n  CHECKEQUAL(0, bigInsertOldApi-\u003einsertTuple());\n  CHECKEQUAL(0, bigInsertOldApi-\u003eequal((Uint32)0, \n                                       NdbDictionary::getValuePtr\n                                       (record,\n                                        bigAttrRowBuf,\n                                        0)));\n  CHECKEQUAL(0, bigInsertOldApi-\u003esetValue(1, \n                                          NdbDictionary::getValuePtr\n                                          (record,\n                                           bigAttrRowBuf,\n                                           1)));\n\n  CHECKEQUAL(-1, trans-\u003eexecute(NdbTransaction::NoCommit));\n\n  /* ZGET_DATABUF_ERR expected */\n  CHECKEQUAL(218, trans-\u003egetNdbError().code)\n\n  trans-\u003eclose();\n\n  // TODO : Add code to testUpgrade\n#if 0\n  /*\n   * Short TCKEYREQ    KeyInfo accumulate       Consume + send long\n   *                     (TCKEYREQ + KEYINFO)\n   * Short TCKEYREQ    AttrInfo accumulate      Consume + send short key\n   *                                             + long AI\n   *                      (TCKEYREQ + ATTRINFO)\n   */\n  /* Change error insert so that next TCKEYREQ will grab\n   * all but one SegmentedSection so that we can then test SegmentedSection\n   * exhaustion when importing the Key/AttrInfo words from the\n   * TCKEYREQ signal itself.\n   */\n  restarter.insertErrorInAllNodes(8066);\n\n\n  /* Now a 'short' TCKEYREQ, there will be space to import the\n   * short key, but not the AttrInfo\n   */\n  /* Start transaction on same node */\n  CHECKNOTNULL(trans= pNdb-\u003estartTransaction(ctx-\u003egetTab(),\n                                             \u0026smallKey[0],\n                                             smallKeySize));\n  \n  CHECKNOTNULL(bigInsertOldApi= trans-\u003egetNdbOperation(ctx-\u003egetTab()));\n  \n  CHECKEQUAL(0, bigInsertOldApi-\u003einsertTuple());\n  CHECKEQUAL(0, bigInsertOldApi-\u003eequal((Uint32)0, \n                                       NdbDictionary::getValuePtr\n                                       (record,\n                                        smallRowBuf,\n                                        0)));\n  CHECKEQUAL(0, bigInsertOldApi-\u003esetValue(1, NdbDictionary::getValuePtr\n                                          (record,\n                                           smallRowBuf,\n                                           1)));\n\n  CHECKEQUAL(-1, trans-\u003eexecute(NdbTransaction::NoCommit));\n\n  /* ZGET_DATABUF_ERR expected */\n  CHECKEQUAL(218, trans-\u003egetNdbError().code)\n\n  trans-\u003eclose();\n\n  /* Change error insert so that there are no SectionSegments \n   * This will cause failure when attempting to import the\n   * KeyInfo from the TCKEYREQ\n   */\n  restarter.insertErrorInAllNodes(8067);\n\n  /* Now a 'short' TCKEYREQ - there will be no space to import the key */\n  CHECKNOTNULL(trans= pNdb-\u003estartTransaction(ctx-\u003egetTab(),\n                                             \u0026smallKey[0],\n                                             smallKeySize));\n  \n  CHECKNOTNULL(bigInsertOldApi= trans-\u003egetNdbOperation(ctx-\u003egetTab()));\n  \n  CHECKEQUAL(0, bigInsertOldApi-\u003einsertTuple());\n  CHECKEQUAL(0, bigInsertOldApi-\u003eequal((Uint32)0, \n                                       NdbDictionary::getValuePtr\n                                       (record,\n                                        smallRowBuf,\n                                        0)));\n  CHECKEQUAL(0, bigInsertOldApi-\u003esetValue(1, \n                                          NdbDictionary::getValuePtr\n                                          (record,\n                                           smallRowBuf,\n                                           1)));\n\n  CHECKEQUAL(-1, trans-\u003eexecute(NdbTransaction::NoCommit));\n\n  /* ZGET_DATABUF_ERR expected */\n  CHECKEQUAL(218, trans-\u003egetNdbError().code)\n\n  trans-\u003eclose();  \n#endif\n\n  /* Finished with error insert, cleanup the error insertion\n   * Error insert 8068 will free the hoarded segments\n   */\n  CHECKNOTNULL(trans= pNdb-\u003estartTransaction(ctx-\u003egetTab(),\n                                             \u0026smallKey[0],\n                                             smallKeySize));\n\n  CHECKEQUAL(NDBT_OK, activateErrorInsert(trans, \n                                          record, \n                                          ctx-\u003egetTab(),\n                                          smallRowBuf, \n                                          \u0026restarter, \n                                          8068));\n\n  trans-\u003eexecute(NdbTransaction::Rollback);\n  \n  CHECKEQUAL(0, trans-\u003egetNdbError().code);\n\n  trans-\u003eclose();\n\n  return NDBT_OK;\n}\n  \n/* Test for correct behaviour using unique key operations\n * when an NDBD node's SegmentedSection pool is exhausted.\n */\nint testSegmentedSectionIx(NDBT_Context* ctx, NDBT_Step* step){\n  /* \n   * Signal type       Exhausted @              How\n   * -----------------------------------------------------\n   * Long TCINDXREQ    Initial import           Consume + send \n   * Long TCINDXREQ    Build second TCKEYREQ    Consume + send short\n   *                                             w. long base key\n   */\n  /* We will generate : \n   *   10 SS left : \n   *     Long IndexReq with too long Key/AttrInfo\n   *    1 SS left :\n   *     Long IndexReq read with short Key + Attrinfo to long \n   *       base table Key\n   */\n  /* We just run on one table */\n  if (strcmp(ctx-\u003egetTab()-\u003egetName(), \"WIDE_2COL_IX\") != 0)\n    return NDBT_OK;\n\n  const char* indexName= \"WIDE_2COL_IX$NDBT_IDX0\";\n  const Uint32 maxRowBytes= NDB_MAX_TUPLE_SIZE_IN_WORDS * sizeof(Uint32);\n  const Uint32 srcBuffBytes= NDBT_Tables::MaxVarTypeKeyBytes;\n  const Uint32 maxIndexKeyBytes= NDBT_Tables::MaxKeyMaxVarTypeAttrBytesIndex;\n  /* We want to use 6 Segmented Sections, each of 60 32-bit words, including\n   * a 2 byte length overhead\n   * (We don't want to use 10 Segmented Sections as in some scenarios TUP \n   *  uses Segmented Sections when sending results, and if we use TUP on\n   *  the same node, the exhaustion will occur in TUP, which is not what\n   *  we're testing)\n   */\n  const Uint32 mediumPrimaryKeyBytes= (6* 60 * 4) - 2;\n  char smallKey[50];\n  char srcBuff[srcBuffBytes];\n  char smallRowBuf[maxRowBytes];\n  char bigKeyIxBuf[maxRowBytes];\n  char bigAttrIxBuf[maxRowBytes];\n  char bigKeyRowBuf[maxRowBytes];\n  char resultSpace[maxRowBytes];\n\n  /* Small key for hinting to same TC */\n  Uint32 smallKeySize= setLongVarchar(\u0026smallKey[0],\n                                      \"ShortKey\",\n                                      8);\n\n  /* Large value source */\n  memset(srcBuff, 'B', srcBuffBytes);\n\n  Ndb* pNdb= GETNDB(step);\n\n  const NdbRecord* baseRecord= ctx-\u003egetTab()-\u003egetDefaultRecord();\n  const NdbRecord* ixRecord= pNdb-\u003e\n    getDictionary()-\u003egetIndex(indexName,\n                              ctx-\u003egetTab()-\u003egetName())-\u003egetDefaultRecord();\n\n  /* Setup buffers\n   * Small row buffer with short key and data in base table record format\n   */ \n  setLongVarchar(NdbDictionary::getValuePtr(baseRecord,\n                                            smallRowBuf,\n                                            0),\n                 \"ShortKey\",\n                 8);\n  NdbDictionary::setNull(baseRecord, smallRowBuf, 0, false);\n\n  setLongVarchar(NdbDictionary::getValuePtr(baseRecord,\n                                            smallRowBuf,\n                                            1),\n                 \"ShortData\",\n                 9);\n  NdbDictionary::setNull(baseRecord, smallRowBuf, 1, false);\n\n  /* Big index key buffer\n   * Big index key (normal row attribute) in index record format\n   * Index's key is attrid 1 from the base table\n   * This could get confusing !\n   */\n  \n  setLongVarchar(NdbDictionary::getValuePtr(ixRecord,\n                                            bigKeyIxBuf,\n                                            1),\n                 \u0026srcBuff[0],\n                 maxIndexKeyBytes);\n  NdbDictionary::setNull(ixRecord, bigKeyIxBuf, 1, false);\n\n  /* Big AttrInfo buffer\n   * Small key and large attrinfo in base table record format */\n  setLongVarchar(NdbDictionary::getValuePtr(baseRecord,\n                                            bigAttrIxBuf,\n                                            0),\n                 \"ShortIXKey\", \n                 10);\n\n  NdbDictionary::setNull(baseRecord, bigAttrIxBuf, 0, false);\n\n  setLongVarchar(NdbDictionary::getValuePtr(baseRecord,\n                                            bigAttrIxBuf,\n                                            1),\n                 \u0026srcBuff[0],\n                 maxIndexKeyBytes);\n  NdbDictionary::setNull(baseRecord, bigAttrIxBuf, 1, false);\n\n  /* Big key row buffer \n   * Medium sized key and small attrinfo (index key) in\n   * base table record format\n   */\n  setLongVarchar(NdbDictionary::getValuePtr(baseRecord,\n                                            bigKeyRowBuf,\n                                            0),\n                 \u0026srcBuff[0], \n                 mediumPrimaryKeyBytes);\n\n  NdbDictionary::setNull(baseRecord, bigKeyRowBuf, 0, false);\n\n  setLongVarchar(NdbDictionary::getValuePtr(baseRecord,\n                                            bigKeyRowBuf,\n                                            1),\n                 \"ShortIXKey\",\n                 10);\n  NdbDictionary::setNull(baseRecord, bigKeyRowBuf, 1, false);\n\n\n  /* Start a transaction on a specific node */\n  NdbTransaction* trans= pNdb-\u003estartTransaction(ctx-\u003egetTab(),\n                                                \u0026smallKey[0],\n                                                smallKeySize);\n  /* Insert a row in the base table with a big PK, and\n   * small data (Unique IX key).  This is used later to lookup\n   * a big PK and cause overflow when reading TRANSID_AI in TC.\n   */\n  CHECKNOTNULL(trans-\u003einsertTuple(baseRecord,\n                                  bigKeyRowBuf));\n\n  CHECKEQUAL(0, trans-\u003eexecute(NdbTransaction::Commit));\n\n  NdbRestarter restarter;\n  /* Start a transaction on a specific node */\n  trans= pNdb-\u003estartTransaction(ctx-\u003egetTab(),\n                                \u0026smallKey[0],\n                                smallKeySize);\n  CHECKNOTNULL(trans);\n\n  /* Activate error insert 8065 in this transaction, limits any\n   * single append/import to 10 sections.\n   */\n  CHECKEQUAL(NDBT_OK, activateErrorInsert(trans, \n                                          baseRecord, \n                                          ctx-\u003egetTab(),\n                                          smallRowBuf, \n                                          \u0026restarter, \n                                          8065));\n\n  /* Ok, let's try an index read with a big index key.\n   * Since it's part of the same transaction, it'll go via\n   * the same TC.\n   */\n  const NdbOperation* bigRead= trans-\u003ereadTuple(ixRecord,\n                                                bigKeyIxBuf,\n                                                baseRecord,\n                                                resultSpace);\n\n  CHECKNOTNULL(bigRead);\n\n  CHECKEQUAL(-1, trans-\u003eexecute(NdbTransaction::NoCommit));\n\n  /* ZGET_DATABUF_ERR expected */\n  CHECKEQUAL(218, trans-\u003egetNdbError().code)\n\n  trans-\u003eclose();\n\n  \n  /* Ok, now a long TCINDXREQ to the same TC - this\n   * has slightly different abort handling since no other\n   * operations exist in this new transaction.\n   */\n  /* Start a transaction on a specific node */\n  CHECKNOTNULL(trans= pNdb-\u003estartTransaction(ctx-\u003egetTab(),\n                                             \u0026smallKey[0],\n                                             smallKeySize));\n\n  CHECKNOTNULL(trans-\u003ereadTuple(ixRecord,\n                                bigKeyIxBuf,\n                                baseRecord,\n                                resultSpace));\n  \n  CHECKEQUAL(-1, trans-\u003eexecute(NdbTransaction::NoCommit));\n\n  /* ZGET_DATABUF_ERR expected */\n  CHECKEQUAL(218, trans-\u003egetNdbError().code);\n  \n  trans-\u003eclose();\n\n  /* Now a TCINDXREQ that overflows, but is not the last in the\n   * batch, what happens to the other TCINDXREQ in the batch?\n   */\n  CHECKNOTNULL(trans= pNdb-\u003estartTransaction(ctx-\u003egetTab(),\n                                             \u0026smallKey[0],\n                                             smallKeySize));\n\n  CHECKNOTNULL(trans-\u003ereadTuple(ixRecord,\n                                bigKeyIxBuf,\n                                baseRecord,\n                                resultSpace));\n  /* Another read */\n  CHECKNOTNULL(trans-\u003ereadTuple(ixRecord,\n                                bigKeyIxBuf,\n                                baseRecord,\n                                resultSpace));\n  \n  CHECKEQUAL(-1, trans-\u003eexecute(NdbTransaction::NoCommit));\n\n  /* ZGET_DATABUF_ERR expected */\n  CHECKEQUAL(218, trans-\u003egetNdbError().code);\n  \n  trans-\u003eclose();\n\n\n  /* Next we read a tuple with a large primary key via the unique\n   * index.  The index read itself should be fine, but\n   * pulling in the base table PK will cause abort due to overflow\n   * handling TRANSID_AI\n   */\n  /* Start a transaction on a specific node */\n  CHECKNOTNULL(trans= pNdb-\u003estartTransaction(ctx-\u003egetTab(),\n                                             \u0026smallKey[0],\n                                             smallKeySize));\n\n  /* Activate error insert 8066 in this transaction, limits a\n   * single import/append to 1 section.\n   * Note that the TRANSID_AI is received by TC as a short-signal\n   * train, so no single append is large, but when the first\n   * segment is used and append starts on the second, it will\n   * fail.\n   */\n  CHECKEQUAL(NDBT_OK, activateErrorInsert(trans, \n                                          baseRecord, \n                                          ctx-\u003egetTab(),\n                                          smallRowBuf, \n                                          \u0026restarter, \n                                          8066));\n  CHECKEQUAL(0, trans-\u003eexecute(NdbTransaction::NoCommit));\n  \n  CHECKNOTNULL(bigRead= trans-\u003ereadTuple(ixRecord,\n                                         bigAttrIxBuf,\n                                         baseRecord,\n                                         resultSpace));\n\n  CHECKEQUAL(-1, trans-\u003eexecute(NdbTransaction::NoCommit));\n\n  /* ZGET_DATABUF_ERR expected */\n  CHECKEQUAL(218, trans-\u003egetNdbError().code)\n\n  trans-\u003eclose();\n\n  // TODO Move short signal testing to testUpgrade\n#if 0\n  /*\n   * Short TCINDXREQ   KeyInfo accumulate       Consume + send long\n   *                     (TCINDXREQ + KEYINFO)\n   * Short TCINDXREQ   AttrInfo accumulate      Consume + send short key\n   *                                             + long AI\n   *                     (TCINDXREQ + ATTRINFO)\n   */\n  /* Now try with a 'short' TCINDXREQ, generated using the old Api \n   * with a big index key value\n   */\n  CHECKNOTNULL(trans= pNdb-\u003estartTransaction(ctx-\u003egetTab(),\n                                             \u0026smallKey[0],\n                                             smallKeySize));\n  \n  const NdbDictionary::Index* index;\n  CHECKNOTNULL(index= pNdb-\u003egetDictionary()-\u003e\n               getIndex(indexName,\n                        ctx-\u003egetTab()-\u003egetName()));\n\n  NdbIndexOperation* bigReadOldApi;\n  CHECKNOTNULL(bigReadOldApi= trans-\u003egetNdbIndexOperation(index));\n\n  CHECKEQUAL(0, bigReadOldApi-\u003ereadTuple());\n  /* We use the attribute id of the index, not the base table here */\n  CHECKEQUAL(0, bigReadOldApi-\u003eequal((Uint32)0, \n                                     NdbDictionary::getValuePtr\n                                     (ixRecord,\n                                      bigKeyIxBuf,\n                                      1)));\n\n  CHECKNOTNULL(bigReadOldApi-\u003egetValue((Uint32)1));\n\n  CHECKEQUAL(-1, trans-\u003eexecute(NdbTransaction::NoCommit));\n\n  /* ZGET_DATABUF_ERR expected */\n  CHECKEQUAL(218, trans-\u003egetNdbError().code)\n\n  trans-\u003eclose();\n\n  /* Now try with a 'short' TCINDXREQ, generated using the old Api \n   * with a big attrinfo value\n   */\n  CHECKNOTNULL(trans= pNdb-\u003estartTransaction(ctx-\u003egetTab(),\n                                             \u0026smallKey[0],\n                                             smallKeySize));\n  \n  NdbIndexOperation* bigUpdateOldApi;\n  CHECKNOTNULL(bigUpdateOldApi= trans-\u003egetNdbIndexOperation(index));\n\n  CHECKEQUAL(0, bigUpdateOldApi-\u003eupdateTuple());\n  /* We use the attribute id of the index, not the base table here */\n  CHECKEQUAL(0, bigUpdateOldApi-\u003eequal((Uint32)0, \n                                       NdbDictionary::getValuePtr\n                                       (baseRecord,\n                                        smallRowBuf,\n                                        1)));\n\n  CHECKEQUAL(0, bigUpdateOldApi-\u003esetValue((Uint32)1,\n                                          NdbDictionary::getValuePtr\n                                          (baseRecord,\n                                           bigAttrIxBuf,\n                                           1)));\n  \n  CHECKEQUAL(-1, trans-\u003eexecute(NdbTransaction::NoCommit));\n\n  /* ZGET_DATABUF_ERR expected */\n  CHECKEQUAL(218, trans-\u003egetNdbError().code)\n\n  trans-\u003eclose();\n\n  /* Change error insert so that next TCINDXREQ will grab\n   * all but one SegmentedSection\n   */\n  restarter.insertErrorInAllNodes(8066);\n\n  /* Now a short TCINDXREQ where the KeyInfo from the TCINDXREQ\n   * can be imported, but the ATTRINFO can't\n   */\n  CHECKNOTNULL(trans= pNdb-\u003estartTransaction(ctx-\u003egetTab(),\n                                             \u0026smallKey[0],\n                                             smallKeySize));\n  \n  CHECKNOTNULL(bigUpdateOldApi= trans-\u003egetNdbIndexOperation(index));\n\n  CHECKEQUAL(0, bigUpdateOldApi-\u003eupdateTuple());\n  /* We use the attribute id of the index, not the base table here */\n  CHECKEQUAL(0, bigUpdateOldApi-\u003eequal((Uint32)0, \n                                       NdbDictionary::getValuePtr\n                                       (baseRecord,\n                                        smallRowBuf,\n                                        1)));\n\n  CHECKEQUAL(0, bigUpdateOldApi-\u003esetValue((Uint32)1,\n                                          NdbDictionary::getValuePtr\n                                          (baseRecord,\n                                           bigAttrIxBuf,\n                                           1)));\n  \n  CHECKEQUAL(-1, trans-\u003eexecute(NdbTransaction::NoCommit));\n\n  /* ZGET_DATABUF_ERR expected */\n  CHECKEQUAL(218, trans-\u003egetNdbError().code)\n\n  trans-\u003eclose();\n\n  /* Change error insert so that there are no SectionSegments */\n  restarter.insertErrorInAllNodes(8067);\n\n  /* Now a short TCINDXREQ where the KeyInfo from the TCINDXREQ\n   * can't be imported\n   */\n  CHECKNOTNULL(trans= pNdb-\u003estartTransaction(ctx-\u003egetTab(),\n                                             \u0026smallKey[0],\n                                             smallKeySize));\n\n  CHECKNOTNULL(bigUpdateOldApi= trans-\u003egetNdbIndexOperation(index));\n\n  CHECKEQUAL(0, bigUpdateOldApi-\u003eupdateTuple());\n  /* We use the attribute id of the index, not the base table here */\n  CHECKEQUAL(0, bigUpdateOldApi-\u003eequal((Uint32)0, \n                                       NdbDictionary::getValuePtr\n                                       (baseRecord,\n                                        smallRowBuf,\n                                        1)));\n\n  CHECKEQUAL(0, bigUpdateOldApi-\u003esetValue((Uint32)1,\n                                          NdbDictionary::getValuePtr\n                                          (baseRecord,\n                                           bigAttrIxBuf,\n                                           1)));\n  \n  CHECKEQUAL(-1, trans-\u003eexecute(NdbTransaction::NoCommit));\n\n  /* ZGET_DATABUF_ERR expected */\n  CHECKEQUAL(218, trans-\u003egetNdbError().code)\n\n  trans-\u003eclose();\n\n#endif  \n\n  /* Finished with error insert, cleanup the error insertion */\n  CHECKNOTNULL(trans= pNdb-\u003estartTransaction(ctx-\u003egetTab(),\n                                             \u0026smallKey[0],\n                                             smallKeySize));\n\n  CHECKEQUAL(NDBT_OK, activateErrorInsert(trans, \n                                          baseRecord, \n                                          ctx-\u003egetTab(),\n                                          smallRowBuf, \n                                          \u0026restarter, \n                                          8068));\n\n  trans-\u003eexecute(NdbTransaction::Rollback);\n  \n  CHECKEQUAL(0, trans-\u003egetNdbError().code);\n\n  trans-\u003eclose();\n\n  return NDBT_OK;\n}\n\n\nint testSegmentedSectionScan(NDBT_Context* ctx, NDBT_Step* step){\n  /* Test that TC handling of segmented section exhaustion is\n   * correct\n   * Since NDBAPI always send long requests, that is all that\n   * we test\n   */\n    /* We just run on one table */\n  if (strcmp(ctx-\u003egetTab()-\u003egetName(), \"WIDE_2COL\") != 0)\n    return NDBT_OK;\n\n  const Uint32 maxRowBytes= NDB_MAX_TUPLE_SIZE_IN_WORDS * sizeof(Uint32);\n  char smallKey[50];\n  char smallRowBuf[maxRowBytes];\n\n  Uint32 smallKeySize= setLongVarchar(\u0026smallKey[0],\n                                      \"ShortKey\",\n                                      8);\n\n  const NdbRecord* record= ctx-\u003egetTab()-\u003egetDefaultRecord();\n\n  /* Setup buffers\n   * Small row buffer with small key and small data\n   */ \n  setLongVarchar(NdbDictionary::getValuePtr(record,\n                                            smallRowBuf,\n                                            0),\n                 \"ShortKey\",\n                 8);\n  NdbDictionary::setNull(record, smallRowBuf, 0, false);\n\n  setLongVarchar(NdbDictionary::getValuePtr(record,\n                                            smallRowBuf,\n                                            1),\n                 \"ShortData\",\n                 9);\n  NdbDictionary::setNull(record, smallRowBuf, 1, false);\n\n  NdbRestarter restarter;\n  Ndb* pNdb= GETNDB(step);\n\n  /* Start a transaction on a specific node */\n  NdbTransaction* trans= pNdb-\u003estartTransaction(ctx-\u003egetTab(),\n                                                \u0026smallKey[0],\n                                                smallKeySize);\n  CHECKNOTNULL(trans);\n\n  /* Activate error insert 8066 in this transaction, limits a \n   * single import/append to 1 section.\n   */\n  CHECKEQUAL(NDBT_OK, activateErrorInsert(trans, \n                                          record, \n                                          ctx-\u003egetTab(),\n                                          smallRowBuf, \n                                          \u0026restarter, \n                                          8066));\n\n  /* A scan will always send 2 long sections (Receiver Ids,\n   * AttrInfo)\n   * Let's start a scan with \u003e 2400 bytes of\n   * ATTRINFO and see what happens\n   */\n  NdbScanOperation* scan= trans-\u003egetNdbScanOperation(ctx-\u003egetTab());\n\n  CHECKNOTNULL(scan);\n\n  CHECKEQUAL(0, scan-\u003ereadTuples());\n\n  /* Create a particularly useless program */\n  NdbInterpretedCode prog;\n\n  for (Uint32 w=0; w \u003c 2500; w++)\n    CHECKEQUAL(0, prog.load_const_null(1));\n\n  CHECKEQUAL(0, prog.interpret_exit_ok());\n  CHECKEQUAL(0, prog.finalise());\n\n  CHECKEQUAL(0, scan-\u003esetInterpretedCode(\u0026prog));\n\n  /* Api doesn't seem to wait for result of scan request */\n  CHECKEQUAL(0, trans-\u003eexecute(NdbTransaction::NoCommit));\n\n  CHECKEQUAL(0, trans-\u003egetNdbError().code);\n\n  CHECKEQUAL(-1, scan-\u003enextResult());\n  \n  CHECKEQUAL(217, scan-\u003egetNdbError().code);\n\n  trans-\u003eclose();\n\n  /* Finished with error insert, cleanup the error insertion */\n  CHECKNOTNULL(trans= pNdb-\u003estartTransaction(ctx-\u003egetTab(),\n                                             \u0026smallKey[0],\n                                             smallKeySize));\n\n  CHECKEQUAL(NDBT_OK, activateErrorInsert(trans, \n                                          record, \n                                          ctx-\u003egetTab(),\n                                          smallRowBuf, \n                                          \u0026restarter, \n                                          8068));\n\n  CHECKEQUAL(0, trans-\u003eexecute(NdbTransaction::Rollback));\n  \n  CHECKEQUAL(0, trans-\u003egetNdbError().code);\n\n  trans-\u003eclose();\n\n  return NDBT_OK;\n}\n\nint testDropSignalFragments(NDBT_Context* ctx, NDBT_Step* step){\n  /* Segmented section exhaustion results in dropped signals\n   * Fragmented signals split one logical signal over multiple\n   * physical signals (to cope with the MAX_SIGNAL_LENGTH=32kB\n   * limitation).\n   * This testcase checks that when individual signals comprising\n   * a fragmented signal (in this case SCANTABREQ) are dropped, the\n   * system behaves correctly.\n   * Correct behaviour is to behave in the same way as if the signal\n   * was not fragmented, and for SCANTABREQ, to return a temporary\n   * resource error.\n   */\n  NdbRestarter restarter;\n  Ndb* pNdb= GETNDB(step);\n\n  /* SEND \u003e ((2 * MAX_SEND_MESSAGE_BYTESIZE) + SOME EXTRA) \n   * This way we get at least 3 fragments\n   * However, as this is generally \u003e 64kB, it's too much AttrInfo for\n   * a ScanTabReq, so the 'success' case returns error 874\n   */\n  const Uint32 PROG_WORDS= 16500; \n\n  struct SubCase\n  {\n    Uint32 errorInsertCode;\n    int expectedRc;\n  };\n  const Uint32 numSubCases= 5;\n  const SubCase cases[numSubCases]= \n  /* Error insert   Scanrc */\n    {{          0,     874},  // Normal, success which gives too much AI error\n     {       8074,     217},  // Drop first fragment -\u003e error 217\n     {       8075,     217},  // Drop middle fragment(s) -\u003e error 217\n     {       8076,     217},  // Drop last fragment -\u003e error 217\n     {       8077,     217}}; // Drop all fragments -\u003e error 217\n  const Uint32 numIterations= 50;\n  \n  Uint32 buff[ PROG_WORDS + 10 ]; // 10 extra for final 'return' etc.\n\n  for (Uint32 iteration=0; iteration \u003c (numIterations * numSubCases); iteration++)\n  {\n    /* Start a transaction */\n    NdbTransaction* trans= pNdb-\u003estartTransaction();\n    CHECKNOTNULL(trans);\n\n    SubCase subcase= cases[iteration % numSubCases];\n\n    Uint32 errorInsertVal= subcase.errorInsertCode;\n    // printf(\"Inserting error : %u\\n\", errorInsertVal);\n    /* We insert the error twice, to bias races between\n     * error-insert propagation and the succeeding scan\n     * in favour of error insert winning!\n     * This problem needs a more general fix\n     */\n    CHECKEQUAL(0, restarter.insertErrorInAllNodes(errorInsertVal));\n    CHECKEQUAL(0, restarter.insertErrorInAllNodes(errorInsertVal));\n\n    NdbScanOperation* scan= trans-\u003egetNdbScanOperation(ctx-\u003egetTab());\n    \n    CHECKNOTNULL(scan);\n    \n    CHECKEQUAL(0, scan-\u003ereadTuples());\n    \n    /* Create a large program, to give a large SCANTABREQ */\n    NdbInterpretedCode prog(ctx-\u003egetTab(), buff, PROG_WORDS + 10);\n    \n    for (Uint32 w=0; w \u003c PROG_WORDS; w++)\n      CHECKEQUAL(0, prog.load_const_null(1));\n    \n    CHECKEQUAL(0, prog.interpret_exit_ok());\n    CHECKEQUAL(0, prog.finalise());\n    \n    CHECKEQUAL(0, scan-\u003esetInterpretedCode(\u0026prog));\n    \n    /* Api doesn't seem to wait for result of scan request */\n    CHECKEQUAL(0, trans-\u003eexecute(NdbTransaction::NoCommit));\n    \n    CHECKEQUAL(0, trans-\u003egetNdbError().code);\n\n    CHECKEQUAL(-1, scan-\u003enextResult());\n    \n    int expectedResult= subcase.expectedRc;\n    CHECKEQUAL(expectedResult, scan-\u003egetNdbError().code);\n\n    scan-\u003eclose();\n    \n    trans-\u003eclose();\n  }\n\n  restarter.insertErrorInAllNodes(0);\n\n  return NDBT_OK;\n}\n\nint create100Tables(NDBT_Context* ctx, NDBT_Step* step)\n{\n  Ndb* pNdb = GETNDB(step);\n  const NdbDictionary::Table* pTab= ctx-\u003egetTab();\n  \n  /* Run as a 'T1' testcase - do nothing for other tables */\n  if (strcmp(pTab-\u003egetName(), \"T1\") != 0)\n    return NDBT_OK;\n\n  for (Uint32 t=0; t \u003c 100; t++)\n  {\n    char tabnameBuff[10];\n    snprintf(tabnameBuff, sizeof(tabnameBuff), \"TAB%u\", t);\n    \n    NdbDictionary::Table tab;\n    tab.setName(tabnameBuff);\n    NdbDictionary::Column pk;\n    pk.setName(\"PK\");\n    pk.setType(NdbDictionary::Column::Varchar);\n    pk.setLength(20);\n    pk.setNullable(false);\n    pk.setPrimaryKey(true);\n    tab.addColumn(pk);\n\n    pNdb-\u003egetDictionary()-\u003edropTable(tab.getName());\n    if(pNdb-\u003egetDictionary()-\u003ecreateTable(tab) != 0)\n    {\n      ndbout \u003c\u003c \"Create table failed with error : \"\n             \u003c\u003c pNdb-\u003egetDictionary()-\u003egetNdbError().code\n             \u003c\u003c \" \"\n             \u003c\u003c pNdb-\u003egetDictionary()-\u003egetNdbError().message\n             \u003c\u003c endl;\n      return NDBT_FAILED;\n    }\n    \n    ndbout \u003c\u003c \"Created table \" \u003c\u003c tabnameBuff \u003c\u003c endl;\n  }\n\n  return NDBT_OK;\n}\n\nint drop100Tables(NDBT_Context* ctx, NDBT_Step* step)\n{\n  Ndb* pNdb = GETNDB(step);\n  const NdbDictionary::Table* pTab= ctx-\u003egetTab();\n\n  /* Run as a 'T1' testcase - do nothing for other tables */\n  if (strcmp(pTab-\u003egetName(), \"T1\") != 0)\n    return NDBT_OK;\n    \n  for (Uint32 t=0; t \u003c 100; t++)\n  {\n    char tabnameBuff[10];\n    snprintf(tabnameBuff, sizeof(tabnameBuff), \"TAB%u\", t);\n    \n    if (pNdb-\u003egetDictionary()-\u003edropTable(tabnameBuff) != 0)\n    {\n      ndbout \u003c\u003c \"Drop table failed with error : \"\n             \u003c\u003c pNdb-\u003egetDictionary()-\u003egetNdbError().code\n             \u003c\u003c \" \"\n             \u003c\u003c pNdb-\u003egetDictionary()-\u003egetNdbError().message\n             \u003c\u003c endl;\n    }\n    else\n    {\n      ndbout \u003c\u003c \"Dropped table \" \u003c\u003c tabnameBuff \u003c\u003c endl;\n    }\n  }\n  \n  return NDBT_OK;\n}\n\nint dropTable(NDBT_Context* ctx, NDBT_Step* step, Uint32 num)\n{\n  Ndb* pNdb = GETNDB(step);\n  const NdbDictionary::Table* pTab= ctx-\u003egetTab();\n\n  /* Run as a 'T1' testcase - do nothing for other tables */\n  if (strcmp(pTab-\u003egetName(), \"T1\") != 0)\n    return NDBT_OK;\n    \n  char tabnameBuff[10];\n  snprintf(tabnameBuff, sizeof(tabnameBuff), \"TAB%u\", num);\n  \n  if (pNdb-\u003egetDictionary()-\u003edropTable(tabnameBuff) != 0)\n  {\n    ndbout \u003c\u003c \"Drop table failed with error : \"\n           \u003c\u003c pNdb-\u003egetDictionary()-\u003egetNdbError().code\n           \u003c\u003c \" \"\n           \u003c\u003c pNdb-\u003egetDictionary()-\u003egetNdbError().message\n           \u003c\u003c endl;\n  }\n  else\n  {\n    ndbout \u003c\u003c \"Dropped table \" \u003c\u003c tabnameBuff \u003c\u003c endl;\n  }\n  \n  return NDBT_OK;\n}\n\n\nenum Scenarios\n{\n//  NORMAL,  // Commented to save some time.\n  DROP_TABLE,\n  RESTART_MASTER,\n  RESTART_SLAVE,\n  NUM_SCENARIOS\n};\n\n\nenum Tasks\n{\n  WAIT = 0,\n  DROP_TABLE_REQ = 1,\n  MASTER_RESTART_REQ = 2,\n  SLAVE_RESTART_REQ = 3\n};\n\nint testWorker(NDBT_Context* ctx, NDBT_Step* step)\n{\n  /* Run as a 'T1' testcase - do nothing for other tables */\n  if (strcmp(ctx-\u003egetTab()-\u003egetName(), \"T1\") != 0)\n    return NDBT_OK;\n\n  /* Worker step to run in a separate thread for\n   * blocking activities\n   * Generally the blocking of the DIH table definition flush\n   * blocks the completion of the drop table/node restarts,\n   * so this must be done in a separate thread to avoid\n   * deadlocks.\n   */\n  \n  while (!ctx-\u003eisTestStopped())\n  {\n    ndbout_c(\"Worker : waiting for request...\");\n    ctx-\u003egetPropertyWait(\"DIHWritesRequest\", 1);\n  \n    if (!ctx-\u003eisTestStopped())\n    {\n      Uint32 req = ctx-\u003egetProperty(\"DIHWritesRequestType\", (Uint32)0);\n\n      switch ((Tasks) req)\n      {\n      case DROP_TABLE_REQ:\n      {\n        /* Drop table */\n        ndbout_c(\"Worker : dropping table\");\n        if (dropTable(ctx, step, 2) != NDBT_OK)\n        {\n          return NDBT_FAILED;\n        }\n        ndbout_c(\"Worker : table dropped.\");\n        break;\n      }\n      case MASTER_RESTART_REQ:\n      {\n        ndbout_c(\"Worker : restarting Master\");\n        \n        NdbRestarter restarter;\n        int master_nodeid = restarter.getMasterNodeId();\n        ndbout_c(\"Worker : Restarting Master (%d)...\", master_nodeid);\n        if (restarter.restartOneDbNode2(master_nodeid, \n                                        NdbRestarter::NRRF_NOSTART |\n                                        NdbRestarter::NRRF_FORCE |\n                                        NdbRestarter::NRRF_ABORT) ||\n            restarter.waitNodesNoStart(\u0026master_nodeid, 1) ||\n            restarter.startAll())\n        {\n          ndbout_c(\"Worker : Error restarting Master.\");\n          return NDBT_FAILED;\n        }\n        ndbout_c(\"Worker : Waiting for master to recover...\");\n        if (restarter.waitNodesStarted(\u0026master_nodeid, 1))\n        {\n          ndbout_c(\"Worker : Error waiting for Master restart\");\n          return NDBT_FAILED;\n        }\n        ndbout_c(\"Worker : Master recovered.\");\n        break;\n      }\n      case SLAVE_RESTART_REQ:\n      {\n        NdbRestarter restarter;\n        int slave_nodeid = restarter.getRandomNotMasterNodeId(rand());\n        ndbout_c(\"Worker : Restarting non-master (%d)...\", slave_nodeid);\n        if (restarter.restartOneDbNode2(slave_nodeid, \n                                        NdbRestarter::NRRF_NOSTART |\n                                        NdbRestarter::NRRF_FORCE |\n                                        NdbRestarter::NRRF_ABORT) ||\n            restarter.waitNodesNoStart(\u0026slave_nodeid, 1) ||\n            restarter.startAll())\n        {\n          ndbout_c(\"Worker : Error restarting Slave.\");\n          return NDBT_FAILED;\n        }\n        ndbout_c(\"Worker : Waiting for slave to recover...\");\n        if (restarter.waitNodesStarted(\u0026slave_nodeid, 1))\n        {\n          ndbout_c(\"Worker : Error waiting for Slave restart\");\n          return NDBT_FAILED;\n        }\n        ndbout_c(\"Worker : Slave recovered.\");\n        break;\n      }\n      default:\n      { \n        break;\n      }\n      }\n    }\n    ctx-\u003esetProperty(\"DIHWritesRequestType\", (Uint32) 0);\n    ctx-\u003esetProperty(\"DIHWritesRequest\", (Uint32) 2);\n  }\n  \n  ndbout_c(\"Worker, done.\");\n  return NDBT_OK;\n}\n\nint testSlowDihFileWrites(NDBT_Context* ctx, NDBT_Step* step)\n{\n  /* Testcase checks behaviour with slow flushing of DIH table definitions\n   * This caused problems in the past by exhausting the DIH page pool\n   * Now there's a concurrent operations limit.\n   * Check that it behaves with many queued ops, parallel drop/node restarts\n   */\n  \n  /* Run as a 'T1' testcase - do nothing for other tables */\n  if (strcmp(ctx-\u003egetTab()-\u003egetName(), \"T1\") != 0)\n    return NDBT_OK;\n\n  /* 1. Activate slow write error insert\n   * 2. Trigger LCP\n   * 3. Wait some time, periodically producing info on \n   *    the internal state\n   * 4. Perform some parallel action (drop table/node restarts)\n   * 5. Wait some time, periodically producing info on \n   *    the internal state\n   * 6. Clear the error insert\n   * 7. Wait a little longer\n   * 8. Done.\n   */\n  NdbRestarter restarter;\n\n  for (Uint32 scenario = 0;  scenario \u003c NUM_SCENARIOS; scenario++)\n  {\n    ndbout_c(\"Inserting error 7235\");\n    restarter.insertErrorInAllNodes(7235);\n    \n    ndbout_c(\"Triggering LCP\");\n    int dumpArg = 7099;\n    restarter.dumpStateAllNodes(\u0026dumpArg, 1);\n    \n    const Uint32 periodSeconds = 10;\n    Uint32 waitPeriods = 6;\n    dumpArg = 7032;\n    \n    for (Uint32 p=0; p\u003cwaitPeriods; p++)\n    {\n      if (p == 3)\n      {\n        switch ((Scenarios) scenario)\n        {\n        case DROP_TABLE:\n        {\n          /* Drop one of the early-created tables */\n          ndbout_c(\"Requesting DROP TABLE\");\n          ctx-\u003esetProperty(\"DIHWritesRequestType\", (Uint32) DROP_TABLE_REQ);\n          ctx-\u003esetProperty(\"DIHWritesRequest\", (Uint32) 1);\n          break;\n        }\n        case RESTART_MASTER:\n        {\n          ndbout_c(\"Requesting Master restart\");\n          ctx-\u003esetProperty(\"DIHWritesRequestType\", (Uint32) MASTER_RESTART_REQ);\n          ctx-\u003esetProperty(\"DIHWritesRequest\", (Uint32) 1);\n\n          break;\n        }\n        case RESTART_SLAVE:\n        {\n          ndbout_c(\"Requesting Slave restart\");\n          ctx-\u003esetProperty(\"DIHWritesRequestType\", (Uint32) SLAVE_RESTART_REQ);\n          ctx-\u003esetProperty(\"DIHWritesRequest\", (Uint32) 1);\n\n          break;\n        }\n        default:\n          break;\n        }\n      }\n\n      ndbout_c(\"Dumping DIH page info to ndbd stdout\");\n      restarter.dumpStateAllNodes(\u0026dumpArg, 1);\n      NdbSleep_MilliSleep(periodSeconds * 1000);\n    }\n    \n    ndbout_c(\"Clearing error insert...\");\n    restarter.insertErrorInAllNodes(0);\n    \n    waitPeriods = 2;\n    for (Uint32 p=0; p\u003cwaitPeriods; p++)\n    {\n      ndbout_c(\"Dumping DIH page info to ndbd stdout\");\n      restarter.dumpStateAllNodes(\u0026dumpArg, 1);\n      NdbSleep_MilliSleep(periodSeconds * 1000);\n    }\n    \n    ndbout_c(\"Waiting for worker to finish task...\");\n    ctx-\u003egetPropertyWait(\"DIHWritesRequest\", 2);\n    \n    if (ctx-\u003eisTestStopped())\n      return NDBT_OK;\n\n    ndbout_c(\"Done.\");\n  }  \n\n  /* Finish up */\n  ctx-\u003estopTest();\n\n  return NDBT_OK;\n}\n\n\nNDBT_TESTSUITE(testLimits);\n\nTESTCASE(\"ExhaustSegmentedSectionPk\",\n         \"Test behaviour at Segmented Section exhaustion for PK\"){\n  INITIALIZER(testSegmentedSectionPk);\n}\n\nTESTCASE(\"ExhaustSegmentedSectionIX\",\n         \"Test behaviour at Segmented Section exhaustion for Unique index\"){\n  INITIALIZER(testSegmentedSectionIx);\n}\nTESTCASE(\"ExhaustSegmentedSectionScan\",\n         \"Test behaviour at Segmented Section exhaustion for Scan\"){\n  INITIALIZER(testSegmentedSectionScan);\n}\n\nTESTCASE(\"DropSignalFragments\",\n         \"Test behaviour of Segmented Section exhaustion with fragmented signals\"){\n  INITIALIZER(testDropSignalFragments);\n}\n\nTESTCASE(\"SlowDihFileWrites\",\n         \"Test behaviour of slow Dih table file writes\")\n{\n  INITIALIZER(create100Tables);\n  STEP(testWorker);\n  STEP(testSlowDihFileWrites);\n  FINALIZER(drop100Tables);\n}\n\nNDBT_TESTSUITE_END(testLimits);\n\nint main(int argc, const char** argv){\n  ndb_init();\n  NDBT_TESTSUITE_INSTANCE(testLimits);\n  return testLimits.execute(argc, argv);\n}\n"}
{"repo_name":"Roxtedy/SkyFire_6xx","ref":"refs/heads/master","path":"src/server/game/Handlers/TicketHandler.cpp","copies":"15","language":"C++","content":"/*\n * Copyright (C) 2011-2014 Project SkyFire \u003chttp://www.projectskyfire.org/\u003e\n * Copyright (C) 2008-2014 TrinityCore \u003chttp://www.trinitycore.org/\u003e\n * Copyright (C) 2005-2014 MaNGOS \u003chttp://getmangos.com/\u003e\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the\n * Free Software Foundation; either version 3 of the License, or (at your\n * option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n * more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program. If not, see \u003chttp://www.gnu.org/licenses/\u003e.\n */\n\n#include \"zlib.h\"\n#include \"Common.h\"\n#include \"Language.h\"\n#include \"ObjectMgr.h\"\n#include \"Opcodes.h\"\n#include \"Player.h\"\n#include \"TicketMgr.h\"\n#include \"Util.h\"\n#include \"World.h\"\n#include \"WorldPacket.h\"\n#include \"WorldSession.h\"\n\nvoid WorldSession::HandleGMTicketCreateOpcode(WorldPacket\u0026 recvData)\n{\n    // Don't accept tickets if the ticket queue is disabled. (Ticket UI is greyed out but not fully dependable)\n    if (sTicketMgr-\u003eGetStatus() == GMTICKET_QUEUE_STATUS_DISABLED)\n        return;\n\n    if (GetPlayer()-\u003egetLevel() \u003c sWorld-\u003egetIntConfig(CONFIG_TICKET_LEVEL_REQ))\n    {\n        SendNotification(GetTrinityString(LANG_TICKET_REQ), sWorld-\u003egetIntConfig(CONFIG_TICKET_LEVEL_REQ));\n        return;\n    }\n\n    GMTicketResponse response = GMTICKET_RESPONSE_CREATE_ERROR;\n    GmTicket* ticket = sTicketMgr-\u003eGetTicketByPlayer(GetPlayer()-\u003eGetGUID());\n\n    if (ticket \u0026\u0026 ticket-\u003eIsCompleted())\n        sTicketMgr-\u003eCloseTicket(ticket-\u003eGetId(), GetPlayer()-\u003eGetGUID());;\n\n    // Player must not have ticket\n    if (!ticket || ticket-\u003eIsClosed())\n    {\n        ticket = new GmTicket(GetPlayer(), recvData);\n\n        uint32 count;\n        std::list\u003cuint32\u003e times;\n        uint32 decompressedSize;\n        std::string chatLog;\n\n        recvData \u003e\u003e count;\n\n        for (uint32 i = 0; i \u003c count; i++)\n        {\n            uint32 time;\n            recvData \u003e\u003e time;\n            times.push_back(time);\n        }\n\n        recvData \u003e\u003e decompressedSize;\n\n        if (count \u0026\u0026 decompressedSize \u0026\u0026 decompressedSize \u003c 0xFFFF)\n        {\n            uint32 pos = recvData.rpos();\n            ByteBuffer dest;\n            dest.resize(decompressedSize);\n\n            uLongf realSize = decompressedSize;\n            if (uncompress(dest.contents(), \u0026realSize, recvData.contents() + pos, recvData.size() - pos) == Z_OK)\n            {\n                dest \u003e\u003e chatLog;\n                ticket-\u003eSetChatLog(times, chatLog);\n            }\n            else\n            {\n                TC_LOG_ERROR(\"network\", \"CMSG_GMTICKET_CREATE possibly corrupt. Uncompression failed.\");\n                recvData.rfinish();\n                delete ticket;\n                return;\n            }\n\n            recvData.rfinish(); // Will still have compressed data in buffer.\n        }\n\n        sTicketMgr-\u003eAddTicket(ticket);\n        sTicketMgr-\u003eUpdateLastChange();\n\n        sWorld-\u003eSendGMText(LANG_COMMAND_TICKETNEW, GetPlayer()-\u003eGetName().c_str(), ticket-\u003eGetId());\n\n        response = GMTICKET_RESPONSE_CREATE_SUCCESS;\n    }\n\n    WorldPacket data(SMSG_GMTICKET_CREATE, 4);\n    data \u003c\u003c uint32(response);\n    SendPacket(\u0026data);\n}\n\nvoid WorldSession::HandleGMTicketUpdateOpcode(WorldPacket\u0026 recvData)\n{\n    std::string message;\n    recvData \u003e\u003e message;\n\n    GMTicketResponse response = GMTICKET_RESPONSE_UPDATE_ERROR;\n    if (GmTicket* ticket = sTicketMgr-\u003eGetTicketByPlayer(GetPlayer()-\u003eGetGUID()))\n    {\n        SQLTransaction trans = SQLTransaction(NULL);\n        ticket-\u003eSetMessage(message);\n        ticket-\u003eSaveToDB(trans);\n\n        sWorld-\u003eSendGMText(LANG_COMMAND_TICKETUPDATED, GetPlayer()-\u003eGetName().c_str(), ticket-\u003eGetId());\n\n        response = GMTICKET_RESPONSE_UPDATE_SUCCESS;\n    }\n\n    WorldPacket data(SMSG_GMTICKET_UPDATETEXT, 4);\n    data \u003c\u003c uint32(response);\n    SendPacket(\u0026data);\n}\n\nvoid WorldSession::HandleGMTicketDeleteOpcode(WorldPacket \u0026 /*recvData*/)\n{\n    if (GmTicket* ticket = sTicketMgr-\u003eGetTicketByPlayer(GetPlayer()-\u003eGetGUID()))\n    {\n        WorldPacket data(SMSG_GMTICKET_DELETETICKET, 4);\n        data \u003c\u003c uint32(GMTICKET_RESPONSE_TICKET_DELETED);\n        SendPacket(\u0026data);\n\n        sWorld-\u003eSendGMText(LANG_COMMAND_TICKETPLAYERABANDON, GetPlayer()-\u003eGetName().c_str(), ticket-\u003eGetId());\n\n        sTicketMgr-\u003eCloseTicket(ticket-\u003eGetId(), GetPlayer()-\u003eGetGUID());\n        sTicketMgr-\u003eSendTicket(this, NULL);\n    }\n}\n\nvoid WorldSession::HandleGMTicketGetTicketOpcode(WorldPacket \u0026 /*recvData*/)\n{\n    SendQueryTimeResponse();\n\n    if (GmTicket* ticket = sTicketMgr-\u003eGetTicketByPlayer(GetPlayer()-\u003eGetGUID()))\n    {\n        if (ticket-\u003eIsCompleted())\n            ticket-\u003eSendResponse(this);\n        else\n            sTicketMgr-\u003eSendTicket(this, ticket);\n    }\n    else\n        sTicketMgr-\u003eSendTicket(this, NULL);\n}\n\nvoid WorldSession::HandleGMTicketSystemStatusOpcode(WorldPacket \u0026 /*recvData*/)\n{\n    // Note: This only disables the ticket UI at client side and is not fully reliable\n    // are we sure this is a uint32? Should ask Zor\n    WorldPacket data(SMSG_GMTICKET_SYSTEMSTATUS, 4);\n    data \u003c\u003c uint32(sTicketMgr-\u003eGetStatus() ? GMTICKET_QUEUE_STATUS_ENABLED : GMTICKET_QUEUE_STATUS_DISABLED);\n    SendPacket(\u0026data);\n}\n\nvoid WorldSession::HandleGMSurveySubmit(WorldPacket\u0026 recvData)\n{\n    uint32 nextSurveyID = sTicketMgr-\u003eGetNextSurveyID();\n    // just put the survey into the database\n    uint32 mainSurvey; // GMSurveyCurrentSurvey.dbc, column 1 (all 9) ref to GMSurveySurveys.dbc\n    recvData \u003e\u003e mainSurvey;\n\n    // sub_survey1, r1, comment1, sub_survey2, r2, comment2, sub_survey3, r3, comment3, sub_survey4, r4, comment4, sub_survey5, r5, comment5, sub_survey6, r6, comment6, sub_survey7, r7, comment7, sub_survey8, r8, comment8, sub_survey9, r9, comment9, sub_survey10, r10, comment10,\n    for (uint8 i = 0; i \u003c 15; i++)\n    {\n        uint32 subSurveyId; // ref to i'th GMSurveySurveys.dbc field (all fields in that dbc point to fields in GMSurveyQuestions.dbc)\n        recvData \u003e\u003e subSurveyId;\n        if (!subSurveyId)\n            break;\n\n        uint8 rank; // probably some sort of ref to GMSurveyAnswers.dbc\n        recvData \u003e\u003e rank;\n        std::string comment; // comment (\"Usage: GMSurveyAnswerSubmit(question, rank, comment)\")\n        recvData \u003e\u003e comment;\n\n        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_GM_SUBSURVEY);\n        stmt-\u003esetUInt32(0, nextSurveyID);\n        stmt-\u003esetUInt32(1, subSurveyId);\n        stmt-\u003esetUInt32(2, rank);\n        stmt-\u003esetString(3, comment);\n        CharacterDatabase.Execute(stmt);\n    }\n\n    std::string comment; // just a guess\n    recvData \u003e\u003e comment;\n\n    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_GM_SURVEY);\n    stmt-\u003esetUInt32(0, GUID_LOPART(GetPlayer()-\u003eGetGUID()));\n    stmt-\u003esetUInt32(1, nextSurveyID);\n    stmt-\u003esetUInt32(2, mainSurvey);\n    stmt-\u003esetString(3, comment);\n\n    CharacterDatabase.Execute(stmt);\n}\n\nvoid WorldSession::HandleReportLag(WorldPacket\u0026 recvData)\n{\n    // just put the lag report into the database...\n    // can't think of anything else to do with it\n    uint32 lagType, mapId;\n    recvData \u003e\u003e lagType;\n    recvData \u003e\u003e mapId;\n    float x, y, z;\n    recvData \u003e\u003e x;\n    recvData \u003e\u003e y;\n    recvData \u003e\u003e z;\n\n    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_LAG_REPORT);\n    stmt-\u003esetUInt32(0, GUID_LOPART(GetPlayer()-\u003eGetGUID()));\n    stmt-\u003esetUInt8 (1, lagType);\n    stmt-\u003esetUInt16(2, mapId);\n    stmt-\u003esetFloat (3, x);\n    stmt-\u003esetFloat (4, y);\n    stmt-\u003esetFloat (5, z);\n    stmt-\u003esetUInt32(6, GetLatency());\n    stmt-\u003esetUInt32(7, time(NULL));\n    CharacterDatabase.Execute(stmt);\n}\n\nvoid WorldSession::HandleGMResponseResolve(WorldPacket\u0026 /*recvPacket*/)\n{\n    // empty packet\n    if (GmTicket* ticket = sTicketMgr-\u003eGetTicketByPlayer(GetPlayer()-\u003eGetGUID()))\n    {\n        uint8 getSurvey = 0;\n        if (float(rand_chance()) \u003c sWorld-\u003egetFloatConfig(CONFIG_CHANCE_OF_GM_SURVEY))\n            getSurvey = 1;\n\n        WorldPacket data(SMSG_GMRESPONSE_STATUS_UPDATE, 4);\n        data \u003c\u003c uint8(getSurvey);\n        SendPacket(\u0026data);\n\n        WorldPacket data2(SMSG_GMTICKET_DELETETICKET, 4);\n        data2 \u003c\u003c uint32(GMTICKET_RESPONSE_TICKET_DELETED);\n        SendPacket(\u0026data2);\n\n        sTicketMgr-\u003eCloseTicket(ticket-\u003eGetId(), GetPlayer()-\u003eGetGUID());\n        sTicketMgr-\u003eSendTicket(this, NULL);\n    }\n}\n"}
{"repo_name":"huan5765/codelite-translate2chinese","ref":"refs/heads/master","path":"sdk/astyle/src/ASResource.cpp","copies":"14","language":"C++","content":"/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\r\n *\r\n *   ASResource.cpp\r\n *\r\n *   This file is a part of \"Artistic Style\" - an indentation and\r\n *   reformatting tool for C, C++, C# and Java source files.\r\n *   http://astyle.sourceforge.net\r\n *\r\n *   The \"Artistic Style\" project, including all files needed to\r\n *   compile it, is free software; you can redistribute it and/or\r\n *   modify it under the terms of the GNU Lesser General Public\r\n *   License as published by the Free Software Foundation; either\r\n *   version 2.1 of the License, or (at your option) any later\r\n *   version.\r\n *\r\n *   This program is distributed in the hope that it will be useful,\r\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n *   GNU Lesser General Public License for more details.\r\n *\r\n *   You should have received a copy of the GNU Lesser General Public\r\n *   License along with this project; if not, write to the\r\n *   Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\r\n *   Boston, MA  02110-1301, USA.\r\n *\r\n * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\r\n */\r\n\r\n#include \"astyle.h\"\r\n\r\n\r\nnamespace astyle\r\n{\r\nconst string ASResource::AS_IF = string(\"if\");\r\nconst string ASResource::AS_ELSE = string(\"else\");\r\nconst string ASResource::AS_FOR = string(\"for\");\r\nconst string ASResource::AS_DO = string(\"do\");\r\nconst string ASResource::AS_WHILE = string(\"while\");\r\nconst string ASResource::AS_SWITCH = string(\"switch\");\r\nconst string ASResource::AS_CASE = string(\"case\");\r\nconst string ASResource::AS_DEFAULT = string(\"default\");\r\nconst string ASResource::AS_CLASS = string(\"class\");\r\nconst string ASResource::AS_STRUCT = string(\"struct\");\r\nconst string ASResource::AS_UNION = string(\"union\");\r\nconst string ASResource::AS_INTERFACE = string(\"interface\");\r\nconst string ASResource::AS_NAMESPACE = string(\"namespace\");\r\nconst string ASResource::AS_EXTERN = string(\"extern\");\r\nconst string ASResource::AS_PUBLIC = string(\"public\");\r\nconst string ASResource::AS_PROTECTED = string(\"protected\");\r\nconst string ASResource::AS_PRIVATE = string(\"private\");\r\nconst string ASResource::AS_STATIC = string(\"static\");\r\nconst string ASResource::AS_SYNCHRONIZED = string(\"synchronized\");\r\nconst string ASResource::AS_OPERATOR = string(\"operator\");\r\nconst string ASResource::AS_TEMPLATE = string(\"template\");\r\nconst string ASResource::AS_TRY = string(\"try\");\r\nconst string ASResource::AS_CATCH = string(\"catch\");\r\nconst string ASResource::AS_FINALLY = string(\"finally\");\r\nconst string ASResource::AS_THROWS = string(\"throws\");\r\nconst string ASResource::AS_CONST = string(\"const\");\r\n\r\nconst string ASResource::AS_ASM = string(\"asm\");\r\n\r\nconst string ASResource::AS_BAR_DEFINE = string(\"#define\");\r\nconst string ASResource::AS_BAR_INCLUDE = string(\"#include\");\r\nconst string ASResource::AS_BAR_IF = string(\"#if\");\r\nconst string ASResource::AS_BAR_EL = string(\"#el\");\r\nconst string ASResource::AS_BAR_ENDIF = string(\"#endif\");\r\n\r\nconst string ASResource::AS_OPEN_BRACKET = string(\"{\");\r\nconst string ASResource::AS_CLOSE_BRACKET = string(\"}\");\r\nconst string ASResource::AS_OPEN_LINE_COMMENT = string(\"//\");\r\nconst string ASResource::AS_OPEN_COMMENT = string(\"/*\");\r\nconst string ASResource::AS_CLOSE_COMMENT = string(\"*/\");\r\n\r\nconst string ASResource::AS_ASSIGN = string(\"=\");\r\nconst string ASResource::AS_PLUS_ASSIGN = string(\"+=\");\r\nconst string ASResource::AS_MINUS_ASSIGN = string(\"-=\");\r\nconst string ASResource::AS_MULT_ASSIGN = string(\"*=\");\r\nconst string ASResource::AS_DIV_ASSIGN = string(\"/=\");\r\nconst string ASResource::AS_MOD_ASSIGN = string(\"%=\");\r\nconst string ASResource::AS_OR_ASSIGN = string(\"|=\");\r\nconst string ASResource::AS_AND_ASSIGN = string(\"\u0026=\");\r\nconst string ASResource::AS_XOR_ASSIGN = string(\"^=\");\r\nconst string ASResource::AS_GR_GR_ASSIGN = string(\"\u003e\u003e=\");\r\nconst string ASResource::AS_LS_LS_ASSIGN = string(\"\u003c\u003c=\");\r\nconst string ASResource::AS_GR_GR_GR_ASSIGN = string(\"\u003e\u003e\u003e=\");\r\nconst string ASResource::AS_LS_LS_LS_ASSIGN = string(\"\u003c\u003c\u003c=\");\r\nconst string ASResource::AS_RETURN = string(\"return\");\r\n\r\nconst string ASResource::AS_EQUAL = string(\"==\");\r\nconst string ASResource::AS_PLUS_PLUS = string(\"++\");\r\nconst string ASResource::AS_MINUS_MINUS = string(\"--\");\r\nconst string ASResource::AS_NOT_EQUAL = string(\"!=\");\r\nconst string ASResource::AS_GR_EQUAL = string(\"\u003e=\");\r\nconst string ASResource::AS_GR_GR = string(\"\u003e\u003e\");\r\nconst string ASResource::AS_GR_GR_GR = string(\"\u003e\u003e\u003e\");\r\nconst string ASResource::AS_LS_EQUAL = string(\"\u003c=\");\r\nconst string ASResource::AS_LS_LS = string(\"\u003c\u003c\");\r\nconst string ASResource::AS_LS_LS_LS = string(\"\u003c\u003c\u003c\");\r\nconst string ASResource::AS_ARROW = string(\"-\u003e\");\r\nconst string ASResource::AS_AND = string(\"\u0026\u0026\");\r\nconst string ASResource::AS_OR = string(\"||\");\r\nconst string ASResource::AS_COLON_COLON = string(\"::\");\r\nconst string ASResource::AS_PAREN_PAREN = string(\"()\");\r\nconst string ASResource::AS_BLPAREN_BLPAREN = string(\"[]\");\r\n\r\nconst string ASResource::AS_PLUS = string(\"+\");\r\nconst string ASResource::AS_MINUS = string(\"-\");\r\nconst string ASResource::AS_MULT = string(\"*\");\r\nconst string ASResource::AS_DIV = string(\"/\");\r\nconst string ASResource::AS_MOD = string(\"%\");\r\nconst string ASResource::AS_GR = string(\"\u003e\");\r\nconst string ASResource::AS_LS = string(\"\u003c\");\r\nconst string ASResource::AS_NOT = string(\"!\");\r\nconst string ASResource::AS_BIT_OR = string(\"|\");\r\nconst string ASResource::AS_BIT_AND = string(\"\u0026\");\r\nconst string ASResource::AS_BIT_NOT = string(\"~\");\r\nconst string ASResource::AS_BIT_XOR = string(\"^\");\r\nconst string ASResource::AS_QUESTION = string(\"?\");\r\nconst string ASResource::AS_COLON = string(\":\");\r\nconst string ASResource::AS_COMMA = string(\",\");\r\nconst string ASResource::AS_SEMICOLON = string(\";\");\r\n\r\nconst string ASResource::AS_FOREACH = string(\"foreach\");\r\nconst string ASResource::AS_LOCK = string(\"lock\");\r\nconst string ASResource::AS_UNSAFE = string(\"unsafe\");\r\nconst string ASResource::AS_FIXED = string(\"fixed\");\r\nconst string ASResource::AS_GET = string(\"get\");\r\nconst string ASResource::AS_SET = string(\"set\");\r\nconst string ASResource::AS_ADD = string(\"add\");\r\nconst string ASResource::AS_REMOVE = string(\"remove\");\r\n\r\nconst string ASResource::AS_CONST_CAST = string(\"const_cast\");\r\nconst string ASResource::AS_DYNAMIC_CAST = string(\"dynamic_cast\");\r\nconst string ASResource::AS_REINTERPRET_CAST = string(\"reinterpret_cast\");\r\nconst string ASResource::AS_STATIC_CAST = string(\"static_cast\");\r\n\r\n\r\n/**\r\n * Build the vector of assignment operators.\r\n * Used by BOTH ASFormatter.cpp and ASBeautifier.cpp\r\n *\r\n * @param assignmentOperators   a reference to the vector to be built.\r\n */\r\nvoid ASResource::buildAssignmentOperators(vector\u003cconst string*\u003e \u0026assignmentOperators)\r\n{\r\n\tassignmentOperators.push_back(\u0026AS_ASSIGN);\r\n\tassignmentOperators.push_back(\u0026AS_PLUS_ASSIGN);\r\n\tassignmentOperators.push_back(\u0026AS_MINUS_ASSIGN);\r\n\tassignmentOperators.push_back(\u0026AS_MULT_ASSIGN);\r\n\tassignmentOperators.push_back(\u0026AS_DIV_ASSIGN);\r\n\tassignmentOperators.push_back(\u0026AS_MOD_ASSIGN);\r\n\tassignmentOperators.push_back(\u0026AS_OR_ASSIGN);\r\n\tassignmentOperators.push_back(\u0026AS_AND_ASSIGN);\r\n\tassignmentOperators.push_back(\u0026AS_XOR_ASSIGN);\r\n\r\n\t// Java\r\n\tassignmentOperators.push_back(\u0026AS_GR_GR_GR_ASSIGN);\r\n\tassignmentOperators.push_back(\u0026AS_GR_GR_ASSIGN);\r\n\tassignmentOperators.push_back(\u0026AS_LS_LS_ASSIGN);\r\n\r\n\t// Unknown\r\n\tassignmentOperators.push_back(\u0026AS_LS_LS_LS_ASSIGN);\r\n\r\n\tassignmentOperators.push_back(\u0026AS_RETURN);\r\n}\r\n\r\n/**\r\n * Build the vector of C++ cast operators.\r\n * Used by ONLY ASFormatter.cpp\r\n *\r\n * @param castOperators     a reference to the vector to be built.\r\n */\r\nvoid ASResource::buildCastOperators(vector\u003cconst string*\u003e \u0026castOperators)\r\n{\r\n\tcastOperators.push_back(\u0026AS_CONST_CAST);\r\n\tcastOperators.push_back(\u0026AS_DYNAMIC_CAST);\r\n\tcastOperators.push_back(\u0026AS_REINTERPRET_CAST);\r\n\tcastOperators.push_back(\u0026AS_STATIC_CAST);\r\n}\r\n\r\n/**\r\n * Build the vector of header words.\r\n * Used by BOTH ASFormatter.cpp and ASBeautifier.cpp\r\n *\r\n * @param headers       a reference to the vector to be built.\r\n */\r\nvoid ASResource::buildHeaders(vector\u003cconst string*\u003e \u0026headers, int fileType, bool beautifier)\r\n{\r\n\theaders.push_back(\u0026AS_IF);\r\n\theaders.push_back(\u0026AS_ELSE);\r\n\theaders.push_back(\u0026AS_FOR);\r\n\theaders.push_back(\u0026AS_WHILE);\r\n\theaders.push_back(\u0026AS_DO);\r\n\theaders.push_back(\u0026AS_SWITCH);\r\n\theaders.push_back(\u0026AS_TRY);\r\n\theaders.push_back(\u0026AS_CATCH);\r\n\r\n\tif (beautifier)\r\n\t{\r\n\t\theaders.push_back(\u0026AS_CASE);\r\n\t\theaders.push_back(\u0026AS_DEFAULT);\r\n\t\theaders.push_back(\u0026AS_CONST);\r\n\t\theaders.push_back(\u0026AS_STATIC);\r\n\t\theaders.push_back(\u0026AS_EXTERN);\r\n\t\theaders.push_back(\u0026AS_TEMPLATE);\r\n\t}\r\n\r\n\tif (fileType == JAVA_TYPE)\r\n\t{\r\n\t\theaders.push_back(\u0026AS_FINALLY);\r\n\t\theaders.push_back(\u0026AS_SYNCHRONIZED);\r\n\t}\r\n\r\n\tif (fileType == SHARP_TYPE)\r\n\t{\r\n\t\theaders.push_back(\u0026AS_FINALLY);\r\n\t\theaders.push_back(\u0026AS_FOREACH);\r\n\t\theaders.push_back(\u0026AS_LOCK);\r\n\t\theaders.push_back(\u0026AS_UNSAFE);\r\n\t\theaders.push_back(\u0026AS_FIXED);\r\n\t\theaders.push_back(\u0026AS_GET);\r\n\t\theaders.push_back(\u0026AS_SET);\r\n\t\theaders.push_back(\u0026AS_ADD);\r\n\t\theaders.push_back(\u0026AS_REMOVE);\r\n\t}\r\n}\r\n\r\n/**\r\n * Build the vector of non-assignment operators.\r\n * Used by ONLY ASBeautifier.cpp\r\n *\r\n * @param nonParenHeaders       a reference to the vector to be built.\r\n */\r\nvoid ASResource::buildNonAssignmentOperators(vector\u003cconst string*\u003e \u0026nonAssignmentOperators)\r\n{\r\n\tnonAssignmentOperators.push_back(\u0026AS_EQUAL);\r\n\tnonAssignmentOperators.push_back(\u0026AS_PLUS_PLUS);\r\n\tnonAssignmentOperators.push_back(\u0026AS_MINUS_MINUS);\r\n\tnonAssignmentOperators.push_back(\u0026AS_NOT_EQUAL);\r\n\tnonAssignmentOperators.push_back(\u0026AS_GR_EQUAL);\r\n\tnonAssignmentOperators.push_back(\u0026AS_GR_GR_GR);\r\n\tnonAssignmentOperators.push_back(\u0026AS_GR_GR);\r\n\tnonAssignmentOperators.push_back(\u0026AS_LS_EQUAL);\r\n\tnonAssignmentOperators.push_back(\u0026AS_LS_LS_LS);\r\n\tnonAssignmentOperators.push_back(\u0026AS_LS_LS);\r\n\tnonAssignmentOperators.push_back(\u0026AS_ARROW);\r\n\tnonAssignmentOperators.push_back(\u0026AS_AND);\r\n\tnonAssignmentOperators.push_back(\u0026AS_OR);\r\n}\r\n\r\n/**\r\n * Build the vector of header non-paren headers.\r\n * Used by BOTH ASFormatter.cpp and ASBeautifier.cpp\r\n *\r\n * @param nonParenHeaders       a reference to the vector to be built.\r\n */\r\nvoid ASResource::buildNonParenHeaders(vector\u003cconst string*\u003e \u0026nonParenHeaders, int fileType, bool beautifier)\r\n{\r\n\tnonParenHeaders.push_back(\u0026AS_ELSE);\r\n\tnonParenHeaders.push_back(\u0026AS_DO);\r\n\tnonParenHeaders.push_back(\u0026AS_TRY);\r\n\r\n\tif (beautifier)\r\n\t{\r\n\t\tnonParenHeaders.push_back(\u0026AS_CASE);\r\n\t\tnonParenHeaders.push_back(\u0026AS_DEFAULT);\r\n\t\tnonParenHeaders.push_back(\u0026AS_CONST);\r\n\t\tnonParenHeaders.push_back(\u0026AS_STATIC);\r\n\t\tnonParenHeaders.push_back(\u0026AS_EXTERN);\r\n\t\tnonParenHeaders.push_back(\u0026AS_TEMPLATE);\r\n\t}\r\n\r\n\tif (fileType == JAVA_TYPE)\r\n\t{\r\n\t\tnonParenHeaders.push_back(\u0026AS_FINALLY);\r\n\t}\r\n\r\n\tif (fileType == SHARP_TYPE)\r\n\t{\r\n\t\tnonParenHeaders.push_back(\u0026AS_FINALLY);\r\n\t\tnonParenHeaders.push_back(\u0026AS_UNSAFE);\r\n\t\tnonParenHeaders.push_back(\u0026AS_GET);\r\n\t\tnonParenHeaders.push_back(\u0026AS_SET);\r\n\t\tnonParenHeaders.push_back(\u0026AS_ADD);\r\n\t\tnonParenHeaders.push_back(\u0026AS_REMOVE);\r\n\t}\r\n}\r\n\r\n/**\r\n * Build the vector of operators.\r\n * Used by ONLY ASFormatter.cpp\r\n *\r\n * @param operators             a reference to the vector to be built.\r\n */\r\nvoid ASResource::buildOperators(vector\u003cconst string*\u003e \u0026operators)\r\n{\r\n\toperators.push_back(\u0026AS_PLUS_ASSIGN);\r\n\toperators.push_back(\u0026AS_MINUS_ASSIGN);\r\n\toperators.push_back(\u0026AS_MULT_ASSIGN);\r\n\toperators.push_back(\u0026AS_DIV_ASSIGN);\r\n\toperators.push_back(\u0026AS_MOD_ASSIGN);\r\n\toperators.push_back(\u0026AS_OR_ASSIGN);\r\n\toperators.push_back(\u0026AS_AND_ASSIGN);\r\n\toperators.push_back(\u0026AS_XOR_ASSIGN);\r\n\toperators.push_back(\u0026AS_EQUAL);\r\n\toperators.push_back(\u0026AS_PLUS_PLUS);\r\n\toperators.push_back(\u0026AS_MINUS_MINUS);\r\n\toperators.push_back(\u0026AS_NOT_EQUAL);\r\n\toperators.push_back(\u0026AS_GR_EQUAL);\r\n\toperators.push_back(\u0026AS_GR_GR_GR_ASSIGN);\r\n\toperators.push_back(\u0026AS_GR_GR_ASSIGN);\r\n\toperators.push_back(\u0026AS_GR_GR_GR);\r\n\toperators.push_back(\u0026AS_GR_GR);\r\n\toperators.push_back(\u0026AS_LS_EQUAL);\r\n\toperators.push_back(\u0026AS_LS_LS_LS_ASSIGN);\r\n\toperators.push_back(\u0026AS_LS_LS_ASSIGN);\r\n\toperators.push_back(\u0026AS_LS_LS_LS);\r\n\toperators.push_back(\u0026AS_LS_LS);\r\n\toperators.push_back(\u0026AS_ARROW);\r\n\toperators.push_back(\u0026AS_AND);\r\n\toperators.push_back(\u0026AS_OR);\r\n\toperators.push_back(\u0026AS_COLON_COLON);\r\n\toperators.push_back(\u0026AS_PLUS);\r\n\toperators.push_back(\u0026AS_MINUS);\r\n\toperators.push_back(\u0026AS_MULT);\r\n\toperators.push_back(\u0026AS_DIV);\r\n\toperators.push_back(\u0026AS_MOD);\r\n\toperators.push_back(\u0026AS_QUESTION);\r\n\toperators.push_back(\u0026AS_COLON);\r\n\toperators.push_back(\u0026AS_ASSIGN);\r\n\toperators.push_back(\u0026AS_LS);\r\n\toperators.push_back(\u0026AS_GR);\r\n\toperators.push_back(\u0026AS_NOT);\r\n\toperators.push_back(\u0026AS_BIT_OR);\r\n\toperators.push_back(\u0026AS_BIT_AND);\r\n\toperators.push_back(\u0026AS_BIT_NOT);\r\n\toperators.push_back(\u0026AS_BIT_XOR);\r\n\toperators.push_back(\u0026AS_OPERATOR);\r\n\toperators.push_back(\u0026AS_COMMA);\r\n\toperators.push_back(\u0026AS_RETURN);\r\n}\r\n\r\n/**\r\n * Build the vector of pre-block statements.\r\n * Used by ONLY ASBeautifier.cpp\r\n *\r\n * @param preBlockStatements        a reference to the vector to be built.\r\n */\r\nvoid ASResource::buildPreBlockStatements(vector\u003cconst string*\u003e \u0026preBlockStatements)\r\n{\r\n\tpreBlockStatements.push_back(\u0026AS_CLASS);\r\n\tpreBlockStatements.push_back(\u0026AS_STRUCT);\r\n\tpreBlockStatements.push_back(\u0026AS_UNION);\r\n\tpreBlockStatements.push_back(\u0026AS_INTERFACE);\r\n\tpreBlockStatements.push_back(\u0026AS_NAMESPACE);\r\n\tpreBlockStatements.push_back(\u0026AS_THROWS);\r\n\tpreBlockStatements.push_back(\u0026AS_EXTERN);\r\n}\r\n\r\n/**\r\n * Build the vector of pre-command headers.\r\n * Used by ONLY ASFormatter.cpp\r\n *\r\n * @param preCommandHeaders     a reference to the vector to be built.\r\n */\r\nvoid ASResource::buildPreCommandHeaders(vector\u003cconst string*\u003e \u0026preCommandHeaders)\r\n{\r\n\tpreCommandHeaders.push_back(\u0026AS_EXTERN);\r\n\tpreCommandHeaders.push_back(\u0026AS_THROWS);\r\n\tpreCommandHeaders.push_back(\u0026AS_CONST);\r\n}\r\n\r\n/**\r\n * Build the vector of pre-definition headers.\r\n * Used by ONLY ASFormatter.cpp\r\n *\r\n * @param preDefinitionHeaders      a reference to the vector to be built.\r\n */\r\nvoid ASResource::buildPreDefinitionHeaders(vector\u003cconst string*\u003e \u0026preDefinitionHeaders)\r\n{\r\n\tpreDefinitionHeaders.push_back(\u0026AS_CLASS);\r\n\tpreDefinitionHeaders.push_back(\u0026AS_INTERFACE);\r\n\tpreDefinitionHeaders.push_back(\u0026AS_NAMESPACE);\r\n\tpreDefinitionHeaders.push_back(\u0026AS_STRUCT);\r\n}\r\n\r\n\r\n}   // end namespace astyle\r\n"}
{"repo_name":"MattMulhern/OpenMamaCassandra","ref":"refs/heads/master","path":"mamda/c_cpp/src/examples/parsecmd.cpp","copies":"11","language":"C++","content":"/* $Id$\n *\n * OpenMAMA: The open middleware agnostic messaging API\n * Copyright (C) 2011 NYSE Technologies, Inc.\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n * 02110-1301 USA\n */\n\n#include \u003cmama/mama.h\u003e\n#include \u003cmama/mamacpp.h\u003e\n#include \u003cmama/MamaTransport.h\u003e\n#include \"parsecmd.h\"\n#include \u003cfstream\u003e\n#include \u003ciostream\u003e\n#include \u003cstring\u003e\n#include \u003cmap\u003e\n#include \u003cstring.h\u003e\n#include \u003cmamda/MamdaVersion.h\u003e\n\nusing std::ifstream;\nusing std::cerr;\nusing std::string;\nusing std::map;\n\nusing namespace Wombat;\n\ntypedef map\u003cstring,const char*\u003e  OptionMap;\n\nextern void usage (int);\n\nExampleLogLevel gExampleLogLevel = EXAMPLE_LOG_LEVEL_NORMAL;\n\nstruct CommonCommandLineParser::CommonCommandLineParserImpl\n{\n    CommonCommandLineParserImpl (int          argc, \n                                 const char*  argv[]);\n\n    const char*          mSourceName;\n    const char*          mTportName;\n    MamaSource*          mSource;\n    const char*          mDictSourceName;\n    const char*          mDictTportName;\n    const char*          mDictFileName;\n    MamaSource*          mDictSource;\n    const char*          mOptionSourceName;\n    const char*          mOptionTportName;\n    MamaSource*          mOptionSource;\n    const char*          mSymbolMapFile;\n    vector\u003cconst char*\u003e  mSymbolList;\n    double               mThrottleRate;\n    int                  mThreads;\n    double               mTimeout;\n    MamaLogLevel         mSubscLogLevel;\n    OptionMap            mOptions;\n    bool                 mLogReqResp;\n    bool                 mUseWorldView;\n    const char*          mSymbology;\n    int                  mChurnRate;\n    double               mTimerInterval;\n    const char*          mLogFileName;\n    const char*          mMiddleware;\n    int                  mPrecision;\n    int                  mShutdownTime;\n    bool                 mShowDeltas;\n    mamaBridge           mBridge;\n    bool                 mSnapShot;\n    const char*          mQueryArg1;\n    const char*          mQueryArg2;\n    const char*          mQueryArg3;\n\tconst char*          mQueryArg4;\n    int                  mQuery;\n    int                  mQueryType;\n    int                  mQueryCycles;\n    bool                 mPublishRecaps;\n};\n\nCommonCommandLineParser::CommonCommandLineParser (\n    int          argc, \n    const char*  argv[])\n    : mImpl (*new CommonCommandLineParserImpl (argc,argv))\n{\n}\n\nCommonCommandLineParser::~CommonCommandLineParser ()\n{\n    delete \u0026mImpl;\n}\n\nbool CommonCommandLineParser::getPublishRecaps()\n{\n    return mImpl.mPublishRecaps;\n}\n\nMamaSource*  CommonCommandLineParser::getSource ()\n{\n    if (!mImpl.mSource)\n    {\n        mImpl.mSource = new MamaSource (\"default\", \n                                          mImpl.mTportName, \n                                          mImpl.mSourceName,\n                                          mImpl.mBridge);\n        mImpl.mSource-\u003egetTransport()-\u003esetOutboundThrottle (\n                                        mImpl.mThrottleRate, \n                                        MAMA_THROTTLE_DEFAULT);\n    }    \n    return mImpl.mSource;\n}\n\nMamaSource*  CommonCommandLineParser::getDictSource ()\n{\n    if (!mImpl.mDictSource)\n    {\n        mImpl.mDictSource = new MamaSource (\"dict\", \n                                              mImpl.mDictTportName \n                                                ? mImpl.mDictTportName \n                                                : mImpl.mTportName,\n                                              mImpl.mDictSourceName,\n                                              mImpl.mBridge);\n    }\n    return mImpl.mDictSource;\n}\n\nMamaSource*  CommonCommandLineParser::getOptionSource ()\n{\n    if (!mImpl.mOptionSource)\n    {\n        mImpl.mOptionSource = new MamaSource (\"options\", \n                                          mImpl.mOptionTportName \n                                            ? mImpl.mOptionTportName\n                                            : mImpl.mTportName, \n                                          mImpl.mOptionSourceName,\n                                          mImpl.mBridge);    \n        mImpl.mOptionSource-\u003egetTransport()-\u003esetOutboundThrottle (\n                                        mImpl.mThrottleRate, \n                                        MAMA_THROTTLE_DEFAULT);\n    }\n    return mImpl.mOptionSource;    \n}\n\nconst char*  CommonCommandLineParser::getSymbolMapFile ()\n{\n    return mImpl.mSymbolMapFile;\n}\n\nconst vector\u003cconst char*\u003e\u0026  CommonCommandLineParser::getSymbolList ()\n{\n    return mImpl.mSymbolList;\n}\n\ndouble  CommonCommandLineParser::getThrottleRate ()\n{\n    return mImpl.mThrottleRate;\n}\n\nint  CommonCommandLineParser::getNumThreads ()\n{\n    return mImpl.mThreads;\n}\n\ndouble  CommonCommandLineParser::getTimeout ()\n{\n    return mImpl.mTimeout;\n}\n\nMamaLogLevel  CommonCommandLineParser::getSubscLogLevel ()\n{\n    return mImpl.mSubscLogLevel;\n}\n\nbool CommonCommandLineParser::getUseWorldview ()\n{\n    return mImpl.mUseWorldView;\n}\n\nbool CommonCommandLineParser::getLogReqResp ()\n{\n    return mImpl.mLogReqResp;\n}\n\nconst char* CommonCommandLineParser::getSymbology ()\n{\n    return mImpl.mSymbology;\n}\n\nconst char* CommonCommandLineParser::getMiddleware ()\n{\n    return mImpl.mMiddleware;\n}\n\nint CommonCommandLineParser::getPrecision ()\n{\n  return mImpl.mPrecision;\n}\n\nint CommonCommandLineParser::getShutdownTime ()\n{\n  return mImpl.mShutdownTime;\n}\n\nbool CommonCommandLineParser::showDeltas ()\n{\n  return mImpl.mShowDeltas;\n}\n\nmamaBridge CommonCommandLineParser::getBridge ()\n{\n    return mImpl.mBridge;\n}\n\nbool CommonCommandLineParser::getSnapshot()\n{\n    return mImpl.mSnapShot;\n}\n\nbool  CommonCommandLineParser::getOptBool (char  option0)\n{\n    string option (\u0026option0, 0, 1);\n    OptionMap::iterator found = mImpl.mOptions.find (option);\n    return (found != mImpl.mOptions.end ());\n}\n\nbool  CommonCommandLineParser::getOptBool (const char*  option0)\n{\n    string option (option0);\n    OptionMap::iterator found = mImpl.mOptions.find (option);\n    return (found != mImpl.mOptions.end ());\n}\n\nint  CommonCommandLineParser::getOptInt (char  option0, int defaultValue)\n{\n    string option (\u0026option0, 0, 1);\n    OptionMap::iterator found = mImpl.mOptions.find (option);\n    if (found != mImpl.mOptions.end ())\n    {\n        const char* value = found-\u003esecond;\n        if (value)\n            return strtol (value, NULL, 10);\n    }\n    return defaultValue;\n}\n\nint  CommonCommandLineParser::getOptInt (const char*  option0, int defaultValue)\n{\n    string option (option0);\n    OptionMap::iterator found = mImpl.mOptions.find (option);\n    if (found != mImpl.mOptions.end ())\n    {\n        const char* value = found-\u003esecond;\n        if (value)\n            return strtol (value, NULL, 10);\n    }\n    return defaultValue;\n}\n\nconst char*  CommonCommandLineParser::getOptString (char  option0)\n{\n    string option (\u0026option0, 0, 1);\n    OptionMap::iterator found = mImpl.mOptions.find (option);\n    if (found != mImpl.mOptions.end ())\n    {\n        return found-\u003esecond;\n    }\n    return NULL;\n}\n\nconst char*  CommonCommandLineParser::getOptString (const char*  option0)\n{\n    string option (option0);\n    OptionMap::iterator found = mImpl.mOptions.find (option);\n    if (found != mImpl.mOptions.end ())\n    {\n        return found-\u003esecond;\n    }\n    return NULL;\n}\n\nint CommonCommandLineParser::getChurnRate ()\n{\n    return mImpl.mChurnRate;\n}\n\ndouble CommonCommandLineParser::getTimerInterval ()\n{\n    return mImpl.mTimerInterval;\n}\n\nconst char* CommonCommandLineParser::getLogFileName ()\n{\n    return mImpl.mLogFileName;    \n}\n\nconst char*  CommonCommandLineParser::getQueryArg1 ()\n{\n    return mImpl.mQueryArg1;  \n}\n\nconst char* CommonCommandLineParser::getQueryArg2 ()\n{\n    return mImpl.mQueryArg2;  \n}\n\nconst char* CommonCommandLineParser::getQueryArg3 ()\n{\n    return mImpl.mQueryArg3;  \n}\n\nconst char* CommonCommandLineParser::getQueryArg4 ()\n{\n    return mImpl.mQueryArg4;  \n}\n\nint CommonCommandLineParser::getQuery ()\n{\n    return mImpl.mQuery;  \n}\n\nint CommonCommandLineParser::getQueryType ()\n{\n    return mImpl.mQueryType;  \n}\n\n\nint CommonCommandLineParser::getQueries ()\n{\n    return mImpl.mQueryCycles;  \n}\n\nCommonCommandLineParser::CommonCommandLineParserImpl::CommonCommandLineParserImpl (\n    int          argc, \n    const char*  argv[])\n{\n    mSource        = NULL;\n    mDictSource    = NULL;\n    mOptionSource  = NULL;\n    mSymbolMapFile = NULL;\n    mThrottleRate  = 500.0;\n    mThreads       = 0;\n    mTimeout       = 1.0;\n    mChurnRate     = 0;\n    mTimerInterval = 1.0; //Default Value\n    mLogFileName   = NULL;\n    mMiddleware    = \"wmw\";\n    mPrecision     = 2;\n    mShutdownTime  = 0;\n    mShowDeltas    = false;\n    mBridge        = NULL;\n    int i          = 1;\n    mUseWorldView  = false;\n    \n    mTportName        = NULL;\n    mDictTportName    = NULL;\n    mOptionTportName  = NULL;\n    mSourceName       = \"WOMBAT\";\n    mDictSourceName   = \"WOMBAT\";\n    mOptionSourceName = \"OPRA\";\n    mSnapShot         = false;\n    mPublishRecaps    = false;\n\n    mQueryArg1   = NULL;\n    mQueryArg2   = NULL;\n    mQueryArg3   = NULL;\n\tmQueryArg4   = NULL;\n    mQuery       = 0;\n    mQueryType   = 0;\n    mQueryCycles = 1;\n    \n    while (i \u003c argc)\n    {\n        bool handled = false;\n        if ((strcmp (argv[i], \"-OS\") == 0) ||\n            (strcmp (argv[i], \"-optionSource\") == 0) ||\n            (strcmp (argv[i], \"-option-source\") == 0))\n        {\n            mOptionSourceName = argv[i + 1];\n            handled = true;\n        }\n        else if ((strcmp (argv[i], \"-S\") == 0) ||\n            (strcmp (argv[i], \"-source\") == 0))\n        {\n            mSourceName = argv[i + 1];\n            handled = true;\n        }\n        else if ((strcmp (argv[i], \"-use_dict_file\") == 0))\n        {\n            mDictFileName = argv[i + 1];\n        }\n        else if ((strcmp (argv[i], \"-DS\") == 0) ||\n            (strcmp (argv[i], \"-dict-source\") == 0) ||\n            (strcmp (argv[i], \"-dictSource\") == 0) ||\n            (strcmp (argv[i], \"-d\") == 0))\n        {\n            mDictSourceName = argv[i + 1];\n            handled = true;\n        }\n        else if ((strcmp (argv[i], \"-T\") == 0) ||\n                 (strcmp (argv[i], \"-tport\") == 0))\n        {\n            mTportName = argv[i + 1];\n            handled = true;\n        }\n        else if ((strcmp (argv[i], \"-DT\") == 0) ||\n            (strcmp (argv[i], \"-dictTport\") == 0) ||\n            (strcmp (argv[i], \"-dict-tport\") == 0) ||\n            (strcmp (argv[i], \"-dict_tport\") == 0))\n        {\n            mDictTportName = argv[i + 1];\n            handled = true;\n        }\n        else if ((strcmp (argv[i], \"-OT\") == 0) ||\n            (strcmp (argv[i], \"-optionTport\") == 0) ||\n            (strcmp (argv[i], \"-option-tport\") == 0))\n        {\n            mOptionTportName = argv[i + 1];\n            handled = true;\n        }\n        else if (strcmp (argv[i], \"-s\") == 0)\n        {\n            mSymbolList.push_back (argv[i + 1]);\n            handled = true;\n        }\n        else if (strcmp (argv[i], \"-threads\") == 0)\n        {\n            mThreads = strtol (argv[i + 1], NULL, 10);\n            handled = true;\n        }\n        else if ((strcmp (argv[i], \"-r\") == 0) ||\n                 (strcmp (argv[i], \"-rate\") == 0))\n        {\n            mThrottleRate = strtod (argv[i + 1], NULL);\n            handled = true;\n        }\n        else if (strcmp (argv[i], \"-t\") == 0)\n        {\n            mTimeout = strtod (argv[i + 1], NULL); \n            handled = true;\n        }\n        else if (strcmp (argv[i], \"-mp\") == 0)\n        {\n            mSymbolMapFile = argv[i + 1];\n            handled = true;\n        }\n        else if (strcmp (argv[i], \"-m\") == 0)\n        {\n            mMiddleware = argv[i + 1];\n            handled = true;\n        }\n        else if (strcmp (argv[i], \"-precision\") == 0)\n        {\n          mPrecision = strtol (argv[i + 1], NULL, 10);\n          if(!mPrecision)\n          {\n            mPrecision=2;\n          }\n          if(mPrecision\u003e6)\n          {\n            mPrecision=6;\n          }\n          handled = true;\n        }\n        else if (strcmp (\"-shutdown\", argv[i]) == 0)\n        {\n            mShutdownTime = atoi (argv[i + 1]);           \n        }        \n        else if (strcmp (argv[i], \"-deltas\") == 0)\n        {\n            mShowDeltas = true;\n        }\n        else if (strcmp (argv[i], \"-churn\") == 0)\n        {\n            mChurnRate = strtol (argv[i + 1], NULL, 10);\n            handled = true;\n        }\n        else if (strcmp (argv[i], \"-timerInterval\") == 0)\n        {\n            mTimerInterval = strtod (argv[i + 1], NULL);\n            handled = true;\n        }\n        else if (strcmp (argv[i], \"-logfile\") == 0)\n        {\n            mLogFileName = argv[i + 1];\n            handled = true;\n        }\n        else if (strcmp (argv[i], \"-f\") == 0)\n        {\n            const char* filename = argv[i + 1];\n            ifstream input (filename);\n            if (!input)\n            {\n                cerr \u003c\u003c \"Cannot open file: \" \u003c\u003c filename \u003c\u003c \"\\n\";\n                exit (1);\n            }\n            string symbol;\n            input \u003e\u003e symbol;\n            while (!input.eof ())\n            {\n                if (!symbol.empty ())\n                {\n                    // Note: we never free the memory allocated by\n                    // strdup () in this example!\n                    mSymbolList.push_back (strdup (symbol.c_str ()));\n                }\n                input \u003e\u003e symbol;\n            }\n            handled = true;\n        }\n        else if (strcmp (argv[i], \"-v\") == 0)\n        {\n            if (mama_getLogLevel () == MAMA_LOG_LEVEL_NORMAL)\n            {\n                mama_enableLogging (stderr, MAMA_LOG_LEVEL_FINE);\n            }\n            else if (mama_getLogLevel () == MAMA_LOG_LEVEL_FINE)\n            {\n                mama_enableLogging (stderr, MAMA_LOG_LEVEL_FINER);\n            }\n            else\n            {\n                mama_enableLogging (stderr, MAMA_LOG_LEVEL_FINEST);\n            }\n            handled = true;\n        }\n        else if (strcmp (argv[i], \"-q\") == 0)\n        {\n            if (gExampleLogLevel == EXAMPLE_LOG_LEVEL_NORMAL )\n            {\n                gExampleLogLevel = EXAMPLE_LOG_LEVEL_QUIET;\n            }\n            else if (gExampleLogLevel == EXAMPLE_LOG_LEVEL_QUIET)\n            {\n                gExampleLogLevel = EXAMPLE_LOG_LEVEL_QUIETER;\n            }\n            else if (gExampleLogLevel == EXAMPLE_LOG_LEVEL_QUIETER)\n            {\n                gExampleLogLevel = EXAMPLE_LOG_LEVEL_QUIETEST;\n            }\n            handled = true;\n        }\n        else if (strcmp (argv[i], \"-V\") == 0)\n        {\n            if (mSubscLogLevel == MAMA_LOG_LEVEL_NORMAL)\n            {\n                mSubscLogLevel = MAMA_LOG_LEVEL_FINE;\n            }\n            else if (mSubscLogLevel == MAMA_LOG_LEVEL_FINE)\n            {\n                mSubscLogLevel = MAMA_LOG_LEVEL_FINER;\n            }\n            else\n            {\n                mSubscLogLevel = MAMA_LOG_LEVEL_FINEST;\n            }\n            handled = true;\n        }\n        else if (strcmp (argv[i], \"-W\") == 0)\n        {\n            mUseWorldView = true;\n            handled = true;     \n        }\n        else if (strcmp (argv[i], \"-L\") == 0)\n        {\n            mLogReqResp = true;\n            handled = true;     \n        }\n        else if (strcmp (argv[i], \"-Y\") == 0)\n        {\n            mSymbology = argv[i+1];\n            handled = true;     \n        }\n        else if ((strcmp (argv[i], \"-?\") == 0) ||\n                 (strcmp (argv[i], \"--help\") == 0))\n        {\n            usage(1);\n            handled = true;     \n        }\n        else if (strcmp (argv[i], \"-PR\") == 0)\n        {\n            mPublishRecaps = true;\n        }\n        else if (strcmp (argv[i], \"-1\") == 0)\n        {\n            mSnapShot = true;\n            handled = true;     \n        }\n        else if (strcmp (argv[i], \"-Q\") == 0)\n        {\n            mQuery = strtol (argv[i + 1], NULL, 10);     \n        }\n        else if (strcmp (argv[i], \"-QT\") == 0)\n        {\n            mQueryType = strtol (argv[i + 1], NULL, 10);     \n        }\n        else if (strcmp (argv[i], \"-A1\") == 0)\n        {\n            mQueryArg1 = argv[i + 1];\n        }\n        else if (strcmp (argv[i], \"-A2\") == 0)\n        {\n            mQueryArg2 = argv[i + 1];\n        }\n        else if (strcmp (argv[i], \"-A3\") == 0)\n        {\n            mQueryArg3 = argv[i + 1];\n        }\n\t\telse if (strcmp (argv[i], \"-A4\") == 0)\n        {\n            mQueryArg4 = argv[i + 1];\n        }\n        else if (strcmp (argv[i], \"-QC\") == 0)\n        {\n            mQueryCycles =strtol (argv[i + 1], NULL, 10);     \n        }\n        if (argv[i][0] == '-')\n        {\n            // general option (may or may not have following arg)\n            const char* opt = argv[i]+1;\n            if (strlen (opt) \u003e 0)\n            {\n                if ((i+1 \u003c argc) \u0026\u0026 (argv[i+1][0] != '-'))\n                {\n                    // next arg does not begin with '-'\n                    mOptions[opt] = argv[i+1];\n                    i += 2;\n                }\n                else\n                {\n                    // no additional arg\n                    mOptions[opt] = \"1\";\n                    i++;\n                }\n            }\n            handled = true;\n        }\n\n        if (!handled)\n        {\n            usage (1);\n        }\n    }\n    \n    mBridge = Mama::loadBridge (mMiddleware);\n}\n"}
{"repo_name":"goldcoin/gldcoin","ref":"refs/heads/master","path":"BuildDeps/deps/boost/libs/polygon/example/voronoi_visualizer.cpp","copies":"54","language":"C++","content":"// Boost.Polygon library voronoi_visualizer.cpp file\n\n//          Copyright Andrii Sydorchuk 2010-2012.\n// Distributed under the Boost Software License, Version 1.0.\n//    (See accompanying file LICENSE_1_0.txt or copy at\n//          http://www.boost.org/LICENSE_1_0.txt)\n\n// See http://www.boost.org for updates, documentation, and revision history.\n\n#include \u003ciostream\u003e\n#include \u003cvector\u003e\n\n#include \u003cQtOpenGL/QGLWidget\u003e\n#include \u003cQtGui/QtGui\u003e\n\n#include \u003cboost/polygon/polygon.hpp\u003e\n#include \u003cboost/polygon/voronoi.hpp\u003e\nusing namespace boost::polygon;\n\n#include \"voronoi_visual_utils.hpp\"\n\nclass GLWidget : public QGLWidget {\n  Q_OBJECT\n\n public:\n  explicit GLWidget(QMainWindow* parent = NULL) :\n      QGLWidget(QGLFormat(QGL::SampleBuffers), parent),\n      primary_edges_only_(false),\n      internal_edges_only_(false) {\n    startTimer(40);\n  }\n\n  QSize sizeHint() const {\n    return QSize(600, 600);\n  }\n\n  void build(const QString\u0026 file_path) {\n    // Clear all containers.\n    clear();\n\n    // Read data.\n    read_data(file_path);\n\n    // No data, don't proceed.\n    if (!brect_initialized_) {\n      return;\n    }\n\n    // Construct bounding rectangle.\n    construct_brect();\n\n    // Construct voronoi diagram.\n    construct_voronoi(\n        point_data_.begin(), point_data_.end(),\n        segment_data_.begin(), segment_data_.end(),\n        \u0026vd_);\n\n    // Color exterior edges.\n    for (const_edge_iterator it = vd_.edges().begin();\n         it != vd_.edges().end(); ++it) {\n      if (!it-\u003eis_finite()) {\n        color_exterior(\u0026(*it));\n      }\n    }\n\n    // Update view port.\n    update_view_port();\n  }\n\n  void show_primary_edges_only() {\n    primary_edges_only_ ^= true;\n  }\n\n  void show_internal_edges_only() {\n    internal_edges_only_ ^= true;\n  }\n\n protected:\n  void initializeGL() {\n    glHint(GL_POINT_SMOOTH_HINT, GL_NICEST);\n    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);\n    glEnable(GL_BLEND);\n    glEnable(GL_POINT_SMOOTH);\n  }\n\n  void paintGL() {\n    qglClearColor(QColor::fromRgb(255, 255, 255));\n    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n\n    draw_points();\n    draw_segments();\n    draw_vertices();\n    draw_edges();\n  }\n\n  void resizeGL(int width, int height) {\n    int side = qMin(width, height);\n    glViewport((width - side) / 2, (height - side) / 2, side, side);\n  }\n\n  void timerEvent(QTimerEvent* e) {\n    update();\n  }\n\n private:\n  typedef double coordinate_type;\n  typedef point_data\u003ccoordinate_type\u003e point_type;\n  typedef segment_data\u003ccoordinate_type\u003e segment_type;\n  typedef rectangle_data\u003ccoordinate_type\u003e rect_type;\n  typedef voronoi_builder\u003cint\u003e VB;\n  typedef voronoi_diagram\u003ccoordinate_type\u003e VD;\n  typedef VD::cell_type cell_type;\n  typedef VD::cell_type::source_index_type source_index_type;\n  typedef VD::cell_type::source_category_type source_category_type;\n  typedef VD::edge_type edge_type;\n  typedef VD::cell_container_type cell_container_type;\n  typedef VD::cell_container_type vertex_container_type;\n  typedef VD::edge_container_type edge_container_type;\n  typedef VD::const_cell_iterator const_cell_iterator;\n  typedef VD::const_vertex_iterator const_vertex_iterator;\n  typedef VD::const_edge_iterator const_edge_iterator;\n\n  static const std::size_t EXTERNAL_COLOR = 1;\n\n  void clear() {\n    brect_initialized_ = false;\n    point_data_.clear();\n    segment_data_.clear();\n    vd_.clear();\n  }\n\n  void read_data(const QString\u0026 file_path) {\n    QFile data(file_path);\n    if (!data.open(QFile::ReadOnly)) {\n      QMessageBox::warning(\n          this, tr(\"Voronoi Visualizer\"),\n          tr(\"Disable to open file \") + file_path);\n    }\n    QTextStream in_stream(\u0026data);\n    std::size_t num_points, num_segments;\n    int x1, y1, x2, y2;\n    in_stream \u003e\u003e num_points;\n    for (std::size_t i = 0; i \u003c num_points; ++i) {\n      in_stream \u003e\u003e x1 \u003e\u003e y1;\n      point_type p(x1, y1);\n      update_brect(p);\n      point_data_.push_back(p);\n    }\n    in_stream \u003e\u003e num_segments;\n    for (std::size_t i = 0; i \u003c num_segments; ++i) {\n      in_stream \u003e\u003e x1 \u003e\u003e y1 \u003e\u003e x2 \u003e\u003e y2;\n      point_type lp(x1, y1);\n      point_type hp(x2, y2);\n      update_brect(lp);\n      update_brect(hp);\n      segment_data_.push_back(segment_type(lp, hp));\n    }\n    in_stream.flush();\n  }\n\n  void update_brect(const point_type\u0026 point) {\n    if (brect_initialized_) {\n      encompass(brect_, point);\n    } else {\n      set_points(brect_, point, point);\n      brect_initialized_ = true;\n    }\n  }\n\n  void construct_brect() {\n    double side = (std::max)(xh(brect_) - xl(brect_), yh(brect_) - yl(brect_));\n    center(shift_, brect_);\n    set_points(brect_, shift_, shift_);\n    bloat(brect_, side * 1.2);\n  }\n\n  void color_exterior(const VD::edge_type* edge) {\n    if (edge-\u003ecolor() == EXTERNAL_COLOR) {\n      return;\n    }\n    edge-\u003ecolor(EXTERNAL_COLOR);\n    edge-\u003etwin()-\u003ecolor(EXTERNAL_COLOR);\n    const VD::vertex_type* v = edge-\u003evertex1();\n    if (v == NULL || !edge-\u003eis_primary()) {\n      return;\n    }\n    v-\u003ecolor(EXTERNAL_COLOR);\n    const VD::edge_type* e = v-\u003eincident_edge();\n    do {\n      color_exterior(e);\n      e = e-\u003erot_next();\n    } while (e != v-\u003eincident_edge());\n  }\n\n  void update_view_port() {\n    glMatrixMode(GL_PROJECTION);\n    glLoadIdentity();\n    rect_type view_rect = brect_;\n    deconvolve(view_rect, shift_);\n    glOrtho(xl(view_rect), xh(view_rect),\n            yl(view_rect), yh(view_rect),\n            -1.0, 1.0);\n    glMatrixMode(GL_MODELVIEW);\n  }\n\n  void draw_points() {\n    // Draw input points and endpoints of the input segments.\n    glColor3f(0.0f, 0.5f, 1.0f);\n    glPointSize(9);\n    glBegin(GL_POINTS);\n    for (std::size_t i = 0; i \u003c point_data_.size(); ++i) {\n      point_type point = point_data_[i];\n      deconvolve(point, shift_);\n      glVertex2f(point.x(), point.y());\n    }\n    for (std::size_t i = 0; i \u003c segment_data_.size(); ++i) {\n      point_type lp = low(segment_data_[i]);\n      lp = deconvolve(lp, shift_);\n      glVertex2f(lp.x(), lp.y());\n      point_type hp = high(segment_data_[i]);\n      hp = deconvolve(hp, shift_);\n      glVertex2f(hp.x(), hp.y());\n    }\n    glEnd();\n  }\n\n  void draw_segments() {\n    // Draw input segments.\n    glColor3f(0.0f, 0.5f, 1.0f);\n    glLineWidth(2.7f);\n    glBegin(GL_LINES);\n    for (std::size_t i = 0; i \u003c segment_data_.size(); ++i) {\n      point_type lp = low(segment_data_[i]);\n      lp = deconvolve(lp, shift_);\n      glVertex2f(lp.x(), lp.y());\n      point_type hp = high(segment_data_[i]);\n      hp = deconvolve(hp, shift_);\n      glVertex2f(hp.x(), hp.y());\n    }\n    glEnd();\n  }\n\n  void draw_vertices() {\n    // Draw voronoi vertices.\n    glColor3f(0.0f, 0.0f, 0.0f);\n    glPointSize(6);\n    glBegin(GL_POINTS);\n    for (const_vertex_iterator it = vd_.vertices().begin();\n         it != vd_.vertices().end(); ++it) {\n      if (internal_edges_only_ \u0026\u0026 (it-\u003ecolor() == EXTERNAL_COLOR)) {\n        continue;\n      }\n      point_type vertex(it-\u003ex(), it-\u003ey());\n      vertex = deconvolve(vertex, shift_);\n      glVertex2f(vertex.x(), vertex.y());\n    }\n    glEnd();\n  }\n  void draw_edges() {\n    // Draw voronoi edges.\n    glColor3f(0.0f, 0.0f, 0.0f);\n    glLineWidth(1.7f);\n    for (const_edge_iterator it = vd_.edges().begin();\n         it != vd_.edges().end(); ++it) {\n      if (primary_edges_only_ \u0026\u0026 !it-\u003eis_primary()) {\n        continue;\n      }\n      if (internal_edges_only_ \u0026\u0026 (it-\u003ecolor() == EXTERNAL_COLOR)) {\n        continue;\n      }\n      std::vector\u003cpoint_type\u003e samples;\n      if (!it-\u003eis_finite()) {\n        clip_infinite_edge(*it, \u0026samples);\n      } else {\n        point_type vertex0(it-\u003evertex0()-\u003ex(), it-\u003evertex0()-\u003ey());\n        samples.push_back(vertex0);\n        point_type vertex1(it-\u003evertex1()-\u003ex(), it-\u003evertex1()-\u003ey());\n        samples.push_back(vertex1);\n        if (it-\u003eis_curved()) {\n          sample_curved_edge(*it, \u0026samples);\n        }\n      }\n      glBegin(GL_LINE_STRIP);\n      for (std::size_t i = 0; i \u003c samples.size(); ++i) {\n        point_type vertex = deconvolve(samples[i], shift_);\n        glVertex2f(vertex.x(), vertex.y());\n      }\n      glEnd();\n    }\n  }\n\n  void clip_infinite_edge(\n      const edge_type\u0026 edge, std::vector\u003cpoint_type\u003e* clipped_edge) {\n    const cell_type\u0026 cell1 = *edge.cell();\n    const cell_type\u0026 cell2 = *edge.twin()-\u003ecell();\n    point_type origin, direction;\n    // Infinite edges could not be created by two segment sites.\n    if (cell1.contains_point() \u0026\u0026 cell2.contains_point()) {\n      point_type p1 = retrieve_point(cell1);\n      point_type p2 = retrieve_point(cell2);\n      origin.x((p1.x() + p2.x()) * 0.5);\n      origin.y((p1.y() + p2.y()) * 0.5);\n      direction.x(p1.y() - p2.y());\n      direction.y(p2.x() - p1.x());\n    } else {\n      origin = cell1.contains_segment() ?\n          retrieve_point(cell2) :\n          retrieve_point(cell1);\n      segment_type segment = cell1.contains_segment() ?\n          retrieve_segment(cell1) :\n          retrieve_segment(cell2);\n      coordinate_type dx = high(segment).x() - low(segment).x();\n      coordinate_type dy = high(segment).y() - low(segment).y();\n      if ((low(segment) == origin) ^ cell1.contains_point()) {\n        direction.x(dy);\n        direction.y(-dx);\n      } else {\n        direction.x(-dy);\n        direction.y(dx);\n      }\n    }\n    coordinate_type side = xh(brect_) - xl(brect_);\n    coordinate_type koef =\n        side / (std::max)(fabs(direction.x()), fabs(direction.y()));\n    if (edge.vertex0() == NULL) {\n      clipped_edge-\u003epush_back(point_type(\n          origin.x() - direction.x() * koef,\n          origin.y() - direction.y() * koef));\n    } else {\n      clipped_edge-\u003epush_back(\n          point_type(edge.vertex0()-\u003ex(), edge.vertex0()-\u003ey()));\n    }\n    if (edge.vertex1() == NULL) {\n      clipped_edge-\u003epush_back(point_type(\n          origin.x() + direction.x() * koef,\n          origin.y() + direction.y() * koef));\n    } else {\n      clipped_edge-\u003epush_back(\n          point_type(edge.vertex1()-\u003ex(), edge.vertex1()-\u003ey()));\n    }\n  }\n\n  void sample_curved_edge(\n      const edge_type\u0026 edge,\n      std::vector\u003cpoint_type\u003e* sampled_edge) {\n    coordinate_type max_dist = 1E-3 * (xh(brect_) - xl(brect_));\n    point_type point = edge.cell()-\u003econtains_point() ?\n        retrieve_point(*edge.cell()) :\n        retrieve_point(*edge.twin()-\u003ecell());\n    segment_type segment = edge.cell()-\u003econtains_point() ?\n        retrieve_segment(*edge.twin()-\u003ecell()) :\n        retrieve_segment(*edge.cell());\n    voronoi_visual_utils\u003ccoordinate_type\u003e::discretize(\n        point, segment, max_dist, sampled_edge);\n  }\n\n  point_type retrieve_point(const cell_type\u0026 cell) {\n    source_index_type index = cell.source_index();\n    source_category_type category = cell.source_category();\n    if (category == SOURCE_CATEGORY_SINGLE_POINT) {\n      return point_data_[index];\n    }\n    index -= point_data_.size();\n    if (category == SOURCE_CATEGORY_SEGMENT_START_POINT) {\n      return low(segment_data_[index]);\n    } else {\n      return high(segment_data_[index]);\n    }\n  }\n\n  segment_type retrieve_segment(const cell_type\u0026 cell) {\n    source_index_type index = cell.source_index() - point_data_.size();\n    return segment_data_[index];\n  }\n\n  point_type shift_;\n  std::vector\u003cpoint_type\u003e point_data_;\n  std::vector\u003csegment_type\u003e segment_data_;\n  rect_type brect_;\n  VB vb_;\n  VD vd_;\n  bool brect_initialized_;\n  bool primary_edges_only_;\n  bool internal_edges_only_;\n};\n\nclass MainWindow : public QWidget {\n  Q_OBJECT\n\n public:\n  MainWindow() {\n    glWidget_ = new GLWidget();\n    file_dir_ = QDir(QDir::currentPath(), tr(\"*.txt\"));\n    file_name_ = tr(\"\");\n\n    QHBoxLayout* centralLayout = new QHBoxLayout;\n    centralLayout-\u003eaddWidget(glWidget_);\n    centralLayout-\u003eaddLayout(create_file_layout());\n    setLayout(centralLayout);\n\n    update_file_list();\n    setWindowTitle(tr(\"Voronoi Visualizer\"));\n    layout()-\u003esetSizeConstraint(QLayout::SetFixedSize);\n  }\n\n private slots:\n  void primary_edges_only() {\n    glWidget_-\u003eshow_primary_edges_only();\n  }\n\n  void internal_edges_only() {\n    glWidget_-\u003eshow_internal_edges_only();\n  }\n\n  void browse() {\n    QString new_path = QFileDialog::getExistingDirectory(\n        0, tr(\"Choose Directory\"), file_dir_.absolutePath());\n    if (new_path.isEmpty()) {\n      return;\n    }\n    file_dir_.setPath(new_path);\n    update_file_list();\n  }\n\n  void build() {\n    file_name_ = file_list_-\u003ecurrentItem()-\u003etext();\n    QString file_path = file_dir_.filePath(file_name_);\n    message_label_-\u003esetText(\"Building...\");\n    glWidget_-\u003ebuild(file_path);\n    message_label_-\u003esetText(\"Double click the item to build voronoi diagram:\");\n    setWindowTitle(tr(\"Voronoi Visualizer - \") + file_path);\n  }\n\n  void print_scr() {\n    if (!file_name_.isEmpty()) {\n      QImage screenshot = glWidget_-\u003egrabFrameBuffer(true);\n      QString output_file = file_dir_.absolutePath() + tr(\"/\") +\n          file_name_.left(file_name_.indexOf('.')) + tr(\".png\");\n      screenshot.save(output_file, 0, -1);\n    }\n  }\n\n private:\n  QGridLayout* create_file_layout() {\n    QGridLayout* file_layout = new QGridLayout;\n\n    message_label_ = new QLabel(\"Double click item to build voronoi diagram:\");\n\n    file_list_ = new QListWidget();\n    file_list_-\u003econnect(file_list_,\n                        SIGNAL(itemDoubleClicked(QListWidgetItem*)),\n                        this,\n                        SLOT(build()));\n\n    QCheckBox* primary_checkbox = new QCheckBox(\"Show primary edges only.\");\n    connect(primary_checkbox, SIGNAL(clicked()),\n        this, SLOT(primary_edges_only()));\n\n    QCheckBox* internal_checkbox = new QCheckBox(\"Show internal edges only.\");\n    connect(internal_checkbox, SIGNAL(clicked()),\n        this, SLOT(internal_edges_only()));\n\n    QPushButton* browse_button =\n        new QPushButton(tr(\"Browse Input Directory\"));\n    connect(browse_button, SIGNAL(clicked()), this, SLOT(browse()));\n    browse_button-\u003esetMinimumHeight(50);\n\n    QPushButton* print_scr_button = new QPushButton(tr(\"Make Screenshot\"));\n    connect(print_scr_button, SIGNAL(clicked()), this, SLOT(print_scr()));\n    print_scr_button-\u003esetMinimumHeight(50);\n\n    file_layout-\u003eaddWidget(message_label_, 0, 0);\n    file_layout-\u003eaddWidget(file_list_, 1, 0);\n    file_layout-\u003eaddWidget(primary_checkbox, 2, 0);\n    file_layout-\u003eaddWidget(internal_checkbox, 3, 0);\n    file_layout-\u003eaddWidget(browse_button, 4, 0);\n    file_layout-\u003eaddWidget(print_scr_button, 5, 0);\n\n    return file_layout;\n  }\n\n  void update_file_list() {\n    QFileInfoList list = file_dir_.entryInfoList();\n    file_list_-\u003eclear();\n    if (file_dir_.count() == 0) {\n      return;\n    }\n    QFileInfoList::const_iterator it;\n    for (it = list.begin(); it != list.end(); it++) {\n      file_list_-\u003eaddItem(it-\u003efileName());\n    }\n    file_list_-\u003esetCurrentRow(0);\n  }\n\n  QDir file_dir_;\n  QString file_name_;\n  GLWidget* glWidget_;\n  QListWidget* file_list_;\n  QLabel* message_label_;\n};\n\nint main(int argc, char* argv[]) {\n  QApplication app(argc, argv);\n  MainWindow window;\n  window.show();\n  return app.exec();\n}\n\n#include \"voronoi_visualizer.moc\"\n"}
{"repo_name":"waddlesplash/DolphinQt","ref":"refs/heads/dolphin-qt","path":"Externals/wxWidgets3/src/osx/carbon/textctrl.cpp","copies":"85","language":"C++","content":"/////////////////////////////////////////////////////////////////////////////\n// Name:        src/osx/carbon/textctrl.cpp\n// Purpose:     wxTextCtrl\n// Author:      Stefan Csomor\n// Modified by: Ryan Norton (MLTE GetLineLength and GetLineText)\n// Created:     1998-01-01\n// Copyright:   (c) Stefan Csomor\n// Licence:     wxWindows licence\n/////////////////////////////////////////////////////////////////////////////\n\n#include \"wx/wxprec.h\"\n\n#if wxUSE_TEXTCTRL\n\n#include \"wx/textctrl.h\"\n\n#ifndef WX_PRECOMP\n    #include \"wx/intl.h\"\n    #include \"wx/app.h\"\n    #include \"wx/utils.h\"\n    #include \"wx/dc.h\"\n    #include \"wx/button.h\"\n    #include \"wx/menu.h\"\n    #include \"wx/settings.h\"\n    #include \"wx/msgdlg.h\"\n    #include \"wx/toplevel.h\"\n#endif\n\n#ifdef __DARWIN__\n    #include \u003csys/types.h\u003e\n    #include \u003csys/stat.h\u003e\n#else\n    #include \u003cstat.h\u003e\n#endif\n\n#if wxUSE_STD_IOSTREAM\n    #if wxUSE_IOSTREAMH\n        #include \u003cfstream.h\u003e\n    #else\n        #include \u003cfstream\u003e\n    #endif\n#endif\n\n#include \"wx/filefn.h\"\n#include \"wx/sysopt.h\"\n#include \"wx/thread.h\"\n\n#include \"wx/osx/private.h\"\n#include \"wx/osx/carbon/private/mactext.h\"\n\nclass wxMacFunctor\n{\npublic :\n    wxMacFunctor() {}\n    virtual ~wxMacFunctor() {}\n\n    virtual void* operator()() = 0 ;\n\n    static void* CallBackProc( void *param )\n    {\n        wxMacFunctor* f = (wxMacFunctor*) param ;\n        void *result = (*f)() ;\n        return result ;\n    }\n} ;\n\ntemplate\u003ctypename classtype, typename param1type\u003e\n\nclass wxMacObjectFunctor1 : public wxMacFunctor\n{\n    typedef void (classtype::*function)( param1type p1 ) ;\n    typedef void (classtype::*ref_function)( const param1type\u0026 p1 ) ;\npublic :\n    wxMacObjectFunctor1( classtype *obj , function f , param1type p1 ) :\n        wxMacFunctor()\n    {\n        m_object = obj ;\n        m_function = f ;\n        m_param1 = p1 ;\n    }\n\n    wxMacObjectFunctor1( classtype *obj , ref_function f , param1type p1 ) :\n        wxMacFunctor()\n    {\n        m_object = obj ;\n        m_refFunction = f ;\n        m_param1 = p1 ;\n    }\n\n    virtual ~wxMacObjectFunctor1() {}\n\n    virtual void* operator()()\n    {\n        (m_object-\u003e*m_function)( m_param1 ) ;\n        return NULL ;\n    }\n\nprivate :\n    classtype* m_object ;\n    param1type m_param1 ;\n    union\n    {\n        function m_function ;\n        ref_function m_refFunction ;\n    } ;\n} ;\n\ntemplate\u003ctypename classtype, typename param1type\u003e\nvoid* wxMacMPRemoteCall( classtype *object , void (classtype::*function)( param1type p1 ) , param1type p1 )\n{\n    wxMacObjectFunctor1\u003cclasstype, param1type\u003e params(object, function, p1) ;\n    void *result =\n        MPRemoteCall( wxMacFunctor::CallBackProc , \u0026params , kMPOwningProcessRemoteContext ) ;\n    return result ;\n}\n\ntemplate\u003ctypename classtype, typename param1type\u003e\nvoid* wxMacMPRemoteCall( classtype *object , void (classtype::*function)( const param1type\u0026 p1 ) , param1type p1 )\n{\n    wxMacObjectFunctor1\u003cclasstype,param1type\u003e params(object, function, p1) ;\n    void *result =\n        MPRemoteCall( wxMacFunctor::CallBackProc , \u0026params , kMPOwningProcessRemoteContext ) ;\n    return result ;\n}\n\ntemplate\u003ctypename classtype, typename param1type\u003e\nvoid* wxMacMPRemoteGUICall( classtype *object , void (classtype::*function)( param1type p1 ) , param1type p1 )\n{\n    wxMutexGuiLeave() ;\n    void *result = wxMacMPRemoteCall( object , function , p1 ) ;\n    wxMutexGuiEnter() ;\n    return result ;\n}\n\ntemplate\u003ctypename classtype, typename param1type\u003e\nvoid* wxMacMPRemoteGUICall( classtype *object , void (classtype::*function)( const param1type\u0026 p1 ) , param1type p1 )\n{\n    wxMutexGuiLeave() ;\n    void *result = wxMacMPRemoteCall( object , function , p1 ) ;\n    wxMutexGuiEnter() ;\n    return result ;\n}\n\nclass WXDLLEXPORT wxMacPortSaver\n{\n    wxDECLARE_NO_COPY_CLASS(wxMacPortSaver);\n\npublic:\n    wxMacPortSaver( GrafPtr port );\n    ~wxMacPortSaver();\nprivate :\n    GrafPtr m_port;\n};\n\n\n/*\n Clips to the visible region of a control within the current port\n */\n\nclass WXDLLEXPORT wxMacWindowClipper : public wxMacPortSaver\n{\n    wxDECLARE_NO_COPY_CLASS(wxMacWindowClipper);\n\npublic:\n    wxMacWindowClipper( const wxWindow* win );\n    ~wxMacWindowClipper();\nprivate:\n    GrafPtr   m_newPort;\n    RgnHandle m_formerClip;\n    RgnHandle m_newClip;\n};\n\nwxMacPortSaver::wxMacPortSaver( GrafPtr port )\n{\n    ::GetPort( \u0026m_port );\n    ::SetPort( port );\n}\n\nwxMacPortSaver::~wxMacPortSaver()\n{\n    ::SetPort( m_port );\n}\n\nwxMacWindowClipper::wxMacWindowClipper( const wxWindow* win ) :\nwxMacPortSaver( (GrafPtr) GetWindowPort( (WindowRef) win-\u003eMacGetTopLevelWindowRef() ) )\n{\n    m_newPort = (GrafPtr) GetWindowPort( (WindowRef) win-\u003eMacGetTopLevelWindowRef() ) ;\n    m_formerClip = NewRgn() ;\n    m_newClip = NewRgn() ;\n    GetClip( m_formerClip ) ;\n\n    if ( win )\n    {\n        // guard against half constructed objects, this just leads to a empty clip\n        if ( win-\u003eGetPeer() )\n        {\n            int x = 0 , y = 0;\n            win-\u003eMacWindowToRootWindow( \u0026x, \u0026y ) ;\n\n            // get area including focus rect\n            HIShapeGetAsQDRgn( ((wxWindow*)win)-\u003eMacGetVisibleRegion(true).GetWXHRGN() , m_newClip );\n            if ( !EmptyRgn( m_newClip ) )\n                OffsetRgn( m_newClip , x , y ) ;\n        }\n\n        SetClip( m_newClip ) ;\n    }\n}\n\nwxMacWindowClipper::~wxMacWindowClipper()\n{\n    SetPort( m_newPort ) ;\n    SetClip( m_formerClip ) ;\n    DisposeRgn( m_newClip ) ;\n    DisposeRgn( m_formerClip ) ;\n}\n\n// common parts for implementations based on MLTE\n\nclass wxMacMLTEControl : public wxMacControl, public wxTextWidgetImpl\n{\npublic :\n    wxMacMLTEControl( wxTextCtrl *peer ) ;\n    ~wxMacMLTEControl() {}\n\n    virtual bool        CanFocus() const\n                        { return true; }\n\n    virtual wxString GetStringValue() const ;\n    virtual void SetStringValue( const wxString \u0026str ) ;\n\n    static TXNFrameOptions FrameOptionsFromWXStyle( long wxStyle ) ;\n\n    void AdjustCreationAttributes( const wxColour\u0026 background, bool visible ) ;\n\n    virtual void SetFont( const wxFont \u0026 font, const wxColour\u0026 foreground, long windowStyle, bool ignoreBlack ) ;\n    virtual void SetBackgroundColour(const wxColour\u0026 col );\n    virtual void SetStyle( long start, long end, const wxTextAttr\u0026 style ) ;\n    virtual void Copy() ;\n    virtual void Cut() ;\n    virtual void Paste() ;\n    virtual bool CanPaste() const ;\n    virtual void SetEditable( bool editable ) ;\n    virtual long GetLastPosition() const ;\n    virtual void Replace( long from, long to, const wxString \u0026str ) ;\n    virtual void Remove( long from, long to ) ;\n    virtual void GetSelection( long* from, long* to ) const ;\n    virtual void SetSelection( long from, long to ) ;\n\n    virtual void WriteText( const wxString\u0026 str ) ;\n\n    virtual bool HasOwnContextMenu() const\n    {\n        TXNCommandEventSupportOptions options ;\n        TXNGetCommandEventSupport( m_txn , \u0026 options ) ;\n        return options \u0026 kTXNSupportEditCommandProcessing ;\n    }\n\n    virtual void CheckSpelling(bool check)\n    {\n        TXNSetSpellCheckAsYouType( m_txn, (Boolean) check );\n    }\n    virtual void Clear() ;\n\n    virtual bool CanUndo() const ;\n    virtual void Undo() ;\n    virtual bool CanRedo()  const;\n    virtual void Redo() ;\n    virtual int GetNumberOfLines() const ;\n    virtual long XYToPosition(long x, long y) const ;\n    virtual bool PositionToXY(long pos, long *x, long *y) const ;\n    virtual void ShowPosition( long pos ) ;\n    virtual int GetLineLength(long lineNo) const ;\n    virtual wxString GetLineText(long lineNo) const ;\n\n    void SetTXNData( const wxString\u0026 st , TXNOffset start , TXNOffset end ) ;\n    TXNObject GetTXNObject() { return m_txn ; }\n\nprotected :\n    void TXNSetAttribute( const wxTextAttr\u0026 style , long from , long to ) ;\n\n    TXNObject m_txn ;\n} ;\n\n// implementation available under OSX\n\nclass wxMacMLTEHIViewControl : public wxMacMLTEControl\n{\npublic :\n    wxMacMLTEHIViewControl( wxTextCtrl *wxPeer,\n                             const wxString\u0026 str,\n                             const wxPoint\u0026 pos,\n                             const wxSize\u0026 size, long style ) ;\n    virtual ~wxMacMLTEHIViewControl() ;\n\n    virtual bool SetFocus() ;\n    virtual bool HasFocus() const ;\n    virtual void SetBackgroundColour(const wxColour\u0026 col ) ;\n\nprotected :\n    HIViewRef m_scrollView ;\n    HIViewRef m_textView ;\n};\n\n// 'classic' MLTE implementation\n\nclass wxMacMLTEClassicControl : public wxMacMLTEControl\n{\npublic :\n    wxMacMLTEClassicControl( wxTextCtrl *wxPeer,\n                             const wxString\u0026 str,\n                             const wxPoint\u0026 pos,\n                             const wxSize\u0026 size, long style ) ;\n    virtual ~wxMacMLTEClassicControl() ;\n\n    virtual void VisibilityChanged(bool shown) ;\n    virtual void SuperChangedPosition() ;\n\n    virtual void            MacControlUserPaneDrawProc(wxInt16 part) ;\n    virtual wxInt16         MacControlUserPaneHitTestProc(wxInt16 x, wxInt16 y) ;\n    virtual wxInt16         MacControlUserPaneTrackingProc(wxInt16 x, wxInt16 y, void* actionProc) ;\n    virtual void            MacControlUserPaneIdleProc() ;\n    virtual wxInt16         MacControlUserPaneKeyDownProc(wxInt16 keyCode, wxInt16 charCode, wxInt16 modifiers) ;\n    virtual void            MacControlUserPaneActivateProc(bool activating) ;\n    virtual wxInt16         MacControlUserPaneFocusProc(wxInt16 action) ;\n    virtual void            MacControlUserPaneBackgroundProc(void* info) ;\n\n    virtual bool SetupCursor( const wxPoint\u0026 WXUNUSED(pt) )\n    {\n        MacControlUserPaneIdleProc();\n        return true;\n    }\n\n    virtual void            Move(int x, int y, int width, int height);\n\nprotected :\n    OSStatus                 DoCreate();\n\n    void                    MacUpdatePosition() ;\n    void                    MacActivatePaneText(bool setActive) ;\n    void                    MacFocusPaneText(bool setFocus) ;\n    void                    MacSetObjectVisibility(bool vis) ;\n\nprivate :\n    TXNFrameID              m_txnFrameID ;\n    GrafPtr                 m_txnPort ;\n    WindowRef               m_txnWindow ;\n    // bounds of the control as we last did set the txn frames\n    Rect                    m_txnControlBounds ;\n    Rect                    m_txnVisBounds ;\n\n    static pascal void TXNScrollActionProc( ControlRef controlRef , ControlPartCode partCode ) ;\n    static pascal void TXNScrollInfoProc(\n        SInt32 iValue, SInt32 iMaximumValue,\n        TXNScrollBarOrientation iScrollBarOrientation, SInt32 iRefCon ) ;\n\n    ControlRef              m_sbHorizontal ;\n    SInt32                  m_lastHorizontalValue ;\n    ControlRef              m_sbVertical ;\n    SInt32                  m_lastVerticalValue ;\n};\n\nwxWidgetImplType* wxWidgetImpl::CreateTextControl( wxTextCtrl* wxpeer,\n                                    wxWindowMac* WXUNUSED(parent),\n                                    wxWindowID WXUNUSED(id),\n                                    const wxString\u0026 str,\n                                    const wxPoint\u0026 pos,\n                                    const wxSize\u0026 size,\n                                    long style,\n                                    long WXUNUSED(extraStyle))\n{\n    return new wxMacMLTEHIViewControl( wxpeer , str , pos , size , style ) ;\n}\n\n// ----------------------------------------------------------------------------\n// standard unicode control implementation\n// ----------------------------------------------------------------------------\n\n// the current unicode textcontrol implementation has a bug : only if the control\n// is currently having the focus, the selection can be retrieved by the corresponding\n// data tag. So we have a mirroring using a member variable\n// TODO : build event table using virtual member functions for wxMacControl\n\nstatic const EventTypeSpec unicodeTextControlEventList[] =\n{\n    { kEventClassControl , kEventControlSetFocusPart } ,\n} ;\n\nstatic pascal OSStatus wxMacUnicodeTextControlControlEventHandler( EventHandlerCallRef handler , EventRef event , void *data )\n{\n    OSStatus result = eventNotHandledErr ;\n    wxMacUnicodeTextControl* focus = (wxMacUnicodeTextControl*) data ;\n    wxMacCarbonEvent cEvent( event ) ;\n\n    switch ( GetEventKind( event ) )\n    {\n        case kEventControlSetFocusPart :\n        {\n            ControlPartCode controlPart = cEvent.GetParameter\u003cControlPartCode\u003e(kEventParamControlPart , typeControlPartCode );\n            if ( controlPart == kControlFocusNoPart )\n            {\n                // about to lose focus -\u003e store selection to field\n                focus-\u003eGetData\u003cControlEditTextSelectionRec\u003e( 0, kControlEditTextSelectionTag, \u0026focus-\u003em_selection );\n            }\n            result = CallNextEventHandler(handler,event) ;\n            if ( controlPart != kControlFocusNoPart )\n            {\n                // about to gain focus -\u003e set selection from field\n                focus-\u003eSetData\u003cControlEditTextSelectionRec\u003e( 0, kControlEditTextSelectionTag, \u0026focus-\u003em_selection );\n            }\n            break;\n        }\n        default:\n            break ;\n    }\n\n    return result ;\n}\n\nstatic pascal OSStatus wxMacUnicodeTextControlEventHandler( EventHandlerCallRef handler , EventRef event , void *data )\n{\n    OSStatus result = eventNotHandledErr ;\n\n    switch ( GetEventClass( event ) )\n    {\n        case kEventClassControl :\n            result = wxMacUnicodeTextControlControlEventHandler( handler , event , data ) ;\n            break ;\n\n        default :\n            break ;\n    }\n    return result ;\n}\n\nDEFINE_ONE_SHOT_HANDLER_GETTER( wxMacUnicodeTextControlEventHandler )\n\nwxMacUnicodeTextControl::wxMacUnicodeTextControl( wxTextCtrl *wxPeer )\n    : wxMacControl( wxPeer ),\n      wxTextWidgetImpl( wxPeer )\n{\n}\n\nwxMacUnicodeTextControl::wxMacUnicodeTextControl( wxTextCtrl *wxPeer,\n    const wxString\u0026 str,\n    const wxPoint\u0026 pos,\n    const wxSize\u0026 size, long style )\n    : wxMacControl( wxPeer ),\n      wxTextWidgetImpl( wxPeer )\n{\n    m_font = wxPeer-\u003eGetFont() ;\n    m_windowStyle = style ;\n    m_selection.selStart = m_selection.selEnd = 0;\n    Rect bounds = wxMacGetBoundsForControl( wxPeer , pos , size ) ;\n    wxString st = str ;\n    wxMacConvertNewlines10To13( \u0026st ) ;\n    wxCFStringRef cf(st , m_font.GetEncoding()) ;\n\n    m_valueTag = kControlEditTextCFStringTag ;\n    Boolean isPassword = ( m_windowStyle \u0026 wxTE_PASSWORD ) != 0 ;\n    if ( isPassword )\n    {\n        m_valueTag = kControlEditTextPasswordCFStringTag ;\n    }\n    OSStatus err = CreateEditUnicodeTextControl(\n        MAC_WXHWND(wxPeer-\u003eMacGetTopLevelWindowRef()), \u0026bounds , cf ,\n        isPassword , NULL , \u0026m_controlRef ) ;\n    verify_noerr( err );\n\n    if ( !(m_windowStyle \u0026 wxTE_MULTILINE) )\n        SetData\u003cBoolean\u003e( kControlEditTextPart , kControlEditTextSingleLineTag , true ) ;\n\n    InstallEventHandlers();\n}\n\nvoid wxMacUnicodeTextControl::InstallEventHandlers()\n{\n    ::InstallControlEventHandler( m_controlRef , GetwxMacUnicodeTextControlEventHandlerUPP(),\n                                GetEventTypeCount(unicodeTextControlEventList), unicodeTextControlEventList, this,\n                                (EventHandlerRef*) \u0026m_macTextCtrlEventHandler);\n}\n\nwxMacUnicodeTextControl::~wxMacUnicodeTextControl()\n{\n    ::RemoveEventHandler((EventHandlerRef) m_macTextCtrlEventHandler);\n}\n\nvoid wxMacUnicodeTextControl::VisibilityChanged(bool shown)\n{\n    if ( !(m_windowStyle \u0026 wxTE_MULTILINE) \u0026\u0026 shown )\n    {\n        // work around a refresh issue insofar as not always the entire content is shown,\n        // even if this would be possible\n        ControlEditTextSelectionRec sel ;\n        CFStringRef value = NULL ;\n\n        verify_noerr( GetData\u003cControlEditTextSelectionRec\u003e( 0, kControlEditTextSelectionTag, \u0026sel ) );\n        verify_noerr( GetData\u003cCFStringRef\u003e( 0, m_valueTag, \u0026value ) );\n        verify_noerr( SetData\u003cCFStringRef\u003e( 0, m_valueTag, \u0026value ) );\n        verify_noerr( SetData\u003cControlEditTextSelectionRec\u003e( 0, kControlEditTextSelectionTag, \u0026sel ) );\n\n        CFRelease( value ) ;\n    }\n}\n\nwxString wxMacUnicodeTextControl::GetStringValue() const\n{\n    wxString result ;\n    CFStringRef value = GetData\u003cCFStringRef\u003e(0, m_valueTag) ;\n    if ( value )\n    {\n        wxCFStringRef cf(value) ;\n        result = cf.AsString() ;\n    }\n\n#if '\\n' == 10\n    wxMacConvertNewlines13To10( \u0026result ) ;\n#else\n    wxMacConvertNewlines10To13( \u0026result ) ;\n#endif\n\n    return result ;\n}\n\nvoid wxMacUnicodeTextControl::SetStringValue( const wxString \u0026str )\n{\n    wxString st = str ;\n    wxMacConvertNewlines10To13( \u0026st ) ;\n    wxCFStringRef cf( st , m_font.GetEncoding() ) ;\n    verify_noerr( SetData\u003cCFStringRef\u003e( 0, m_valueTag , cf ) ) ;\n}\n\nvoid wxMacUnicodeTextControl::Copy()\n{\n    SendHICommand( kHICommandCopy ) ;\n}\n\nvoid wxMacUnicodeTextControl::Cut()\n{\n    SendHICommand( kHICommandCut ) ;\n}\n\nvoid wxMacUnicodeTextControl::Paste()\n{\n    SendHICommand( kHICommandPaste ) ;\n}\n\nbool wxMacUnicodeTextControl::CanPaste() const\n{\n    return true ;\n}\n\nvoid wxMacUnicodeTextControl::SetEditable(bool WXUNUSED(editable))\n{\n#if 0 // leads to problem because text cannot be selected anymore\n    SetData\u003cBoolean\u003e( kControlEditTextPart , kControlEditTextLockedTag , (Boolean) !editable ) ;\n#endif\n}\n\nvoid wxMacUnicodeTextControl::GetSelection( long* from, long* to ) const\n{\n    ControlEditTextSelectionRec sel ;\n    if (HasFocus())\n        verify_noerr( GetData\u003cControlEditTextSelectionRec\u003e( 0, kControlEditTextSelectionTag, \u0026sel ) ) ;\n    else\n        sel = m_selection ;\n\n    if ( from )\n        *from = sel.selStart ;\n    if ( to )\n        *to = sel.selEnd ;\n}\n\nvoid wxMacUnicodeTextControl::SetSelection( long from , long to )\n{\n    ControlEditTextSelectionRec sel ;\n    wxString result ;\n    int textLength = 0 ;\n    CFStringRef value = GetData\u003cCFStringRef\u003e(0, m_valueTag) ;\n    if ( value )\n    {\n        wxCFStringRef cf(value) ;\n        textLength = cf.AsString().length() ;\n    }\n\n    if ((from == -1) \u0026\u0026 (to == -1))\n    {\n        from = 0 ;\n        to = textLength ;\n    }\n    else\n    {\n        from = wxMin(textLength,wxMax(from,0)) ;\n        if ( to == -1 )\n            to = textLength;\n        else\n            to = wxMax(0,wxMin(textLength,to)) ;\n    }\n\n    sel.selStart = from ;\n    sel.selEnd = to ;\n    if ( HasFocus() )\n        SetData\u003cControlEditTextSelectionRec\u003e( 0, kControlEditTextSelectionTag, \u0026sel ) ;\n    else\n        m_selection = sel;\n}\n\nvoid wxMacUnicodeTextControl::WriteText( const wxString\u0026 str )\n{\n    // TODO: this MPRemoting will be moved into a remoting peer proxy for any command\n    if ( !wxIsMainThread() )\n    {\n#if wxOSX_USE_CARBON\n        // unfortunately CW 8 is not able to correctly deduce the template types,\n        // so we have to instantiate explicitly\n        wxMacMPRemoteGUICall\u003cwxTextCtrl,wxString\u003e( (wxTextCtrl*) GetWXPeer() , \u0026wxTextCtrl::WriteText , str ) ;\n#endif\n        return ;\n    }\n\n    wxString st = str ;\n    wxMacConvertNewlines10To13( \u0026st ) ;\n\n    if ( HasFocus() )\n    {\n        wxCFStringRef cf(st , m_font.GetEncoding() ) ;\n        CFStringRef value = cf ;\n        SetData\u003cCFStringRef\u003e( 0, kControlEditTextInsertCFStringRefTag, \u0026value );\n    }\n    else\n    {\n        wxString val = GetStringValue() ;\n        long start , end ;\n        GetSelection( \u0026start , \u0026end ) ;\n        val.Remove( start , end - start ) ;\n        val.insert( start , str ) ;\n        SetStringValue( val ) ;\n        SetSelection( start + str.length() , start + str.length() ) ;\n    }\n}\n\n// ----------------------------------------------------------------------------\n// MLTE control implementation (common part)\n// ----------------------------------------------------------------------------\n\n// if MTLE is read only, no changes at all are allowed, not even from\n// procedural API, in order to allow changes via API all the same we must undo\n// the readonly status while we are executing, this class helps to do so\n\nclass wxMacEditHelper\n{\npublic :\n    wxMacEditHelper( TXNObject txn )\n    {\n        TXNControlTag tag[] = { kTXNIOPrivilegesTag } ;\n        m_txn = txn ;\n        TXNGetTXNObjectControls( m_txn , 1 , tag , m_data ) ;\n        if ( m_data[0].uValue == kTXNReadOnly )\n        {\n            TXNControlData data[] = { { kTXNReadWrite } } ;\n            TXNSetTXNObjectControls( m_txn , false , 1 , tag , data ) ;\n        }\n    }\n\n    ~wxMacEditHelper()\n    {\n        TXNControlTag tag[] = { kTXNIOPrivilegesTag } ;\n        if ( m_data[0].uValue == kTXNReadOnly )\n            TXNSetTXNObjectControls( m_txn , false , 1 , tag , m_data ) ;\n    }\n\nprotected :\n    TXNObject m_txn ;\n    TXNControlData m_data[1] ;\n} ;\n\nwxMacMLTEControl::wxMacMLTEControl( wxTextCtrl *peer )\n    : wxMacControl( peer ),\n      wxTextWidgetImpl( peer )\n{\n    SetNeedsFocusRect( true ) ;\n}\n\nwxString wxMacMLTEControl::GetStringValue() const\n{\n    wxString result ;\n    OSStatus err ;\n    Size actualSize = 0;\n\n    {\n#if wxUSE_UNICODE\n        Handle theText ;\n        err = TXNGetDataEncoded( m_txn, kTXNStartOffset, kTXNEndOffset, \u0026theText, kTXNUnicodeTextData );\n\n        // all done\n        if ( err != noErr )\n        {\n            actualSize = 0 ;\n        }\n        else\n        {\n            actualSize = GetHandleSize( theText ) / sizeof(UniChar) ;\n            if ( actualSize \u003e 0 )\n            {\n                wxChar *ptr = NULL ;\n\n                SetHandleSize( theText, (actualSize + 1) * sizeof(UniChar) ) ;\n                HLock( theText ) ;\n                (((UniChar*)*theText)[actualSize]) = 0 ;\n                wxMBConvUTF16 converter ;\n                size_t noChars = converter.MB2WC( NULL , (const char*)*theText , 0 ) ;\n                wxASSERT_MSG( noChars != wxCONV_FAILED, wxT(\"Unable to count the number of characters in this string!\") );\n                ptr = new wxChar[noChars + 1] ;\n\n                noChars = converter.MB2WC( ptr , (const char*)*theText , noChars + 1 ) ;\n                wxASSERT_MSG( noChars != wxCONV_FAILED, wxT(\"Conversion of string failed!\") );\n                ptr[noChars] = 0 ;\n                HUnlock( theText ) ;\n\n                ptr[actualSize] = 0 ;\n                result = wxString( ptr ) ;\n                delete [] ptr ;\n            }\n\n            DisposeHandle( theText ) ;\n        }\n#else // !wxUSE_UNICODE\n        Handle theText ;\n        err = TXNGetDataEncoded( m_txn , kTXNStartOffset, kTXNEndOffset, \u0026theText, kTXNTextData );\n\n        // all done\n        if ( err != noErr )\n        {\n            actualSize = 0 ;\n        }\n        else\n        {\n            actualSize = GetHandleSize( theText ) ;\n            if ( actualSize \u003e 0 )\n            {\n                HLock( theText ) ;\n                result = wxString( *theText , wxConvLocal , actualSize ) ;\n                HUnlock( theText ) ;\n            }\n\n            DisposeHandle( theText ) ;\n        }\n#endif // wxUSE_UNICODE/!wxUSE_UNICODE\n    }\n\n#if '\\n' == 10\n    wxMacConvertNewlines13To10( \u0026result ) ;\n#else\n    wxMacConvertNewlines10To13( \u0026result ) ;\n#endif\n\n    return result ;\n}\n\nvoid wxMacMLTEControl::SetStringValue( const wxString \u0026str )\n{\n    wxString st = str;\n    wxMacConvertNewlines10To13( \u0026st );\n\n    {\n#ifndef __LP64__\n        wxMacWindowClipper c( GetWXPeer() ) ;\n#endif\n\n        {\n            wxMacEditHelper help( m_txn );\n            SetTXNData( st, kTXNStartOffset, kTXNEndOffset );\n        }\n\n        TXNSetSelection( m_txn, 0, 0 );\n        TXNShowSelection( m_txn, kTXNShowStart );\n    }\n}\n\nTXNFrameOptions wxMacMLTEControl::FrameOptionsFromWXStyle( long wxStyle )\n{\n    TXNFrameOptions frameOptions = kTXNDontDrawCaretWhenInactiveMask;\n\n    frameOptions |= kTXNDoFontSubstitutionMask;\n\n    if ( ! (wxStyle \u0026 wxTE_NOHIDESEL) )\n        frameOptions |= kTXNDontDrawSelectionWhenInactiveMask ;\n\n    if ( wxStyle \u0026 (wxHSCROLL | wxTE_DONTWRAP) )\n        frameOptions |= kTXNWantHScrollBarMask ;\n\n    if ( wxStyle \u0026 wxTE_MULTILINE )\n    {\n        if ( ! (wxStyle \u0026 wxTE_DONTWRAP ) )\n            frameOptions |= kTXNAlwaysWrapAtViewEdgeMask ;\n\n        if ( !(wxStyle \u0026 wxTE_NO_VSCROLL) )\n        {\n            frameOptions |= kTXNWantVScrollBarMask ;\n\n            // The following code causes drawing problems on 10.4. Perhaps it can be restored for\n            // older versions of the OS, but I'm not sure it's appropriate to put a grow icon here\n            // anyways, as AFAIK users can't actually use it to resize the text ctrl.\n//            if ( frameOptions \u0026 kTXNWantHScrollBarMask )\n//                frameOptions |= kTXNDrawGrowIconMask ;\n        }\n    }\n    else\n    {\n        frameOptions |= kTXNSingleLineOnlyMask ;\n    }\n\n    return frameOptions ;\n}\n\nvoid wxMacMLTEControl::AdjustCreationAttributes(const wxColour \u0026background,\n                                                bool WXUNUSED(visible))\n{\n    TXNControlTag iControlTags[] =\n        {\n            kTXNDoFontSubstitution,\n            kTXNWordWrapStateTag ,\n        };\n    TXNControlData iControlData[] =\n        {\n            { true },\n            { kTXNNoAutoWrap },\n        };\n\n    int toptag = WXSIZEOF( iControlTags ) ;\n\n    if ( m_windowStyle \u0026 wxTE_MULTILINE )\n    {\n        iControlData[1].uValue =\n            (m_windowStyle \u0026 wxTE_DONTWRAP)\n            ? kTXNNoAutoWrap\n            : kTXNAutoWrap;\n    }\n\n    OSStatus err = TXNSetTXNObjectControls( m_txn, false, toptag, iControlTags, iControlData ) ;\n    verify_noerr( err );\n\n    // setting the default font:\n    // under 10.2 this causes a visible caret, therefore we avoid it\n\n    Str255 fontName ;\n    SInt16 fontSize ;\n    Style fontStyle ;\n\n    GetThemeFont( kThemeSystemFont , GetApplicationScript() , fontName , \u0026fontSize , \u0026fontStyle ) ;\n\n    TXNTypeAttributes typeAttr[] =\n    {\n        { kTXNQDFontNameAttribute , kTXNQDFontNameAttributeSize , { (void*) fontName } } ,\n        { kTXNQDFontSizeAttribute , kTXNFontSizeAttributeSize , { (void*) (fontSize \u003c\u003c 16) } } ,\n        { kTXNQDFontStyleAttribute , kTXNQDFontStyleAttributeSize , { (void*) normal } } ,\n    } ;\n\n    err = TXNSetTypeAttributes(\n        m_txn, WXSIZEOF(typeAttr),\n        typeAttr, kTXNStartOffset, kTXNEndOffset );\n    verify_noerr( err );\n\n    if ( m_windowStyle \u0026 wxTE_PASSWORD )\n    {\n        UniChar c = 0x00A5 ;\n        err = TXNEchoMode( m_txn , c , 0 , true );\n        verify_noerr( err );\n    }\n\n    TXNBackground tback;\n    tback.bgType = kTXNBackgroundTypeRGB;\n    background.GetRGBColor( \u0026tback.bg.color );\n    TXNSetBackground( m_txn , \u0026tback );\n\n\n    TXNCommandEventSupportOptions options ;\n    if ( TXNGetCommandEventSupport( m_txn, \u0026options ) == noErr )\n    {\n        options |=\n            kTXNSupportEditCommandProcessing\n            | kTXNSupportEditCommandUpdating\n            | kTXNSupportFontCommandProcessing\n            | kTXNSupportFontCommandUpdating;\n\n        // only spell check when not read-only\n        // use system options for the default\n        bool checkSpelling = false ;\n        if ( !(m_windowStyle \u0026 wxTE_READONLY) )\n        {\n#if wxUSE_SYSTEM_OPTIONS\n            if ( wxSystemOptions::HasOption( wxMAC_TEXTCONTROL_USE_SPELL_CHECKER ) \u0026\u0026 (wxSystemOptions::GetOptionInt( wxMAC_TEXTCONTROL_USE_SPELL_CHECKER ) == 1) )\n            {\n                checkSpelling = true ;\n            }\n#endif\n        }\n\n        if ( checkSpelling )\n            options |=\n                kTXNSupportSpellCheckCommandProcessing\n                | kTXNSupportSpellCheckCommandUpdating;\n\n        TXNSetCommandEventSupport( m_txn , options ) ;\n    }\n}\n\nvoid wxMacMLTEControl::SetBackgroundColour(const wxColour\u0026 col )\n{\n    TXNBackground tback;\n    tback.bgType = kTXNBackgroundTypeRGB;\n    col.GetRGBColor(\u0026tback.bg.color);\n    TXNSetBackground( m_txn , \u0026tback );\n}\n\nstatic inline int wxConvertToTXN(int x)\n{\n    return static_cast\u003cint\u003e(x / 254.0 * 72 + 0.5);\n}\n\nvoid wxMacMLTEControl::TXNSetAttribute( const wxTextAttr\u0026 style , long from , long to )\n{\n    TXNTypeAttributes typeAttr[4] ;\n    RGBColor color ;\n    size_t typeAttrCount = 0 ;\n\n    TXNMargins margins;\n    TXNControlTag    controlTags[4];\n    TXNControlData   controlData[4];\n    size_t controlAttrCount = 0;\n\n    TXNTab* tabs = NULL;\n\n    bool relayout = false;\n    wxFont font ;\n\n    if ( style.HasFont() )\n    {\n        wxASSERT( typeAttrCount \u003c WXSIZEOF(typeAttr) );\n        font = style.GetFont() ;\n        typeAttr[typeAttrCount].tag = kTXNATSUIStyle ;\n        typeAttr[typeAttrCount].size = kTXNATSUIStyleSize ;\n        typeAttr[typeAttrCount].data.dataPtr = font.MacGetATSUStyle() ;\n        typeAttrCount++ ;\n    }\n\n    if ( style.HasTextColour() )\n    {\n        wxASSERT( typeAttrCount \u003c WXSIZEOF(typeAttr) );\n        style.GetTextColour().GetRGBColor( \u0026color );\n        typeAttr[typeAttrCount].tag = kTXNQDFontColorAttribute ;\n        typeAttr[typeAttrCount].size = kTXNQDFontColorAttributeSize ;\n        typeAttr[typeAttrCount].data.dataPtr = (void*) \u0026color ;\n        typeAttrCount++ ;\n    }\n\n    if ( style.HasAlignment() )\n    {\n        wxASSERT( controlAttrCount \u003c WXSIZEOF(controlTags) );\n        SInt32 align;\n\n        switch ( style.GetAlignment() )\n        {\n            case wxTEXT_ALIGNMENT_LEFT:\n                align = kTXNFlushLeft;\n                break;\n            case wxTEXT_ALIGNMENT_CENTRE:\n                align = kTXNCenter;\n                break;\n            case wxTEXT_ALIGNMENT_RIGHT:\n                align = kTXNFlushRight;\n                break;\n            case wxTEXT_ALIGNMENT_JUSTIFIED:\n                align = kTXNFullJust;\n                break;\n            default :\n            case wxTEXT_ALIGNMENT_DEFAULT:\n                align = kTXNFlushDefault;\n                break;\n        }\n\n        controlTags[controlAttrCount] = kTXNJustificationTag ;\n        controlData[controlAttrCount].sValue = align ;\n        controlAttrCount++ ;\n    }\n\n    if ( style.HasLeftIndent() || style.HasRightIndent() )\n    {\n        wxASSERT( controlAttrCount \u003c WXSIZEOF(controlTags) );\n        controlTags[controlAttrCount] = kTXNMarginsTag;\n        controlData[controlAttrCount].marginsPtr = \u0026margins;\n        verify_noerr( TXNGetTXNObjectControls (m_txn, 1 ,\n                                \u0026controlTags[controlAttrCount], \u0026controlData[controlAttrCount]) );\n        if ( style.HasLeftIndent() )\n        {\n            margins.leftMargin = wxConvertToTXN(style.GetLeftIndent());\n        }\n        if ( style.HasRightIndent() )\n        {\n            margins.rightMargin = wxConvertToTXN(style.GetRightIndent());\n        }\n        controlAttrCount++ ;\n    }\n\n    if ( style.HasTabs() )\n    {\n        const wxArrayInt\u0026 tabarray = style.GetTabs();\n        // unfortunately Mac only applies a tab distance, not individually different tabs\n        controlTags[controlAttrCount] = kTXNTabSettingsTag;\n        if ( tabarray.size() \u003e 0 )\n            controlData[controlAttrCount].tabValue.value = wxConvertToTXN(tabarray[0]);\n        else\n            controlData[controlAttrCount].tabValue.value = 72 ;\n\n        controlData[controlAttrCount].tabValue.tabType = kTXNLeftTab;\n        controlAttrCount++ ;\n    }\n\n    // unfortunately the relayout is not automatic\n    if ( controlAttrCount \u003e 0 )\n    {\n        verify_noerr( TXNSetTXNObjectControls (m_txn, false /* don't clear all */, controlAttrCount,\n                                controlTags, controlData) );\n        relayout = true;\n    }\n\n    if ( typeAttrCount \u003e 0 )\n    {\n        verify_noerr( TXNSetTypeAttributes( m_txn , typeAttrCount, typeAttr, from , to ) );\n        if (from != to)\n            relayout = true;\n    }\n\n    if ( tabs != NULL )\n    {\n        delete[] tabs;\n    }\n\n    if ( relayout )\n    {\n        TXNRecalcTextLayout( m_txn );\n    }\n}\n\nvoid wxMacMLTEControl::SetFont(const wxFont \u0026 font,\n                               const wxColour\u0026 foreground,\n                               long WXUNUSED(windowStyle),\n                               bool WXUNUSED(ignoreBlack))\n{\n    wxMacEditHelper help( m_txn ) ;\n    TXNSetAttribute( wxTextAttr( foreground, wxNullColour, font ), kTXNStartOffset, kTXNEndOffset ) ;\n}\n\nvoid wxMacMLTEControl::SetStyle( long start, long end, const wxTextAttr\u0026 style )\n{\n    wxMacEditHelper help( m_txn ) ;\n    TXNSetAttribute( style, start, end ) ;\n}\n\nvoid wxMacMLTEControl::Copy()\n{\n    TXNCopy( m_txn );\n}\n\nvoid wxMacMLTEControl::Cut()\n{\n    TXNCut( m_txn );\n}\n\nvoid wxMacMLTEControl::Paste()\n{\n    TXNPaste( m_txn );\n}\n\nbool wxMacMLTEControl::CanPaste() const\n{\n    return TXNIsScrapPastable() ;\n}\n\nvoid wxMacMLTEControl::SetEditable(bool editable)\n{\n    TXNControlTag tag[] = { kTXNIOPrivilegesTag } ;\n    TXNControlData data[] = { { editable ? kTXNReadWrite : kTXNReadOnly } } ;\n    TXNSetTXNObjectControls( m_txn, false, WXSIZEOF(tag), tag, data ) ;\n}\n\nlong wxMacMLTEControl::GetLastPosition() const\n{\n    wxTextPos actualsize = 0 ;\n\n    Handle theText ;\n#if wxUSE_UNICODE\n    OSErr err = TXNGetDataEncoded( m_txn, kTXNStartOffset, kTXNEndOffset, \u0026theText, kTXNUnicodeTextData );\n    // all done\n    if ( err == noErr )\n    {\n        actualsize = GetHandleSize( theText )/sizeof(UniChar);\n        DisposeHandle( theText ) ;\n    }\n#else\n    OSErr err = TXNGetDataEncoded( m_txn, kTXNStartOffset, kTXNEndOffset, \u0026theText, kTXNTextData );\n\n    // all done\n    if ( err == noErr )\n    {\n        actualsize = GetHandleSize( theText ) ;\n        DisposeHandle( theText ) ;\n    }\n#endif\n    else\n    {\n        actualsize = 0 ;\n    }\n\n    return actualsize ;\n}\n\nvoid wxMacMLTEControl::Replace( long from , long to , const wxString \u0026str )\n{\n    wxString value = str ;\n    wxMacConvertNewlines10To13( \u0026value ) ;\n\n    wxMacEditHelper help( m_txn ) ;\n#ifndef __LP64__\n    wxMacWindowClipper c( GetWXPeer() ) ;\n#endif\n\n    TXNSetSelection( m_txn, from, to == -1 ? kTXNEndOffset : to ) ;\n    TXNClear( m_txn ) ;\n    SetTXNData( value, kTXNUseCurrentSelection, kTXNUseCurrentSelection ) ;\n}\n\nvoid wxMacMLTEControl::Remove( long from , long to )\n{\n#ifndef __LP64__\n    wxMacWindowClipper c( GetWXPeer() ) ;\n#endif\n    wxMacEditHelper help( m_txn ) ;\n    TXNSetSelection( m_txn , from , to ) ;\n    TXNClear( m_txn ) ;\n}\n\nvoid wxMacMLTEControl::GetSelection( long* from, long* to) const\n{\n    TXNOffset f,t ;\n    TXNGetSelection( m_txn , \u0026f , \u0026t ) ;\n    *from = f;\n    *to = t;\n}\n\nvoid wxMacMLTEControl::SetSelection( long from , long to )\n{\n#ifndef __LP64__\n    wxMacWindowClipper c( GetWXPeer() ) ;\n#endif\n\n    // change the selection\n    if ((from == -1) \u0026\u0026 (to == -1))\n        TXNSelectAll( m_txn );\n    else\n        TXNSetSelection( m_txn, from, to == -1 ? kTXNEndOffset : to );\n\n    TXNShowSelection( m_txn, kTXNShowStart );\n}\n\nvoid wxMacMLTEControl::WriteText( const wxString\u0026 str )\n{\n    // TODO: this MPRemoting will be moved into a remoting peer proxy for any command\n    if ( !wxIsMainThread() )\n    {\n#if wxOSX_USE_CARBON\n        // unfortunately CW 8 is not able to correctly deduce the template types,\n        // so we have to instantiate explicitly\n        wxMacMPRemoteGUICall\u003cwxTextCtrl,wxString\u003e( (wxTextCtrl*) GetWXPeer() , \u0026wxTextCtrl::WriteText , str ) ;\n#endif\n        return ;\n    }\n\n    wxString st = str ;\n    wxMacConvertNewlines10To13( \u0026st ) ;\n\n    long start , end , dummy ;\n\n    GetSelection( \u0026start , \u0026dummy ) ;\n#ifndef __LP64__\n    wxMacWindowClipper c( GetWXPeer() ) ;\n#endif\n\n    {\n        wxMacEditHelper helper( m_txn ) ;\n        SetTXNData( st, kTXNUseCurrentSelection, kTXNUseCurrentSelection ) ;\n    }\n\n    GetSelection( \u0026dummy, \u0026end ) ;\n\n    // TODO: SetStyle( start , end , GetDefaultStyle() ) ;\n}\n\nvoid wxMacMLTEControl::Clear()\n{\n#ifndef __LP64__\n    wxMacWindowClipper c( GetWXPeer() ) ;\n#endif\n    wxMacEditHelper st( m_txn ) ;\n    TXNSetSelection( m_txn , kTXNStartOffset , kTXNEndOffset ) ;\n    TXNClear( m_txn ) ;\n}\n\nbool wxMacMLTEControl::CanUndo() const\n{\n    return TXNCanUndo( m_txn , NULL ) ;\n}\n\nvoid wxMacMLTEControl::Undo()\n{\n    TXNUndo( m_txn ) ;\n}\n\nbool wxMacMLTEControl::CanRedo() const\n{\n    return TXNCanRedo( m_txn , NULL ) ;\n}\n\nvoid wxMacMLTEControl::Redo()\n{\n    TXNRedo( m_txn ) ;\n}\n\nint wxMacMLTEControl::GetNumberOfLines() const\n{\n    ItemCount lines = 0 ;\n    TXNGetLineCount( m_txn, \u0026lines ) ;\n\n    return lines ;\n}\n\nlong wxMacMLTEControl::XYToPosition(long x, long y) const\n{\n    Point curpt ;\n    wxTextPos lastpos ;\n\n    // TODO: find a better implementation : while we can get the\n    // line metrics of a certain line, we don't get its starting\n    // position, so it would probably be rather a binary search\n    // for the start position\n    long xpos = 0, ypos = 0 ;\n    int lastHeight = 0 ;\n    ItemCount n ;\n\n    lastpos = GetLastPosition() ;\n    for ( n = 0 ; n \u003c= (ItemCount) lastpos ; ++n )\n    {\n        if ( y == ypos \u0026\u0026 x == xpos )\n            return n ;\n\n        TXNOffsetToPoint( m_txn, n, \u0026curpt ) ;\n\n        if ( curpt.v \u003e lastHeight )\n        {\n            xpos = 0 ;\n            if ( n \u003e 0 )\n                ++ypos ;\n\n            lastHeight = curpt.v ;\n        }\n        else\n            ++xpos ;\n    }\n\n    return 0 ;\n}\n\nbool wxMacMLTEControl::PositionToXY( long pos, long *x, long *y ) const\n{\n    Point curpt ;\n    wxTextPos lastpos ;\n\n    if ( y )\n        *y = 0 ;\n    if ( x )\n        *x = 0 ;\n\n    lastpos = GetLastPosition() ;\n    if ( pos \u003c= lastpos )\n    {\n        // TODO: find a better implementation - while we can get the\n        // line metrics of a certain line, we don't get its starting\n        // position, so it would probably be rather a binary search\n        // for the start position\n        long xpos = 0, ypos = 0 ;\n        int lastHeight = 0 ;\n        ItemCount n ;\n\n        for ( n = 0 ; n \u003c= (ItemCount) pos ; ++n )\n        {\n            TXNOffsetToPoint( m_txn, n, \u0026curpt ) ;\n\n            if ( curpt.v \u003e lastHeight )\n            {\n                xpos = 0 ;\n                if ( n \u003e 0 )\n                    ++ypos ;\n\n                lastHeight = curpt.v ;\n            }\n            else\n                ++xpos ;\n        }\n\n        if ( y )\n            *y = ypos ;\n        if ( x )\n            *x = xpos ;\n    }\n\n    return false ;\n}\n\nvoid wxMacMLTEControl::ShowPosition( long pos )\n{\n    Point current, desired ;\n    TXNOffset selstart, selend;\n\n    TXNGetSelection( m_txn, \u0026selstart, \u0026selend );\n    TXNOffsetToPoint( m_txn, selstart, \u0026current );\n    TXNOffsetToPoint( m_txn, pos, \u0026desired );\n\n    // TODO: use HIPoints for 10.3 and above\n\n    OSErr theErr = noErr;\n    long dv = desired.v - current.v;\n    long dh = desired.h - current.h;\n    TXNShowSelection( m_txn, kTXNShowStart ) ; // NB: should this be kTXNShowStart or kTXNShowEnd ??\n    theErr = TXNScroll( m_txn, kTXNScrollUnitsInPixels, kTXNScrollUnitsInPixels, \u0026dv, \u0026dh );\n\n    // there will be an error returned for classic MLTE implementation when the control is\n    // invisible, but HITextView works correctly, so we don't assert that one\n    // wxASSERT_MSG( theErr == noErr, wxT(\"TXNScroll returned an error!\") );\n}\n\nvoid wxMacMLTEControl::SetTXNData( const wxString\u0026 st, TXNOffset start, TXNOffset end )\n{\n#if wxUSE_UNICODE\n    wxMBConvUTF16 converter ;\n    ByteCount byteBufferLen = converter.WC2MB( NULL, st.wc_str(), 0 ) ;\n    wxASSERT_MSG( byteBufferLen != wxCONV_FAILED,\n                  wxT(\"Conversion to UTF-16 unexpectedly failed\") );\n    UniChar *unibuf = (UniChar*)malloc( byteBufferLen + 2 ) ; // 2 for NUL in UTF-16\n    converter.WC2MB( (char*)unibuf, st.wc_str(), byteBufferLen + 2 ) ;\n    TXNSetData( m_txn, kTXNUnicodeTextData, (void*)unibuf, byteBufferLen, start, end ) ;\n    free( unibuf ) ;\n#else // !wxUSE_UNICODE\n    wxCharBuffer text = st.mb_str( wxConvLocal ) ;\n    TXNSetData( m_txn, kTXNTextData, (void*)text.data(), strlen( text ), start, end ) ;\n#endif // wxUSE_UNICODE/!wxUSE_UNICODE\n}\n\nwxString wxMacMLTEControl::GetLineText(long lineNo) const\n{\n    wxString line ;\n\n    if ( lineNo \u003c GetNumberOfLines() )\n    {\n        Point firstPoint;\n        Fixed lineWidth, lineHeight, currentHeight;\n        long ypos ;\n\n        // get the first possible position in the control\n        TXNOffsetToPoint(m_txn, 0, \u0026firstPoint);\n\n        // Iterate through the lines until we reach the one we want,\n        // adding to our current y pixel point position\n        ypos = 0 ;\n        currentHeight = 0;\n        while (ypos \u003c lineNo)\n        {\n            TXNGetLineMetrics(m_txn, ypos++, \u0026lineWidth, \u0026lineHeight);\n            currentHeight += lineHeight;\n        }\n\n        Point thePoint = { firstPoint.v + (currentHeight \u003e\u003e 16), firstPoint.h + (0) };\n        TXNOffset theOffset;\n        TXNPointToOffset(m_txn, thePoint, \u0026theOffset);\n\n        wxString content = GetStringValue() ;\n        Point currentPoint = thePoint;\n        while (thePoint.v == currentPoint.v \u0026\u0026 theOffset \u003c content.length())\n        {\n            line += content[theOffset];\n            TXNOffsetToPoint(m_txn, ++theOffset, \u0026currentPoint);\n        }\n    }\n\n    return line ;\n}\n\nint wxMacMLTEControl::GetLineLength(long lineNo) const\n{\n    int theLength = 0;\n\n    if ( lineNo \u003c GetNumberOfLines() )\n    {\n        Point firstPoint;\n        Fixed lineWidth, lineHeight, currentHeight;\n        long ypos;\n\n        // get the first possible position in the control\n        TXNOffsetToPoint(m_txn, 0, \u0026firstPoint);\n\n        // Iterate through the lines until we reach the one we want,\n        // adding to our current y pixel point position\n        ypos = 0;\n        currentHeight = 0;\n        while (ypos \u003c lineNo)\n        {\n            TXNGetLineMetrics(m_txn, ypos++, \u0026lineWidth, \u0026lineHeight);\n            currentHeight += lineHeight;\n        }\n\n        Point thePoint = { firstPoint.v + (currentHeight \u003e\u003e 16), firstPoint.h + (0) };\n        TXNOffset theOffset;\n        TXNPointToOffset(m_txn, thePoint, \u0026theOffset);\n\n        wxString content = GetStringValue() ;\n        Point currentPoint = thePoint;\n        while (thePoint.v == currentPoint.v \u0026\u0026 theOffset \u003c content.length())\n        {\n            ++theLength;\n            TXNOffsetToPoint(m_txn, ++theOffset, \u0026currentPoint);\n        }\n    }\n\n    return theLength ;\n}\n\n// ----------------------------------------------------------------------------\n// MLTE control implementation (OSX part)\n// ----------------------------------------------------------------------------\n\n// tiger multi-line textcontrols with no CR in the entire content\n// don't scroll automatically, so we need a hack.\n// This attempt only works 'before' the key (ie before CallNextEventHandler)\n// is processed, thus the scrolling always occurs one character too late, but\n// better than nothing ...\n\nstatic const EventTypeSpec eventList[] =\n{\n    { kEventClassTextInput, kEventTextInputUnicodeForKeyEvent } ,\n} ;\n\nstatic pascal OSStatus wxMacUnicodeTextEventHandler( EventHandlerCallRef handler , EventRef event , void *data )\n{\n    OSStatus result = eventNotHandledErr ;\n    wxMacMLTEHIViewControl* focus = (wxMacMLTEHIViewControl*) data ;\n\n    switch ( GetEventKind( event ) )\n    {\n        case kEventTextInputUnicodeForKeyEvent :\n        {\n            TXNOffset from , to ;\n            TXNGetSelection( focus-\u003eGetTXNObject() , \u0026from , \u0026to ) ;\n            if ( from == to )\n                TXNShowSelection( focus-\u003eGetTXNObject() , kTXNShowStart );\n            result = CallNextEventHandler(handler,event);\n            break;\n        }\n        default:\n            break ;\n    }\n\n    return result ;\n}\n\nstatic pascal OSStatus wxMacTextControlEventHandler( EventHandlerCallRef handler , EventRef event , void *data )\n{\n    OSStatus result = eventNotHandledErr ;\n\n    switch ( GetEventClass( event ) )\n    {\n        case kEventClassTextInput :\n            result = wxMacUnicodeTextEventHandler( handler , event , data ) ;\n            break ;\n\n        default :\n            break ;\n    }\n    return result ;\n}\n\nDEFINE_ONE_SHOT_HANDLER_GETTER( wxMacTextControlEventHandler )\n\nwxMacMLTEHIViewControl::wxMacMLTEHIViewControl( wxTextCtrl *wxPeer,\n    const wxString\u0026 str,\n    const wxPoint\u0026 pos,\n    const wxSize\u0026 size, long style ) : wxMacMLTEControl( wxPeer )\n{\n    m_font = wxPeer-\u003eGetFont() ;\n    m_windowStyle = style ;\n    Rect bounds = wxMacGetBoundsForControl( wxPeer , pos , size ) ;\n    wxString st = str ;\n    wxMacConvertNewlines10To13( \u0026st ) ;\n\n    HIRect hr = {\n        { bounds.left , bounds.top },\n        { bounds.right - bounds.left, bounds.bottom - bounds.top } } ;\n\n    m_scrollView = NULL ;\n    TXNFrameOptions frameOptions = FrameOptionsFromWXStyle( style ) ;\n    if (( frameOptions \u0026 (kTXNWantVScrollBarMask | kTXNWantHScrollBarMask)) || (frameOptions \u0026kTXNSingleLineOnlyMask))\n    {\n        if ( frameOptions \u0026 (kTXNWantVScrollBarMask | kTXNWantHScrollBarMask) )\n        {\n            HIScrollViewCreate(\n                (frameOptions \u0026 kTXNWantHScrollBarMask ? kHIScrollViewOptionsHorizScroll : 0)\n                | (frameOptions \u0026 kTXNWantVScrollBarMask ? kHIScrollViewOptionsVertScroll : 0) ,\n                \u0026m_scrollView ) ;\n        }\n        else\n        {\n            HIScrollViewCreate(kHIScrollViewOptionsVertScroll,\u0026m_scrollView);\n            HIScrollViewSetScrollBarAutoHide(m_scrollView,true);\n        }\n\n        HIViewSetFrame( m_scrollView, \u0026hr );\n        HIViewSetVisible( m_scrollView, true );\n    }\n\n    m_textView = NULL ;\n    HITextViewCreate( NULL , 0, frameOptions , \u0026m_textView ) ;\n    m_txn = HITextViewGetTXNObject( m_textView ) ;\n    HIViewSetVisible( m_textView , true ) ;\n    if ( m_scrollView )\n    {\n        HIViewAddSubview( m_scrollView , m_textView ) ;\n        m_controlRef = m_scrollView ;\n        InstallEventHandler( (WXWidget) m_textView ) ;\n    }\n    else\n    {\n        HIViewSetFrame( m_textView, \u0026hr );\n        m_controlRef = m_textView ;\n    }\n\n    AdjustCreationAttributes( *wxWHITE , true ) ;\n#ifndef __LP64__\n    wxMacWindowClipper c( GetWXPeer() ) ;\n#endif\n    SetTXNData( st , kTXNStartOffset, kTXNEndOffset ) ;\n\n    TXNSetSelection( m_txn, 0, 0 );\n    TXNShowSelection( m_txn, kTXNShowStart );\n\n    ::InstallControlEventHandler( m_textView , GetwxMacTextControlEventHandlerUPP(),\n                                GetEventTypeCount(eventList), eventList, this,\n                                NULL);\n}\n\nwxMacMLTEHIViewControl::~wxMacMLTEHIViewControl()\n{\n}\n\nbool wxMacMLTEHIViewControl::SetFocus()\n{\n    return SetKeyboardFocus( GetControlOwner( m_textView ), m_textView, kControlFocusNextPart ) == noErr ;\n}\n\nbool wxMacMLTEHIViewControl::HasFocus() const\n{\n    ControlRef control ;\n    if ( GetUserFocusWindow() == NULL )\n        return false;\n\n    GetKeyboardFocus( GetUserFocusWindow() , \u0026control ) ;\n    return control == m_textView ;\n}\n\nvoid wxMacMLTEHIViewControl::SetBackgroundColour(const wxColour\u0026 col )\n{\n    HITextViewSetBackgroundColor( m_textView, col.GetPixel() );\n}\n\n#endif // wxUSE_TEXTCTRL\n"}
{"repo_name":"PGer/incubator-hawq","ref":"refs/heads/master","path":"src/backend/access/parquet/metadatautil_c++/Metadatainterface.cpp","copies":"10","language":"C++","content":"\n#include \u003ciostream\u003e\n#include \u003cstdint.h\u003e\n#include \u003cboost/shared_ptr.hpp\u003e\n#include \u003cboost/math_fwd.hpp\u003e\n#include \u003cthrift/protocol/TBinaryProtocol.h\u003e\n#include \u003cfcntl.h\u003e\n#include \u003cfstream\u003e\n#include \u003cstdio.h\u003e\n#include \u003cbitset\u003e\n#include \"MetadataUtil.h\"\nusing namespace hawq;\nusing namespace std;\nusing namespace boost;\n\nextern \"C\" {\n#include \"postgres.h\"\n#include \"utils/palloc.h\"\n\n/*\n * Read buffer to get page metadata\n */\nint\nreadPageMetadata(\n\t\tuint8_t \t\t\t\t*buf,\n\t\tuint32_t\t\t\t\t*len,\n\t\tint \t\t\t\t\tcompact,\n\t\tstruct PageMetadata_4C\t**ppageMetdata)\n{\n\t*ppageMetdata = (struct PageMetadata_4C*)palloc0(sizeof(struct PageMetadata_4C));\n\tbool compactBool = (compact == 1) ? true : false;\n\tint iret = MetadataUtil::readPageMetadata(buf, len, compactBool, *ppageMetdata);\n\treturn iret;\n}\n\n/*\n * Write hawq page metadata to buffer\n */\nint\nwritePageMetadata(\n\t\tuint8_t\t\t\t\t\t**buf,\n\t\tuint32_t\t\t\t\t*len,\n\t\tstruct PageMetadata_4C\t*ppageMetadata)\n{\n\tint iret = MetadataUtil::writePageMetadata(buf, len, ppageMetadata);\n\treturn iret;\n}\n\n/*\n * Write hawq column chunk metadata to buffer\n */\nint\nwriteColumnChunkMetadata(\n\t\tuint8_t\t\t\t\t\t\t\t**buf,\n\t\tuint32_t\t\t\t\t\t\t*len,\n\t\tstruct ColumnChunkMetadata_4C\t*blockMetadata)\n{\n\tint iret = MetadataUtil::writeColumnChunkMetadata(buf, len, blockMetadata);\n\treturn iret;\n}\n}\n"}
{"repo_name":"geocool/libtmx-parser","ref":"refs/heads/master","path":"src/tmxparser.cpp","copies":"2","language":"C++","content":"/*\nThe MIT License (MIT)\n\nCopyright (c) 2014 Stephen Damm - shinhalsafar@gmail.com\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\n\n#include \"tmxparser.h\"\n\n#include \"base64.h\"\n\n\n#if (defined(_WIN32))\n     #include \u003cstring.h\u003e\n#endif\n\n#if (( defined(ANDROID)))\n     #include \u003candroid/log.h\u003e\n     #include \u003cstring.h\u003e\n#else\n\t#include \u003ccstdlib\u003e\n\t#include \u003ccstdio\u003e\n#endif\n\n#include \u003calgorithm\u003e\n#include \u003cstring\u003e\n#include \u003csstream\u003e\n\n\n#ifndef LOG_TAG\n#define LOG_TAG \"libtmxparser\"\n#endif\n\n\n#if defined(WIN32) || defined(_WIN32)\n#define PATH_SEPARATOR \"\\\\\"\n#define PATH_SEPARATOR_ALT \"/\"\n#else\n#define PATH_SEPARATOR \"/\"\n#define PATH_SEPARATOR_ALT \"/\" // needs value!\n#endif\n\n\n// quote define define :D\n#  define QUOTEME_(x) #x\n#  define QUOTEME(x) QUOTEME_(x)\n\n\n// print helpers\n#define WHERESTR  \"[file %s, line %d]: \"\n#define WHEREARG  __FILE__, __LINE__\n\n\n// LOGGING\n#if (( defined(ANDROID)))\n     #ifdef DEBUG\n          #define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, LOG_TAG, \" (\" __FILE__ \":\" QUOTEME(__LINE__) \") \" __VA_ARGS__ )\n     #else\n          #define LOGD(...)\n     #endif\n\n     #define LOGI(...) __android_log_print(ANDROID_LOG_INFO, LOG_TAG, \"\" __VA_ARGS__ )\n     #define LOGE(...) __android_log_print(ANDROID_LOG_ERROR, LOG_TAG, __VA_ARGS__ )\n\t #define LOGW(...) __android_log_print(ANDROID_LOG_WARN, LOG_TAG, __VA_ARGS__ )\n#else\n     #ifdef DEBUG\n     #define LOGD(...) fprintf(stderr, \"D/\" LOG_TAG \" (\" __FILE__ \":\" QUOTEME(__LINE__) \"): \" __VA_ARGS__ ); fprintf(stderr, \"\\n\");\n     #else\n     #define LOGD(...)\n     #endif\n     #define LOGI(...) fprintf(stdout, \"I/\" QUOTEME(LOG_TAG) \"(\" \")\" __VA_ARGS__ ); fprintf(stdout, \"\\n\");\n     #define LOGE(...) fprintf(stderr, \"E/\" QUOTEME(LOG_TAG) \"(\" \")\" __VA_ARGS__ ); fprintf(stderr, \"\\n\");\n\t #define LOGW(...) fprintf(stderr, \"W/\" QUOTEME(LOG_TAG) \"(\" \")\" __VA_ARGS__ ); fprintf(stderr, \"\\n\");\n#endif\n\n\nnamespace tmxparser\n{\n\n\n#define CHECK_AND_RETRIEVE_OPT_ATTRIBUTE_STRING(XMLELEMENT, ATTRIBNAME, LHS) \\\n\tif (XMLELEMENT-\u003eAttribute(ATTRIBNAME) != NULL) \\\n\t{ \\\n\t\tLHS = XMLELEMENT-\u003eAttribute(ATTRIBNAME); \\\n\t} \\\n\telse \\\n\t{ \\\n\t\tLHS = '\\0'; \\\n\t}\n\n\n#define CHECK_AND_RETRIEVE_REQ_ATTRIBUTE_STRING(XMLELEMENT, ATTRIBNAME, LHS) \\\n\tLHS = XMLELEMENT-\u003eAttribute(ATTRIBNAME); \\\n\tif (LHS.size() == 0) \\\n\t{ \\\n\t\tLOGE(\"Missing required attribute [%s]\", ATTRIBNAME); \\\n\t\treturn TmxReturn::kMissingRequiredAttribute; \\\n\t}\n\n\n#define CHECK_AND_RETRIEVE_REQ_ATTRIBUTE(FUNC, ATTRIBNAME, OUT) \\\n\t\tif (FUNC(ATTRIBNAME, OUT) == tinyxml2::XML_NO_ATTRIBUTE) \\\n\t\t{ \\\n\t\t\tLOGE(\"Missing required attribute [%s]\", ATTRIBNAME); \\\n\t\t\treturn kMissingRequiredAttribute; \\\n\t\t}\n\n\n// Prototypes\nTmxReturn _parseStart(tinyxml2::XMLElement* element, TmxMap* outMap, const std::string\u0026 tilesetPath);\nTmxReturn _parseEnd(TmxMap* outMap, const std::string\u0026 tilesetPath);\nvoid _parseEndHelper(TmxImage\u0026 image, const std::string\u0026 tilesetPath);\nTmxReturn _parseMapNode(tinyxml2::XMLElement* element, TmxMap* outMap);\nTmxReturn _parsePropertyNode(tinyxml2::XMLElement* element, TmxPropertyMap_t* outPropertyMap);\nTmxReturn _parseImageNode(tinyxml2::XMLElement* element, TmxImage* outImage);\nTmxReturn _parseTilesetNode(tinyxml2::XMLElement* element, TmxTileset* outTileset);\nTmxReturn _parseTileDefinitionNode(tinyxml2::XMLElement* element, TmxTileDefinition* outTileDefinition);\nTmxReturn _parseTileAnimationNode(tinyxml2::XMLElement* element, TmxAnimationFrameCollection_t* outAnimationCollection);\nTmxReturn _parseLayerNode(tinyxml2::XMLElement* element, const TmxTilesetCollection_t\u0026 tilesets, TmxLayer* outLayer);\nTmxReturn _parseLayerDataNode(tinyxml2::XMLElement* element, const TmxTilesetCollection_t\u0026 tilesets, TmxLayerTileCollection_t* outTileCollection);\nTmxReturn _parseLayerXmlTileNode(tinyxml2::XMLElement* element, const TmxTilesetCollection_t\u0026 tilesets, TmxLayerTile* outTile);\nTmxReturn _calculateTileIndices(const TmxTilesetCollection_t\u0026 tilesets, TmxLayerTile* outTile);\nTmxReturn _parseObjectGroupNode(tinyxml2::XMLElement* element, TmxObjectGroup* outObjectGroup);\nTmxReturn _parseObjectNode(tinyxml2::XMLElement* element, TmxObject* outObj);\nTmxReturn _parseOffsetNode(tinyxml2::XMLElement* element, TmxOffset* offset);\nTmxReturn _parseImageLayerNode(tinyxml2::XMLElement* element, TmxImageLayer* outImageLayer);\n\nTmxReturn parseFromFile(const std::string\u0026 fileName, TmxMap* outMap, const std::string\u0026 tilesetPath)\n{\n\ttinyxml2::XMLDocument doc;\n\tif (doc.LoadFile(fileName.c_str()) != tinyxml2::XML_SUCCESS)\n\t{\n\t\tLOGE(\"Cannot read xml file\");\n\t\treturn TmxReturn::kErrorParsing;\n\t}\n\n\t// parse the map node\n\treturn _parseStart(doc.FirstChildElement(\"map\"), outMap, tilesetPath);\n}\n\n\nTmxReturn parseFromMemory(void* data, size_t length, TmxMap* outMap, const std::string\u0026 tilesetPath)\n{\n\ttinyxml2::XMLDocument doc;\n\tif (doc.Parse((char*)data, length))\n\t{\n\t\tLOGE(\"Cannot parse xml memory file...\");\n\t\treturn TmxReturn::kErrorParsing;\n\t}\n\n\treturn _parseStart(doc.FirstChildElement(\"map\"), outMap, tilesetPath);\n}\n\n\nTmxReturn _parseStart(tinyxml2::XMLElement* element, TmxMap* outMap, const std::string\u0026 tilesetPath)\n{\n\tTmxReturn retVal = _parseMapNode(element, outMap);\n\treturn (retVal == TmxReturn::kSuccess) ? _parseEnd(outMap, tilesetPath) : retVal;\n}\n\n\nTmxReturn _parseEnd(TmxMap* outMap, const std::string\u0026 tilesetPath)\n{\n\tfor (auto tileIt = outMap-\u003etilesetCollection.begin(); tileIt != outMap-\u003etilesetCollection.end(); ++tileIt)\n\t\t_parseEndHelper(tileIt-\u003eimage, tilesetPath);\n\n\tfor (auto tileIt = outMap-\u003eimageLayerCollection.begin(); tileIt != outMap-\u003eimageLayerCollection.end(); ++tileIt)\n\t\t_parseEndHelper(tileIt-\u003eimage, tilesetPath);\n\n\treturn TmxReturn::kSuccess;\n}\n\n\nvoid _parseEndHelper(TmxImage\u0026 image, const std::string\u0026 tilesetPath)\n{\n\tauto pathSeperatorMissing = (image.source.find(PATH_SEPARATOR) == std::string::npos);\n\tauto pathSeperatorAltMissing = (image.source.find(PATH_SEPARATOR_ALT) == std::string::npos);\n\n\tif (pathSeperatorMissing \u0026\u0026 pathSeperatorAltMissing) // no path_seperator found --\u003e relative path\n\t{\n\t\tstd::string baseFilename = image.source.substr(image.source.find_last_of(PATH_SEPARATOR) + 1);\n\n\t\t/*\n\t\t * here we find out what separator is used in tilesetPath and choose it\n\t\t * if both (alternative and normal) separators are used, we always use the normal separator\n\t\t **/\n\t\tauto seperatorThere = (tilesetPath.find(PATH_SEPARATOR) != std::string::npos);\n\t\tauto seperatorAltThere = (tilesetPath.find(PATH_SEPARATOR_ALT) != std::string::npos);\n\t\tauto tileSetPathSeparator = PATH_SEPARATOR;\n\n\t\tif (!seperatorThere \u0026\u0026 seperatorAltThere) // only alternative separator exists in tilesetPath --\u003e choose it\n\t\t\ttileSetPathSeparator = PATH_SEPARATOR_ALT;\n\n\t\timage.source = tilesetPath + tileSetPathSeparator + baseFilename;\n\t}\n}\n\n\nTmxReturn _parseMapNode(tinyxml2::XMLElement* element, TmxMap* outMap)\n{\n\tif (element == NULL)\n\t{\n\t\treturn TmxReturn::kMissingMapNode;\n\t}\n\n\toutMap-\u003eversion = element-\u003eAttribute(\"version\");\n\tconst char* orientation = element-\u003eAttribute(\"orientation\");\n\tif (orientation != NULL)\n\t{\n\t\tif (strcmp(orientation, \"orthogonal\") == 0)\n\t\t{\n\t\t\toutMap-\u003eorientation = TmxOrientation::kOrthogonal;\n\t\t}\n\t\telse if (strcmp(orientation, \"isometric\") == 0)\n\t\t{\n\t\t\toutMap-\u003eorientation = TmxOrientation::kIsometric;\n\t\t}\n\t\telse if (strcmp(orientation, \"staggered\") == 0)\n\t\t{\n\t\t\toutMap-\u003eorientation = TmxOrientation::kStaggered;\n\t\t}\n\t}\n\telse\n\t{\n\t\tLOGW(\"Missing orientation attribute\");\n\t}\n\n\tCHECK_AND_RETRIEVE_REQ_ATTRIBUTE(element-\u003eQueryUnsignedAttribute, \"width\", \u0026outMap-\u003ewidth);\n\tCHECK_AND_RETRIEVE_REQ_ATTRIBUTE(element-\u003eQueryUnsignedAttribute, \"height\", \u0026outMap-\u003eheight);\n\tCHECK_AND_RETRIEVE_REQ_ATTRIBUTE(element-\u003eQueryUnsignedAttribute, \"tilewidth\", \u0026outMap-\u003etileWidth);\n\tCHECK_AND_RETRIEVE_REQ_ATTRIBUTE(element-\u003eQueryUnsignedAttribute, \"tileheight\", \u0026outMap-\u003etileHeight);\n\n\tCHECK_AND_RETRIEVE_OPT_ATTRIBUTE_STRING(element, \"backgroundcolor\", outMap-\u003ebackgroundColor);\n\tCHECK_AND_RETRIEVE_OPT_ATTRIBUTE_STRING(element, \"renderorder\", outMap-\u003erenderOrder);\n\n\n\tTmxReturn error = _parsePropertyNode(element-\u003eFirstChildElement(\"properties\"), \u0026outMap-\u003epropertyMap);\n\tif (error)\n\t{\n\t\tLOGE(\"Error processing map properties...\");\n\t\treturn error;\n\t}\n\n\tfor (tinyxml2::XMLElement* child = element-\u003eFirstChildElement(\"tileset\"); child != NULL; child = child-\u003eNextSiblingElement(\"tileset\"))\n\t{\n\t\tTmxTileset set;\n\t\terror = _parseTilesetNode(child, \u0026set);\n\t\tif (error)\n\t\t{\n\t\t\tLOGE(\"Error processing tileset node...\");\n\t\t\treturn error;\n\t\t}\n\n\t\toutMap-\u003etilesetCollection.push_back(set);\n\t}\n\n\tfor (tinyxml2::XMLElement* child = element-\u003eFirstChildElement(\"layer\"); child != NULL; child = child-\u003eNextSiblingElement(\"layer\"))\n\t{\n\t\tTmxLayer layer;\n\t\terror = _parseLayerNode(child, outMap-\u003etilesetCollection, \u0026layer);\n\t\tif (error)\n\t\t{\n\t\t\tLOGE(\"Error processing layer node...\");\n\t\t\treturn error;\n\t\t}\n\n\t\toutMap-\u003elayerCollection.push_back(layer);\n\t}\n\n\tfor (tinyxml2::XMLElement* child = element-\u003eFirstChildElement(\"objectgroup\"); child != NULL; child = child-\u003eNextSiblingElement(\"objectgroup\"))\n\t{\n\t\tTmxObjectGroup group;\n\t\terror = _parseObjectGroupNode(child, \u0026group);\n\t\tif (error)\n\t\t{\n\t\t\tLOGE(\"Error processing objectgroup node...\");\n\t\t\treturn error;\n\t\t}\n\n\t\toutMap-\u003eobjectGroupCollection.push_back(group);\n\t}\n\n\tfor (tinyxml2::XMLElement* child = element-\u003eFirstChildElement(\"imagelayer\"); child != NULL; child = child-\u003eNextSiblingElement(\"imagelayer\"))\n\t{\n\t\tTmxImageLayer imageLayer;\n\t\terror = _parseImageLayerNode(child, \u0026imageLayer);\n\t\tif (error)\n\t\t{\n\t\t\tLOGE(\"Error parsing imagelayer node...\");\n\t\t\treturn error;\n\t\t}\n\n\t\toutMap-\u003eimageLayerCollection.push_back(imageLayer);\n\t}\n\n\treturn error;\n}\n\n\nTmxReturn _parsePropertyNode(tinyxml2::XMLElement* element, TmxPropertyMap_t* outPropertyMap)\n{\n\tif (element == NULL)\n\t{\n\t\t// ignore this, not everything requires properties\n\t\treturn TmxReturn::kSuccess;\n\t}\n\n\tfor (tinyxml2::XMLElement* child = element-\u003eFirstChildElement(\"property\"); child != NULL; child = child-\u003eNextSiblingElement(\"property\"))\n\t{\n\t\tif (strcmp(child-\u003eName(), \"property\") == 0)\n\t\t{\n\t\t\tif (child-\u003eAttribute(\"name\") != NULL \u0026\u0026 child-\u003eAttribute(\"value\") != NULL)\n\t\t\t{\n\t\t\t\t(*outPropertyMap)[child-\u003eAttribute(\"name\")] = child-\u003eAttribute(\"value\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn TmxReturn::kMalformedPropertyNode;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn TmxReturn::kSuccess;\n}\n\n\nTmxReturn _parseImageNode(tinyxml2::XMLElement* element, TmxImage* outImage)\n{\n\tCHECK_AND_RETRIEVE_REQ_ATTRIBUTE_STRING(element, \"source\", outImage-\u003esource);\n\tCHECK_AND_RETRIEVE_OPT_ATTRIBUTE_STRING(element, \"format\", outImage-\u003eformat);\n\tCHECK_AND_RETRIEVE_OPT_ATTRIBUTE_STRING(element, \"trans\", outImage-\u003etransparentColor);\n\n\toutImage-\u003ewidth = element-\u003eUnsignedAttribute(\"width\");\n\toutImage-\u003eheight = element-\u003eUnsignedAttribute(\"height\");\n\n\treturn TmxReturn::kSuccess;\n}\n\n\nTmxReturn _parseTilesetNode(tinyxml2::XMLElement* element, TmxTileset* outTileset)\n{\n\n\tif (strcmp(element-\u003eName(), \"tileset\") == 0)\n\t{\n\t\tCHECK_AND_RETRIEVE_REQ_ATTRIBUTE(element-\u003eQueryUnsignedAttribute, \"firstgid\", \u0026outTileset-\u003efirstgid);\n\t\toutTileset-\u003ename = element-\u003eAttribute(\"name\");\n\t\tCHECK_AND_RETRIEVE_REQ_ATTRIBUTE(element-\u003eQueryUnsignedAttribute, \"tilewidth\", \u0026outTileset-\u003etileWidth);\n\t\tCHECK_AND_RETRIEVE_REQ_ATTRIBUTE(element-\u003eQueryUnsignedAttribute, \"tileheight\", \u0026outTileset-\u003etileHeight);\n\t\toutTileset-\u003etileSpacingInImage = element-\u003eUnsignedAttribute(\"spacing\");\n\t\toutTileset-\u003etileMarginInImage = element-\u003eUnsignedAttribute(\"margin\");\n\n\t\t// TODO - read TODO at end of this function\n\t\tif (element-\u003eFirstChildElement(\"image\") == NULL)\n\t\t{\n\t\t\tLOGE(\"We do not support maps with tilesets that have no image associated currently...\");\n\t\t\treturn kErrorParsing;\n\t\t}\n\n\t\tTmxImage image;\n\t\tTmxReturn error = _parseImageNode(element-\u003eFirstChildElement(\"image\"), \u0026outTileset-\u003eimage);\n\t\tif (error)\n\t\t{\n\t\t\tLOGE(\"Error parsing image node...\");\n\t\t\treturn error;\n\t\t}\n\n\t\toutTileset-\u003eoffset.x = 0;\n\t\toutTileset-\u003eoffset.y = 0;\n\n\t\tif (element-\u003eFirstChildElement(\"tileoffset\") != NULL)\n\t\t{\n\t\t\terror = _parseOffsetNode(element-\u003eFirstChildElement(\"tileoffset\"), \u0026outTileset-\u003eoffset);\n\t\t}\n\n\t\tfor (tinyxml2::XMLElement* child = element-\u003eFirstChildElement(\"tile\"); child != NULL; child = child-\u003eNextSiblingElement(\"tile\"))\n\t\t{\n\t\t\tTmxTileDefinition tileDef;\n\n\t\t\ttileDef.id = 0;\n\n\t\t\terror = _parseTileDefinitionNode(child, \u0026tileDef);\n\t\t\tif (error)\n\t\t\t{\n\t\t\t\tLOGE(\"Error parsing tile definition\");\n\t\t\t\treturn error;\n\t\t\t}\n\n\t\t\toutTileset-\u003etileDefinitions[tileDef.id] = tileDef;\n\t\t}\n\n\t\t// derive row/col count, calculate tile indices\n\t\t// TODO - this is why we do not accept tilesets without image tag atm\n\t\toutTileset-\u003ecolCount = (outTileset-\u003eimage.width - outTileset-\u003etileMarginInImage) / (outTileset-\u003etileWidth + outTileset-\u003etileSpacingInImage);\n\t\toutTileset-\u003erowCount = (outTileset-\u003eimage.height - outTileset-\u003etileMarginInImage) / (outTileset-\u003etileHeight + outTileset-\u003etileSpacingInImage);\n\t}\n\n\treturn TmxReturn::kSuccess;\n}\n\n\nTmxReturn _parseTileDefinitionNode(tinyxml2::XMLElement* element, TmxTileDefinition* outTileDefinition)\n{\n\tTmxReturn error = TmxReturn::kSuccess;\n\n\toutTileDefinition-\u003eid = element-\u003eUnsignedAttribute(\"id\");\n\terror = _parsePropertyNode(element-\u003eFirstChildElement(\"properties\"), \u0026outTileDefinition-\u003epropertyMap);\n\tif (error)\n\t{\n\t\treturn error;\n\t}\n\n\tif (element-\u003eFirstChildElement(\"animation\") != NULL)\n\t{\n\t\terror = _parseTileAnimationNode(element-\u003eFirstChildElement(\"animation\"), \u0026outTileDefinition-\u003eanimations);\n\t}\n\n\tfor (tinyxml2::XMLElement* child = element-\u003eFirstChildElement(\"objectgroup\"); child != NULL; child = child-\u003eNextSiblingElement(\"objectgroup\"))\n\t{\n\t\tTmxObjectGroup group;\n\t\terror = _parseObjectGroupNode(child, \u0026group);\n\t\tif (error)\n\t\t{\n\t\t\tLOGE(\"Error processing objectgroup node...\");\n\t\t\treturn error;\n\t\t}\n\n\t\toutTileDefinition-\u003eobjectgroups.push_back(group);\n\t}\n\n\treturn error;\n}\n\n\nTmxReturn _parseTileAnimationNode(tinyxml2::XMLElement* element, TmxAnimationFrameCollection_t* outAnimationCollection)\n{\n\tfor (tinyxml2::XMLElement* child = element-\u003eFirstChildElement(\"frame\"); child != NULL; child = child-\u003eNextSiblingElement(\"frame\"))\n\t{\n\t\tTmxAnimationFrame frame;\n\t\tframe.duration = child-\u003eFloatAttribute(\"duration\");\n\t\tframe.tileId = child-\u003eUnsignedAttribute(\"tileid\");\n\n\t\toutAnimationCollection-\u003epush_back(frame);\n\t}\n\n\treturn kSuccess;\n}\n\n\nTmxReturn _parseLayerNode(tinyxml2::XMLElement* element, const TmxTilesetCollection_t\u0026 tilesets, TmxLayer* outLayer)\n{\n\tTmxReturn error = TmxReturn::kSuccess;\n\n\toutLayer-\u003ename = element-\u003eAttribute(\"name\");\n\tif (element-\u003eAttribute(\"opacity\"))\n\t\toutLayer-\u003eopacity = element-\u003eFloatAttribute(\"opacity\");\n\telse\n\t\toutLayer-\u003eopacity = 1.f;\n\tif (element-\u003eAttribute(\"visible\"))\n\t\toutLayer-\u003evisible = (element-\u003eIntAttribute(\"visible\") == 1 ? true : false);\n\telse\n\t\toutLayer-\u003evisible = true;\n\toutLayer-\u003ewidth = element-\u003eUnsignedAttribute(\"width\");\n\toutLayer-\u003eheight = element-\u003eUnsignedAttribute(\"height\");\n\n\terror = _parsePropertyNode(element-\u003eFirstChildElement(\"properties\"), \u0026outLayer-\u003epropertyMap);\n\tif (error)\n\t{\n\t\tLOGE(\"Error parsing layer property node...\");\n\t\treturn error;\n\t}\n\n\t// check data node and type\n\ttinyxml2::XMLElement* dataElement = element-\u003eFirstChildElement(\"data\");\n\tif (dataElement != NULL)\n\t{\n\t\terror = _parseLayerDataNode(dataElement, tilesets, \u0026outLayer-\u003etiles);\n\t}\n\telse\n\t{\n\t\tLOGE(\"Layer missing data node...\");\n\t\treturn TmxReturn::kMissingDataNode;\n\t}\n\n\treturn error;\n}\n\n\nTmxReturn _parseLayerDataNode(tinyxml2::XMLElement* element, const TmxTilesetCollection_t\u0026 tilesets, TmxLayerTileCollection_t* outTileCollection)\n{\n\tTmxReturn error = TmxReturn::kSuccess;\n\n\tconst char* encoding = element-\u003eAttribute(\"encoding\");\n\tconst char* compression = element-\u003eAttribute(\"compression\");\n\n\tif (compression != NULL)\n\t{\n\t\tLOGE(\"Does not support compression yet...\");\n\t\treturn TmxReturn::kErrorParsing;\n\t}\n\n\tif (encoding == NULL)\n\t{\n\t\tfor (tinyxml2::XMLElement* child = element-\u003eFirstChildElement(\"tile\"); child != NULL; child = child-\u003eNextSiblingElement(\"tile\"))\n\t\t{\n\t\t\tTmxLayerTile tile;\n\t\t\terror = _parseLayerXmlTileNode(child, tilesets, \u0026tile);\n\t\t\toutTileCollection-\u003epush_back(tile);\n\t\t}\n\t}\n\telse if (strcmp(encoding, \"csv\") == 0)\n\t{\n\t\tstd::stringstream csvss(element-\u003eFirstChild()-\u003eValue());\n\t\t//LOGE(\"TEXT = %s\", csv.c_str());\n\n\t\tunsigned int gid = 0;\n\t\twhile (csvss \u003e\u003e gid)\n\t\t{\n\t\t\tif (csvss.peek() == ',' || csvss.peek() == '\\n')\n\t\t\t{\n\t\t\t\tcsvss.ignore();\n\t\t\t}\n\n\t\t\tTmxLayerTile tile;\n\n\t\t\ttile.gid = gid;\n\t\t\terror = _calculateTileIndices(tilesets, \u0026tile);\n\t\t\tif (error == TmxReturn::kErrorParsing)\n\t\t\t{\n\t\t\t\treturn error;\n\t\t\t}\n\n\t\t\toutTileCollection-\u003epush_back(tile);\n\t\t}\n\t}\n\telse if (strcmp(encoding, \"base64\") == 0)\n\t{\n\t\tstd::string csvbase64 = element-\u003eFirstChild()-\u003eValue();\n\n\t\tcsvbase64.erase(std::remove(csvbase64.begin(), csvbase64.end(), '\\n'), csvbase64.end());\n\t\tcsvbase64.erase(std::remove(csvbase64.begin(), csvbase64.end(), '\\r'), csvbase64.end());\n\t\tcsvbase64.erase(std::remove(csvbase64.begin(), csvbase64.end(), ' '), csvbase64.end());\n\n\t\tstd::string csv = base64_decode(csvbase64);\n\n\t\tunsigned int length = csv.size() / sizeof(unsigned int);\n\n\t\t// tiled base64 layer data is an unsigned 32bit array little endian\n\t\t// TODO - verify this on other platforms, write some tests\n\t\tunsigned int* p = (unsigned int*)csv.c_str();\n\t\tfor (unsigned int i = 0; i \u003c length; i++)\n\t\t{\n\t\t\tTmxLayerTile tile;\n\t\t\ttile.gid = p[i];\n\t\t\terror = _calculateTileIndices(tilesets, \u0026tile);\n\t\t\tif (error == TmxReturn::kErrorParsing)\n\t\t\t{\n\t\t\t\treturn error;\n\t\t\t}\n\n\t\t\toutTileCollection-\u003epush_back(tile);\n\t\t}\n\t}\n\telse\n\t{\n\t\tLOGE(\"Unsupported layer compression [%s]... coming soon...\", encoding);\n\t\treturn TmxReturn::kErrorParsing;\n\t}\n\n\treturn error;\n}\n\n\n\nTmxReturn _parseLayerXmlTileNode(tinyxml2::XMLElement* element, const TmxTilesetCollection_t\u0026 tilesets, TmxLayerTile* outTile)\n{\n\tTmxReturn error = TmxReturn::kSuccess;\n\n\tunsigned int gid = element-\u003eUnsignedAttribute(\"gid\");\n\n\tunsigned int flipXFlag = 0x80000000;\n\tunsigned int flipYFlag = 0x40000000;\n\tunsigned int flipDiagonalFlag = 0x20000000;\n\n\toutTile-\u003eflipX = (gid \u0026 flipXFlag ? true : false);\n\toutTile-\u003eflipY = (gid \u0026 flipYFlag ? true : false);\n\toutTile-\u003eflipDiagonal = (gid \u0026 flipDiagonalFlag ? true : false);\n\toutTile-\u003egid = (gid \u0026 ~(flipXFlag | flipYFlag | flipDiagonalFlag));\n\n\treturn _calculateTileIndices(tilesets, outTile);\n}\n\n\nTmxReturn _calculateTileIndices(const TmxTilesetCollection_t\u0026 tilesets, TmxLayerTile* outTile)\n{\n\toutTile-\u003etilesetIndex = 0;\n\toutTile-\u003etileFlatIndex = 0;\n\n\t// exit quickly\n\tif (outTile-\u003egid == 0)\n\t{\n\t\treturn TmxReturn::kSuccess;\n\t}\n\n\t// search for tilesetindex\n\t// O(n) where n = number of tilesets\n\t// Generally n will never be high but this method is called from an O(m) method.\n\tunsigned int index = 0;\n\tunsigned int lastEndIndex = 1;\n\tfor (auto it = tilesets.begin(); it != tilesets.end(); ++it)\n\t{\n\t\tunsigned int colCount = it-\u003ecolCount;\n\t\tunsigned int rowCount = it-\u003erowCount;\n\t\tunsigned int startIndex = it-\u003efirstgid;\n\t\tunsigned int endIndex = it-\u003efirstgid + ( colCount * rowCount );\n\n\t\tif (outTile-\u003egid \u003e= startIndex \u0026\u0026 outTile-\u003egid \u003c endIndex)\n\t\t{\n\t\t\toutTile-\u003etilesetIndex = index;\n\t\t\toutTile-\u003etileFlatIndex = (outTile-\u003egid) - lastEndIndex;\n\n\t\t\t// done\n\t\t\treturn TmxReturn::kSuccess;\n\t\t}\n\n\t\tlastEndIndex = endIndex;\n\n\t\tindex++;\n\t}\n\n\t// if we made it here, tile indices could not be found\n\treturn TmxReturn::kUnknownTileIndices;\n}\n\n\nTmxReturn _parseObjectGroupNode(tinyxml2::XMLElement* element, TmxObjectGroup* outObjectGroup)\n{\n\tTmxReturn error = TmxReturn::kSuccess;\n\n\tCHECK_AND_RETRIEVE_OPT_ATTRIBUTE_STRING(element, \"name\", outObjectGroup-\u003ename);\n\n\tif (element-\u003eAttribute(\"opacity\") != NULL)\n\t{\n\t\toutObjectGroup-\u003eopacity = element-\u003eFloatAttribute(\"opacity\");\n\t}\n\telse\n\t{\n\t\toutObjectGroup-\u003eopacity = 1.0f;\n\t}\n\n\tif (element-\u003eAttribute(\"visible\") != NULL)\n\t{\n\t\toutObjectGroup-\u003evisible = element-\u003eBoolAttribute(\"visible\");\n\t}\n\telse\n\t{\n\t\toutObjectGroup-\u003evisible = true;\n\t}\n\n\terror = _parsePropertyNode(element-\u003eFirstChildElement(\"properties\"), \u0026outObjectGroup-\u003epropertyMap);\n\tif (error)\n\t{\n\t\treturn error;\n\t}\n\n\tfor (tinyxml2::XMLElement* child = element-\u003eFirstChildElement(\"object\"); child != NULL; child = child-\u003eNextSiblingElement(\"object\"))\n\t{\n\t\tTmxObject obj;\n\t\terror = _parseObjectNode(child, \u0026obj);\n\t\tif (error)\n\t\t{\n\t\t\tLOGE(\"Error parsing object node...\");\n\t\t\treturn TmxReturn::kErrorParsing;\n\t\t}\n\t\toutObjectGroup-\u003eobjects.push_back(obj);\n\t}\n\n\treturn error;\n}\n\n\nTmxReturn _parseObjectNode(tinyxml2::XMLElement* element, TmxObject* outObj)\n{\n\tTmxReturn error = TmxReturn::kSuccess;\n\n\tif (element-\u003eAttribute(\"name\"))\n\t{\n\t\toutObj-\u003ename = element-\u003eAttribute(\"name\");\n\t}\n\n\tif (element-\u003eAttribute(\"type\"))\n\t{\n\t\toutObj-\u003etype = element-\u003eAttribute(\"type\");\n\t}\n\toutObj-\u003ex = element-\u003eFloatAttribute(\"x\");\n\toutObj-\u003ey = element-\u003eFloatAttribute(\"y\");\n\toutObj-\u003ewidth = element-\u003eFloatAttribute(\"width\");\n\toutObj-\u003eheight = element-\u003eFloatAttribute(\"height\");\n\toutObj-\u003erotation = element-\u003eFloatAttribute(\"rotation\");\n\toutObj-\u003ereferenceGid = element-\u003eUnsignedAttribute(\"gid\");\n\toutObj-\u003evisible = element-\u003eBoolAttribute(\"visible\");\n\n\terror = _parsePropertyNode(element-\u003eFirstChildElement(\"properties\"), \u0026outObj-\u003epropertyMap);\n\tif (error)\n\t{\n\t\treturn error;\n\t}\n\n\n\ttinyxml2::XMLElement* shapeElement = NULL;\n\tif ((shapeElement = element-\u003eFirstChildElement(\"ellipse\")) != NULL)\n\t{\n\t\toutObj-\u003eshapeType = kEllipse;\n\t}\n\telse if ((shapeElement = element-\u003eFirstChildElement(\"polygon\")) != NULL)\n\t{\n\t\toutObj-\u003eshapeType = kPolygon;\n\t}\n\telse if ((shapeElement = element-\u003eFirstChildElement(\"polyline\")) != NULL)\n\t{\n\t\toutObj-\u003eshapeType = kPolyline;\n\t}\n\telse\n\t{\n\t\toutObj-\u003eshapeType = kSquare;\n\t}\n\n\tif ((outObj-\u003eshapeType == kPolygon || outObj-\u003eshapeType == kPolyline) \u0026\u0026 shapeElement != NULL)\n\t{\n\t\tif (shapeElement-\u003eAttribute(\"points\") == NULL)\n\t\t{\n\t\t\tLOGE(\"Missing points attribute for shape requiring one...\");\n\t\t\treturn TmxReturn::kErrorParsing;\n\t\t}\n\n\t\tstd::string pointString = shapeElement-\u003eAttribute(\"points\");\n\t\tstd::istringstream pairStringStream(pointString);\n\t\tstd::string pairToken;\n\t\twhile(std::getline(pairStringStream, pairToken, ' '))\n\t\t{\n\t\t\tTmxShapePoint pair;\n\t\t\tstd::istringstream pointStringString(pairToken);\n\t\t\tstd::string pointToken;\n\t\t\tstd::getline(pointStringString, pointToken, ',');\n\t\t\tpair.first = (float)atof(pointToken.c_str());\n\t\t\tstd::getline(pointStringString, pointToken, ',');\n\t\t\tpair.second = (float)atof(pointToken.c_str());\n\n\t\t\toutObj-\u003eshapePoints.push_back(pair);\n\t\t}\n\t}\n\n\treturn error;\n}\n\n\nTmxReturn calculateTileCoordinatesUV(const TmxTileset\u0026 tileset,  unsigned int tileFlatIndex, float pixelCorrection, bool flipY, TmxRect\u0026 outRect)\n{\n\tif (tileFlatIndex \u003e= tileset.colCount * tileset.rowCount)\n\t{\n\t\treturn TmxReturn::kInvalidTileIndex;\n\t}\n\n\tTileId_t xIndex = tileFlatIndex % tileset.colCount;\n\tTileId_t yIndex = tileFlatIndex / tileset.colCount;\n\n\tunsigned int widthDelta = tileset.tileSpacingInImage + tileset.tileMarginInImage*xIndex;\n\tunsigned int heightDelta = tileset.tileSpacingInImage + tileset.tileMarginInImage*yIndex;\n\n\tfloat u = (float)((xIndex * tileset.tileWidth) + widthDelta + pixelCorrection) / (float)tileset.image.width;\n\tfloat v = (float)((yIndex * tileset.tileHeight) + heightDelta + pixelCorrection) / (float)tileset.image.height;\n\n\tfloat u2 = (float)((( (xIndex+1) * tileset.tileWidth) + widthDelta) - pixelCorrection) / (float)tileset.image.width;\n\tfloat v2 = (float)((( (yIndex+1) * tileset.tileHeight) + heightDelta) - pixelCorrection) / (float)tileset.image.height;\n\n\tif (flipY)\n\t{\n\t\tfloat tmpV = v;\n\t\tv = 1.f - v2;\n\t\tv2 = 1.f - tmpV;\n\t}\n\n\toutRect.u = u;\n\toutRect.v = v;\n\toutRect.u2 = u2;\n\toutRect.v2 = v2;\n\n\treturn kSuccess;\n}\n\ntmxparser::TmxReturn _parseOffsetNode(tinyxml2::XMLElement* element, TmxOffset* offset)\n{\n\tTmxReturn error = TmxReturn::kSuccess;\n\n\toffset-\u003ex = 0;\n\toffset-\u003ey = 0;\n\n\tif (element-\u003eAttribute(\"x\"))\n\t{\n\t\toffset-\u003ex = element-\u003eIntAttribute(\"x\");\n\t}\n\n\tif (element-\u003eAttribute(\"y\"))\n\t{\n\t\toffset-\u003ey = element-\u003eIntAttribute(\"y\");\n\t}\n\n\treturn error;\n}\n\ntmxparser::TmxReturn _parseImageLayerNode(tinyxml2::XMLElement* element, TmxImageLayer* outImageLayer)\n{\n\tTmxReturn error = TmxReturn::kSuccess;\n\n\tCHECK_AND_RETRIEVE_REQ_ATTRIBUTE_STRING(element, \"name\", outImageLayer-\u003ename);\n\t\n\t// x : optional , default 0\n\tif (element-\u003eQueryUnsignedAttribute(\"x\", \u0026outImageLayer-\u003ex) == tinyxml2::XML_NO_ATTRIBUTE)\n\t\toutImageLayer-\u003ex = 0U;\n\n\t// y : optional , default 0\n\tif (element-\u003eQueryUnsignedAttribute(\"y\", \u0026outImageLayer-\u003ey) == tinyxml2::XML_NO_ATTRIBUTE)\n\t\toutImageLayer-\u003ey = 0U;\n\n\t// width: optional, default: 0\n\tif (element-\u003eQueryUnsignedAttribute(\"width\", \u0026outImageLayer-\u003ewidthInTiles) == tinyxml2::XML_NO_ATTRIBUTE)\n\t\toutImageLayer-\u003ewidthInTiles = 0U;\n\t\n\t// height: optional, default: 0\n\tif (element-\u003eQueryUnsignedAttribute(\"height\", \u0026outImageLayer-\u003eheightInTiles) == tinyxml2::XML_NO_ATTRIBUTE)\n\t\toutImageLayer-\u003eheightInTiles = 0U;\n\n\t// opacity: optional, default: 1.0\n\tif (element-\u003eQueryFloatAttribute(\"opacity\", \u0026outImageLayer-\u003eopacity) == tinyxml2::XML_NO_ATTRIBUTE)\n\t\toutImageLayer-\u003eopacity = 1.f;\n\n\t// visible: optional, default: true\n\tif (element-\u003eQueryBoolAttribute(\"visible\", \u0026outImageLayer-\u003evisible) == tinyxml2::XML_NO_ATTRIBUTE)\n\t\toutImageLayer-\u003evisible = true;\n\n\t// properties: optional\n\tif (element-\u003eFirstChildElement(\"properties\") != NULL)\n\t{\n\t\terror = _parsePropertyNode(element-\u003eFirstChildElement(\"properties\"), \u0026outImageLayer-\u003epropertyMap);\n\t\tif (error != kSuccess)\n\t\t{\n\t\t\tLOGE(\"Error parsing image layer property node...\");\n\t\t\treturn error;\n\t\t}\n\t}\n\n\t// image: optional\n\tif (element-\u003eFirstChildElement(\"image\") != NULL)\n\t{\n\t\terror = _parseImageNode(element-\u003eFirstChildElement(\"image\"), \u0026outImageLayer-\u003eimage);\n\t\tif (error != kSuccess)\n\t\t\treturn error;\n\t}\n\n\treturn error;\n}\n\n}\n\n"}
{"repo_name":"yxcoin/yxcoin","ref":"refs/heads/master","path":"src/boost_1_55_0/libs/phoenix/test/include/stl/algorithm/querying.cpp","copies":"60","language":"C++","content":"/*=============================================================================\n    Copyright (c) 2011 Thomas Heller\n    Distributed under the Boost Software License, Version 1.0. (See accompanying\n    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n==============================================================================*/\n#include \u003cboost/phoenix/stl/algorithm/querying.hpp\u003e\nint main() {}\n"}
{"repo_name":"leighleighleigh/smol-pong","ref":"refs/heads/master","path":"smol_pong/DNSServer.cpp","copies":"9","language":"C++","content":"#include \"./DNSServer.h\"\n#include \u003clwip/def.h\u003e\n#include \u003cArduino.h\u003e\n\n#define DEBUG\n#define DEBUG_OUTPUT Serial\n\nDNSServer::DNSServer()\n{\n  _ttl = htonl(60);\n  _errorReplyCode = DNSReplyCode::NonExistentDomain;\n}\n\nbool DNSServer::start(const uint16_t \u0026port, const String \u0026domainName,\n                     const IPAddress \u0026resolvedIP)\n{\n  _port = port;\n  _domainName = domainName;\n  _resolvedIP[0] = resolvedIP[0];\n  _resolvedIP[1] = resolvedIP[1];\n  _resolvedIP[2] = resolvedIP[2];\n  _resolvedIP[3] = resolvedIP[3];\n  downcaseAndRemoveWwwPrefix(_domainName);\n  return _udp.begin(_port) == 1;\n}\n\nvoid DNSServer::setErrorReplyCode(const DNSReplyCode \u0026replyCode)\n{\n  _errorReplyCode = replyCode;\n}\n\nvoid DNSServer::setTTL(const uint32_t \u0026ttl)\n{\n  _ttl = htonl(ttl);\n}\n\nvoid DNSServer::stop()\n{\n  _udp.stop();\n}\n\nvoid DNSServer::downcaseAndRemoveWwwPrefix(String \u0026domainName)\n{\n  domainName.toLowerCase();\n  domainName.replace(\"www.\", \"\");\n}\n\nvoid DNSServer::processNextRequest()\n{\n  _currentPacketSize = _udp.parsePacket();\n  if (_currentPacketSize)\n  {\n    _buffer = (unsigned char*)malloc(_currentPacketSize * sizeof(char));\n    _udp.read(_buffer, _currentPacketSize);\n    _dnsHeader = (DNSHeader*) _buffer;\n\n    if (_dnsHeader-\u003eQR == DNS_QR_QUERY \u0026\u0026\n        _dnsHeader-\u003eOPCode == DNS_OPCODE_QUERY \u0026\u0026\n        requestIncludesOnlyOneQuestion() \u0026\u0026\n        (_domainName == \"*\" || getDomainNameWithoutWwwPrefix() == _domainName)\n       )\n    {\n      replyWithIP();\n    }\n    else if (_dnsHeader-\u003eQR == DNS_QR_QUERY)\n    {\n      replyWithCustomCode();\n    }\n\n    free(_buffer);\n  }\n}\n\nbool DNSServer::requestIncludesOnlyOneQuestion()\n{\n  return ntohs(_dnsHeader-\u003eQDCount) == 1 \u0026\u0026\n         _dnsHeader-\u003eANCount == 0 \u0026\u0026\n         _dnsHeader-\u003eNSCount == 0 \u0026\u0026\n         _dnsHeader-\u003eARCount == 0;\n}\n\nString DNSServer::getDomainNameWithoutWwwPrefix()\n{\n  String parsedDomainName = \"\";\n  unsigned char *start = _buffer + 12;\n  if (*start == 0)\n  {\n    return parsedDomainName;\n  }\n  int pos = 0;\n  while(true)\n  {\n    unsigned char labelLength = *(start + pos);\n    for(int i = 0; i \u003c labelLength; i++)\n    {\n      pos++;\n      parsedDomainName += (char)*(start + pos);\n    }\n    pos++;\n    if (*(start + pos) == 0)\n    {\n      downcaseAndRemoveWwwPrefix(parsedDomainName);\n      return parsedDomainName;\n    }\n    else\n    {\n      parsedDomainName += \".\";\n    }\n  }\n}\n\nvoid DNSServer::replyWithIP()\n{\n  _dnsHeader-\u003eQR = DNS_QR_RESPONSE;\n  _dnsHeader-\u003eANCount = _dnsHeader-\u003eQDCount;\n  _dnsHeader-\u003eQDCount = _dnsHeader-\u003eQDCount; \n  //_dnsHeader-\u003eRA = 1;  \n\n  _udp.beginPacket(_udp.remoteIP(), _udp.remotePort());\n  _udp.write(_buffer, _currentPacketSize);\n\n  _udp.write((uint8_t)192); //  answer name is a pointer\n  _udp.write((uint8_t)12);  // pointer to offset at 0x00c\n\n  _udp.write((uint8_t)0);   // 0x0001  answer is type A query (host address)\n  _udp.write((uint8_t)1);\n\n  _udp.write((uint8_t)0);   //0x0001 answer is class IN (internet address)\n  _udp.write((uint8_t)1);\n \n  _udp.write((unsigned char*)\u0026_ttl, 4);\n\n  // Length of RData is 4 bytes (because, in this case, RData is IPv4)\n  _udp.write((uint8_t)0);\n  _udp.write((uint8_t)4);\n  _udp.write(_resolvedIP, sizeof(_resolvedIP));\n  _udp.endPacket();\n\n\n\n  #ifdef DEBUG\n    DEBUG_OUTPUT.print(\"DNS responds: \");\n    DEBUG_OUTPUT.print(_resolvedIP[0]);\n    DEBUG_OUTPUT.print(\".\");\n    DEBUG_OUTPUT.print(_resolvedIP[1]);\n    DEBUG_OUTPUT.print(\".\");\n    DEBUG_OUTPUT.print(_resolvedIP[2]);\n    DEBUG_OUTPUT.print(\".\");\n    DEBUG_OUTPUT.print(_resolvedIP[3]);\n    DEBUG_OUTPUT.print(\" for \");\n    DEBUG_OUTPUT.println(getDomainNameWithoutWwwPrefix());\n  #endif\n}\n\nvoid DNSServer::replyWithCustomCode()\n{\n  _dnsHeader-\u003eQR = DNS_QR_RESPONSE;\n  _dnsHeader-\u003eRCode = (unsigned char)_errorReplyCode;\n  _dnsHeader-\u003eQDCount = 0;\n\n  _udp.beginPacket(_udp.remoteIP(), _udp.remotePort());\n  _udp.write(_buffer, sizeof(DNSHeader));\n  _udp.endPacket();\n}\n\n"}
{"repo_name":"xhochy/arrow","ref":"refs/heads/master","path":"ruby/red-arrow/ext/arrow/raw-records.cpp","copies":"6","language":"C++","content":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n#include \"converters.hpp\"\n\nnamespace red_arrow {\n  namespace {\n    class RawRecordsBuilder : private Converter, public arrow::ArrayVisitor {\n    public:\n      explicit RawRecordsBuilder(VALUE records, int n_columns)\n        : Converter(),\n          records_(records),\n          n_columns_(n_columns) {\n      }\n\n      void build(const arrow::RecordBatch\u0026 record_batch) {\n        rb::protect([\u0026] {\n          const auto n_rows = record_batch.num_rows();\n          for (int64_t i = 0; i \u003c n_rows; ++i) {\n            auto record = rb_ary_new_capa(n_columns_);\n            rb_ary_push(records_, record);\n          }\n          row_offset_ = 0;\n          for (int i = 0; i \u003c n_columns_; ++i) {\n            const auto array = record_batch.column(i).get();\n            column_index_ = i;\n            check_status(array-\u003eAccept(this),\n                         \"[record-batch][raw-records]\");\n          }\n          return Qnil;\n        });\n      }\n\n      void build(const arrow::Table\u0026 table) {\n        rb::protect([\u0026] {\n          const auto n_rows = table.num_rows();\n          for (int64_t i = 0; i \u003c n_rows; ++i) {\n            auto record = rb_ary_new_capa(n_columns_);\n            rb_ary_push(records_, record);\n          }\n          for (int i = 0; i \u003c n_columns_; ++i) {\n            const auto\u0026 chunked_array = table.column(i).get();\n            column_index_ = i;\n            row_offset_ = 0;\n            for (const auto array : chunked_array-\u003echunks()) {\n              check_status(array-\u003eAccept(this),\n                           \"[table][raw-records]\");\n              row_offset_ += array-\u003elength();\n            }\n          }\n          return Qnil;\n        });\n      }\n\n#define VISIT(TYPE)                                                     \\\n      arrow::Status Visit(const arrow::TYPE ## Array\u0026 array) override { \\\n        convert(array);                                                 \\\n        return arrow::Status::OK();                                     \\\n      }\n\n      VISIT(Null)\n      VISIT(Boolean)\n      VISIT(Int8)\n      VISIT(Int16)\n      VISIT(Int32)\n      VISIT(Int64)\n      VISIT(UInt8)\n      VISIT(UInt16)\n      VISIT(UInt32)\n      VISIT(UInt64)\n      // TODO\n      // VISIT(HalfFloat)\n      VISIT(Float)\n      VISIT(Double)\n      VISIT(Binary)\n      VISIT(String)\n      VISIT(FixedSizeBinary)\n      VISIT(Date32)\n      VISIT(Date64)\n      VISIT(Time32)\n      VISIT(Time64)\n      VISIT(Timestamp)\n      // TODO\n      // VISIT(Interval)\n      VISIT(List)\n      VISIT(Struct)\n      VISIT(Union)\n      VISIT(Dictionary)\n      VISIT(Decimal128)\n      // TODO\n      // VISIT(Extension)\n\n#undef VISIT\n\n    private:\n      template \u003ctypename ArrayType\u003e\n      void convert(const ArrayType\u0026 array) {\n        const auto n = array.length();\n        if (array.null_count() \u003e 0) {\n          for (int64_t i = 0, ii = row_offset_; i \u003c n; ++i, ++ii) {\n            auto value = Qnil;\n            if (!array.IsNull(i)) {\n              value = convert_value(array, i);\n            }\n            auto record = rb_ary_entry(records_, ii);\n            rb_ary_store(record, column_index_, value);\n          }\n        } else {\n          for (int64_t i = 0, ii = row_offset_; i \u003c n; ++i, ++ii) {\n            auto record = rb_ary_entry(records_, ii);\n            rb_ary_store(record, column_index_, convert_value(array, i));\n          }\n        }\n      }\n\n      // Destination for converted records.\n      VALUE records_;\n\n      // The current column index.\n      int column_index_;\n\n      // The current row offset.\n      int64_t row_offset_;\n\n      // The number of columns.\n      const int n_columns_;\n    };\n  }\n\n  VALUE\n  record_batch_raw_records(VALUE rb_record_batch) {\n    auto garrow_record_batch = GARROW_RECORD_BATCH(RVAL2GOBJ(rb_record_batch));\n    auto record_batch = garrow_record_batch_get_raw(garrow_record_batch).get();\n    const auto n_rows = record_batch-\u003enum_rows();\n    const auto n_columns = record_batch-\u003enum_columns();\n    auto records = rb_ary_new_capa(n_rows);\n\n    try {\n      RawRecordsBuilder builder(records, n_columns);\n      builder.build(*record_batch);\n    } catch (rb::State\u0026 state) {\n      state.jump();\n    }\n\n    return records;\n  }\n\n  VALUE\n  table_raw_records(VALUE rb_table) {\n    auto garrow_table = GARROW_TABLE(RVAL2GOBJ(rb_table));\n    auto table = garrow_table_get_raw(garrow_table).get();\n    const auto n_rows = table-\u003enum_rows();\n    const auto n_columns = table-\u003enum_columns();\n    auto records = rb_ary_new_capa(n_rows);\n\n    try {\n      RawRecordsBuilder builder(records, n_columns);\n      builder.build(*table);\n    } catch (rb::State\u0026 state) {\n      state.jump();\n    }\n\n    return records;\n  }\n}\n"}
{"repo_name":"tectronics/mysql-parallel-replication","ref":"refs/heads/master","path":"extra/yassl/taocrypt/src/hash.cpp","copies":"41","language":"C++","content":"/*\n   Copyright (C) 2000-2007 MySQL AB\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; version 2 of the License.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING. If not, write to the\n   Free Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,\n   MA  02110-1301  USA.\n*/\n\n/* hash.cpp implements a base for digest types\n*/\n\n#include \"runtime.hpp\"\n#include \u003cstring.h\u003e\n#include \u003cassert.h\u003e\n\n#include \"hash.hpp\"\n\n\nnamespace TaoCrypt {\n\n\nHASHwithTransform::HASHwithTransform(word32 digSz, word32 buffSz)\n{\n    assert(digSz  \u003c= MaxDigestSz);\n    assert(buffSz \u003c= MaxBufferSz);\n}\n\n\nvoid HASHwithTransform::AddLength(word32 len)\n{\n    HashLengthType tmp = loLen_;\n    if ( (loLen_ += len) \u003c tmp)\n        hiLen_++;                       // carry low to high\n    hiLen_ += SafeRightShift\u003c8*sizeof(HashLengthType)\u003e(len);\n}\n\n\n// Update digest with data of size len, do in blocks\nvoid HASHwithTransform::Update(const byte* data, word32 len)\n{\n    // do block size increments\n    word32 blockSz = getBlockSize();\n    byte*  local   = reinterpret_cast\u003cbyte*\u003e(buffer_);\n\n    while (len) {\n        word32 add = min(len, blockSz - buffLen_);\n        memcpy(\u0026local[buffLen_], data, add);\n\n        buffLen_ += add;\n        data     += add;\n        len      -= add;\n\n        if (buffLen_ == blockSz) {\n            ByteReverseIf(local, local, blockSz, getByteOrder());\n            Transform();\n            AddLength(blockSz);\n            buffLen_ = 0;\n        }\n    }\n}\n\n\n// Final process, place digest in hash\nvoid HASHwithTransform::Final(byte* hash)\n{\n    word32    blockSz   = getBlockSize();\n    word32    digestSz  = getDigestSize();\n    word32    padSz     = getPadSize();\n    ByteOrder order     = getByteOrder();\n\n    AddLength(buffLen_);                        // before adding pads\n    HashLengthType preLoLen = GetBitCountLo();\n    HashLengthType preHiLen = GetBitCountHi();\n    byte*     local     = reinterpret_cast\u003cbyte*\u003e(buffer_);\n\n    local[buffLen_++] = 0x80;  // add 1\n\n    // pad with zeros\n    if (buffLen_ \u003e padSz) {\n        memset(\u0026local[buffLen_], 0, blockSz - buffLen_);\n        buffLen_ += blockSz - buffLen_;\n\n        ByteReverseIf(local, local, blockSz, order);\n        Transform();\n        buffLen_ = 0;\n    }\n    memset(\u0026local[buffLen_], 0, padSz - buffLen_);\n\n    ByteReverseIf(local, local, blockSz, order);\n    \n    memcpy(\u0026local[padSz],   order ? \u0026preHiLen : \u0026preLoLen, sizeof(preLoLen));\n    memcpy(\u0026local[padSz+4], order ? \u0026preLoLen : \u0026preHiLen, sizeof(preLoLen));\n\n    Transform();\n    ByteReverseIf(digest_, digest_, digestSz, order);\n    memcpy(hash, digest_, digestSz);\n\n    Init();  // reset state\n}\n\n\n#ifdef WORD64_AVAILABLE\n\nHASH64withTransform::HASH64withTransform(word32 digSz, word32 buffSz)\n{\n    assert(digSz  \u003c= MaxDigestSz);\n    assert(buffSz \u003c= MaxBufferSz);\n}\n\n\nvoid HASH64withTransform::AddLength(word32 len)\n{\n    HashLengthType tmp = loLen_;\n    if ( (loLen_ += len) \u003c tmp)\n        hiLen_++;                       // carry low to high\n    hiLen_ += SafeRightShift\u003c8*sizeof(HashLengthType)\u003e(len);\n}\n\n\n// Update digest with data of size len, do in blocks\nvoid HASH64withTransform::Update(const byte* data, word32 len)\n{\n    // do block size increments\n    word32 blockSz = getBlockSize();\n    byte*  local   = reinterpret_cast\u003cbyte*\u003e(buffer_);\n\n    while (len) {\n        word32 add = min(len, blockSz - buffLen_);\n        memcpy(\u0026local[buffLen_], data, add);\n\n        buffLen_ += add;\n        data     += add;\n        len      -= add;\n\n        if (buffLen_ == blockSz) {\n            ByteReverseIf(buffer_, buffer_, blockSz, getByteOrder());\n            Transform();\n            AddLength(blockSz);\n            buffLen_ = 0;\n        }\n    }\n}\n\n\n// Final process, place digest in hash\nvoid HASH64withTransform::Final(byte* hash)\n{\n    word32    blockSz  = getBlockSize();\n    word32    digestSz = getDigestSize();\n    word32    padSz    = getPadSize();\n    ByteOrder order    = getByteOrder();\n\n    AddLength(buffLen_);                        // before adding pads\n    HashLengthType preLoLen = GetBitCountLo();\n    HashLengthType preHiLen = GetBitCountHi();\n    byte*     local         = reinterpret_cast\u003cbyte*\u003e(buffer_);\n\n    local[buffLen_++] = 0x80;  // add 1\n\n    // pad with zeros\n    if (buffLen_ \u003e padSz) {\n        memset(\u0026local[buffLen_], 0, blockSz - buffLen_);\n        buffLen_ += blockSz - buffLen_;\n\n        ByteReverseIf(buffer_, buffer_, blockSz, order);\n        Transform();\n        buffLen_ = 0;\n    }\n    memset(\u0026local[buffLen_], 0, padSz - buffLen_);\n   \n    ByteReverseIf(buffer_, buffer_, padSz, order);\n    \n    buffer_[blockSz / sizeof(word64) - 2] = order ? preHiLen : preLoLen;\n    buffer_[blockSz / sizeof(word64) - 1] = order ? preLoLen : preHiLen;\n\n    Transform();\n    ByteReverseIf(digest_, digest_, digestSz, order);\n    memcpy(hash, digest_, digestSz);\n\n    Init();  // reset state\n}\n\n#endif // WORD64_AVAILABLE\n\n\n} // namespace\n"}
{"repo_name":"geodynamics/gale","ref":"refs/heads/master","path":"boost/libs/regex/performance/time_greta.cpp","copies":"45","language":"C++","content":"/*\n *\n * Copyright (c) 2002\n * John Maddock\n *\n * Use, modification and distribution are subject to the \n * Boost Software License, Version 1.0. (See accompanying file \n * LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n *\n */\n\n#include \"regex_comparison.hpp\"\n#if defined(BOOST_HAS_GRETA)\n#include \u003ccassert\u003e\n#include \u003cboost/timer.hpp\u003e\n#include \"regexpr2.h\"\n\nnamespace g{\n\ndouble time_match(const std::string\u0026 re, const std::string\u0026 text, bool icase)\n{\n   regex::rpattern e(re, (icase ? regex::MULTILINE | regex::NORMALIZE | regex::NOCASE : regex::MULTILINE | regex::NORMALIZE));\n   regex::match_results what;\n   boost::timer tim;\n   int iter = 1;\n   int counter, repeats;\n   double result = 0;\n   double run;\n   assert(e.match(text, what));\n   do\n   {\n      tim.restart();\n      for(counter = 0; counter \u003c iter; ++counter)\n      {\n         e.match(text, what);\n      }\n      result = tim.elapsed();\n      iter *= 2;\n   }while(result \u003c 0.5);\n   iter /= 2;\n\n   // repeat test and report least value for consistency:\n   for(repeats = 0; repeats \u003c REPEAT_COUNT; ++repeats)\n   {\n      tim.restart();\n      for(counter = 0; counter \u003c iter; ++counter)\n      {\n         e.match(text, what);\n      }\n      run = tim.elapsed();\n      result = (std::min)(run, result);\n   }\n   return result / iter;\n}\n\ndouble time_find_all(const std::string\u0026 re, const std::string\u0026 text, bool icase)\n{\n   regex::rpattern e(re, (icase ? regex::MULTILINE | regex::NORMALIZE | regex::NOCASE : regex::MULTILINE | regex::NORMALIZE));\n   regex::match_results what;\n   boost::timer tim;\n   int iter = 1;\n   int counter, repeats;\n   double result = 0;\n   double run;\n   do\n   {\n      tim.restart();\n      for(counter = 0; counter \u003c iter; ++counter)\n      {\n         e.match(text.begin(), text.end(), what);\n         while(what.backref(0).matched)\n         { \n            e.match(what.backref(0).end(), text.end(), what); \n         }\n      }\n      result = tim.elapsed();\n      iter *= 2;\n   }while(result \u003c 0.5);\n   iter /= 2;\n\n   if(result \u003e 10)\n      return result / iter;\n\n   // repeat test and report least value for consistency:\n   for(repeats = 0; repeats \u003c REPEAT_COUNT; ++repeats)\n   {\n      tim.restart();\n      for(counter = 0; counter \u003c iter; ++counter)\n      {\n         e.match(text.begin(), text.end(), what);\n         while(what.backref(0).matched)\n         { \n            e.match(what.backref(0).end(), text.end(), what); \n         }\n      }\n      run = tim.elapsed();\n      result = (std::min)(run, result);\n   }\n   return result / iter;\n}\n\n}\n\n#else\n\nnamespace g {\n\ndouble time_match(const std::string\u0026 re, const std::string\u0026 text, bool icase)\n{\n   return -1;\n}\n\ndouble time_find_all(const std::string\u0026 re, const std::string\u0026 text, bool icase)\n{\n   return -1;\n}\n\n}\n\n#endif\n\n\n"}
{"repo_name":"cryptometh/cryptometh_1","ref":"refs/heads/master","path":"src/cryptopp/vmac.cpp","copies":"76","language":"C++","content":"// vmac.cpp - written and placed in the public domain by Wei Dai\n// based on Ted Krovetz's public domain vmac.c and draft-krovetz-vmac-01.txt\n\n#include \"pch.h\"\n#include \"vmac.h\"\n#include \"argnames.h\"\n#include \"cpu.h\"\n\nNAMESPACE_BEGIN(CryptoPP)\n\n#if defined(_MSC_VER) \u0026\u0026 !CRYPTOPP_BOOL_SLOW_WORD64\n#include \u003cintrin.h\u003e\n#endif\n\n#define VMAC_BOOL_WORD128 (defined(CRYPTOPP_WORD128_AVAILABLE) \u0026\u0026 !defined(CRYPTOPP_X64_ASM_AVAILABLE))\n#ifdef __BORLANDC__\n#define const\t// Turbo C++ 2006 workaround\n#endif\nstatic const word64 p64   = W64LIT(0xfffffffffffffeff);  /* 2^64 - 257 prime  */\nstatic const word64 m62   = W64LIT(0x3fffffffffffffff);  /* 62-bit mask       */\nstatic const word64 m63   = W64LIT(0x7fffffffffffffff);  /* 63-bit mask       */\nstatic const word64 m64   = W64LIT(0xffffffffffffffff);  /* 64-bit mask       */\nstatic const word64 mpoly = W64LIT(0x1fffffff1fffffff);  /* Poly key mask     */\n#ifdef __BORLANDC__\n#undef const\n#endif\n#if VMAC_BOOL_WORD128\n#ifdef __powerpc__\n// workaround GCC Bug 31690: ICE with const __uint128_t and C++ front-end\n#define m126\t\t\t\t((word128(m62)\u003c\u003c64)|m64)\n#else\nstatic const word128 m126 = (word128(m62)\u003c\u003c64)|m64;\t\t /* 126-bit mask      */\n#endif\n#endif\n\nvoid VMAC_Base::UncheckedSetKey(const byte *userKey, unsigned int keylength, const NameValuePairs \u0026params)\n{\n\tint digestLength = params.GetIntValueWithDefault(Name::DigestSize(), DefaultDigestSize());\n\tif (digestLength != 8 \u0026\u0026 digestLength != 16)\n\t\tthrow InvalidArgument(\"VMAC: DigestSize must be 8 or 16\");\n\tm_is128 = digestLength == 16;\n\n\tm_L1KeyLength = params.GetIntValueWithDefault(Name::L1KeyLength(), 128);\n\tif (m_L1KeyLength \u003c= 0 || m_L1KeyLength % 128 != 0)\n\t\tthrow InvalidArgument(\"VMAC: L1KeyLength must be a positive multiple of 128\");\n\n\tAllocateBlocks();\n\n\tBlockCipher \u0026cipher = AccessCipher();\n\tcipher.SetKey(userKey, keylength, params);\n\tunsigned int blockSize = cipher.BlockSize();\n\tunsigned int blockSizeInWords = blockSize / sizeof(word64);\n\tSecBlock\u003cword64\u003e out(blockSizeInWords);\n\tSecByteBlock in;\n\tin.CleanNew(blockSize);\n\tsize_t i;\n\n\t/* Fill nh key */\n\tin[0] = 0x80; \n\tcipher.AdvancedProcessBlocks(in, NULL, (byte *)m_nhKey(), m_nhKeySize()*sizeof(word64), cipher.BT_InBlockIsCounter);\n\tConditionalByteReverse\u003cword64\u003e(BIG_ENDIAN_ORDER, m_nhKey(), m_nhKey(), m_nhKeySize()*sizeof(word64));\n\n\t/* Fill poly key */\n\tin[0] = 0xC0;\n\tin[15] = 0;\n\tfor (i = 0; i \u003c= (size_t)m_is128; i++)\n\t{\n\t\tcipher.ProcessBlock(in, out.BytePtr());\n\t\tm_polyState()[i*4+2] = GetWord\u003cword64\u003e(true, BIG_ENDIAN_ORDER, out.BytePtr()) \u0026 mpoly;\n\t\tm_polyState()[i*4+3]  = GetWord\u003cword64\u003e(true, BIG_ENDIAN_ORDER, out.BytePtr()+8) \u0026 mpoly;\n\t\tin[15]++;\n\t}\n\n\t/* Fill ip key */\n\tin[0] = 0xE0;\n\tin[15] = 0;\n\tword64 *l3Key = m_l3Key();\n\tfor (i = 0; i \u003c= (size_t)m_is128; i++)\n\t\tdo\n\t\t{\n\t\t\tcipher.ProcessBlock(in, out.BytePtr());\n\t\t\tl3Key[i*2+0] = GetWord\u003cword64\u003e(true, BIG_ENDIAN_ORDER, out.BytePtr());\n\t\t\tl3Key[i*2+1] = GetWord\u003cword64\u003e(true, BIG_ENDIAN_ORDER, out.BytePtr()+8);\n\t\t\tin[15]++;\n\t\t} while ((l3Key[i*2+0] \u003e= p64) || (l3Key[i*2+1] \u003e= p64));\n\n\tm_padCached = false;\n\tsize_t nonceLength;\n\tconst byte *nonce = GetIVAndThrowIfInvalid(params, nonceLength);\n\tResynchronize(nonce, (int)nonceLength);\n}\n\nvoid VMAC_Base::GetNextIV(RandomNumberGenerator \u0026rng, byte *IV)\n{\n\tSimpleKeyingInterface::GetNextIV(rng, IV);\n\tIV[0] \u0026= 0x7f;\n}\n\nvoid VMAC_Base::Resynchronize(const byte *nonce, int len)\n{\n\tsize_t length = ThrowIfInvalidIVLength(len);\n\tsize_t s = IVSize();\n\tbyte *storedNonce = m_nonce();\n\n\tif (m_is128)\n\t{\n\t\tmemset(storedNonce, 0, s-length);\n\t\tmemcpy(storedNonce+s-length, nonce, length);\n\t\tAccessCipher().ProcessBlock(storedNonce, m_pad());\n\t}\n\telse\n\t{\n\t\tif (m_padCached \u0026\u0026 (storedNonce[s-1] | 1) == (nonce[length-1] | 1))\n\t\t{\n\t\t\tm_padCached = VerifyBufsEqual(storedNonce+s-length, nonce, length-1);\n\t\t\tfor (size_t i=0; m_padCached \u0026\u0026 i\u003cs-length; i++)\n\t\t\t\tm_padCached = (storedNonce[i] == 0);\n\t\t}\n\t\tif (!m_padCached)\n\t\t{\n\t\t\tmemset(storedNonce, 0, s-length);\n\t\t\tmemcpy(storedNonce+s-length, nonce, length-1);\n\t\t\tstoredNonce[s-1] = nonce[length-1] \u0026 0xfe;\n\t\t\tAccessCipher().ProcessBlock(storedNonce, m_pad());\n\t\t\tm_padCached = true;\n\t\t}\n\t\tstoredNonce[s-1] = nonce[length-1];\n\t}\n\tm_isFirstBlock = true;\n\tRestart();\n}\n\nvoid VMAC_Base::HashEndianCorrectedBlock(const word64 *data)\n{\n\tassert(false);\n\tthrow 0;\n}\n\n#if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE \u0026\u0026 CRYPTOPP_BOOL_X86\n#pragma warning(disable: 4731)\t// frame pointer register 'ebp' modified by inline assembly code\nvoid\n#ifdef __GNUC__\n__attribute__ ((noinline))\t\t// Intel Compiler 9.1 workaround\n#endif\nVMAC_Base::VHASH_Update_SSE2(const word64 *data, size_t blocksRemainingInWord64, int tagPart)\n{\n\tconst word64 *nhK = m_nhKey();\n\tword64 *polyS = m_polyState();\n\tword32 L1KeyLength = m_L1KeyLength;\n\n#ifdef __GNUC__\n\tword32 temp;\n\t__asm__ __volatile__\n\t(\n\tAS2(\tmov\t\t%%ebx, %0)\n\tAS2(\tmov\t\t%1, %%ebx)\n\t\".intel_syntax noprefix;\"\n#else\n\t#if _MSC_VER \u003c 1300 || defined(__INTEL_COMPILER)\n\tchar isFirstBlock = m_isFirstBlock;\n\tAS2(\tmov\t\tebx, [L1KeyLength])\n\tAS2(\tmov\t\tdl, [isFirstBlock])\n\t#else\n\tAS2(\tmov\t\tecx, this)\n\tAS2(\tmov\t\tebx, [ecx+m_L1KeyLength])\n\tAS2(\tmov\t\tdl, [ecx+m_isFirstBlock])\n\t#endif\n\tAS2(\tmov\t\teax, tagPart)\n\tAS2(\tshl\t\teax, 4)\n\tAS2(\tmov\t\tedi, nhK)\n\tAS2(\tadd\t\tedi, eax)\n\tAS2(\tadd\t\teax, eax)\n\tAS2(\tadd\t\teax, polyS)\n\n\tAS2(\tmov\t\tesi, data)\n\tAS2(\tmov\t\tecx, blocksRemainingInWord64)\n#endif\n\n\tAS2(\tshr\t\tebx, 3)\n\tAS1(\tpush\tebp)\n\tAS2(\tsub\t\tesp, 12)\n\tASL(4)\n\tAS2(\tmov\t\tebp, ebx)\n\tAS2(\tcmp\t\tecx, ebx)\n\tAS2(\tcmovl\tebp, ecx)\n\tAS2(\tsub\t\tecx, ebp)\n\tAS2(\tlea\t\tebp, [edi+8*ebp])\t// end of nhK\n\tAS2(\tmovq\tmm6, [esi])\n\tAS2(\tpaddq\tmm6, [edi])\n\tAS2(\tmovq\tmm5, [esi+8])\n\tAS2(\tpaddq\tmm5, [edi+8])\n\tAS2(\tadd\t\tesi, 16)\n\tAS2(\tadd\t\tedi, 16)\n\tAS2(\tmovq\tmm4, mm6)\n\tASS(\tpshufw\tmm2, mm6, 1, 0, 3, 2)\n\tAS2(\tpmuludq\tmm6, mm5)\n\tASS(\tpshufw\tmm3, mm5, 1, 0, 3, 2)\n\tAS2(\tpmuludq\tmm5, mm2)\n\tAS2(\tpmuludq\tmm2, mm3)\n\tAS2(\tpmuludq\tmm3, mm4)\n\tAS2(\tpxor\tmm7, mm7)\n\tAS2(\tmovd\t[esp], mm6)\n\tAS2(\tpsrlq\tmm6, 32)\n\tAS2(\tmovd\t[esp+4], mm5)\n\tAS2(\tpsrlq\tmm5, 32)\n\tAS2(\tcmp\t\tedi, ebp)\n\tASJ(\tje,\t\t1, f)\n\tASL(0)\n\tAS2(\tmovq\tmm0, [esi])\n\tAS2(\tpaddq\tmm0, [edi])\n\tAS2(\tmovq\tmm1, [esi+8])\n\tAS2(\tpaddq\tmm1, [edi+8])\n\tAS2(\tadd\t\tesi, 16)\n\tAS2(\tadd\t\tedi, 16)\n\tAS2(\tmovq\tmm4, mm0)\n\tAS2(\tpaddq\tmm5, mm2)\n\tASS(\tpshufw\tmm2, mm0, 1, 0, 3, 2)\n\tAS2(\tpmuludq\tmm0, mm1)\n\tAS2(\tmovd\t[esp+8], mm3)\n\tAS2(\tpsrlq\tmm3, 32)\n\tAS2(\tpaddq\tmm5, mm3)\n\tASS(\tpshufw\tmm3, mm1, 1, 0, 3, 2)\n\tAS2(\tpmuludq\tmm1, mm2)\n\tAS2(\tpmuludq\tmm2, mm3)\n\tAS2(\tpmuludq\tmm3, mm4)\n\tAS2(\tmovd\tmm4, [esp])\n\tAS2(\tpaddq\tmm7, mm4)\n\tAS2(\tmovd\tmm4, [esp+4])\n\tAS2(\tpaddq\tmm6, mm4)\n\tAS2(\tmovd\tmm4, [esp+8])\n\tAS2(\tpaddq\tmm6, mm4)\n\tAS2(\tmovd\t[esp], mm0)\n\tAS2(\tpsrlq\tmm0, 32)\n\tAS2(\tpaddq\tmm6, mm0)\n\tAS2(\tmovd\t[esp+4], mm1)\n\tAS2(\tpsrlq\tmm1, 32)\n\tAS2(\tpaddq\tmm5, mm1)\n\tAS2(\tcmp\t\tedi, ebp)\n\tASJ(\tjne,\t0, b)\n\tASL(1)\n\tAS2(\tpaddq\tmm5, mm2)\n\tAS2(\tmovd\t[esp+8], mm3)\n\tAS2(\tpsrlq\tmm3, 32)\n\tAS2(\tpaddq\tmm5, mm3)\n\tAS2(\tmovd\tmm4, [esp])\n\tAS2(\tpaddq\tmm7, mm4)\n\tAS2(\tmovd\tmm4, [esp+4])\n\tAS2(\tpaddq\tmm6, mm4)\n\tAS2(\tmovd\tmm4, [esp+8])\n\tAS2(\tpaddq\tmm6, mm4)\n\tAS2(\tlea\t\tebp, [8*ebx])\n\tAS2(\tsub\t\tedi, ebp)\t\t// reset edi to start of nhK\n\n\tAS2(\tmovd\t[esp], mm7)\n\tAS2(\tpsrlq\tmm7, 32)\n\tAS2(\tpaddq\tmm6, mm7)\n\tAS2(\tmovd\t[esp+4], mm6)\n\tAS2(\tpsrlq\tmm6, 32)\n\tAS2(\tpaddq\tmm5, mm6)\n\tAS2(\tpsllq\tmm5, 2)\n\tAS2(\tpsrlq\tmm5, 2)\n\n#define a0 [eax+2*4]\n#define a1 [eax+3*4]\n#define a2 [eax+0*4]\n#define a3 [eax+1*4]\n#define k0 [eax+2*8+2*4]\n#define k1 [eax+2*8+3*4]\n#define k2 [eax+2*8+0*4]\n#define k3 [eax+2*8+1*4]\n\tAS2(\ttest\tdl, dl)\n\tASJ(\tjz,\t\t2, f)\n\tAS2(\tmovd\tmm1, k0)\n\tAS2(\tmovd\tmm0, [esp])\n\tAS2(\tpaddq\tmm0, mm1)\n\tAS2(\tmovd\ta0, mm0)\n\tAS2(\tpsrlq\tmm0, 32)\n\tAS2(\tmovd\tmm1, k1)\n\tAS2(\tmovd\tmm2, [esp+4])\n\tAS2(\tpaddq\tmm1, mm2)\n\tAS2(\tpaddq\tmm0, mm1)\n\tAS2(\tmovd\ta1, mm0)\n\tAS2(\tpsrlq\tmm0, 32)\n\tAS2(\tpaddq\tmm5, k2)\n\tAS2(\tpaddq\tmm0, mm5)\n\tAS2(\tmovq\ta2, mm0)\n\tAS2(\txor\t\tedx, edx)\n\tASJ(\tjmp,\t3, f)\n\tASL(2)\n\tAS2(\tmovd\tmm0, a3)\n\tAS2(\tmovq\tmm4, mm0)\n\tAS2(\tpmuludq\tmm0, k3)\t\t// a3*k3\n\tAS2(\tmovd\tmm1, a0)\n\tAS2(\tpmuludq\tmm1, k2)\t\t// a0*k2\n\tAS2(\tmovd\tmm2, a1)\n\tAS2(\tmovd\tmm6, k1)\n\tAS2(\tpmuludq\tmm2, mm6)\t\t// a1*k1\n\tAS2(\tmovd\tmm3, a2)\n\tAS2(\tpsllq\tmm0, 1)\n\tAS2(\tpaddq\tmm0, mm5)\n\tAS2(\tmovq\tmm5, mm3)\n\tAS2(\tmovd\tmm7, k0)\n\tAS2(\tpmuludq\tmm3, mm7)\t\t// a2*k0\n\tAS2(\tpmuludq\tmm4, mm7)\t\t// a3*k0\n\tAS2(\tpmuludq\tmm5, mm6)\t\t// a2*k1\n\tAS2(\tpaddq\tmm0, mm1)\n\tAS2(\tmovd\tmm1, a1)\n\tAS2(\tpaddq\tmm4, mm5)\n\tAS2(\tmovq\tmm5, mm1)\n\tAS2(\tpmuludq\tmm1, k2)\t\t// a1*k2\n\tAS2(\tpaddq\tmm0, mm2)\n\tAS2(\tmovd\tmm2, a0)\n\tAS2(\tpaddq\tmm0, mm3)\n\tAS2(\tmovq\tmm3, mm2)\n\tAS2(\tpmuludq\tmm2, k3)\t\t// a0*k3\n\tAS2(\tpmuludq\tmm3, mm7)\t\t// a0*k0\n\tAS2(\tmovd\t[esp+8], mm0)\n\tAS2(\tpsrlq\tmm0, 32)\n\tAS2(\tpmuludq\tmm7, mm5)\t\t// a1*k0\n\tAS2(\tpmuludq\tmm5, k3)\t\t// a1*k3\n\tAS2(\tpaddq\tmm0, mm1)\n\tAS2(\tmovd\tmm1, a2)\n\tAS2(\tpmuludq\tmm1, k2)\t\t// a2*k2\n\tAS2(\tpaddq\tmm0, mm2)\n\tAS2(\tpaddq\tmm0, mm4)\n\tAS2(\tmovq\tmm4, mm0)\n\tAS2(\tmovd\tmm2, a3)\n\tAS2(\tpmuludq\tmm2, mm6)\t\t// a3*k1\n\tAS2(\tpmuludq\tmm6, a0)\t\t// a0*k1\n\tAS2(\tpsrlq\tmm0, 31)\n\tAS2(\tpaddq\tmm0, mm3)\n\tAS2(\tmovd\tmm3, [esp])\n\tAS2(\tpaddq\tmm0, mm3)\n\tAS2(\tmovd\tmm3, a2)\n\tAS2(\tpmuludq\tmm3, k3)\t\t// a2*k3\n\tAS2(\tpaddq\tmm5, mm1)\n\tAS2(\tmovd\tmm1, a3)\n\tAS2(\tpmuludq\tmm1, k2)\t\t// a3*k2\n\tAS2(\tpaddq\tmm5, mm2)\n\tAS2(\tmovd\tmm2, [esp+4])\n\tAS2(\tpsllq\tmm5, 1)\n\tAS2(\tpaddq\tmm0, mm5)\n\tAS2(\tpsllq\tmm4, 33)\n\tAS2(\tmovd\ta0, mm0)\n\tAS2(\tpsrlq\tmm0, 32)\n\tAS2(\tpaddq\tmm6, mm7)\n\tAS2(\tmovd\tmm7, [esp+8])\n\tAS2(\tpaddq\tmm0, mm6)\n\tAS2(\tpaddq\tmm0, mm2)\n\tAS2(\tpaddq\tmm3, mm1)\n\tAS2(\tpsllq\tmm3, 1)\n\tAS2(\tpaddq\tmm0, mm3)\n\tAS2(\tpsrlq\tmm4, 1)\n\tAS2(\tmovd\ta1, mm0)\n\tAS2(\tpsrlq\tmm0, 32)\n\tAS2(\tpor\t\tmm4, mm7)\n\tAS2(\tpaddq\tmm0, mm4)\n\tAS2(\tmovq\ta2, mm0)\n#undef a0\n#undef a1\n#undef a2\n#undef a3\n#undef k0\n#undef k1\n#undef k2\n#undef k3\n\n\tASL(3)\n\tAS2(\ttest\tecx, ecx)\n\tASJ(\tjnz,\t4, b)\n\n\tAS2(\tadd\t\tesp, 12)\n\tAS1(\tpop\t\tebp)\n\tAS1(\temms)\n#ifdef __GNUC__\n\t\".att_syntax prefix;\"\n\tAS2(\tmov\t%0, %%ebx)\n\t\t: \"=m\" (temp)\n\t\t: \"m\" (L1KeyLength), \"c\" (blocksRemainingInWord64), \"S\" (data), \"D\" (nhK+tagPart*2), \"d\" (m_isFirstBlock), \"a\" (polyS+tagPart*4)\n\t\t: \"memory\", \"cc\"\n\t);\n#endif\n}\n#endif\n\n#if VMAC_BOOL_WORD128\n\t#define DeclareNH(a) word128 a=0\n\t#define MUL64(rh,rl,i1,i2) {word128 p = word128(i1)*(i2); rh = word64(p\u003e\u003e64); rl = word64(p);}\n\t#define AccumulateNH(a, b, c) a += word128(b)*(c)\n\t#define Multiply128(r, i1, i2) r = word128(word64(i1)) * word64(i2)\n#else\n\t#if _MSC_VER \u003e= 1400 \u0026\u0026 !defined(__INTEL_COMPILER)\n\t\t#define MUL32(a, b) __emulu(word32(a), word32(b))\n\t#else\n\t\t#define MUL32(a, b) ((word64)((word32)(a)) * (word32)(b))\n\t#endif\n\t#if defined(CRYPTOPP_X64_ASM_AVAILABLE)\n\t\t#define DeclareNH(a)\t\t\tword64 a##0=0, a##1=0\n\t\t#define MUL64(rh,rl,i1,i2)\t\tasm (\"mulq %3\" : \"=a\"(rl), \"=d\"(rh) : \"a\"(i1), \"g\"(i2) : \"cc\");\n\t\t#define AccumulateNH(a, b, c)\tasm (\"mulq %3; addq %%rax, %0; adcq %%rdx, %1\" : \"+r\"(a##0), \"+r\"(a##1) : \"a\"(b), \"g\"(c) : \"%rdx\", \"cc\");\n\t\t#define ADD128(rh,rl,ih,il)     asm (\"addq %3, %1; adcq %2, %0\" : \"+r\"(rh),\"+r\"(rl) : \"r\"(ih),\"r\"(il) : \"cc\");\n\t#elif defined(_MSC_VER) \u0026\u0026 !CRYPTOPP_BOOL_SLOW_WORD64\n\t\t#define DeclareNH(a) word64 a##0=0, a##1=0\n\t\t#define MUL64(rh,rl,i1,i2)   (rl) = _umul128(i1,i2,\u0026(rh));\n\t\t#define AccumulateNH(a, b, c)\t{\\\n\t\t\tword64 ph, pl;\\\n\t\t\tpl = _umul128(b,c,\u0026ph);\\\n\t\t\ta##0 += pl;\\\n\t\t\ta##1 += ph + (a##0 \u003c pl);}\n\t#else\n\t\t#define VMAC_BOOL_32BIT 1\n\t\t#define DeclareNH(a) word64 a##0=0, a##1=0, a##2=0\n\t\t#define MUL64(rh,rl,i1,i2)                                               \\\n\t\t\t{   word64 _i1 = (i1), _i2 = (i2);                                 \\\n\t\t\t\tword64 m1= MUL32(_i1,_i2\u003e\u003e32);                                 \\\n\t\t\t\tword64 m2= MUL32(_i1\u003e\u003e32,_i2);                                 \\\n\t\t\t\trh         = MUL32(_i1\u003e\u003e32,_i2\u003e\u003e32);                             \\\n\t\t\t\trl         = MUL32(_i1,_i2);                                     \\\n\t\t\t\tADD128(rh,rl,(m1 \u003e\u003e 32),(m1 \u003c\u003c 32));                             \\\n\t\t\t\tADD128(rh,rl,(m2 \u003e\u003e 32),(m2 \u003c\u003c 32));                             \\\n\t\t\t}\n\t\t#define AccumulateNH(a, b, c)\t{\\\n\t\t\tword64 p = MUL32(b, c);\\\n\t\t\ta##1 += word32((p)\u003e\u003e32);\\\n\t\t\ta##0 += word32(p);\\\n\t\t\tp = MUL32((b)\u003e\u003e32, c);\\\n\t\t\ta##2 += word32((p)\u003e\u003e32);\\\n\t\t\ta##1 += word32(p);\\\n\t\t\tp = MUL32((b)\u003e\u003e32, (c)\u003e\u003e32);\\\n\t\t\ta##2 += p;\\\n\t\t\tp = MUL32(b, (c)\u003e\u003e32);\\\n\t\t\ta##1 += word32(p);\\\n\t\t\ta##2 += word32(p\u003e\u003e32);}\n\t#endif\n#endif\n#ifndef VMAC_BOOL_32BIT\n\t#define VMAC_BOOL_32BIT 0\n#endif\n#ifndef ADD128\n\t#define ADD128(rh,rl,ih,il)                                          \\\n\t\t{   word64 _il = (il);                                         \\\n\t\t\t(rl) += (_il);                                               \\\n\t\t\t(rh) += (ih) + ((rl) \u003c (_il));                               \\\n\t\t}\n#endif\n\n#if !(defined(_MSC_VER) \u0026\u0026 _MSC_VER \u003c 1300)\ntemplate \u003cbool T_128BitTag\u003e\n#endif\nvoid VMAC_Base::VHASH_Update_Template(const word64 *data, size_t blocksRemainingInWord64)\n{\n\t#define INNER_LOOP_ITERATION(j)\t{\\\n\t\tword64 d0 = ConditionalByteReverse(LITTLE_ENDIAN_ORDER, data[i+2*j+0]);\\\n\t\tword64 d1 = ConditionalByteReverse(LITTLE_ENDIAN_ORDER, data[i+2*j+1]);\\\n\t\tAccumulateNH(nhA, d0+nhK[i+2*j+0], d1+nhK[i+2*j+1]);\\\n\t\tif (T_128BitTag)\\\n\t\t\tAccumulateNH(nhB, d0+nhK[i+2*j+2], d1+nhK[i+2*j+3]);\\\n\t\t}\n\n#if (defined(_MSC_VER) \u0026\u0026 _MSC_VER \u003c 1300)\n\tbool T_128BitTag = m_is128;\n#endif\n\tsize_t L1KeyLengthInWord64 = m_L1KeyLength / 8;\n\tsize_t innerLoopEnd = L1KeyLengthInWord64;\n\tconst word64 *nhK = m_nhKey();\n\tword64 *polyS = m_polyState();\n\tbool isFirstBlock = true;\n\tsize_t i;\n\n\t#if !VMAC_BOOL_32BIT\n\t\t#if VMAC_BOOL_WORD128\n\t\t\tword128 a1, a2;\n\t\t#else\n\t\t\tword64 ah1, al1, ah2, al2;\n\t\t#endif\n\t\tword64 kh1, kl1, kh2, kl2;\n\t\tkh1=(polyS+0*4+2)[0]; kl1=(polyS+0*4+2)[1];\n\t\tif (T_128BitTag)\n\t\t{\n\t\t\tkh2=(polyS+1*4+2)[0]; kl2=(polyS+1*4+2)[1];\n\t\t}\n\t#endif\n\n\tdo\n\t{\n\t\tDeclareNH(nhA);\n\t\tDeclareNH(nhB);\n\n\t\ti = 0;\n\t\tif (blocksRemainingInWord64 \u003c L1KeyLengthInWord64)\n\t\t{\n\t\t\tif (blocksRemainingInWord64 % 8)\n\t\t\t{\n\t\t\t\tinnerLoopEnd = blocksRemainingInWord64 % 8;\n\t\t\t\tfor (; i\u003cinnerLoopEnd; i+=2)\n\t\t\t\t\tINNER_LOOP_ITERATION(0);\n\t\t\t}\n\t\t\tinnerLoopEnd = blocksRemainingInWord64;\n\t\t}\n\t\tfor (; i\u003cinnerLoopEnd; i+=8)\n\t\t{\n\t\t\tINNER_LOOP_ITERATION(0);\n\t\t\tINNER_LOOP_ITERATION(1);\n\t\t\tINNER_LOOP_ITERATION(2);\n\t\t\tINNER_LOOP_ITERATION(3);\n\t\t}\n\t\tblocksRemainingInWord64 -= innerLoopEnd;\n\t\tdata += innerLoopEnd;\n\n\t\t#if VMAC_BOOL_32BIT\n\t\t\tword32 nh0[2],  nh1[2];\n\t\t\tword64 nh2[2];\n\n\t\t\tnh0[0] = word32(nhA0);\n\t\t\tnhA1 += (nhA0 \u003e\u003e 32);\n\t\t\tnh1[0] = word32(nhA1);\n\t\t\tnh2[0] = (nhA2 + (nhA1 \u003e\u003e 32)) \u0026 m62;\n\n\t\t\tif (T_128BitTag)\n\t\t\t{\n\t\t\t\tnh0[1] = word32(nhB0);\n\t\t\t\tnhB1 += (nhB0 \u003e\u003e 32);\n\t\t\t\tnh1[1] = word32(nhB1);\n\t\t\t\tnh2[1] = (nhB2 + (nhB1 \u003e\u003e 32)) \u0026 m62;\n\t\t\t}\n\n\t\t\t#define a0 (((word32 *)(polyS+i*4))[2+NativeByteOrder::ToEnum()])\n\t\t\t#define a1 (*(((word32 *)(polyS+i*4))+3-NativeByteOrder::ToEnum()))\t\t// workaround for GCC 3.2\n\t\t\t#define a2 (((word32 *)(polyS+i*4))[0+NativeByteOrder::ToEnum()])\n\t\t\t#define a3 (*(((word32 *)(polyS+i*4))+1-NativeByteOrder::ToEnum()))\n\t\t\t#define aHi ((polyS+i*4)[0])\n\t\t\t#define k0 (((word32 *)(polyS+i*4+2))[2+NativeByteOrder::ToEnum()])\n\t\t\t#define k1 (*(((word32 *)(polyS+i*4+2))+3-NativeByteOrder::ToEnum()))\n\t\t\t#define k2 (((word32 *)(polyS+i*4+2))[0+NativeByteOrder::ToEnum()])\n\t\t\t#define k3 (*(((word32 *)(polyS+i*4+2))+1-NativeByteOrder::ToEnum()))\n\t\t\t#define kHi ((polyS+i*4+2)[0])\n\n\t\t\tif (isFirstBlock)\n\t\t\t{\n\t\t\t\tisFirstBlock = false;\n\t\t\t\tif (m_isFirstBlock)\n\t\t\t\t{\n\t\t\t\t\tm_isFirstBlock = false;\n\t\t\t\t\tfor (i=0; i\u003c=(size_t)T_128BitTag; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tword64 t = (word64)nh0[i] + k0;\n\t\t\t\t\t\ta0 = (word32)t;\n\t\t\t\t\t\tt = (t \u003e\u003e 32) + nh1[i] + k1;\n\t\t\t\t\t\ta1 = (word32)t;\n\t\t\t\t\t\taHi = (t \u003e\u003e 32) + nh2[i] + kHi;\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (i=0; i\u003c=(size_t)T_128BitTag; i++)\n\t\t\t{\n\t\t\t\tword64 p, t;\n\t\t\t\tword32 t2;\n\n\t\t\t\tp = MUL32(a3, 2*k3);\n\t\t\t\tp += nh2[i];\n\t\t\t\tp += MUL32(a0, k2);\n\t\t\t\tp += MUL32(a1, k1);\n\t\t\t\tp += MUL32(a2, k0);\n\t\t\t\tt2 = (word32)p;\n\t\t\t\tp \u003e\u003e= 32;\n\t\t\t\tp += MUL32(a0, k3);\n\t\t\t\tp += MUL32(a1, k2);\n\t\t\t\tp += MUL32(a2, k1);\n\t\t\t\tp += MUL32(a3, k0);\n\t\t\t\tt = (word64(word32(p) \u0026 0x7fffffff) \u003c\u003c 32) | t2;\n\t\t\t\tp \u003e\u003e= 31;\n\t\t\t\tp += nh0[i];\n\t\t\t\tp += MUL32(a0, k0);\n\t\t\t\tp += MUL32(a1, 2*k3);\n\t\t\t\tp += MUL32(a2, 2*k2);\n\t\t\t\tp += MUL32(a3, 2*k1);\n\t\t\t\tt2 = (word32)p;\n\t\t\t\tp \u003e\u003e= 32;\n\t\t\t\tp += nh1[i];\n\t\t\t\tp += MUL32(a0, k1);\n\t\t\t\tp += MUL32(a1, k0);\n\t\t\t\tp += MUL32(a2, 2*k3);\n\t\t\t\tp += MUL32(a3, 2*k2);\n\t\t\t\ta0 = t2;\n\t\t\t\ta1 = (word32)p;\n\t\t\t\taHi = (p \u003e\u003e 32) + t;\n\t\t\t}\n\n\t\t\t#undef a0\n\t\t\t#undef a1\n\t\t\t#undef a2\n\t\t\t#undef a3\n\t\t\t#undef aHi\n\t\t\t#undef k0\n\t\t\t#undef k1\n\t\t\t#undef k2\n\t\t\t#undef k3\t\t\n\t\t\t#undef kHi\n\t\t#else\t\t// #if VMAC_BOOL_32BIT\n\t\t\tif (isFirstBlock)\n\t\t\t{\n\t\t\t\tisFirstBlock = false;\n\t\t\t\tif (m_isFirstBlock)\n\t\t\t\t{\n\t\t\t\t\tm_isFirstBlock = false;\n\t\t\t\t\t#if VMAC_BOOL_WORD128\n\t\t\t\t\t\t#define first_poly_step(a, kh, kl, m)\ta = (m \u0026 m126) + ((word128(kh) \u003c\u003c 64) | kl)\n\n\t\t\t\t\t\tfirst_poly_step(a1, kh1, kl1, nhA);\n\t\t\t\t\t\tif (T_128BitTag)\n\t\t\t\t\t\t\tfirst_poly_step(a2, kh2, kl2, nhB);\n\t\t\t\t\t#else\n\t\t\t\t\t\t#define first_poly_step(ah, al, kh, kl, mh, ml)\t\t{\\\n\t\t\t\t\t\t\tmh \u0026= m62;\\\n\t\t\t\t\t\t\tADD128(mh, ml, kh, kl);\t\\\n\t\t\t\t\t\t\tah = mh; al = ml;}\n\n\t\t\t\t\t\tfirst_poly_step(ah1, al1, kh1, kl1, nhA1, nhA0);\n\t\t\t\t\t\tif (T_128BitTag)\n\t\t\t\t\t\t\tfirst_poly_step(ah2, al2, kh2, kl2, nhB1, nhB0);\n\t\t\t\t\t#endif\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t#if VMAC_BOOL_WORD128\n\t\t\t\t\t\ta1 = (word128((polyS+0*4)[0]) \u003c\u003c 64) | (polyS+0*4)[1];\n\t\t\t\t\t#else\n\t\t\t\t\t\tah1=(polyS+0*4)[0]; al1=(polyS+0*4)[1];\n\t\t\t\t\t#endif\n\t\t\t\t\tif (T_128BitTag)\n\t\t\t\t\t{\n\t\t\t\t\t\t#if VMAC_BOOL_WORD128\n\t\t\t\t\t\t\ta2 = (word128((polyS+1*4)[0]) \u003c\u003c 64) | (polyS+1*4)[1];\n\t\t\t\t\t\t#else\n\t\t\t\t\t\t\tah2=(polyS+1*4)[0]; al2=(polyS+1*4)[1];\n\t\t\t\t\t\t#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t#if VMAC_BOOL_WORD128\n\t\t\t\t#define poly_step(a, kh, kl, m)\t\\\n\t\t\t\t{   word128 t1, t2, t3, t4;\\\n\t\t\t\t\tMultiply128(t2, a\u003e\u003e64, kl);\\\n\t\t\t\t\tMultiply128(t3, a, kh);\\\n\t\t\t\t\tMultiply128(t1, a, kl);\\\n\t\t\t\t\tMultiply128(t4, a\u003e\u003e64, 2*kh);\\\n\t\t\t\t\tt2 += t3;\\\n\t\t\t\t\tt4 += t1;\\\n\t\t\t\t\tt2 += t4\u003e\u003e64;\\\n\t\t\t\t\ta = (word128(word64(t2)\u0026m63) \u003c\u003c 64) | word64(t4);\\\n\t\t\t\t\tt2 *= 2;\\\n\t\t\t\t\ta += m \u0026 m126;\\\n\t\t\t\t\ta += t2\u003e\u003e64;}\n\n\t\t\t\tpoly_step(a1, kh1, kl1, nhA);\n\t\t\t\tif (T_128BitTag)\n\t\t\t\t\tpoly_step(a2, kh2, kl2, nhB);\n\t\t\t#else\n\t\t\t\t#define poly_step(ah, al, kh, kl, mh, ml)\t\t\t\t\t\\\n\t\t\t\t{   word64 t1h, t1l, t2h, t2l, t3h, t3l, z=0;\t\t\t\t\\\n\t\t\t\t\t/* compute ab*cd, put bd into result registers */       \\\n\t\t\t\t\tMUL64(t2h,t2l,ah,kl);                                   \\\n\t\t\t\t\tMUL64(t3h,t3l,al,kh);                                   \\\n\t\t\t\t\tMUL64(t1h,t1l,ah,2*kh);                                 \\\n\t\t\t\t\tMUL64(ah,al,al,kl);                                     \\\n\t\t\t\t\t/* add together ad + bc */                              \\\n\t\t\t\t\tADD128(t2h,t2l,t3h,t3l);                                \\\n\t\t\t\t\t/* add 2 * ac to result */                              \\\n\t\t\t\t\tADD128(ah,al,t1h,t1l);                                  \\\n\t\t\t\t\t/* now (ah,al), (t2l,2*t2h) need summing */             \\\n\t\t\t\t\t/* first add the high registers, carrying into t2h */   \\\n\t\t\t\t\tADD128(t2h,ah,z,t2l);                                   \\\n\t\t\t\t\t/* double t2h and add top bit of ah */                  \\\n\t\t\t\t\tt2h += t2h + (ah \u003e\u003e 63);                                \\\n\t\t\t\t\tah \u0026= m63;                                              \\\n\t\t\t\t\t/* now add the low registers */                         \\\n\t\t\t\t\tmh \u0026= m62;\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\tADD128(ah,al,mh,ml);                                    \\\n\t\t\t\t\tADD128(ah,al,z,t2h);                                    \\\n\t\t\t\t}\n\n\t\t\t\tpoly_step(ah1, al1, kh1, kl1, nhA1, nhA0);\n\t\t\t\tif (T_128BitTag)\n\t\t\t\t\tpoly_step(ah2, al2, kh2, kl2, nhB1, nhB0);\n\t\t\t#endif\n\t\t#endif\t\t// #if VMAC_BOOL_32BIT\n\t} while (blocksRemainingInWord64);\n\n\t#if VMAC_BOOL_WORD128\n\t\t(polyS+0*4)[0]=word64(a1\u003e\u003e64); (polyS+0*4)[1]=word64(a1);\n\t\tif (T_128BitTag)\n\t\t{\n\t\t\t(polyS+1*4)[0]=word64(a2\u003e\u003e64); (polyS+1*4)[1]=word64(a2);\n\t\t}\n\t#elif !VMAC_BOOL_32BIT\n\t\t(polyS+0*4)[0]=ah1; (polyS+0*4)[1]=al1;\n\t\tif (T_128BitTag)\n\t\t{\n\t\t\t(polyS+1*4)[0]=ah2; (polyS+1*4)[1]=al2;\n\t\t}\n\t#endif\n}\n\ninline void VMAC_Base::VHASH_Update(const word64 *data, size_t blocksRemainingInWord64)\n{\n#if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE \u0026\u0026 CRYPTOPP_BOOL_X86\n\tif (HasSSE2())\n\t{\n\t\tVHASH_Update_SSE2(data, blocksRemainingInWord64, 0);\n\t\tif (m_is128)\n\t\t\tVHASH_Update_SSE2(data, blocksRemainingInWord64, 1);\n\t\tm_isFirstBlock = false;\n\t}\n\telse\n#endif\n\t{\n#if defined(_MSC_VER) \u0026\u0026 _MSC_VER \u003c 1300\n\t\tVHASH_Update_Template(data, blocksRemainingInWord64);\n#else\n\t\tif (m_is128)\n\t\t\tVHASH_Update_Template\u003ctrue\u003e(data, blocksRemainingInWord64);\n\t\telse\n\t\t\tVHASH_Update_Template\u003cfalse\u003e(data, blocksRemainingInWord64);\n#endif\n\t}\n}\n\nsize_t VMAC_Base::HashMultipleBlocks(const word64 *data, size_t length)\n{\n\tsize_t remaining = ModPowerOf2(length, m_L1KeyLength);\n\tVHASH_Update(data, (length-remaining)/8);\n\treturn remaining;\n}\n\nstatic word64 L3Hash(const word64 *input, const word64 *l3Key, size_t len)\n{\n    word64 rh, rl, t, z=0;\n\tword64 p1 = input[0], p2 = input[1];\n\tword64 k1 = l3Key[0], k2 = l3Key[1];\n\n    /* fully reduce (p1,p2)+(len,0) mod p127 */\n    t = p1 \u003e\u003e 63;\n    p1 \u0026= m63;\n    ADD128(p1, p2, len, t);\n    /* At this point, (p1,p2) is at most 2^127+(len\u003c\u003c64) */\n    t = (p1 \u003e m63) + ((p1 == m63) \u0026 (p2 == m64));\n    ADD128(p1, p2, z, t);\n    p1 \u0026= m63;\n\n    /* compute (p1,p2)/(2^64-2^32) and (p1,p2)%(2^64-2^32) */\n    t = p1 + (p2 \u003e\u003e 32);\n    t += (t \u003e\u003e 32);\n    t += (word32)t \u003e 0xfffffffeU;\n    p1 += (t \u003e\u003e 32);\n    p2 += (p1 \u003c\u003c 32);\n\n    /* compute (p1+k1)%p64 and (p2+k2)%p64 */\n    p1 += k1;\n    p1 += (0 - (p1 \u003c k1)) \u0026 257;\n    p2 += k2;\n    p2 += (0 - (p2 \u003c k2)) \u0026 257;\n\n    /* compute (p1+k1)*(p2+k2)%p64 */\n    MUL64(rh, rl, p1, p2);\n    t = rh \u003e\u003e 56;\n    ADD128(t, rl, z, rh);\n    rh \u003c\u003c= 8;\n    ADD128(t, rl, z, rh);\n    t += t \u003c\u003c 8;\n    rl += t;\n    rl += (0 - (rl \u003c t)) \u0026 257;\n    rl += (0 - (rl \u003e p64-1)) \u0026 257;\n    return rl;\n}\n\nvoid VMAC_Base::TruncatedFinal(byte *mac, size_t size)\n{\n\tsize_t len = ModPowerOf2(GetBitCountLo()/8, m_L1KeyLength);\n\n\tif (len)\n\t{\n\t\tmemset(m_data()+len, 0, (0-len)%16);\n\t\tVHASH_Update(DataBuf(), ((len+15)/16)*2);\n\t\tlen *= 8;\t// convert to bits\n\t}\n\telse if (m_isFirstBlock)\n\t{\n\t\t// special case for empty string\n\t\tm_polyState()[0] = m_polyState()[2];\n\t\tm_polyState()[1] = m_polyState()[3];\n\t\tif (m_is128)\n\t\t{\n\t\t\tm_polyState()[4] = m_polyState()[6];\n\t\t\tm_polyState()[5] = m_polyState()[7];\n\t\t}\n\t}\n\n\tif (m_is128)\n\t{\n\t\tword64 t[2];\n\t\tt[0] = L3Hash(m_polyState(), m_l3Key(), len) + GetWord\u003cword64\u003e(true, BIG_ENDIAN_ORDER, m_pad());\n\t\tt[1] = L3Hash(m_polyState()+4, m_l3Key()+2, len) + GetWord\u003cword64\u003e(true, BIG_ENDIAN_ORDER, m_pad()+8);\n\t\tif (size == 16)\n\t\t{\n\t\t\tPutWord(false, BIG_ENDIAN_ORDER, mac, t[0]);\n\t\t\tPutWord(false, BIG_ENDIAN_ORDER, mac+8, t[1]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tt[0] = ConditionalByteReverse(BIG_ENDIAN_ORDER, t[0]);\n\t\t\tt[1] = ConditionalByteReverse(BIG_ENDIAN_ORDER, t[1]);\n\t\t\tmemcpy(mac, t, size);\n\t\t}\n\t}\n\telse\n\t{\n\t\tword64 t = L3Hash(m_polyState(), m_l3Key(), len);\n\t\tt += GetWord\u003cword64\u003e(true, BIG_ENDIAN_ORDER, m_pad() + (m_nonce()[IVSize()-1]\u00261) * 8);\n\t\tif (size == 8)\n\t\t\tPutWord(false, BIG_ENDIAN_ORDER, mac, t);\n\t\telse\n\t\t{\n\t\t\tt = ConditionalByteReverse(BIG_ENDIAN_ORDER, t);\n\t\t\tmemcpy(mac, \u0026t, size);\n\t\t}\n\t}\n}\n\nNAMESPACE_END\n"}
{"repo_name":"omazapa/root-old","ref":"refs/heads/master","path":"interpreter/llvm/src/lib/CodeGen/MachineSSAUpdater.cpp","copies":"33","language":"C++","content":"//===- MachineSSAUpdater.cpp - Unstructured SSA Update Tool ---------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n//\n// This file implements the MachineSSAUpdater class. It's based on SSAUpdater\n// class in lib/Transforms/Utils.\n//\n//===----------------------------------------------------------------------===//\n\n#include \"llvm/CodeGen/MachineSSAUpdater.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/CodeGen/MachineInstr.h\"\n#include \"llvm/CodeGen/MachineInstrBuilder.h\"\n#include \"llvm/CodeGen/MachineRegisterInfo.h\"\n#include \"llvm/Support/AlignOf.h\"\n#include \"llvm/Support/Allocator.h\"\n#include \"llvm/Support/Debug.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include \"llvm/Target/TargetInstrInfo.h\"\n#include \"llvm/Target/TargetRegisterInfo.h\"\n#include \"llvm/Target/TargetSubtargetInfo.h\"\n#include \"llvm/Transforms/Utils/SSAUpdaterImpl.h\"\nusing namespace llvm;\n\n#define DEBUG_TYPE \"machine-ssaupdater\"\n\ntypedef DenseMap\u003cMachineBasicBlock*, unsigned\u003e AvailableValsTy;\nstatic AvailableValsTy \u0026getAvailableVals(void *AV) {\n  return *static_cast\u003cAvailableValsTy*\u003e(AV);\n}\n\nMachineSSAUpdater::MachineSSAUpdater(MachineFunction \u0026MF,\n                                     SmallVectorImpl\u003cMachineInstr*\u003e *NewPHI)\n  : AV(nullptr), InsertedPHIs(NewPHI) {\n  TII = MF.getSubtarget().getInstrInfo();\n  MRI = \u0026MF.getRegInfo();\n}\n\nMachineSSAUpdater::~MachineSSAUpdater() {\n  delete static_cast\u003cAvailableValsTy*\u003e(AV);\n}\n\n/// Initialize - Reset this object to get ready for a new set of SSA\n/// updates.  ProtoValue is the value used to name PHI nodes.\nvoid MachineSSAUpdater::Initialize(unsigned V) {\n  if (!AV)\n    AV = new AvailableValsTy();\n  else\n    getAvailableVals(AV).clear();\n\n  VR = V;\n  VRC = MRI-\u003egetRegClass(VR);\n}\n\n/// HasValueForBlock - Return true if the MachineSSAUpdater already has a value for\n/// the specified block.\nbool MachineSSAUpdater::HasValueForBlock(MachineBasicBlock *BB) const {\n  return getAvailableVals(AV).count(BB);\n}\n\n/// AddAvailableValue - Indicate that a rewritten value is available in the\n/// specified block with the specified value.\nvoid MachineSSAUpdater::AddAvailableValue(MachineBasicBlock *BB, unsigned V) {\n  getAvailableVals(AV)[BB] = V;\n}\n\n/// GetValueAtEndOfBlock - Construct SSA form, materializing a value that is\n/// live at the end of the specified block.\nunsigned MachineSSAUpdater::GetValueAtEndOfBlock(MachineBasicBlock *BB) {\n  return GetValueAtEndOfBlockInternal(BB);\n}\n\nstatic\nunsigned LookForIdenticalPHI(MachineBasicBlock *BB,\n        SmallVectorImpl\u003cstd::pair\u003cMachineBasicBlock*, unsigned\u003e \u003e \u0026PredValues) {\n  if (BB-\u003eempty())\n    return 0;\n\n  MachineBasicBlock::iterator I = BB-\u003ebegin();\n  if (!I-\u003eisPHI())\n    return 0;\n\n  AvailableValsTy AVals;\n  for (unsigned i = 0, e = PredValues.size(); i != e; ++i)\n    AVals[PredValues[i].first] = PredValues[i].second;\n  while (I != BB-\u003eend() \u0026\u0026 I-\u003eisPHI()) {\n    bool Same = true;\n    for (unsigned i = 1, e = I-\u003egetNumOperands(); i != e; i += 2) {\n      unsigned SrcReg = I-\u003egetOperand(i).getReg();\n      MachineBasicBlock *SrcBB = I-\u003egetOperand(i+1).getMBB();\n      if (AVals[SrcBB] != SrcReg) {\n        Same = false;\n        break;\n      }\n    }\n    if (Same)\n      return I-\u003egetOperand(0).getReg();\n    ++I;\n  }\n  return 0;\n}\n\n/// InsertNewDef - Insert an empty PHI or IMPLICIT_DEF instruction which define\n/// a value of the given register class at the start of the specified basic\n/// block. It returns the virtual register defined by the instruction.\nstatic\nMachineInstrBuilder InsertNewDef(unsigned Opcode,\n                           MachineBasicBlock *BB, MachineBasicBlock::iterator I,\n                           const TargetRegisterClass *RC,\n                           MachineRegisterInfo *MRI,\n                           const TargetInstrInfo *TII) {\n  unsigned NewVR = MRI-\u003ecreateVirtualRegister(RC);\n  return BuildMI(*BB, I, DebugLoc(), TII-\u003eget(Opcode), NewVR);\n}\n\n/// GetValueInMiddleOfBlock - Construct SSA form, materializing a value that\n/// is live in the middle of the specified block.\n///\n/// GetValueInMiddleOfBlock is the same as GetValueAtEndOfBlock except in one\n/// important case: if there is a definition of the rewritten value after the\n/// 'use' in BB.  Consider code like this:\n///\n///      X1 = ...\n///   SomeBB:\n///      use(X)\n///      X2 = ...\n///      br Cond, SomeBB, OutBB\n///\n/// In this case, there are two values (X1 and X2) added to the AvailableVals\n/// set by the client of the rewriter, and those values are both live out of\n/// their respective blocks.  However, the use of X happens in the *middle* of\n/// a block.  Because of this, we need to insert a new PHI node in SomeBB to\n/// merge the appropriate values, and this value isn't live out of the block.\n///\nunsigned MachineSSAUpdater::GetValueInMiddleOfBlock(MachineBasicBlock *BB) {\n  // If there is no definition of the renamed variable in this block, just use\n  // GetValueAtEndOfBlock to do our work.\n  if (!HasValueForBlock(BB))\n    return GetValueAtEndOfBlockInternal(BB);\n\n  // If there are no predecessors, just return undef.\n  if (BB-\u003epred_empty()) {\n    // Insert an implicit_def to represent an undef value.\n    MachineInstr *NewDef = InsertNewDef(TargetOpcode::IMPLICIT_DEF,\n                                        BB, BB-\u003egetFirstTerminator(),\n                                        VRC, MRI, TII);\n    return NewDef-\u003egetOperand(0).getReg();\n  }\n\n  // Otherwise, we have the hard case.  Get the live-in values for each\n  // predecessor.\n  SmallVector\u003cstd::pair\u003cMachineBasicBlock*, unsigned\u003e, 8\u003e PredValues;\n  unsigned SingularValue = 0;\n\n  bool isFirstPred = true;\n  for (MachineBasicBlock::pred_iterator PI = BB-\u003epred_begin(),\n         E = BB-\u003epred_end(); PI != E; ++PI) {\n    MachineBasicBlock *PredBB = *PI;\n    unsigned PredVal = GetValueAtEndOfBlockInternal(PredBB);\n    PredValues.push_back(std::make_pair(PredBB, PredVal));\n\n    // Compute SingularValue.\n    if (isFirstPred) {\n      SingularValue = PredVal;\n      isFirstPred = false;\n    } else if (PredVal != SingularValue)\n      SingularValue = 0;\n  }\n\n  // Otherwise, if all the merged values are the same, just use it.\n  if (SingularValue != 0)\n    return SingularValue;\n\n  // If an identical PHI is already in BB, just reuse it.\n  unsigned DupPHI = LookForIdenticalPHI(BB, PredValues);\n  if (DupPHI)\n    return DupPHI;\n\n  // Otherwise, we do need a PHI: insert one now.\n  MachineBasicBlock::iterator Loc = BB-\u003eempty() ? BB-\u003eend() : BB-\u003ebegin();\n  MachineInstrBuilder InsertedPHI = InsertNewDef(TargetOpcode::PHI, BB,\n                                                 Loc, VRC, MRI, TII);\n\n  // Fill in all the predecessors of the PHI.\n  for (unsigned i = 0, e = PredValues.size(); i != e; ++i)\n    InsertedPHI.addReg(PredValues[i].second).addMBB(PredValues[i].first);\n\n  // See if the PHI node can be merged to a single value.  This can happen in\n  // loop cases when we get a PHI of itself and one other value.\n  if (unsigned ConstVal = InsertedPHI-\u003eisConstantValuePHI()) {\n    InsertedPHI-\u003eeraseFromParent();\n    return ConstVal;\n  }\n\n  // If the client wants to know about all new instructions, tell it.\n  if (InsertedPHIs) InsertedPHIs-\u003epush_back(InsertedPHI);\n\n  DEBUG(dbgs() \u003c\u003c \"  Inserted PHI: \" \u003c\u003c *InsertedPHI \u003c\u003c \"\\n\");\n  return InsertedPHI-\u003egetOperand(0).getReg();\n}\n\nstatic\nMachineBasicBlock *findCorrespondingPred(const MachineInstr *MI,\n                                         MachineOperand *U) {\n  for (unsigned i = 1, e = MI-\u003egetNumOperands(); i != e; i += 2) {\n    if (\u0026MI-\u003egetOperand(i) == U)\n      return MI-\u003egetOperand(i+1).getMBB();\n  }\n\n  llvm_unreachable(\"MachineOperand::getParent() failure?\");\n}\n\n/// RewriteUse - Rewrite a use of the symbolic value.  This handles PHI nodes,\n/// which use their value in the corresponding predecessor.\nvoid MachineSSAUpdater::RewriteUse(MachineOperand \u0026U) {\n  MachineInstr *UseMI = U.getParent();\n  unsigned NewVR = 0;\n  if (UseMI-\u003eisPHI()) {\n    MachineBasicBlock *SourceBB = findCorrespondingPred(UseMI, \u0026U);\n    NewVR = GetValueAtEndOfBlockInternal(SourceBB);\n  } else {\n    NewVR = GetValueInMiddleOfBlock(UseMI-\u003egetParent());\n  }\n\n  U.setReg(NewVR);\n}\n\n/// SSAUpdaterTraits\u003cMachineSSAUpdater\u003e - Traits for the SSAUpdaterImpl\n/// template, specialized for MachineSSAUpdater.\nnamespace llvm {\ntemplate\u003c\u003e\nclass SSAUpdaterTraits\u003cMachineSSAUpdater\u003e {\npublic:\n  typedef MachineBasicBlock BlkT;\n  typedef unsigned ValT;\n  typedef MachineInstr PhiT;\n\n  typedef MachineBasicBlock::succ_iterator BlkSucc_iterator;\n  static BlkSucc_iterator BlkSucc_begin(BlkT *BB) { return BB-\u003esucc_begin(); }\n  static BlkSucc_iterator BlkSucc_end(BlkT *BB) { return BB-\u003esucc_end(); }\n\n  /// Iterator for PHI operands.\n  class PHI_iterator {\n  private:\n    MachineInstr *PHI;\n    unsigned idx;\n \n  public:\n    explicit PHI_iterator(MachineInstr *P) // begin iterator\n      : PHI(P), idx(1) {}\n    PHI_iterator(MachineInstr *P, bool) // end iterator\n      : PHI(P), idx(PHI-\u003egetNumOperands()) {}\n\n    PHI_iterator \u0026operator++() { idx += 2; return *this; } \n    bool operator==(const PHI_iterator\u0026 x) const { return idx == x.idx; }\n    bool operator!=(const PHI_iterator\u0026 x) const { return !operator==(x); }\n    unsigned getIncomingValue() { return PHI-\u003egetOperand(idx).getReg(); }\n    MachineBasicBlock *getIncomingBlock() {\n      return PHI-\u003egetOperand(idx+1).getMBB();\n    }\n  };\n  static inline PHI_iterator PHI_begin(PhiT *PHI) { return PHI_iterator(PHI); }\n  static inline PHI_iterator PHI_end(PhiT *PHI) {\n    return PHI_iterator(PHI, true);\n  }\n\n  /// FindPredecessorBlocks - Put the predecessors of BB into the Preds\n  /// vector.\n  static void FindPredecessorBlocks(MachineBasicBlock *BB,\n                                    SmallVectorImpl\u003cMachineBasicBlock*\u003e *Preds){\n    for (MachineBasicBlock::pred_iterator PI = BB-\u003epred_begin(),\n           E = BB-\u003epred_end(); PI != E; ++PI)\n      Preds-\u003epush_back(*PI);\n  }\n\n  /// GetUndefVal - Create an IMPLICIT_DEF instruction with a new register.\n  /// Add it into the specified block and return the register.\n  static unsigned GetUndefVal(MachineBasicBlock *BB,\n                              MachineSSAUpdater *Updater) {\n    // Insert an implicit_def to represent an undef value.\n    MachineInstr *NewDef = InsertNewDef(TargetOpcode::IMPLICIT_DEF,\n                                        BB, BB-\u003egetFirstTerminator(),\n                                        Updater-\u003eVRC, Updater-\u003eMRI,\n                                        Updater-\u003eTII);\n    return NewDef-\u003egetOperand(0).getReg();\n  }\n\n  /// CreateEmptyPHI - Create a PHI instruction that defines a new register.\n  /// Add it into the specified block and return the register.\n  static unsigned CreateEmptyPHI(MachineBasicBlock *BB, unsigned NumPreds,\n                                 MachineSSAUpdater *Updater) {\n    MachineBasicBlock::iterator Loc = BB-\u003eempty() ? BB-\u003eend() : BB-\u003ebegin();\n    MachineInstr *PHI = InsertNewDef(TargetOpcode::PHI, BB, Loc,\n                                     Updater-\u003eVRC, Updater-\u003eMRI,\n                                     Updater-\u003eTII);\n    return PHI-\u003egetOperand(0).getReg();\n  }\n\n  /// AddPHIOperand - Add the specified value as an operand of the PHI for\n  /// the specified predecessor block.\n  static void AddPHIOperand(MachineInstr *PHI, unsigned Val,\n                            MachineBasicBlock *Pred) {\n    MachineInstrBuilder(*Pred-\u003egetParent(), PHI).addReg(Val).addMBB(Pred);\n  }\n\n  /// InstrIsPHI - Check if an instruction is a PHI.\n  ///\n  static MachineInstr *InstrIsPHI(MachineInstr *I) {\n    if (I \u0026\u0026 I-\u003eisPHI())\n      return I;\n    return nullptr;\n  }\n\n  /// ValueIsPHI - Check if the instruction that defines the specified register\n  /// is a PHI instruction.\n  static MachineInstr *ValueIsPHI(unsigned Val, MachineSSAUpdater *Updater) {\n    return InstrIsPHI(Updater-\u003eMRI-\u003egetVRegDef(Val));\n  }\n\n  /// ValueIsNewPHI - Like ValueIsPHI but also check if the PHI has no source\n  /// operands, i.e., it was just added.\n  static MachineInstr *ValueIsNewPHI(unsigned Val, MachineSSAUpdater *Updater) {\n    MachineInstr *PHI = ValueIsPHI(Val, Updater);\n    if (PHI \u0026\u0026 PHI-\u003egetNumOperands() \u003c= 1)\n      return PHI;\n    return nullptr;\n  }\n\n  /// GetPHIValue - For the specified PHI instruction, return the register\n  /// that it defines.\n  static unsigned GetPHIValue(MachineInstr *PHI) {\n    return PHI-\u003egetOperand(0).getReg();\n  }\n};\n\n} // End llvm namespace\n\n/// GetValueAtEndOfBlockInternal - Check to see if AvailableVals has an entry\n/// for the specified BB and if so, return it.  If not, construct SSA form by\n/// first calculating the required placement of PHIs and then inserting new\n/// PHIs where needed.\nunsigned MachineSSAUpdater::GetValueAtEndOfBlockInternal(MachineBasicBlock *BB){\n  AvailableValsTy \u0026AvailableVals = getAvailableVals(AV);\n  if (unsigned V = AvailableVals[BB])\n    return V;\n\n  SSAUpdaterImpl\u003cMachineSSAUpdater\u003e Impl(this, \u0026AvailableVals, InsertedPHIs);\n  return Impl.GetValue(BB);\n}\n"}
{"repo_name":"grzegorz2047/HotelReservation","ref":"refs/heads/master","path":"fileio.cpp","copies":"1","language":"C++","content":"#include \u003cstdio.h\u003e\n#include \u003cstring\u003e\n#include \u003cstdlib.h\u003e\n#include \u003ctime.h\u003e\n#include \u003csstream\u003e\n#include \u003cfstream\u003e\n#include \u003cvector\u003e\n#include \u003ciostream\u003e\n\n    std::vector\u003cstd::string\u003e readFile(std::string filename){\n        std::vector\u003cstd::string\u003e lines;\n        std::ifstream read;\n        std::string line;\n        read.open(filename.c_str());\n        if(!read.good()){\n            read.close();\n            std::ofstream create;\n            create.open(filename.c_str());\n            return lines;\n        }\n        while(!read.eof()){\n            getline(read, line);\n            if(line != \"\"){\n                //std::cout\u003c\u003c\"Wczytano \"\u003c\u003cline\u003c\u003cstd::endl;\n                lines.push_back(line);\n            }\n        }\n        read.close();\n        return lines;\n    }\n    void saveFile(std::string filename, std::vector\u003cstd::string\u003e lines){\n        std::ofstream save;\n        save.open(filename.c_str());\n        for(int i = 0; i \u003c lines.size(); i ++){\n            save \u003c\u003c lines[i] \u003c\u003cstd::endl;\n        }\n        save.close();\n    }\n"}
{"repo_name":"whc10002/study","ref":"refs/heads/master","path":"libcds/test/unit/striped-map/map_boost_flat_map.cpp","copies":"1","language":"C++","content":"/*\n    This file is a part of libcds - Concurrent Data Structures library\n\n    (C) Copyright Maxim Khizhinsky (libcds.dev@gmail.com) 2006-2017\n\n    Source code repo: http://github.com/khizmax/libcds/\n    Download: http://sourceforge.net/projects/libcds/files/\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright notice, this\n      list of conditions and the following disclaimer.\n\n    * Redistributions in binary form must reproduce the above copyright notice,\n      this list of conditions and the following disclaimer in the documentation\n      and/or other materials provided with the distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n    AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n    DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n    FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n    DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n    SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n    CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n    OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n#ifdef CDSUNIT_ENABLE_BOOST_CONTAINER\n\n#include \u003cboost/version.hpp\u003e\n#include \u003ccds/details/defs.h\u003e\n#if CDS_COMPILER == CDS_COMPILER_MSVC \u0026\u0026 CDS_COMPILER_VERSION == CDS_COMPILER_MSVC12 \u0026\u0026 BOOST_VERSION \u003c 105500\n    // Skipped; for Microsoft Visual C++ 2013 and boost::container::flat_map you should use boost version 1.55 or above\" );\n#elif BOOST_VERSION \u003e= 104800\n\n#include \u003ccds/container/striped_map/boost_flat_map.h\u003e\n#include \"test_striped_map.h\"\n\nnamespace {\n    struct test_traits\n    {\n        typedef boost::container::flat_map\u003c\n            cds_test::striped_map_fixture::key_type,\n            cds_test::striped_map_fixture::value_type,\n            cds_test::striped_map_fixture::less\n        \u003e container_type;\n\n        struct copy_policy {\n            typedef container_type::iterator iterator;\n\n            void operator()( container_type\u0026 m, iterator /*itInsert*/, iterator itWhat )\n            {\n                m.insert( *itWhat );\n            }\n        };\n\n        static bool const c_hasFindWith = false;\n        static bool const c_hasEraseWith = false;\n    };\n\n    INSTANTIATE_TYPED_TEST_CASE_P( BoostFlatMap, StripedMap, test_traits );\n    INSTANTIATE_TYPED_TEST_CASE_P( BoostFlatMap, RefinableMap, test_traits );\n\n} // namespace\n\n#else // BOOST_VERSION \u003c 104800\n// Skipped; for boost::container::flat_map you should use boost version 1.48 or above\n#endif  // BOOST_VERSION\n\n#endif // #ifdef CDSUNIT_ENABLE_BOOST_CONTAINER\n"}
{"repo_name":"braindx/scummvm","ref":"refs/heads/master","path":"engines/titanic/gfx/icon_nav_receive.cpp","copies":"33","language":"C++","content":"/* ScummVM - Graphic Adventure Engine\n *\n * ScummVM is the legal property of its developers, whose names\n * are too numerous to list here. Please refer to the COPYRIGHT\n * file distributed with this source distribution.\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n *\n */\n\n#include \"titanic/gfx/icon_nav_receive.h\"\n\nnamespace Titanic {\n\nEMPTY_MESSAGE_MAP(CIconNavReceive, CPetGraphic);\n\nvoid CIconNavReceive::save(SimpleFile *file, int indent) {\n\tfile-\u003ewriteNumberLine(1, indent);\n\tCPetGraphic::save(file, indent);\n}\n\nvoid CIconNavReceive::load(SimpleFile *file) {\n\tfile-\u003ereadNumber();\n\tCPetGraphic::load(file);\n}\n\n} // End of namespace Titanic\n"}
{"repo_name":"AdmiralCurtiss/ppsspp","ref":"refs/heads/master","path":"unittest/UnitTest.cpp","copies":"9","language":"C++","content":"// Copyright (c) 2012- PPSSPP Project.\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, version 2.0 or later versions.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License 2.0 for more details.\n\n// A copy of the GPL 2.0 should have been included with the program.\n// If not, see http://www.gnu.org/licenses/\n\n// Official git repository and contact information can be found at\n// https://github.com/hrydgard/ppsspp and http://www.ppsspp.org/.\n\n// UnitTests\n//\n// This is a program to directly test various functions, without going\n// through a PSP. Especially useful for things like opcode emitters,\n// hashes, and various data conversion utility function.\n//\n// TODO: Make a test of nice unittest asserts and count successes etc.\n// Or just integrate with an existing testing framework.\n\n\n#include \u003ccstdio\u003e\n#include \u003ccstdlib\u003e\n#include \u003ccmath\u003e\n#include \u003cstring\u003e\n#include \u003csstream\u003e\n\n#include \"base/NativeApp.h\"\n#include \"base/logging.h\"\n#include \"Common/CPUDetect.h\"\n#include \"Common/ArmEmitter.h\"\n#include \"ext/disarm.h\"\n#include \"math/math_util.h\"\n#include \"util/text/parsers.h\"\n#include \"Core/Config.h\"\n#include \"Core/MIPS/MIPSVFPUUtils.h\"\n#include \"Core/FileSystems/ISOFileSystem.h\"\n\n#include \"unittest/JitHarness.h\"\n#include \"unittest/TestVertexJit.h\"\n#include \"unittest/UnitTest.h\"\n\nstd::string System_GetProperty(SystemProperty prop) { return \"\"; }\nint System_GetPropertyInt(SystemProperty prop) { return -1; }\nvoid NativeMessageReceived(const char *message, const char *value) {}\nvoid GL_SwapInterval(int) {}\n\n#ifndef M_PI_2\n#define M_PI_2     1.57079632679489661923\n#endif\n\n// asin acos atan: https://github.com/michaldrobot/ShaderFastLibs/blob/master/ShaderFastMathLib.h\n\n// TODO:\n// Fast approximate sincos for NEON\n// http://blog.julien.cayzac.name/2009/12/fast-sinecosine-for-armv7neon.html\n// Fast sincos\n// http://www.dspguru.com/dsp/tricks/parabolic-approximation-of-sin-and-cos\n\n// minimax (surprisingly terrible! something must be wrong)\n// double asin_plus_sqrtthing = .9998421793 + (1.012386649 + (-.6575341673 + .8999841642 + (-1.669668977 + (1.571945105 - .5860008052 * x) * x) * x) * x) * x;\n\n// VERY good. 6 MAD, one division.\n// double asin_plus_sqrtthing = (1.807607311 + (.191900116 + (-2.511278506 + (1.062519236 + (-.3572142480 + .1087063463 * x) * x) * x) * x) * x) / (1.807601897 - 1.615203794 * x);\n// float asin_plus_sqrtthing_correct_ends =\n// \t(1.807607311f + (.191900116f + (-2.511278506f + (1.062519236f + (-.3572142480f + .1087063463f * x) * x) * x) * x) * x) / (1.807607311f - 1.615195094 * x);\n\n// Unfortunately this is very serial.\n// At least there are only 8 constants needed - load them into two low quads and go to town.\n// For every step, VDUP the constant into a new register (out of two alternating), then VMLA or VFMA into it.\n\n// http://www.ecse.rpi.edu/~wrf/Research/Short_Notes/arcsin/\n// minimax polynomial rational approx, pretty good, get four digits consistently.\n// unfortunately fastasin(1.0) / M_PI_2  != 1.0f, but it's pretty close.\nfloat fastasin(double x) {\n\tfloat sign = x \u003e= 0.0f ? 1.0f : -1.0f;\n\tx = fabs(x);\n\tfloat sqrtthing = sqrt(1.0f - x * x);\n\t// note that the sqrt can run parallel while we do the rest\n\t// if the hardware supports it\n\n\tfloat y = -.3572142480f + .1087063463f * x;\n\ty = y * x + 1.062519236f;\n\ty = y * x + -2.511278506f;\n\ty = y * x + .191900116f;\n\ty = y * x + 1.807607311f;\n\ty /= (1.807607311f - 1.615195094 * x);\n\treturn sign * (y - sqrtthing);\n}\n\ndouble atan_66s(double x) {\n\tconst double c1=1.6867629106;\n\tconst double c2=0.4378497304;\n\tconst double c3=1.6867633134;\n\n\tdouble x2; // The input argument squared\n\n\tx2 = x * x;\n\treturn (x*(c1 + x2*c2)/(c3 + x2));\n}\n\n// Terrible.\ndouble fastasin2(double x) {\n\treturn atan_66s(x / sqrt(1 - x * x));\n}\n\n// Also terrible.\nfloat fastasin3(float x) {\n\treturn x + x * x * x * x * x * 0.4971;\n}\n\n// Great! This is the one we'll use. Can be easily rescaled to get the right range for free.\n// http://mathforum.org/library/drmath/view/54137.html\n// http://www.musicdsp.org/showone.php?id=115\nfloat fastasin4(float x) {\n\tfloat sign = x \u003e= 0.0f ? 1.0f : -1.0f;\n\tx = fabs(x);\n\tx = M_PI/2 - sqrtf(1.0f - x) * (1.5707288 + -0.2121144*x + 0.0742610*x*x + -0.0187293*x*x*x);\n\treturn sign * x;\n}\n\n// Or this:\nfloat fastasin5(float x)\n{\n\tfloat sign = x \u003e= 0.0f ? 1.0f : -1.0f;\n\tx = fabs(x);\n\tfloat fRoot = sqrtf(1.0f - x);\n\tfloat fResult = 0.0742610f + -0.0187293f  * x;\n\tfResult = -0.2121144f + fResult * x;\n\tfResult = 1.5707288f + fResult * x;\n\tfResult = M_PI/2 - fRoot*fResult;\n\treturn sign * fResult;\n}\n\n\n// This one is unfortunately not very good. But lets us avoid PI entirely\n// thanks to the special arguments of the PSP functions.\n// http://www.dspguru.com/dsp/tricks/parabolic-approximation-of-sin-and-cos\n#define C            0.70710678118654752440f    // 1.0f / sqrt(2.0f)\n// Some useful constants (PI and \u003cmath.h\u003e are not part of algo)\n#define BITSPERQUARTER (20)\nvoid fcs(float angle, float \u0026sinout, float \u0026cosout) {\n\tint phasein = angle * (1 \u003c\u003c BITSPERQUARTER);\n\t// Modulo phase into quarter, convert to float 0..1\n\tfloat modphase = (phasein \u0026 ((1\u003c\u003cBITSPERQUARTER)-1)) * (1.0f / (1\u003c\u003cBITSPERQUARTER));\n\t// Extract quarter bits \n\tint quarter = phasein \u003e\u003e BITSPERQUARTER;\n\t// Recognize quarter\n\tif (!quarter) {\n\t\t// First quarter, angle = 0 .. pi/2\n\t\tfloat x = modphase - 0.5f;      // 1 sub\n\t\tfloat temp = (2 - 4*C)*x*x + C; // 2 mul, 1 add\n\t\tsinout = temp + x;              // 1 add\n\t\tcosout = temp - x;              // 1 sub\n\t} else if (quarter == 1) {\n\t\t// Second quarter, angle = pi/2 .. pi\n\t\tfloat x = 0.5f - modphase;      // 1 sub\n\t\tfloat temp = (2 - 4*C)*x*x + C; // 2 mul, 1 add\n\t\tsinout = x + temp;              // 1 add\n\t\tcosout = x - temp;              // 1 sub\n\t} else if (quarter == 2) {\n\t\t// Third quarter, angle = pi .. 1.5pi\n\t\tfloat x = modphase - 0.5f;      // 1 sub\n\t\tfloat temp = (4*C - 2)*x*x - C; // 2 mul, 1 sub\n\t\tsinout = temp - x;              // 1 sub\n\t\tcosout = temp + x;              // 1 add\n\t} else if (quarter == 3) {\n\t\t// Fourth quarter, angle = 1.5pi..2pi\n\t\tfloat x = modphase - 0.5f;      // 1 sub\n\t\tfloat temp = (2 - 4*C)*x*x + C; // 2 mul, 1 add\n\t\tsinout = x - temp;              // 1 sub\n\t\tcosout = x + temp;              // 1 add\n\t}\n}\n#undef C\n\n\nconst float PI_SQR      = 9.86960440108935861883449099987615114f;\n\n//https://code.google.com/p/math-neon/source/browse/trunk/math_floorf.c?r=18\n// About 2 correct decimals. Not great.\nvoid fcs2(float theta, float \u0026outsine, float \u0026outcosine) {\n\tfloat gamma = theta + 1;\n\tgamma += 2;\n\tgamma /= 4;\n\ttheta += 2;\n\ttheta /= 4;\n\t//theta -= (float)(int)theta;\n\t//gamma -= (float)(int)gamma;\n\ttheta -= floorf(theta);\n\tgamma -= floorf(gamma);\n\ttheta *= 4;\n\ttheta -= 2;\n\tgamma *= 4;\n\tgamma -= 2;\n\n\tfloat x = 2 * gamma - gamma * fabs(gamma);\n\tfloat y = 2 * theta - theta * fabs(theta);\n\tconst float P = 0.225;\n\toutsine = P * (y * fabsf(y) - y) + y;   // Q * y + P * y * abs(y)\n\toutcosine = P * (x * fabsf(x) - x) + x;   // Q * y + P * y * abs(y)\n}\n\n\n\nvoid fastsincos(float x, float \u0026sine, float \u0026cosine) {\n\tfcs2(x, sine, cosine);\n}\n\nbool TestSinCos() {\n\tfor (int i = -100; i \u003c= 100; i++) {\n\t\tfloat f = i / 30.0f;\n\n\t\t// The PSP sin/cos take as argument angle * M_PI_2.\n\t\t// We need to match that.\n\t\tfloat slowsin = sinf(f * M_PI_2), slowcos = cosf(f * M_PI_2);\n\t\tfloat fastsin, fastcos;\n\t\tfastsincos(f, fastsin, fastcos);\n\t\tprintf(\"%f: slow: %0.8f, %0.8f fast: %0.8f, %0.8f\\n\", f, slowsin, slowcos, fastsin, fastcos);\n\t}\n\treturn true;\n}\n\n\nbool TestAsin() {\n\tfor (int i = -100; i \u003c= 100; i++) {\n\t\tfloat f = i / 100.0f;\n\t\tfloat slowval = asinf(f) / M_PI_2;\n\t\tfloat fastval = fastasin5(f) / M_PI_2;\n\t\tprintf(\"slow: %0.16f fast: %0.16f\\n\", slowval, fastval);\n\t\tfloat diff = fabsf(slowval - fastval);\n\t\t// EXPECT_TRUE(diff \u003c 0.0001f);\n\t}\n\t// EXPECT_TRUE(fastasin(1.0) / M_PI_2 \u003c= 1.0f);\n\treturn true;\n}\n\nbool TestMathUtil() {\n\tEXPECT_FALSE(my_isinf(1.0));\n\tvolatile float zero = 0.0f;\n\tEXPECT_TRUE(my_isinf(1.0f/zero));\n\tEXPECT_FALSE(my_isnan(1.0f/zero));\n\treturn true;\n}\n\nbool TestParsers() {\n\tconst char *macstr = \"01:02:03:ff:fe:fd\";\n\tuint8_t mac[6];\n\tParseMacAddress(macstr, mac);\n\tEXPECT_TRUE(mac[0] == 1);\n\tEXPECT_TRUE(mac[1] == 2);\n\tEXPECT_TRUE(mac[2] == 3);\n\tEXPECT_TRUE(mac[3] == 255);\n\tEXPECT_TRUE(mac[4] == 254);\n\tEXPECT_TRUE(mac[5] == 253);\n\treturn true;\n}\n\nbool TestVFPUSinCos() {\n\tfloat sine, cosine;\n\tvfpu_sincos(0.0f, sine, cosine);\n\tEXPECT_EQ_FLOAT(sine, 0.0f);\n\tEXPECT_EQ_FLOAT(cosine, 1.0f);\n\tvfpu_sincos(1.0f, sine, cosine);\n\tEXPECT_APPROX_EQ_FLOAT(sine, 1.0f);\n\tEXPECT_APPROX_EQ_FLOAT(cosine, 0.0f);\n\tvfpu_sincos(2.0f, sine, cosine);\n\tEXPECT_APPROX_EQ_FLOAT(sine, 0.0f);\n\tEXPECT_APPROX_EQ_FLOAT(cosine, -1.0f);\n\tvfpu_sincos(3.0f, sine, cosine);\n\tEXPECT_APPROX_EQ_FLOAT(sine, -1.0f);\n\tEXPECT_APPROX_EQ_FLOAT(cosine, 0.0f);\n\tvfpu_sincos(4.0f, sine, cosine);\n\tEXPECT_EQ_FLOAT(sine, 0.0f);\n\tEXPECT_EQ_FLOAT(cosine, 1.0f);\n\tvfpu_sincos(5.0f, sine, cosine);\n\tEXPECT_APPROX_EQ_FLOAT(sine, 1.0f);\n\tEXPECT_APPROX_EQ_FLOAT(cosine, 0.0f);\n\n\tfor (float angle = -10.0f; angle \u003c 10.0f; angle++) {\n\t\tvfpu_sincos(angle, sine, cosine);\n\t\tEXPECT_APPROX_EQ_FLOAT(sine, sinf(angle * M_PI_2));\n\t\tEXPECT_APPROX_EQ_FLOAT(cosine, cosf(angle * M_PI_2));\n\t}\n\treturn true;\n}\n\nbool TestMatrixTranspose() {\n\tMatrixSize sz = M_4x4;\n\tint matrix = 0;  // M000\n\tu8 cols[4];\n\tu8 rows[4];\n\n\tGetMatrixColumns(matrix, sz, cols);\n\tGetMatrixRows(matrix, sz, rows);\n\n\tint transposed = Xpose(matrix);\n\tu8 x_cols[4];\n\tu8 x_rows[4];\n\n\tGetMatrixColumns(transposed, sz, x_cols);\n\tGetMatrixRows(transposed, sz, x_rows);\n\n\tfor (int i = 0; i \u003c GetMatrixSide(sz); i++) {\n\t\tEXPECT_EQ_INT(cols[i], x_rows[i]);\n\t\tEXPECT_EQ_INT(x_cols[i], rows[i]);\n\t}\n\treturn true;\n}\n\nvoid TestGetMatrix(int matrix, MatrixSize sz) {\n\tILOG(\"Testing matrix %s\", GetMatrixNotation(matrix, sz));\n\tu8 fullMatrix[16];\n\n\tu8 cols[4];\n\tu8 rows[4];\n\n\tGetMatrixColumns(matrix, sz, cols);\n\tGetMatrixRows(matrix, sz, rows);\n\n\tGetMatrixRegs(fullMatrix, sz, matrix);\n\n\tint n = GetMatrixSide(sz);\n\tVectorSize vsz = GetVectorSize(sz);\n\tfor (int i = 0; i \u003c n; i++) {\n\t\t// int colName = GetColumnName(matrix, sz, i, 0);\n\t\t// int rowName = GetRowName(matrix, sz, i, 0);\n\t\tint colName = cols[i];\n\t\tint rowName = rows[i];\n\t\tILOG(\"Column %i: %s\", i, GetVectorNotation(colName, vsz));\n\t\tILOG(\"Row %i: %s\", i, GetVectorNotation(rowName, vsz));\n\n\t\tu8 colRegs[4];\n\t\tu8 rowRegs[4];\n\t\tGetVectorRegs(colRegs, vsz, colName);\n\t\tGetVectorRegs(rowRegs, vsz, rowName);\n\n\t\t// Check that the individual regs are the expected ones.\n\t\tstd::stringstream a, b, c, d;\n\t\tfor (int j = 0; j \u003c n; j++) {\n\t\t\ta.clear();\n\t\t\tb.clear();\n\t\t\ta \u003c\u003c (int)fullMatrix[i * 4 + j] \u003c\u003c \" \";\n\t\t\tb \u003c\u003c (int)colRegs[j] \u003c\u003c \" \";\n\n\t\t\tc.clear();\n\t\t\td.clear();\n\n\t\t\tc \u003c\u003c (int)fullMatrix[j * 4 + i] \u003c\u003c \" \";\n\t\t\td \u003c\u003c (int)rowRegs[j] \u003c\u003c \" \";\n\t\t}\n\t\tILOG(\"Col: %s vs %s\", a.str().c_str(), b.str().c_str());\n\t\tif (a.str() != b.str())\n\t\t\tILOG(\"WRONG!\");\n\t\tILOG(\"Row: %s vs %s\", c.str().c_str(), d.str().c_str());\n\t\tif (c.str() != d.str())\n\t\t\tILOG(\"WRONG!\");\n\t}\n}\n\nbool TestParseLBN() {\n\tconst char *validStrings[] = {\n\t\t\"/sce_lbn0x5fa0_size0x1428\",\n\t\t\"/sce_lbn7050_sizeee850\",\n\t\t\"/sce_lbn0x5eeeh_size0x234x\",  // Check for trailing chars. See #7960.\n\t\t\"/sce_lbneee__size434.\",  // Check for trailing chars. See #7960.\n\t};\n\tint expectedResults[][2] = {\n\t\t{0x5fa0, 0x1428},\n\t\t{0x7050, 0xee850},\n\t\t{0x5eee, 0x234},\n\t\t{0xeee,  0x434},\n\t};\n\tconst char *invalidStrings[] = {\n\t\t\"/sce_lbn0x5fa0_sze0x1428\",\n\t\t\"\",\n\t\t\"//\",\n\t};\n\tfor (int i = 0; i \u003c ARRAY_SIZE(validStrings); i++) {\n\t\tu32 startSector = 0, readSize = 0;\n\t\t// printf(\"testing %s\\n\", validStrings[i]);\n\t\tEXPECT_TRUE(parseLBN(validStrings[i], \u0026startSector, \u0026readSize));\n\t\tEXPECT_EQ_INT(startSector, expectedResults[i][0]);\n\t\tEXPECT_EQ_INT(readSize, expectedResults[i][1]);\n\t}\n\tfor (int i = 0; i \u003c ARRAY_SIZE(invalidStrings); i++) {\n\t\tu32 startSector, readSize;\n\t\tEXPECT_FALSE(parseLBN(invalidStrings[i], \u0026startSector, \u0026readSize));\n\t}\n\treturn true;\n}\n\ntypedef bool (*TestFunc)();\nstruct TestItem {\n\tconst char *name;\n\tTestFunc func;\n};\n\n#define TEST_ITEM(name) { #name, \u0026Test ##name, }\n\nbool TestArmEmitter();\nbool TestArm64Emitter();\nbool TestX64Emitter();\n\nTestItem availableTests[] = {\n#if defined(ARM64) || defined(_M_X64) || defined(_M_IX86)\n\tTEST_ITEM(Arm64Emitter),\n#endif\n#if defined(ARM) || defined(_M_X64) || defined(_M_IX86)\n\tTEST_ITEM(ArmEmitter),\n#endif\n#if defined(_M_X64) || defined(_M_IX86)\n\tTEST_ITEM(X64Emitter),\n#endif\n\tTEST_ITEM(VertexJit),\n\tTEST_ITEM(Asin),\n\tTEST_ITEM(SinCos),\n\tTEST_ITEM(VFPUSinCos),\n\tTEST_ITEM(MathUtil),\n\tTEST_ITEM(Parsers),\n\tTEST_ITEM(Jit),\n\tTEST_ITEM(MatrixTranspose),\n\tTEST_ITEM(ParseLBN),\n};\n\nint main(int argc, const char *argv[]) {\n\tcpu_info.bNEON = true;\n\tcpu_info.bVFP = true;\n\tcpu_info.bVFPv3 = true;\n\tcpu_info.bVFPv4 = true;\n\tg_Config.bEnableLogging = true;\n\n\tbool allTests = false;\n\tTestFunc testFunc = nullptr;\n\tif (argc \u003e= 2) {\n\t\tif (!strcasecmp(argv[1], \"all\")) {\n\t\t\tallTests = true;\n\t\t}\n\t\tfor (auto f : availableTests) {\n\t\t\tif (!strcasecmp(argv[1], f.name)) {\n\t\t\t\ttestFunc = f.func;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (allTests) {\n\t\tint passes = 0;\n\t\tint fails = 0;\n\t\tfor (auto f : availableTests) {\n\t\t\tif (f.func()) {\n\t\t\t\t++passes;\n\t\t\t} else {\n\t\t\t\tprintf(\"%s: FAILED\\n\", f.name);\n\t\t\t\t++fails;\n\t\t\t}\n\t\t}\n\t\tif (passes \u003e 0) {\n\t\t\tprintf(\"%d tests passed.\\n\", passes);\n\t\t}\n\t\tif (fails \u003e 0) {\n\t\t\treturn 2;\n\t\t}\n\t} else if (testFunc == nullptr) {\n\t\tfprintf(stderr, \"You may select a test to run by passing an argument.\\n\");\n\t\tfprintf(stderr, \"\\n\");\n\t\tfprintf(stderr, \"Available tests:\\n\");\n\t\tfor (auto f : availableTests) {\n\t\t\tfprintf(stderr, \"  * %s\\n\", f.name);\n\t\t}\n\t\treturn 1;\n\t} else {\n\t\tif (!testFunc()) {\n\t\t\treturn 2;\n\t\t}\n\t}\n\n\treturn 0;\n}\n"}
{"repo_name":"makhdumi/robomongo","ref":"refs/heads/master","path":"src/third-party/mongodb/src/mongo/db/pipeline/accumulator.cpp","copies":"12","language":"C++","content":"/**\n * Copyright (c) 2011 10gen Inc.\n *\n * This program is free software: you can redistribute it and/or  modify\n * it under the terms of the GNU Affero General Public License, version 3,\n * as published by the Free Software Foundation.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see \u003chttp://www.gnu.org/licenses/\u003e.\n */\n\n#include \"pch.h\"\n#include \"db/pipeline/accumulator.h\"\n\n#include \"db/jsobj.h\"\n#include \"util/mongoutils/str.h\"\n\nnamespace mongo {\n    using namespace mongoutils;\n\n    void Accumulator::addOperand(\n        const intrusive_ptr\u003cExpression\u003e \u0026pExpression) {\n        uassert(15943, str::stream() \u003c\u003c \"group accumulator \" \u003c\u003c\n                getOpName() \u003c\u003c \" only accepts one operand\",\n                vpOperand.size() \u003c 1);\n        \n        ExpressionNary::addOperand(pExpression);\n    }\n\n    Accumulator::Accumulator():\n        ExpressionNary() {\n    }\n\n    void Accumulator::opToBson(BSONObjBuilder *pBuilder, StringData opName,\n                               StringData fieldName, bool requireExpression) const {\n        verify(vpOperand.size() == 1);\n        BSONObjBuilder builder;\n        vpOperand[0]-\u003eaddToBsonObj(\u0026builder, opName, requireExpression);\n        pBuilder-\u003eappend(fieldName, builder.done());\n    }\n\n    void Accumulator::addToBsonObj(BSONObjBuilder *pBuilder,\n                                   StringData fieldName,\n                                   bool requireExpression) const {\n        opToBson(pBuilder, getOpName(), fieldName, requireExpression);\n    }\n\n    void Accumulator::addToBsonArray(BSONArrayBuilder *pBuilder) const {\n        verify(false); // these can't appear in arrays\n    }\n\n    void agg_framework_reservedErrors() {\n        uassert(16030, \"reserved error\", false);\n        uassert(16031, \"reserved error\", false);\n        uassert(16032, \"reserved error\", false);\n        uassert(16033, \"reserved error\", false);\n\n        uassert(16036, \"reserved error\", false);\n        uassert(16037, \"reserved error\", false);\n        uassert(16038, \"reserved error\", false);\n        uassert(16039, \"reserved error\", false);\n        uassert(16040, \"reserved error\", false);\n        uassert(16041, \"reserved error\", false);\n        uassert(16042, \"reserved error\", false);\n        uassert(16043, \"reserved error\", false);\n        uassert(16044, \"reserved error\", false);\n        uassert(16045, \"reserved error\", false);\n        uassert(16046, \"reserved error\", false);\n        uassert(16047, \"reserved error\", false);\n        uassert(16048, \"reserved error\", false);\n        uassert(16049, \"reserved error\", false);\n    }\n}\n"}
{"repo_name":"Pumpuli/multitheftauto","ref":"refs/heads/master","path":"vendor/cegui-0.4.0-custom/WidgetSets/Falagard/src/FalCheckbox.cpp","copies":"47","language":"C++","content":"/************************************************************************\r\n    filename:   FalCheckbox.cpp\r\n    created:    Thu Jun 23 2005\r\n    author:     Paul D Turner \u003cpaul@cegui.org.uk\u003e\r\n*************************************************************************/\r\n/*************************************************************************\r\n    Crazy Eddie's GUI System (http://www.cegui.org.uk)\r\n    Copyright (C)2004 - 2005 Paul D Turner (paul@cegui.org.uk)\r\n \r\n    This library is free software; you can redistribute it and/or\r\n    modify it under the terms of the GNU Lesser General Public\r\n    License as published by the Free Software Foundation; either\r\n    version 2.1 of the License, or (at your option) any later version.\r\n \r\n    This library is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n    Lesser General Public License for more details.\r\n \r\n    You should have received a copy of the GNU Lesser General Public\r\n    License along with this library; if not, write to the Free Software\r\n    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\r\n*************************************************************************/\r\n#include \"StdInc.h\"\r\n#include \"FalCheckbox.h\"\r\n#include \"falagard/CEGUIFalWidgetLookManager.h\"\r\n#include \"falagard/CEGUIFalWidgetLookFeel.h\"\r\n\r\n// Start of CEGUI namespace section\r\nnamespace CEGUI\r\n{\r\n    const utf8 FalagardCheckbox::WidgetTypeName[] = \"Falagard/Checkbox\";\r\n\r\n    FalagardCheckbox::FalagardCheckbox(const String\u0026 type, const String\u0026 name) :\r\n        Checkbox(type, name)\r\n    {\r\n    }\r\n\r\n    FalagardCheckbox::~FalagardCheckbox()\r\n    {\r\n    }\r\n\r\n    void FalagardCheckbox::drawSelf(float z)\r\n    {\r\n        // this is hackish and relies on insider knowlegde of the way that both Checkbox (actually ButtonBase)\r\n        // and Window implement things; Soon I'll get to updating things so that this can be replaced\r\n        // with clean code.\r\n\r\n        // call Checkbox drawSelf method which will call one of the state drawing methods overridden in this class.\r\n        Checkbox::drawSelf(z);\r\n\r\n        // call Window drawSelf to get it to send the cached imagery to the renderer.\r\n        Window::drawSelf(z);\r\n    }\r\n\r\n    void FalagardCheckbox::drawNormal(float z)\r\n    {\r\n        doButtonRender(d_selected ? \"SelectedNormal\" : \"Normal\");\r\n    }\r\n\r\n    void FalagardCheckbox::drawHover(float z)\r\n    {\r\n        doButtonRender(d_selected ? \"SelectedHover\" : \"Hover\");\r\n    }\r\n\r\n    void FalagardCheckbox::drawPushed(float z)\r\n    {\r\n        doButtonRender(d_selected ? \"SelectedPushed\" : \"Pushed\");\r\n    }\r\n\r\n    void FalagardCheckbox::drawDisabled(float z)\r\n    {\r\n        doButtonRender(d_selected ? \"SelectedDisabled\" : \"Disabled\");\r\n    }\r\n\r\n    void FalagardCheckbox::doButtonRender(const String\u0026 state)\r\n    {\r\n        // this is the second part of the hackish code.  We're duplicating the first section of code\r\n        // from the Window::drawSelf method to decide whether to actually do anything.  It is likely\r\n        // this will be replaced with cleaner code in the near future...\r\n\r\n        // do we need to update the cache?\r\n        if (d_needsRedraw)\r\n        {\r\n            const StateImagery* imagery;\r\n\r\n            // remove old cached imagery\r\n            d_renderCache.clearCachedImagery();\r\n            // signal that we'll no loger need a redraw.\r\n            d_needsRedraw = false;\r\n\r\n            try\r\n            {\r\n                // get WidgetLookFeel for the assigned look.\r\n                const WidgetLookFeel\u0026 wlf = WidgetLookManager::getSingleton().getWidgetLook(d_lookName);\r\n                // try and get imagery for the state we were given, though default to Normal states if the\r\n                // desired states do not exist\r\n                imagery = wlf.isStateImageryPresent(state) ? \u0026wlf.getStateImagery(state) : d_selected ? \u0026wlf.getStateImagery(\"SelectedNormal\") : \u0026wlf.getStateImagery(\"Normal\");\r\n            }\r\n            // catch exceptions, but do not exit.\r\n            catch (UnknownObjectException)\r\n            {\r\n                // don't try and draw using missing imagery!\r\n                return;\r\n            }\r\n\r\n            // peform the rendering operation.\r\n            // NB: This is not in the above try block since we want UnknownObjectException exceptions to be emitted from\r\n            // the rendering code for conditions such as missing Imagesets and/or Images.\r\n            imagery-\u003erender(*this);\r\n        }\r\n    }\r\n\r\n\r\n    //////////////////////////////////////////////////////////////////////////\r\n    /*************************************************************************\r\n\r\n        Factory Methods\r\n\r\n    *************************************************************************/\r\n    //////////////////////////////////////////////////////////////////////////\r\n    Window* FalagardCheckboxFactory::createWindow(const String\u0026 name)\r\n    {\r\n        return new FalagardCheckbox(d_type, name);\r\n    }\r\n\r\n    void FalagardCheckboxFactory::destroyWindow(Window* window)\r\n    {\r\n        delete window;\r\n    }\r\n\r\n} // End of  CEGUI namespace section\r\n"}
{"repo_name":"Greymane/SkyFireEMU","ref":"refs/heads/master","path":"dep/acelite/ace/OS_NS_errno.cpp","copies":"544","language":"C++","content":"// -*- C++ -*-\n// $Id: OS_NS_errno.cpp 91781 2010-09-15 12:49:15Z johnnyw $\n\n#include \"ace/OS_NS_errno.h\"\n\n#if !defined (ACE_HAS_INLINED_OSCALLS)\n# include \"ace/OS_NS_errno.inl\"\n#endif /* ACE_HAS_INLINED_OSCALLS */\n\n"}
{"repo_name":"jbrains/trivia","ref":"refs/heads/master","path":"C++/GameRunner.cpp","copies":"26","language":"C++","content":"﻿#include \u003cstdlib.h\u003e\n#include \"Game.h\"\n\nstatic bool notAWinner;\n\nint main()\n{\n\tGame aGame;\n\n\taGame.add(\"Chet\");\n\taGame.add(\"Pat\");\n\taGame.add(\"Sue\");\n\n\tdo\n\t{\n\n\t\taGame.roll(rand() % 5 + 1);\n\n\t\tif (rand() % 9 == 7)\n\t\t{\n\t\t\tnotAWinner = aGame.wrongAnswer();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnotAWinner = aGame.wasCorrectlyAnswered();\n\t\t}\n\t} while (notAWinner);\n\n}\n"}
{"repo_name":"pmprog/TugOfWar","ref":"refs/heads/master","path":"Game/gamelobbystage.cpp","copies":"1","language":"C++","content":"\n#include \"gamelobbystage.h\"\n#include \"menu.h\"\n#include \"input.h\"\n#include \"gamelobby_addlocal.h\"\n#include \"gamestage.h\"\n\nGameLobbyStage::GameLobbyStage()\n{\n\tnetworkconnection = nullptr;\n\tcurrentinfo = new GameInfo( true );\n\tselection = 0;\n\tselectionteamisblue = true;\n}\n\nGameLobbyStage::GameLobbyStage(Network* Connection)\n{\n\tselection = 0;\n\tnetworkconnection = Connection;\n\tcurrentinfo = new GameInfo( Connection-\u003eIsServer() );\n\n\tif( !Connection-\u003eIsServer() )\n\t{\n\t\t// TODO: Request gameinfo from server\n\t}\n}\n\nvoid GameLobbyStage::Begin()\n{\n\toptionfont = FontCache::LoadFont( \"resources/armalite.ttf\", 32 );\n\thelpfont = FontCache::LoadFont( \"resources/armalite.ttf\", 16 );\n\t// AUDIO-\u003ePlayMusic( \"resources/Paul Hannay (Feekzoid) - Last_Ninja_4_loader [1].ogg\", true );\n\n}\n\nvoid GameLobbyStage::Pause()\n{\n}\n\nvoid GameLobbyStage::Resume()\n{\n}\n\nvoid GameLobbyStage::Finish()\n{\n\tAUDIO-\u003eStopMusic();\n\n\tif( networkconnection != nullptr )\n\t{\n\t\tdelete networkconnection;\n\t\tnetworkconnection = nullptr;\n\t}\n}\n\nvoid GameLobbyStage::EventOccurred(Event *e)\n{\n\tInputItems::ItemSet inputevent = InputItems::NONE;\n\n\tif( e-\u003eType == EVENT_KEY_DOWN )\n\t{\n\t\tif( e-\u003eData.Keyboard.KeyCode == ALLEGRO_KEY_ESCAPE )\n\t\t{\n\t\t\tdelete FRAMEWORK-\u003eProgramStages-\u003ePop();\n\t\t\treturn;\n\t\t}\n\n\t\tinputevent = Input::GetItemFromEvent( e );\n\t}\n\n\tif( e-\u003eType == EVENT_JOYSTICK_BUTTON_DOWN \u0026\u0026 inputevent == InputItems::NONE )\n\t{\n\t\tinputevent = Input::GetItemFromEvent( e );\n\t}\n\n\tif( inputevent != InputItems::NONE )\n\t{\n\t\tInputEvent( inputevent );\n\t}\n\n\tNetworkEvent( e );\n\n}\n\nvoid GameLobbyStage::InputEvent(InputItems::ItemSet inputevent)\n{\n\tswitch( inputevent )\n\t{\n\t\tcase InputItems::UP:\n\t\t\tif( selection \u003e 0 )\n\t\t\t{\n\t\t\t\tselection--;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase InputItems::DOWN:\n\t\t\tif( selection \u003c 2 )\n\t\t\t{\n\t\t\t\tselection++;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase InputItems::LEFT:\n\t\t\tselectionteamisblue = true;\n\t\t\tbreak;\n\t\tcase InputItems::RIGHT:\n\t\t\tselectionteamisblue = false;\n\t\t\tbreak;\n\n\t\tcase InputItems::SELECT:\n\t\t\tdelete FRAMEWORK-\u003eProgramStages-\u003ePop();\n\t\t\treturn;\n\t\t\tbreak;\n\t\tcase InputItems::X:\n\t\t\tif( networkconnection == nullptr )\n\t\t\t{\n\t\t\t\tPlayerInfo* p = nullptr;\n\t\t\t\tif( selectionteamisblue )\n\t\t\t\t{\n\t\t\t\t\tif( currentinfo-\u003eBlueTeam[selection] == nullptr)\n\t\t\t\t\t{\n\t\t\t\t\t\tcurrentinfo-\u003eBlueTeam[selection] = new PlayerInfo( \"\", true, false );\n\t\t\t\t\t}\n\t\t\t\t\tp = currentinfo-\u003eBlueTeam[selection];\n\t\t\t\t} else {\n\t\t\t\t\tif( currentinfo-\u003eRedTeam[selection] == nullptr)\n\t\t\t\t\t{\n\t\t\t\t\t\tcurrentinfo-\u003eRedTeam[selection] = new PlayerInfo( \"\", true, false );\n\t\t\t\t\t}\n\t\t\t\t\tp = currentinfo-\u003eRedTeam[selection];\n\t\t\t\t}\n\t\t\t\tp-\u003eBlueTeam = selectionteamisblue;\n\t\t\t\tp-\u003eTeamIndex = selection;\n\t\t\t\tp-\u003eGameData = currentinfo;\n\t\t\t\tFRAMEWORK-\u003eProgramStages-\u003ePush( new GameLobbyAddLocalStage( p ) );\n\t\t\t}\n\t\t\tbreak;\n\t\tcase InputItems::B:\n\t\t\tif( networkconnection == nullptr )\n\t\t\t{\n\t\t\t\tPlayerInfo* p = nullptr;\n\t\t\t\tif( selectionteamisblue )\n\t\t\t\t{\n\t\t\t\t\tif( currentinfo-\u003eBlueTeam[selection] == nullptr )\n\t\t\t\t\t{\n\t\t\t\t\t\tp = new PlayerInfo( \"CPU\", true, true );\n\t\t\t\t\t\tcurrentinfo-\u003eBlueTeam[selection] = p;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif( currentinfo-\u003eRedTeam[selection] == nullptr )\n\t\t\t\t\t{\n\t\t\t\t\t\tp = new PlayerInfo( \"CPU\", true, true );\n\t\t\t\t\t\tcurrentinfo-\u003eRedTeam[selection] = p;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif( p != nullptr )\n\t\t\t\t{\n\t\t\t\t\tp-\u003eBlueTeam = selectionteamisblue;\n\t\t\t\t\tp-\u003eTeamIndex = selection;\n\t\t\t\t\tp-\u003eGameData = currentinfo;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase InputItems::Y:\n\t\t\tif( networkconnection == nullptr || networkconnection-\u003eIsServer() )\n\t\t\t{\n\t\t\t\tPlayerInfo* p = nullptr;\n\t\t\t\tif( selectionteamisblue )\n\t\t\t\t{\n\t\t\t\t\tp = currentinfo-\u003eBlueTeam[selection];\n\t\t\t\t\tcurrentinfo-\u003eBlueTeam[selection] = nullptr;\n\t\t\t\t} else {\n\t\t\t\t\tp = currentinfo-\u003eRedTeam[selection];\n\t\t\t\t\tcurrentinfo-\u003eRedTeam[selection] = nullptr;\n\t\t\t\t}\n\n\t\t\t\tif( p != nullptr )\n\t\t\t\t{\n\t\t\t\t\tif( !p-\u003eLocal )\n\t\t\t\t\t{\n\t\t\t\t\t\t// TODO: Disconnect\n\t\t\t\t\t}\n\t\t\t\t\tdelete p;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase InputItems::START:\n\n\t\t\tif( networkconnection == nullptr || networkconnection-\u003eIsServer() )\n\t\t\t{\n\t\t\t\t// TODO: Tell clients to start the game\n\t\t\t\tGameStage* g = new GameStage( currentinfo );\n\t\t\t\tdelete FRAMEWORK-\u003eProgramStages-\u003ePop();\n\t\t\t\tFRAMEWORK-\u003eProgramStages-\u003ePush( g );\n\t\t\t}\n\t\t\tbreak;\n\n\t}\n}\n\nvoid GameLobbyStage::NetworkEvent(Event* e)\n{\n\tif( e-\u003eType == EVENT_NETWORK_CONNECTION_REQUEST )\n\t{\n\t\tbool freeslot = false;\n\t\tfor( int i = 0; i \u003c 3; i++ )\n\t\t{\n\t\t\tfreeslot = ( currentinfo-\u003eBlueTeam[i] == nullptr ? true : freeslot );\n\t\t\tfreeslot = ( currentinfo-\u003eRedTeam[i] == nullptr ? true : freeslot );\n\t\t}\n\t\tif( freeslot )\n\t\t{\n\t\t\t// TODO: Accept player and balance teams\n\t\t}\n\t}\n\tif( e-\u003eType == EVENT_NETWORK_CONNECTED )\n\t{\n\t\t// TODO: Send current game info\n\t}\n\tif( e-\u003eType == EVENT_NETWORK_DISCONNECTED )\n\t{\n\t\t// TODO: Remove disconnected users\n\t}\n\tif( e-\u003eType == EVENT_NETWORK_PACKET_RECEIVED )\n\t{\n\t\t// TODO: Process packet info\n\t}\n}\n\nvoid GameLobbyStage::Update()\n{\n}\n\nvoid GameLobbyStage::Render()\n{\n\tal_clear_to_color( al_map_rgb( 255, 220, 128 ) );\n\n\toptionfont-\u003eDrawString( (DISPLAY-\u003eGetWidth() / 2) + 2, 12, \"Lobby\", FontHAlign::CENTRE, al_map_rgb( 0, 0, 0 ) );\n\toptionfont-\u003eDrawString( (DISPLAY-\u003eGetWidth() / 2), 10, \"Lobby\", FontHAlign::CENTRE, al_map_rgb( 255, 255, 0 ) );\n\n\tGameResources::DrawPanel( GameResources::BluePanel, 5, 80, 13, 8, 8 );\n\toptionfont-\u003eDrawString( 15, 85, \"Blue Team\", FontHAlign::LEFT, al_map_rgb( 255, 255, 255 ) );\n\n\tRenderPlayerSlot( true, 0, 15, 140 );\n\tRenderPlayerSlot( true, 1, 15, 192 );\n\tRenderPlayerSlot( true, 2, 15, 244 );\n\n\tGameResources::DrawPanel( GameResources::RedPanel, 405, 80, 13, 8, 8 );\n\toptionfont-\u003eDrawString( 415, 85, \"Red Team\", FontHAlign::LEFT, al_map_rgb( 255, 255, 255 ) );\n\n\tRenderPlayerSlot( false, 0, 415, 140 );\n\tRenderPlayerSlot( false, 1, 415, 192 );\n\tRenderPlayerSlot( false, 2, 415, 244 );\n\n\tint textoff = (50 - helpfont-\u003eGetFontHeight()) / 2;\n\tif( networkconnection == nullptr )\n\t{\n\t\t// Add Local Player\n\t\tal_draw_bitmap( Input::GetIcon( InputItems::X ), 10, 320, 0 );\n\t\thelpfont-\u003eDrawString( 64, 320 + textoff, \"Add Local Player\", FontHAlign::LEFT, al_map_rgb( 0, 0, 0 ) );\n\n\t\t// Add AI\n\t\tal_draw_bitmap( Input::GetIcon( InputItems::B ), 10, 370, 0 );\n\t\thelpfont-\u003eDrawString( 64, 370 + textoff, \"Add CPU Player\", FontHAlign::LEFT, al_map_rgb( 0, 0, 0 ) );\n\t}\n\n\tif( networkconnection == nullptr || networkconnection-\u003eIsServer() )\n\t{\n\t\t// Kick Player/AI\n\t\tal_draw_bitmap( Input::GetIcon( InputItems::Y ), 10, 420, 0 );\n\t\thelpfont-\u003eDrawString( 64, 420 + textoff, \"Kick Player\", FontHAlign::LEFT, al_map_rgb( 0, 0, 0 ) );\n\n\t\t// Start game\n\t\tal_draw_bitmap( Input::GetIcon( InputItems::START ), 500, 370, 0 );\n\t\thelpfont-\u003eDrawString( 554, 370 + textoff, \"Start\", FontHAlign::LEFT, al_map_rgb( 0, 0, 0 ) );\n\t}\n\n\t// Abort/Disconnect\n\tal_draw_bitmap( Input::GetIcon( InputItems::SELECT ), 500, 420, 0 );\n\thelpfont-\u003eDrawString( 554, 420 + textoff, \"Quit\", FontHAlign::LEFT, al_map_rgb( 0, 0, 0 ) );\n\n}\n\nbool GameLobbyStage::IsTransition()\n{\n\treturn false;\n}\n\nvoid GameLobbyStage::RenderPlayerSlot(bool BlueTeam, int Index, int X, int Y)\n{\n\tButtonColours::Colours colour = ButtonColours::WHITE;\n\tbool btnup = false;\n\tPlayerInfo* p = (BlueTeam ? currentinfo-\u003eBlueTeam[Index] : currentinfo-\u003eRedTeam[Index]);\n\n\tif( p != nullptr )\n\t{\n\t\tcolour = (BlueTeam ? ButtonColours::BLUE : ButtonColours::RED );\n\t}\n\n\tif( networkconnection == nullptr || networkconnection-\u003eIsServer() )\n\t{\n\t\tif( selection == Index \u0026\u0026 selectionteamisblue == BlueTeam )\n\t\t{\n\t\t\tcolour = ButtonColours::YELLOW;\n\t\t\tbtnup = true;\n\t\t}\n\t}\n\tGameResources::DrawButton( colour, btnup, X, Y, 23, 3 );\n\tif( p != nullptr )\n\t{\n\t\thelpfont-\u003eDrawString( X + 184, Y + 24 - (helpfont-\u003eGetFontHeight() / 2) + (!btnup ? 4 : 0), p-\u003eName, FontHAlign::CENTRE, al_map_rgb( 0, 0, 0 ) );\n\t\t// helpfont-\u003eDrawString( X + 184, Y + 24 - (helpfont-\u003eGetFontHeight() / 2) + (!btnup ? 4 : 0) - 2, p-\u003eName, FontHAlign::CENTRE, al_map_rgb( 255, 255, 255 ) );\n\t}\n\n}\n"}
{"repo_name":"zeliard/aws-sdk-cpp","ref":"refs/heads/windows-custom","path":"aws-cpp-sdk-iam/source/model/ListGroupsRequest.cpp","copies":"8","language":"C++","content":"/*\n* Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\").\n* You may not use this file except in compliance with the License.\n* A copy of the License is located at\n*\n*  http://aws.amazon.com/apache2.0\n*\n* or in the \"license\" file accompanying this file. This file is distributed\n* on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n* express or implied. See the License for the specific language governing\n* permissions and limitations under the License.\n*/\n#include \u003caws/iam/model/ListGroupsRequest.h\u003e\n#include \u003caws/core/utils/StringUtils.h\u003e\n#include \u003caws/core/utils/memory/stl/AWSStringStream.h\u003e\n\nusing namespace Aws::IAM::Model;\nusing namespace Aws::Utils;\n\nListGroupsRequest::ListGroupsRequest() : \n    m_pathPrefixHasBeenSet(false),\n    m_markerHasBeenSet(false),\n    m_maxItems(0),\n    m_maxItemsHasBeenSet(false)\n{\n}\n\nAws::String ListGroupsRequest::SerializePayload() const\n{\n  Aws::StringStream ss;\n  ss \u003c\u003c \"Action=ListGroups\u0026\";\n  if(m_pathPrefixHasBeenSet)\n  {\n    ss \u003c\u003c \"PathPrefix=\" \u003c\u003c StringUtils::URLEncode(m_pathPrefix.c_str()) \u003c\u003c \"\u0026\";\n  }\n  if(m_markerHasBeenSet)\n  {\n    ss \u003c\u003c \"Marker=\" \u003c\u003c StringUtils::URLEncode(m_marker.c_str()) \u003c\u003c \"\u0026\";\n  }\n  if(m_maxItemsHasBeenSet)\n  {\n    ss \u003c\u003c \"MaxItems=\" \u003c\u003c m_maxItems \u003c\u003c \"\u0026\";\n  }\n  ss \u003c\u003c \"Version=2010-05-08\";\n  return ss.str();\n}\n\n"}
{"repo_name":"shliujing/TeamTalk","ref":"refs/heads/master","path":"server/src/db_proxy_server/business/UserAction.cpp","copies":"86","language":"C++","content":"/*================================================================\n *   Copyright (C) 2014 All rights reserved.\n *\n *   文件名称：UserAction.cpp\n *   创 建 者：Zhang Yuanhao\n *   邮    箱：bluefoxah@gmail.com\n *   创建日期：2014年12月15日\n *   描    述：\n *\n ================================================================*/\n\n#include \u003clist\u003e\n#include \u003cmap\u003e\n\n#include \"../ProxyConn.h\"\n#include \"../DBPool.h\"\n#include \"../SyncCenter.h\"\n#include \"public_define.h\"\n#include \"UserModel.h\"\n#include \"IM.Login.pb.h\"\n#include \"IM.Buddy.pb.h\"\n#include \"IM.BaseDefine.pb.h\"\n\n\n\nnamespace DB_PROXY {\n\n    void getUserInfo(CImPdu* pPdu, uint32_t conn_uuid)\n    {\n        IM::Buddy::IMUsersInfoReq msg;\n        IM::Buddy::IMUsersInfoRsp msgResp;\n        if(msg.ParseFromArray(pPdu-\u003eGetBodyData(), pPdu-\u003eGetBodyLength()))\n        {\n            CImPdu* pPduRes = new CImPdu;\n            \n            uint32_t from_user_id = msg.user_id();\n            uint32_t userCount = msg.user_id_list_size();\n            std::list\u003cuint32_t\u003e idList;\n            for(uint32_t i = 0; i \u003c userCount;++i) {\n    \t\tidList.push_back(msg.user_id_list(i));\n            }\n\tstd::list\u003cIM::BaseDefine::UserInfo\u003e lsUser;\n            CUserModel::getInstance()-\u003egetUsers(idList, lsUser);\nmsgResp.set_user_id(from_user_id);\n            for(list\u003cIM::BaseDefine::UserInfo\u003e::iterator it=lsUser.begin();\n                it!=lsUser.end(); ++it)\n            {\n                IM::BaseDefine::UserInfo* pUser = msgResp.add_user_info_list();\n    //            *pUser = *it;\n             \n   pUser-\u003eset_user_id(it-\u003euser_id());\n                pUser-\u003eset_user_gender(it-\u003euser_gender());\n                pUser-\u003eset_user_nick_name(it-\u003euser_nick_name());\n                pUser-\u003eset_avatar_url(it-\u003eavatar_url());\n\n                pUser-\u003eset_sign_info(it-\u003esign_info());\n    pUser-\u003eset_department_id(it-\u003edepartment_id());\n                pUser-\u003eset_email(it-\u003eemail());\n                pUser-\u003eset_user_real_name(it-\u003euser_real_name());\n                pUser-\u003eset_user_tel(it-\u003euser_tel());\n                pUser-\u003eset_user_domain(it-\u003euser_domain());\n                pUser-\u003eset_status(it-\u003estatus());\n            }\n            log(\"userId=%u, userCnt=%u\", from_user_id, userCount);\n            msgResp.set_attach_data(msg.attach_data());\n            pPduRes-\u003eSetPBMsg(\u0026msgResp);\n            pPduRes-\u003eSetSeqNum(pPdu-\u003eGetSeqNum());\n            pPduRes-\u003eSetServiceId(IM::BaseDefine::SID_BUDDY_LIST);\n            pPduRes-\u003eSetCommandId(IM::BaseDefine::CID_BUDDY_LIST_USER_INFO_RESPONSE);\n            CProxyConn::AddResponsePdu(conn_uuid, pPduRes);\n        }\n        else\n        {\n            log(\"parse pb failed\");\n        }\n    }\n    \n    void getChangedUser(CImPdu* pPdu, uint32_t conn_uuid)\n    {\n        IM::Buddy::IMAllUserReq msg;\n        IM::Buddy::IMAllUserRsp msgResp;\n        if(msg.ParseFromArray(pPdu-\u003eGetBodyData(), pPdu-\u003eGetBodyLength()))\n        {\n            CImPdu* pPduRes = new CImPdu;\n            \n            uint32_t nReqId = msg.user_id();\n            uint32_t nLastTime = msg.latest_update_time();\n            uint32_t nLastUpdate = CSyncCenter::getInstance()-\u003egetLastUpdate();\n          \n            list\u003cIM::BaseDefine::UserInfo\u003e lsUsers;\n            if( nLastUpdate \u003e nLastTime)\n            {\n                list\u003cuint32_t\u003e lsIds;\n                CUserModel::getInstance()-\u003egetChangedId(nLastTime, lsIds);\n                CUserModel::getInstance()-\u003egetUsers(lsIds, lsUsers);\n            }\n            msgResp.set_user_id(nReqId);\n            msgResp.set_latest_update_time(nLastTime);\n            for (list\u003cIM::BaseDefine::UserInfo\u003e::iterator it=lsUsers.begin();\n                 it!=lsUsers.end(); ++it) {\n                IM::BaseDefine::UserInfo* pUser = msgResp.add_user_list();\n                //            *pUser = *it;\n                pUser-\u003eset_user_id(it-\u003euser_id());\n                pUser-\u003eset_user_gender(it-\u003euser_gender());\n                pUser-\u003eset_user_nick_name(it-\u003euser_nick_name());\n                pUser-\u003eset_avatar_url(it-\u003eavatar_url());\n                pUser-\u003eset_sign_info(it-\u003esign_info());\n                pUser-\u003eset_department_id(it-\u003edepartment_id());\n                pUser-\u003eset_email(it-\u003eemail());\n                pUser-\u003eset_user_real_name(it-\u003euser_real_name());\n                pUser-\u003eset_user_tel(it-\u003euser_tel());\n                pUser-\u003eset_user_domain(it-\u003euser_domain());\n                pUser-\u003eset_status(it-\u003estatus());\n            }\n            log(\"userId=%u,nLastUpdate=%u, last_time=%u, userCnt=%u\", nReqId,nLastUpdate, nLastTime, msgResp.user_list_size());\n            msgResp.set_attach_data(msg.attach_data());\n            pPduRes-\u003eSetPBMsg(\u0026msgResp);\n            pPduRes-\u003eSetSeqNum(pPdu-\u003eGetSeqNum());\n            pPduRes-\u003eSetServiceId(IM::BaseDefine::SID_BUDDY_LIST);\n            pPduRes-\u003eSetCommandId(IM::BaseDefine::CID_BUDDY_LIST_ALL_USER_RESPONSE);\n            CProxyConn::AddResponsePdu(conn_uuid, pPduRes);\n        }\n        else\n        {\n            log(\"parse pb failed\");\n        }\n    }\n    \n \n    void changeUserSignInfo(CImPdu* pPdu, uint32_t conn_uuid) {\n               IM::Buddy::IMChangeSignInfoReq req;\n                IM::Buddy::IMChangeSignInfoRsp resp;\n                if(req.ParseFromArray(pPdu-\u003eGetBodyData(), pPdu-\u003eGetBodyLength())) {\n                        uint32_t user_id = req.user_id();\n                       const string\u0026 sign_info = req.sign_info();\n            \n                        bool result = CUserModel::getInstance()-\u003eupdateUserSignInfo(user_id, sign_info);\n                    \n                        resp.set_user_id(user_id);\n                        resp.set_result_code(result ? 0 : 1);\n                        if (result) {\n                                resp.set_sign_info(sign_info);\n                                log(\"changeUserSignInfo sucess, user_id=%u, sign_info=%s\", user_id, sign_info.c_str());\n                            } else {\n                                    log(\"changeUserSignInfo false, user_id=%u, sign_info=%s\", user_id, sign_info.c_str());\n                                }\n\n            \n                        CImPdu* pdu_resp = new CImPdu();\n                        resp.set_attach_data(req.attach_data());\n                        pdu_resp-\u003eSetPBMsg(\u0026resp);\n                        pdu_resp-\u003eSetSeqNum(pPdu-\u003eGetSeqNum());\n                        pdu_resp-\u003eSetServiceId(IM::BaseDefine::SID_BUDDY_LIST);\n                        pdu_resp-\u003eSetCommandId(IM::BaseDefine::CID_BUDDY_LIST_CHANGE_SIGN_INFO_RESPONSE);\n                        CProxyConn::AddResponsePdu(conn_uuid, pdu_resp);\n                    \n                    } else {\n                            log(\"changeUserSignInfo: IMChangeSignInfoReq ParseFromArray failed!!!\");\n                        }\n           }\n    void doPushShield(CImPdu* pPdu, uint32_t conn_uuid) {\n        IM::Login::IMPushShieldReq req;\n        IM::Login::IMPushShieldRsp resp;\n        if(req.ParseFromArray(pPdu-\u003eGetBodyData(), pPdu-\u003eGetBodyLength())) {\n            uint32_t user_id = req.user_id();\n            uint32_t shield_status = req.shield_status();\n            // const string\u0026 sign_info = req.sign_info();\n            \n            bool result = CUserModel::getInstance()-\u003eupdatePushShield(user_id, shield_status);\n            \n            resp.set_user_id(user_id);\n            resp.set_result_code(result ? 0 : 1);\n            if (result) {\n                resp.set_shield_status(shield_status);\n                log(\"doPushShield sucess, user_id=%u, shield_status=%u\", user_id, shield_status);\n            } else {\n                log(\"doPushShield false, user_id=%u, shield_status=%u\", user_id, shield_status);\n            }\n            \n            \n            CImPdu* pdu_resp = new CImPdu();\n            resp.set_attach_data(req.attach_data());\n            pdu_resp-\u003eSetPBMsg(\u0026resp);\n            pdu_resp-\u003eSetSeqNum(pPdu-\u003eGetSeqNum());\n            pdu_resp-\u003eSetServiceId(IM::BaseDefine::SID_LOGIN);\n            pdu_resp-\u003eSetCommandId(IM::BaseDefine::CID_LOGIN_RES_PUSH_SHIELD);\n            CProxyConn::AddResponsePdu(conn_uuid, pdu_resp);\n            \n        } else {\n            log(\"doPushShield: IMPushShieldReq ParseFromArray failed!!!\");\n        }\n    }\n    \n    void doQueryPushShield(CImPdu* pPdu, uint32_t conn_uuid) {\n        IM::Login::IMQueryPushShieldReq req;\n        IM::Login::IMQueryPushShieldRsp resp;\n        if(req.ParseFromArray(pPdu-\u003eGetBodyData(), pPdu-\u003eGetBodyLength())) {\n            uint32_t user_id = req.user_id();\n            uint32_t shield_status = 0;\n            \n            bool result = CUserModel::getInstance()-\u003egetPushShield(user_id, \u0026shield_status);\n            \n            resp.set_user_id(user_id);\n            resp.set_result_code(result ? 0 : 1);\n            if (result) {\n                resp.set_shield_status(shield_status);\n                log(\"doQueryPushShield sucess, user_id=%u, shield_status=%u\", user_id, shield_status);\n            } else {\n                log(\"doQueryPushShield false, user_id=%u\", user_id);\n            }\n            \n            \n            CImPdu* pdu_resp = new CImPdu();\n            resp.set_attach_data(req.attach_data());\n            pdu_resp-\u003eSetPBMsg(\u0026resp);\n            pdu_resp-\u003eSetSeqNum(pPdu-\u003eGetSeqNum());\n            pdu_resp-\u003eSetServiceId(IM::BaseDefine::SID_LOGIN);\n            pdu_resp-\u003eSetCommandId(IM::BaseDefine::CID_LOGIN_RES_QUERY_PUSH_SHIELD);\n            CProxyConn::AddResponsePdu(conn_uuid, pdu_resp);\n        } else {\n            log(\"doQueryPushShield: IMQueryPushShieldReq ParseFromArray failed!!!\");\n        }\n    }\n};\n\n"}
{"repo_name":"tony--/WinObjC","ref":"refs/heads/master","path":"deps/3rdparty/iculegacy/source/i18n/rbtz.cpp","copies":"170","language":"C++","content":"/*\n*******************************************************************************\n* Copyright (C) 2007-2010, International Business Machines Corporation and\n* others. All Rights Reserved.\n*******************************************************************************\n*/\n\n#include \u003ctypeinfo\u003e  // for 'typeid' to work\n\n#include \"unicode/utypes.h\"\n\n#if !UCONFIG_NO_FORMATTING\n\n#include \"unicode/rbtz.h\"\n#include \"unicode/gregocal.h\"\n#include \"uvector.h\"\n#include \"gregoimp.h\"\n#include \"cmemory.h\"\n\nU_NAMESPACE_BEGIN\n\n/**\n * A struct representing a time zone transition\n */\nstruct Transition {\n    UDate time;\n    TimeZoneRule* from;\n    TimeZoneRule* to;\n};\n\nstatic UBool compareRules(UVector* rules1, UVector* rules2) {\n    if (rules1 == NULL \u0026\u0026 rules2 == NULL) {\n        return TRUE;\n    } else if (rules1 == NULL || rules2 == NULL) {\n        return FALSE;\n    }\n    int32_t size = rules1-\u003esize();\n    if (size != rules2-\u003esize()) {\n        return FALSE;\n    }\n    for (int32_t i = 0; i \u003c size; i++) {\n        TimeZoneRule *r1 = (TimeZoneRule*)rules1-\u003eelementAt(i);\n        TimeZoneRule *r2 = (TimeZoneRule*)rules2-\u003eelementAt(i);\n        if (*r1 != *r2) {\n            return FALSE;\n        }\n    }\n    return TRUE;\n}\n\nUOBJECT_DEFINE_RTTI_IMPLEMENTATION(RuleBasedTimeZone)\n\nRuleBasedTimeZone::RuleBasedTimeZone(const UnicodeString\u0026 id, InitialTimeZoneRule* initialRule)\n: BasicTimeZone(id), fInitialRule(initialRule), fHistoricRules(NULL), fFinalRules(NULL),\n  fHistoricTransitions(NULL), fUpToDate(FALSE) {\n}\n\nRuleBasedTimeZone::RuleBasedTimeZone(const RuleBasedTimeZone\u0026 source)\n: BasicTimeZone(source), fInitialRule(source.fInitialRule-\u003eclone()),\n  fHistoricTransitions(NULL), fUpToDate(FALSE) {\n    fHistoricRules = copyRules(source.fHistoricRules);\n    fFinalRules = copyRules(source.fFinalRules);\n    if (source.fUpToDate) {\n        UErrorCode status = U_ZERO_ERROR;\n        complete(status);\n    }\n}\n\nRuleBasedTimeZone::~RuleBasedTimeZone() {\n    deleteTransitions();\n    deleteRules();\n}\n\nRuleBasedTimeZone\u0026\nRuleBasedTimeZone::operator=(const RuleBasedTimeZone\u0026 right) {\n    if (*this != right) {\n        BasicTimeZone::operator=(right);\n        deleteRules();\n        fInitialRule = right.fInitialRule-\u003eclone();\n        fHistoricRules = copyRules(right.fHistoricRules);\n        fFinalRules = copyRules(right.fFinalRules);\n        deleteTransitions();\n        fUpToDate = FALSE;\n    }\n    return *this;\n}\n\nUBool\nRuleBasedTimeZone::operator==(const TimeZone\u0026 that) const {\n    if (this == \u0026that) {\n        return TRUE;\n    }\n    if (typeid(*this) != typeid(that)\n        || BasicTimeZone::operator==(that) == FALSE) {\n        return FALSE;\n    }\n    RuleBasedTimeZone *rbtz = (RuleBasedTimeZone*)\u0026that;\n    if (*fInitialRule != *(rbtz-\u003efInitialRule)) {\n        return FALSE;\n    }\n    if (compareRules(fHistoricRules, rbtz-\u003efHistoricRules)\n        \u0026\u0026 compareRules(fFinalRules, rbtz-\u003efFinalRules)) {\n        return TRUE;\n    }\n    return FALSE;\n}\n\nUBool\nRuleBasedTimeZone::operator!=(const TimeZone\u0026 that) const {\n    return !operator==(that);\n}\n\nvoid\nRuleBasedTimeZone::addTransitionRule(TimeZoneRule* rule, UErrorCode\u0026 status) {\n    if (U_FAILURE(status)) {\n        return;\n    }\n    AnnualTimeZoneRule* atzrule = dynamic_cast\u003cAnnualTimeZoneRule*\u003e(rule);\n    if (atzrule != NULL \u0026\u0026 atzrule-\u003egetEndYear() == AnnualTimeZoneRule::MAX_YEAR) {\n        // A final rule\n        if (fFinalRules == NULL) {\n            fFinalRules = new UVector(status);\n            if (U_FAILURE(status)) {\n                return;\n            }\n        } else if (fFinalRules-\u003esize() \u003e= 2) {\n            // Cannot handle more than two final rules\n            status = U_INVALID_STATE_ERROR;\n            return;\n        }\n        fFinalRules-\u003eaddElement((void*)rule, status);\n    } else {\n        // Non-final rule\n        if (fHistoricRules == NULL) {\n            fHistoricRules = new UVector(status);\n            if (U_FAILURE(status)) {\n                return;\n            }\n        }\n        fHistoricRules-\u003eaddElement((void*)rule, status);\n    }\n    // Mark dirty, so transitions are recalculated at next complete() call\n    fUpToDate = FALSE;\n}\n\nvoid\nRuleBasedTimeZone::complete(UErrorCode\u0026 status) {\n    if (U_FAILURE(status)) {\n        return;\n    }\n    if (fUpToDate) {\n        return;\n    }\n    // Make sure either no final rules or a pair of AnnualTimeZoneRules\n    // are available.\n    if (fFinalRules != NULL \u0026\u0026 fFinalRules-\u003esize() != 2) {\n        status = U_INVALID_STATE_ERROR;\n        return;\n    }\n\n    UBool *done = NULL;\n    // Create a TimezoneTransition and add to the list\n    if (fHistoricRules != NULL || fFinalRules != NULL) {\n        TimeZoneRule *curRule = fInitialRule;\n        UDate lastTransitionTime = MIN_MILLIS;\n\n        // Build the transition array which represents historical time zone\n        // transitions.\n        if (fHistoricRules != NULL \u0026\u0026 fHistoricRules-\u003esize() \u003e 0) {\n            int32_t i;\n            int32_t historicCount = fHistoricRules-\u003esize();\n            done = (UBool*)uprv_malloc(sizeof(UBool) * historicCount);\n            if (done == NULL) {\n                status = U_MEMORY_ALLOCATION_ERROR;\n                goto cleanup;\n            }\n            for (i = 0; i \u003c historicCount; i++) {\n                done[i] = FALSE;\n            }\n            while (TRUE) {\n                int32_t curStdOffset = curRule-\u003egetRawOffset();\n                int32_t curDstSavings = curRule-\u003egetDSTSavings();\n                UDate nextTransitionTime = MAX_MILLIS;\n                TimeZoneRule *nextRule = NULL;\n                TimeZoneRule *r = NULL;\n                UBool avail;\n                UDate tt;\n                UnicodeString curName, name;\n                curRule-\u003egetName(curName);\n\n                for (i = 0; i \u003c historicCount; i++) {\n                    if (done[i]) {\n                        continue;\n                    }\n                    r = (TimeZoneRule*)fHistoricRules-\u003eelementAt(i);\n                    avail = r-\u003egetNextStart(lastTransitionTime, curStdOffset, curDstSavings, false, tt);\n                    if (!avail) {\n                        // No more transitions from this rule - skip this rule next time\n                        done[i] = TRUE;\n                    } else {\n                        r-\u003egetName(name);\n                        if (*r == *curRule ||\n                            (name == curName \u0026\u0026 r-\u003egetRawOffset() == curRule-\u003egetRawOffset()\n                            \u0026\u0026 r-\u003egetDSTSavings() == curRule-\u003egetDSTSavings())) {\n                            continue;\n                        }\n                        if (tt \u003c nextTransitionTime) {\n                            nextTransitionTime = tt;\n                            nextRule = r;\n                        }\n                    }\n                }\n\n                if (nextRule ==  NULL) {\n                    // Check if all historic rules are done\n                    UBool bDoneAll = TRUE;\n                    for (int32_t j = 0; j \u003c historicCount; j++) {\n                        if (!done[j]) {\n                            bDoneAll = FALSE;\n                            break;\n                        }\n                    }\n                    if (bDoneAll) {\n                        break;\n                    }\n                }\n\n                if (fFinalRules != NULL) {\n                    // Check if one of final rules has earlier transition date\n                    for (i = 0; i \u003c 2 /* fFinalRules-\u003esize() */; i++) {\n                        TimeZoneRule *fr = (TimeZoneRule*)fFinalRules-\u003eelementAt(i);\n                        if (*fr == *curRule) {\n                            continue;\n                        }\n                        r = (TimeZoneRule*)fFinalRules-\u003eelementAt(i);\n                        avail = r-\u003egetNextStart(lastTransitionTime, curStdOffset, curDstSavings, false, tt);\n                        if (avail) {\n                            if (tt \u003c nextTransitionTime) {\n                                nextTransitionTime = tt;\n                                nextRule = r;\n                            }\n                        }\n                    }\n                }\n\n                if (nextRule == NULL) {\n                    // Nothing more\n                    break;\n                }\n\n                if (fHistoricTransitions == NULL) {\n                    fHistoricTransitions = new UVector(status);\n                    if (U_FAILURE(status)) {\n                        goto cleanup;\n                    }\n                }\n                Transition *trst = (Transition*)uprv_malloc(sizeof(Transition));\n                if (trst == NULL) {\n                    status = U_MEMORY_ALLOCATION_ERROR;\n                    goto cleanup;\n                }\n                trst-\u003etime = nextTransitionTime;\n                trst-\u003efrom = curRule;\n                trst-\u003eto = nextRule;\n                fHistoricTransitions-\u003eaddElement(trst, status);\n                if (U_FAILURE(status)) {\n                    goto cleanup;\n                }\n                lastTransitionTime = nextTransitionTime;\n                curRule = nextRule;\n            }\n        }\n        if (fFinalRules != NULL) {\n            if (fHistoricTransitions == NULL) {\n                fHistoricTransitions = new UVector(status);\n                if (U_FAILURE(status)) {\n                    goto cleanup;\n                }\n            }\n            // Append the first transition for each\n            TimeZoneRule *rule0 = (TimeZoneRule*)fFinalRules-\u003eelementAt(0);\n            TimeZoneRule *rule1 = (TimeZoneRule*)fFinalRules-\u003eelementAt(1);\n            UDate tt0, tt1;\n            UBool avail0 = rule0-\u003egetNextStart(lastTransitionTime, curRule-\u003egetRawOffset(), curRule-\u003egetDSTSavings(), false, tt0);\n            UBool avail1 = rule1-\u003egetNextStart(lastTransitionTime, curRule-\u003egetRawOffset(), curRule-\u003egetDSTSavings(), false, tt1);\n            if (!avail0 || !avail1) {\n                // Should not happen, because both rules are permanent\n                status = U_INVALID_STATE_ERROR;\n                goto cleanup;\n            }\n            Transition *final0 = (Transition*)uprv_malloc(sizeof(Transition));\n            if (final0 == NULL) {\n                status = U_MEMORY_ALLOCATION_ERROR;\n                goto cleanup;\n            }\n            Transition *final1 = (Transition*)uprv_malloc(sizeof(Transition));\n            if (final1 == NULL) {\n                uprv_free(final0);\n                status = U_MEMORY_ALLOCATION_ERROR;\n                goto cleanup;\n            }\n            if (tt0 \u003c tt1) {\n                final0-\u003etime = tt0;\n                final0-\u003efrom = curRule;\n                final0-\u003eto = rule0;\n                rule1-\u003egetNextStart(tt0, rule0-\u003egetRawOffset(), rule0-\u003egetDSTSavings(), false, final1-\u003etime);\n                final1-\u003efrom = rule0;\n                final1-\u003eto = rule1;\n            } else {\n                final0-\u003etime = tt1;\n                final0-\u003efrom = curRule;\n                final0-\u003eto = rule1;\n                rule0-\u003egetNextStart(tt1, rule1-\u003egetRawOffset(), rule1-\u003egetDSTSavings(), false, final1-\u003etime);\n                final1-\u003efrom = rule1;\n                final1-\u003eto = rule0;\n            }\n            fHistoricTransitions-\u003eaddElement(final0, status);\n            if (U_FAILURE(status)) {\n                goto cleanup;\n            }\n            fHistoricTransitions-\u003eaddElement(final1, status);\n            if (U_FAILURE(status)) {\n                goto cleanup;\n            }\n        }\n    }\n    fUpToDate = TRUE;\n    if (done != NULL) {\n        uprv_free(done);\n    }\n    return;\n\ncleanup:\n    deleteTransitions();\n    if (done != NULL) {\n        uprv_free(done);\n    }\n    fUpToDate = FALSE;\n}\n\nTimeZone*\nRuleBasedTimeZone::clone(void) const {\n    return new RuleBasedTimeZone(*this);\n}\n\nint32_t\nRuleBasedTimeZone::getOffset(uint8_t era, int32_t year, int32_t month, int32_t day,\n                             uint8_t dayOfWeek, int32_t millis, UErrorCode\u0026 status) const {\n    if (U_FAILURE(status)) {\n        return 0;\n    }\n    if (month \u003c UCAL_JANUARY || month \u003e UCAL_DECEMBER) {\n        status = U_ILLEGAL_ARGUMENT_ERROR;\n        return 0;\n    } else {\n        return getOffset(era, year, month, day, dayOfWeek, millis,\n                         Grego::monthLength(year, month), status);\n    }\n}\n\nint32_t\nRuleBasedTimeZone::getOffset(uint8_t era, int32_t year, int32_t month, int32_t day,\n                             uint8_t /*dayOfWeek*/, int32_t millis,\n                             int32_t /*monthLength*/, UErrorCode\u0026 status) const {\n    // dayOfWeek and monthLength are unused\n    if (U_FAILURE(status)) {\n        return 0;\n    }\n    if (era == GregorianCalendar::BC) {\n        // Convert to extended year\n        year = 1 - year;\n    }\n    int32_t rawOffset, dstOffset;\n    UDate time = (UDate)Grego::fieldsToDay(year, month, day) * U_MILLIS_PER_DAY + millis;\n    getOffsetInternal(time, TRUE, kDaylight, kStandard, rawOffset, dstOffset, status);\n    if (U_FAILURE(status)) {\n        return 0;\n    }\n    return (rawOffset + dstOffset);\n}\n\nvoid\nRuleBasedTimeZone::getOffset(UDate date, UBool local, int32_t\u0026 rawOffset,\n                             int32_t\u0026 dstOffset, UErrorCode\u0026 status) const {\n    getOffsetInternal(date, local, kFormer, kLatter, rawOffset, dstOffset, status);\n}\n\nvoid\nRuleBasedTimeZone::getOffsetFromLocal(UDate date, int32_t nonExistingTimeOpt, int32_t duplicatedTimeOpt,\n                                      int32_t\u0026 rawOffset, int32_t\u0026 dstOffset, UErrorCode\u0026 status) /*const*/ {\n    getOffsetInternal(date, TRUE, nonExistingTimeOpt, duplicatedTimeOpt, rawOffset, dstOffset, status);\n}\n\n\n/*\n * The internal getOffset implementation\n */\nvoid\nRuleBasedTimeZone::getOffsetInternal(UDate date, UBool local,\n                                     int32_t NonExistingTimeOpt, int32_t DuplicatedTimeOpt,\n                                     int32_t\u0026 rawOffset, int32_t\u0026 dstOffset,\n                                     UErrorCode\u0026 status) const {\n    rawOffset = 0;\n    dstOffset = 0;\n\n    if (U_FAILURE(status)) {\n        return;\n    }\n    if (!fUpToDate) {\n        // Transitions are not yet resolved.  We cannot do it here\n        // because this method is const.  Thus, do nothing and return\n        // error status.\n        status = U_INVALID_STATE_ERROR;\n        return;\n    }\n    const TimeZoneRule *rule = NULL;\n    if (fHistoricTransitions == NULL) {\n        rule = fInitialRule;\n    } else {\n        UDate tstart = getTransitionTime((Transition*)fHistoricTransitions-\u003eelementAt(0),\n            local, NonExistingTimeOpt, DuplicatedTimeOpt);\n        if (date \u003c tstart) {\n            rule = fInitialRule;\n        } else {\n            int32_t idx = fHistoricTransitions-\u003esize() - 1;\n            UDate tend = getTransitionTime((Transition*)fHistoricTransitions-\u003eelementAt(idx),\n                local, NonExistingTimeOpt, DuplicatedTimeOpt);\n            if (date \u003e tend) {\n                if (fFinalRules != NULL) {\n                    rule = findRuleInFinal(date, local, NonExistingTimeOpt, DuplicatedTimeOpt);\n                } else {\n                    // no final rule, use the last rule\n                    rule = ((Transition*)fHistoricTransitions-\u003eelementAt(idx))-\u003eto;\n                }\n            } else {\n                // Find a historical transition\n                while (idx \u003e= 0) {\n                    if (date \u003e= getTransitionTime((Transition*)fHistoricTransitions-\u003eelementAt(idx),\n                        local, NonExistingTimeOpt, DuplicatedTimeOpt)) {\n                        break;\n                    }\n                    idx--;\n                }\n                rule = ((Transition*)fHistoricTransitions-\u003eelementAt(idx))-\u003eto;\n            }\n        }\n    }\n    if (rule != NULL) {\n        rawOffset = rule-\u003egetRawOffset();\n        dstOffset = rule-\u003egetDSTSavings();\n    }\n}\n\nvoid\nRuleBasedTimeZone::setRawOffset(int32_t /*offsetMillis*/) {\n    // We don't support this operation at this moment.\n    // Nothing to do!\n}\n\nint32_t\nRuleBasedTimeZone::getRawOffset(void) const {\n    // Note: This implementation returns standard GMT offset\n    // as of current time.\n    UErrorCode status = U_ZERO_ERROR;\n    int32_t raw, dst;\n    getOffset(uprv_getUTCtime() * U_MILLIS_PER_SECOND,\n        FALSE, raw, dst, status);\n    return raw;\n}\n\nUBool\nRuleBasedTimeZone::useDaylightTime(void) const {\n    // Note: This implementation returns true when\n    // daylight saving time is used as of now or\n    // after the next transition.\n    UErrorCode status = U_ZERO_ERROR;\n    UDate now = uprv_getUTCtime() * U_MILLIS_PER_SECOND;\n    int32_t raw, dst;\n    getOffset(now, FALSE, raw, dst, status);\n    if (dst != 0) {\n        return TRUE;\n    }\n    // If DST is not used now, check if DST is used after the next transition\n    UDate time;\n    TimeZoneRule *from, *to;\n    UBool avail = findNext(now, FALSE, time, from, to);\n    if (avail \u0026\u0026 to-\u003egetDSTSavings() != 0) {\n        return TRUE;\n    }\n    return FALSE;\n}\n\nUBool\nRuleBasedTimeZone::inDaylightTime(UDate date, UErrorCode\u0026 status) const {\n    if (U_FAILURE(status)) {\n        return FALSE;\n    }\n    int32_t raw, dst;\n    getOffset(date, FALSE, raw, dst, status);\n    if (dst != 0) {\n        return TRUE;\n    }\n    return FALSE;\n}\n\nUBool\nRuleBasedTimeZone::hasSameRules(const TimeZone\u0026 other) const {\n    if (this == \u0026other) {\n        return TRUE;\n    }\n    if (typeid(*this) != typeid(other)) {\n        return FALSE;\n    }\n    const RuleBasedTimeZone\u0026 that = (const RuleBasedTimeZone\u0026)other;\n    if (*fInitialRule != *(that.fInitialRule)) {\n        return FALSE;\n    }\n    if (compareRules(fHistoricRules, that.fHistoricRules)\n        \u0026\u0026 compareRules(fFinalRules, that.fFinalRules)) {\n        return TRUE;\n    }\n    return FALSE;\n}\n\nUBool\nRuleBasedTimeZone::getNextTransition(UDate base, UBool inclusive, TimeZoneTransition\u0026 result) /*const*/ {\n    UErrorCode status = U_ZERO_ERROR;\n    complete(status);\n    if (U_FAILURE(status)) {\n        return FALSE;\n    }\n    UDate transitionTime;\n    TimeZoneRule *fromRule, *toRule;\n    UBool found = findNext(base, inclusive, transitionTime, fromRule, toRule);\n    if (found) {\n        result.setTime(transitionTime);\n        result.setFrom((const TimeZoneRule\u0026)*fromRule);\n        result.setTo((const TimeZoneRule\u0026)*toRule);\n        return TRUE;\n    }\n    return FALSE;\n}\n\nUBool\nRuleBasedTimeZone::getPreviousTransition(UDate base, UBool inclusive, TimeZoneTransition\u0026 result) /*const*/ {\n    UErrorCode status = U_ZERO_ERROR;\n    complete(status);\n    if (U_FAILURE(status)) {\n        return FALSE;\n    }\n    UDate transitionTime;\n    TimeZoneRule *fromRule, *toRule;\n    UBool found = findPrev(base, inclusive, transitionTime, fromRule, toRule);\n    if (found) {\n        result.setTime(transitionTime);\n        result.setFrom((const TimeZoneRule\u0026)*fromRule);\n        result.setTo((const TimeZoneRule\u0026)*toRule);\n        return TRUE;\n    }\n    return FALSE;\n}\n\nint32_t\nRuleBasedTimeZone::countTransitionRules(UErrorCode\u0026 /*status*/) /*const*/ {\n    int32_t count = 0;\n    if (fHistoricRules != NULL) {\n        count += fHistoricRules-\u003esize();\n    }\n    if (fFinalRules != NULL) {\n        count += fFinalRules-\u003esize();\n    }\n    return count;\n}\n\nvoid\nRuleBasedTimeZone::getTimeZoneRules(const InitialTimeZoneRule*\u0026 initial,\n                                    const TimeZoneRule* trsrules[],\n                                    int32_t\u0026 trscount,\n                                    UErrorCode\u0026 status) /*const*/ {\n    if (U_FAILURE(status)) {\n        return;\n    }\n    // Initial rule\n    initial = fInitialRule;\n\n    // Transition rules\n    int32_t cnt = 0;\n    int32_t idx;\n    if (fHistoricRules != NULL \u0026\u0026 cnt \u003c trscount) {\n        int32_t historicCount = fHistoricRules-\u003esize();\n        idx = 0;\n        while (cnt \u003c trscount \u0026\u0026 idx \u003c historicCount) {\n            trsrules[cnt++] = (const TimeZoneRule*)fHistoricRules-\u003eelementAt(idx++);\n        }\n    }\n    if (fFinalRules != NULL \u0026\u0026 cnt \u003c trscount) {\n        int32_t finalCount = fFinalRules-\u003esize();\n        idx = 0;\n        while (cnt \u003c trscount \u0026\u0026 idx \u003c finalCount) {\n            trsrules[cnt++] = (const TimeZoneRule*)fFinalRules-\u003eelementAt(idx++);\n        }\n    }\n    // Set the result length\n    trscount = cnt;\n}\n\nvoid\nRuleBasedTimeZone::deleteRules(void) {\n    delete fInitialRule;\n    fInitialRule = NULL;\n    if (fHistoricRules != NULL) {\n        while (!fHistoricRules-\u003eisEmpty()) {\n            delete (TimeZoneRule*)(fHistoricRules-\u003eorphanElementAt(0));\n        }\n        delete fHistoricRules;\n        fHistoricRules = NULL;\n    }\n    if (fFinalRules != NULL) {\n        while (!fFinalRules-\u003eisEmpty()) {\n            delete (AnnualTimeZoneRule*)(fFinalRules-\u003eorphanElementAt(0));\n        }\n        delete fFinalRules;\n        fFinalRules = NULL;\n    }\n}\n\nvoid\nRuleBasedTimeZone::deleteTransitions(void) {\n    if (fHistoricTransitions != NULL) {\n        while (!fHistoricTransitions-\u003eisEmpty()) {\n            Transition *trs = (Transition*)fHistoricTransitions-\u003eorphanElementAt(0);\n            uprv_free(trs);\n        }\n        delete fHistoricTransitions;\n    }\n    fHistoricTransitions = NULL;\n}\n\nUVector*\nRuleBasedTimeZone::copyRules(UVector* source) {\n    if (source == NULL) {\n        return NULL;\n    }\n    UErrorCode ec = U_ZERO_ERROR;\n    int32_t size = source-\u003esize();\n    UVector *rules = new UVector(size, ec);\n    if (U_FAILURE(ec)) {\n        return NULL;\n    }\n    int32_t i;\n    for (i = 0; i \u003c size; i++) {\n        rules-\u003eaddElement(((TimeZoneRule*)source-\u003eelementAt(i))-\u003eclone(), ec);\n        if (U_FAILURE(ec)) {\n            break;\n        }\n    }\n    if (U_FAILURE(ec)) {\n        // In case of error, clean up\n        for (i = 0; i \u003c rules-\u003esize(); i++) {\n            TimeZoneRule *rule = (TimeZoneRule*)rules-\u003eorphanElementAt(i);\n            delete rule;\n        }\n        delete rules;\n        return NULL;\n    }\n    return rules;\n}\n\nTimeZoneRule*\nRuleBasedTimeZone::findRuleInFinal(UDate date, UBool local,\n                                   int32_t NonExistingTimeOpt, int32_t DuplicatedTimeOpt) const {\n    if (fFinalRules == NULL) {\n        return NULL;\n    }\n\n    AnnualTimeZoneRule* fr0 = (AnnualTimeZoneRule*)fFinalRules-\u003eelementAt(0);\n    AnnualTimeZoneRule* fr1 = (AnnualTimeZoneRule*)fFinalRules-\u003eelementAt(1);\n    if (fr0 == NULL || fr1 == NULL) {\n        return NULL;\n    }\n\n    UDate start0, start1;\n    UDate base;\n    int32_t localDelta;\n\n    base = date;\n    if (local) {\n        localDelta = getLocalDelta(fr1-\u003egetRawOffset(), fr1-\u003egetDSTSavings(),\n                                   fr0-\u003egetRawOffset(), fr0-\u003egetDSTSavings(),\n                                   NonExistingTimeOpt, DuplicatedTimeOpt);\n        base -= localDelta;\n    }\n    UBool avail0 = fr0-\u003egetPreviousStart(base, fr1-\u003egetRawOffset(), fr1-\u003egetDSTSavings(), TRUE, start0);\n\n    base = date;\n    if (local) {\n        localDelta = getLocalDelta(fr0-\u003egetRawOffset(), fr0-\u003egetDSTSavings(),\n                                   fr1-\u003egetRawOffset(), fr1-\u003egetDSTSavings(),\n                                   NonExistingTimeOpt, DuplicatedTimeOpt);\n        base -= localDelta;\n    }\n    UBool avail1 = fr1-\u003egetPreviousStart(base, fr0-\u003egetRawOffset(), fr0-\u003egetDSTSavings(), TRUE, start1);\n\n    if (avail0 \u0026\u0026 (!avail1 || start0 \u003e start1)) {\n        return fr0;\n    } else if (avail1) {\n        return fr1;\n    }\n    return NULL;\n}\n\nUBool\nRuleBasedTimeZone::findNext(UDate base, UBool inclusive, UDate\u0026 transitionTime,\n                            TimeZoneRule*\u0026 fromRule, TimeZoneRule*\u0026 toRule) const {\n    if (fHistoricTransitions == NULL) {\n        return FALSE;\n    }\n    UBool isFinal = FALSE;\n    UBool found = FALSE;\n    Transition result;\n    Transition *tzt = (Transition*)fHistoricTransitions-\u003eelementAt(0);\n    UDate tt = tzt-\u003etime;\n    if (tt \u003e base || (inclusive \u0026\u0026 tt == base)) {\n        result = *tzt;\n        found = TRUE;\n    } else {\n        int32_t idx = fHistoricTransitions-\u003esize() - 1;        \n        tzt = (Transition*)fHistoricTransitions-\u003eelementAt(idx);\n        tt = tzt-\u003etime;\n        if (inclusive \u0026\u0026 tt == base) {\n            result = *tzt;\n            found = TRUE;\n        } else if (tt \u003c= base) {\n            if (fFinalRules != NULL) {\n                // Find a transion time with finalRules\n                TimeZoneRule *r0 = (TimeZoneRule*)fFinalRules-\u003eelementAt(0);\n                TimeZoneRule *r1 = (TimeZoneRule*)fFinalRules-\u003eelementAt(1);\n                UDate start0, start1;\n                UBool avail0 = r0-\u003egetNextStart(base, r1-\u003egetRawOffset(), r1-\u003egetDSTSavings(), inclusive, start0);\n                UBool avail1 = r1-\u003egetNextStart(base, r0-\u003egetRawOffset(), r0-\u003egetDSTSavings(), inclusive, start1);\n                //  avail0/avail1 should be always TRUE\n                if (!avail0 \u0026\u0026 !avail1) {\n                    return FALSE;\n                }\n                if (!avail1 || start0 \u003c start1) {\n                    result.time = start0;\n                    result.from = r1;\n                    result.to = r0;\n                } else {\n                    result.time = start1;\n                    result.from = r0;\n                    result.to = r1;\n                }\n                isFinal = TRUE;\n                found = TRUE;\n            }\n        } else {\n            // Find a transition within the historic transitions\n            idx--;\n            Transition *prev = tzt;\n            while (idx \u003e 0) {\n                tzt = (Transition*)fHistoricTransitions-\u003eelementAt(idx);\n                tt = tzt-\u003etime;\n                if (tt \u003c base || (!inclusive \u0026\u0026 tt == base)) {\n                    break;\n                }\n                idx--;\n                prev = tzt;\n            }\n            result.time = prev-\u003etime;\n            result.from = prev-\u003efrom;\n            result.to = prev-\u003eto;\n            found = TRUE;\n        }\n    }\n    if (found) {\n        // For now, this implementation ignore transitions with only zone name changes.\n        if (result.from-\u003egetRawOffset() == result.to-\u003egetRawOffset()\n            \u0026\u0026 result.from-\u003egetDSTSavings() == result.to-\u003egetDSTSavings()) {\n            if (isFinal) {\n                return FALSE;\n            } else {\n                // No offset changes.  Try next one if not final\n                return findNext(result.time, FALSE /* always exclusive */,\n                    transitionTime, fromRule, toRule);\n            }\n        }\n        transitionTime = result.time;\n        fromRule = result.from;\n        toRule = result.to;\n        return TRUE;\n    }\n    return FALSE;\n}\n\nUBool\nRuleBasedTimeZone::findPrev(UDate base, UBool inclusive, UDate\u0026 transitionTime,\n                            TimeZoneRule*\u0026 fromRule, TimeZoneRule*\u0026 toRule) const {\n    if (fHistoricTransitions == NULL) {\n        return FALSE;\n    }\n    UBool found = FALSE;\n    Transition result;\n    Transition *tzt = (Transition*)fHistoricTransitions-\u003eelementAt(0);\n    UDate tt = tzt-\u003etime;\n    if (inclusive \u0026\u0026 tt == base) {\n        result = *tzt;\n        found = TRUE;\n    } else if (tt \u003c base) {\n        int32_t idx = fHistoricTransitions-\u003esize() - 1;        \n        tzt = (Transition*)fHistoricTransitions-\u003eelementAt(idx);\n        tt = tzt-\u003etime;\n        if (inclusive \u0026\u0026 tt == base) {\n            result = *tzt;\n            found = TRUE;\n        } else if (tt \u003c base) {\n            if (fFinalRules != NULL) {\n                // Find a transion time with finalRules\n                TimeZoneRule *r0 = (TimeZoneRule*)fFinalRules-\u003eelementAt(0);\n                TimeZoneRule *r1 = (TimeZoneRule*)fFinalRules-\u003eelementAt(1);\n                UDate start0, start1;\n                UBool avail0 = r0-\u003egetPreviousStart(base, r1-\u003egetRawOffset(), r1-\u003egetDSTSavings(), inclusive, start0);\n                UBool avail1 = r1-\u003egetPreviousStart(base, r0-\u003egetRawOffset(), r0-\u003egetDSTSavings(), inclusive, start1);\n                //  avail0/avail1 should be always TRUE\n                if (!avail0 \u0026\u0026 !avail1) {\n                    return FALSE;\n                }\n                if (!avail1 || start0 \u003e start1) {\n                    result.time = start0;\n                    result.from = r1;\n                    result.to = r0;\n                } else {\n                    result.time = start1;\n                    result.from = r0;\n                    result.to = r1;\n                }\n            } else {\n                result = *tzt;\n            }\n            found = TRUE;\n        } else {\n            // Find a transition within the historic transitions\n            idx--;\n            while (idx \u003e= 0) {\n                tzt = (Transition*)fHistoricTransitions-\u003eelementAt(idx);\n                tt = tzt-\u003etime;\n                if (tt \u003c base || (inclusive \u0026\u0026 tt == base)) {\n                    break;\n                }\n                idx--;\n            }\n            result = *tzt;\n            found = TRUE;\n        }\n    }\n    if (found) {\n        // For now, this implementation ignore transitions with only zone name changes.\n        if (result.from-\u003egetRawOffset() == result.to-\u003egetRawOffset()\n            \u0026\u0026 result.from-\u003egetDSTSavings() == result.to-\u003egetDSTSavings()) {\n            // No offset changes.  Try next one if not final\n            return findPrev(result.time, FALSE /* always exclusive */,\n                transitionTime, fromRule, toRule);\n        }\n        transitionTime = result.time;\n        fromRule = result.from;\n        toRule = result.to;\n        return TRUE;\n    }\n    return FALSE;\n}\n\nUDate\nRuleBasedTimeZone::getTransitionTime(Transition* transition, UBool local,\n                                     int32_t NonExistingTimeOpt, int32_t DuplicatedTimeOpt) const {\n    UDate time = transition-\u003etime;\n    if (local) {\n        time += getLocalDelta(transition-\u003efrom-\u003egetRawOffset(), transition-\u003efrom-\u003egetDSTSavings(),\n                              transition-\u003eto-\u003egetRawOffset(), transition-\u003eto-\u003egetDSTSavings(),\n                              NonExistingTimeOpt, DuplicatedTimeOpt);\n    }\n    return time;\n}\n\nint32_t\nRuleBasedTimeZone::getLocalDelta(int32_t rawBefore, int32_t dstBefore, int32_t rawAfter, int32_t dstAfter,\n                             int32_t NonExistingTimeOpt, int32_t DuplicatedTimeOpt) const {\n    int32_t delta = 0;\n\n    int32_t offsetBefore = rawBefore + dstBefore;\n    int32_t offsetAfter = rawAfter + dstAfter;\n\n    UBool dstToStd = (dstBefore != 0) \u0026\u0026 (dstAfter == 0);\n    UBool stdToDst = (dstBefore == 0) \u0026\u0026 (dstAfter != 0);\n\n    if (offsetAfter - offsetBefore \u003e= 0) {\n        // Positive transition, which makes a non-existing local time range\n        if (((NonExistingTimeOpt \u0026 kStdDstMask) == kStandard \u0026\u0026 dstToStd)\n                || ((NonExistingTimeOpt \u0026 kStdDstMask) == kDaylight \u0026\u0026 stdToDst)) {\n            delta = offsetBefore;\n        } else if (((NonExistingTimeOpt \u0026 kStdDstMask) == kStandard \u0026\u0026 stdToDst)\n                || ((NonExistingTimeOpt \u0026 kStdDstMask) == kDaylight \u0026\u0026 dstToStd)) {\n            delta = offsetAfter;\n        } else if ((NonExistingTimeOpt \u0026 kFormerLatterMask) == kLatter) {\n            delta = offsetBefore;\n        } else {\n            // Interprets the time with rule before the transition,\n            // default for non-existing time range\n            delta = offsetAfter;\n        }\n    } else {\n        // Negative transition, which makes a duplicated local time range\n        if (((DuplicatedTimeOpt \u0026 kStdDstMask) == kStandard \u0026\u0026 dstToStd)\n                || ((DuplicatedTimeOpt \u0026 kStdDstMask) == kDaylight \u0026\u0026 stdToDst)) {\n            delta = offsetAfter;\n        } else if (((DuplicatedTimeOpt \u0026 kStdDstMask) == kStandard \u0026\u0026 stdToDst)\n                || ((DuplicatedTimeOpt \u0026 kStdDstMask) == kDaylight \u0026\u0026 dstToStd)) {\n            delta = offsetBefore;\n        } else if ((DuplicatedTimeOpt \u0026 kFormerLatterMask) == kFormer) {\n            delta = offsetBefore;\n        } else {\n            // Interprets the time with rule after the transition,\n            // default for duplicated local time range\n            delta = offsetAfter;\n        }\n    }\n    return delta;\n}\n\nU_NAMESPACE_END\n\n#endif /* #if !UCONFIG_NO_FORMATTING */\n\n//eof\n\n"}
{"repo_name":"carvalhomb/tsmells","ref":"refs/heads/master","path":"sample/poco/poco/Net/src/ICMPPacket.cpp","copies":"1","language":"C++","content":"//\n// ICMPPacket.cpp\n//\n// $Id: //poco/svn/Net/src/ICMPPacket.cpp#2 $\n//\n// Library: Net\n// Package: ICMP\n// Module:  ICMPPacket\n//\n// Copyright (c) 2006, Applied Informatics Software Engineering GmbH.\n// and Contributors.\n//\n// Permission is hereby granted, free of charge, to any person or organization\n// obtaining a copy of the software and accompanying documentation covered by\n// this license (the \"Software\") to use, reproduce, display, distribute,\n// execute, and transmit the Software, and to prepare derivative works of the\n// Software, and to permit third-parties to whom the Software is furnished to\n// do so, all subject to the following:\n// \n// The copyright notices in the Software and this entire statement, including\n// the above license grant, this restriction and the following disclaimer,\n// must be included in all copies of the Software, in whole or in part, and\n// all derivative works of the Software, unless such copies or derivative\n// works are solely in the form of machine-executable object code generated by\n// a source language processor.\n// \n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT\n// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE\n// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,\n// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n// DEALINGS IN THE SOFTWARE.\n//\n\n\n#include \"Poco/Net/ICMPPacket.h\"\n#include \"Poco/Net/ICMPv4PacketImpl.h\"\n#include \"Poco/Net/NetException.h\"\n#include \"Poco/Timestamp.h\"\n#include \"Poco/Timespan.h\"\n#include \"Poco/Process.h\"\n#include \"Poco/NumberFormatter.h\"\n#include \u003csstream\u003e\n\n\nusing Poco::InvalidArgumentException;\nusing Poco::NotImplementedException;\nusing Poco::Timestamp;\nusing Poco::Timespan;\nusing Poco::Process;\nusing Poco::NumberFormatter;\nusing Poco::UInt8;\nusing Poco::UInt16;\nusing Poco::Int32;\n\n\nnamespace Poco {\nnamespace Net {\n\n\nICMPPacket::ICMPPacket(IPAddress::Family family, int dataSize):_pImpl(0)\n{\n\tif (family == IPAddress::IPv4)\n\t\t_pImpl = new ICMPv4PacketImpl(dataSize);\n#if POCO_HAVE_IPv6\n\telse if (family == IPAddress::IPv6)\n\t\tthrow NotImplementedException(\"ICMPv6 packets not implemented.\");\n#endif\n\telse throw InvalidArgumentException(\"Invalid or unsupported address family passed to ICMPPacket\");\n}\n\n\nICMPPacket::~ICMPPacket()\n{\n\tdelete _pImpl;\n}\n\n\nvoid ICMPPacket::setDataSize(int dataSize)\n{\n\t_pImpl-\u003esetDataSize(dataSize);\n}\n\n\nint ICMPPacket::getDataSize() const\n{\n\treturn _pImpl-\u003egetDataSize();\n}\n\n\nint ICMPPacket::packetSize() const\n{\n\treturn _pImpl-\u003epacketSize();\n}\n\n\nint ICMPPacket::maxPacketSize() const\n{\n\treturn _pImpl-\u003emaxPacketSize();\n}\n\n\nconst Poco::UInt8* ICMPPacket::packet()\n{\n\treturn _pImpl-\u003epacket();\n}\n\n\nstruct timeval ICMPPacket::time(Poco::UInt8* buffer, int length) const\n{\n\treturn _pImpl-\u003etime(buffer, length);\n}\n\n\nbool ICMPPacket::validReplyID(Poco::UInt8* buffer, int length) const\n{\n\treturn _pImpl-\u003evalidReplyID(buffer, length);\n}\n\n\nstd::string ICMPPacket::errorDescription(Poco::UInt8* buffer, int length)\n{\n\treturn _pImpl-\u003eerrorDescription(buffer, length);\n}\n\n\nstd::string ICMPPacket::typeDescription(int typeId)\n{\n\treturn _pImpl-\u003etypeDescription(typeId);\n}\n\n\n} } // namespace Poco::Net\n"}
{"repo_name":"carvalhomb/tsmells","ref":"refs/heads/master","path":"sample/poco/poco/Foundation/testsuite/src/UniqueExpireCacheTest.cpp","copies":"1","language":"C++","content":"//\n// UniqueExpireCacheTest.cpp\n//\n// $Id: //poco/svn/Foundation/testsuite/src/UniqueExpireCacheTest.cpp#2 $\n//\n// Copyright (c) 2006, Applied Informatics Software Engineering GmbH.\n// and Contributors.\n//\n// Permission is hereby granted, free of charge, to any person or organization\n// obtaining a copy of the software and accompanying documentation covered by\n// this license (the \"Software\") to use, reproduce, display, distribute,\n// execute, and transmit the Software, and to prepare derivative works of the\n// Software, and to permit third-parties to whom the Software is furnished to\n// do so, all subject to the following:\n// \n// The copyright notices in the Software and this entire statement, including\n// the above license grant, this restriction and the following disclaimer,\n// must be included in all copies of the Software, in whole or in part, and\n// all derivative works of the Software, unless such copies or derivative\n// works are solely in the form of machine-executable object code generated by\n// a source language processor.\n// \n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT\n// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE\n// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,\n// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n// DEALINGS IN THE SOFTWARE.\n//\n\n\n#include \"UniqueExpireCacheTest.h\"\n#include \"CppUnit/TestCaller.h\"\n#include \"CppUnit/TestSuite.h\"\n#include \"Poco/Exception.h\"\n#include \"Poco/UniqueExpireCache.h\"\n#include \"Poco/UniqueAccessExpireCache.h\"\n#include \"Poco/ExpirationDecorator.h\"\n#include \"Poco/AccessExpirationDecorator.h\"\n#include \"Poco/Bugcheck.h\"\n#include \"Poco/Thread.h\"\n\n\nusing namespace Poco;\n\n\nstruct IntVal\n{\n\tint value;\n\tPoco::Timestamp validUntil;\n\tIntVal(int val, Poco::Timestamp::TimeDiff v):value(val), validUntil()\n\t{\n\t\tvalidUntil += (v*1000);\n\t}\n\n\tconst Poco::Timestamp\u0026 getExpiration() const\n\t{\n\t\treturn validUntil;\n\t}\n};\n\ntypedef AccessExpirationDecorator\u003cint\u003e DIntVal;\n\n#define DURSLEEP 250\n#define DURHALFSLEEP DURSLEEP / 2\n#define DURWAIT  300\n\n\nUniqueExpireCacheTest::UniqueExpireCacheTest(const std::string\u0026 name): CppUnit::TestCase(name)\n{\n}\n\n\nUniqueExpireCacheTest::~UniqueExpireCacheTest()\n{\n}\n\n\nvoid UniqueExpireCacheTest::testClear()\n{\n\tUniqueExpireCache\u003cint, IntVal\u003e aCache;\n\taCache.add(1, IntVal(2, DURSLEEP));\n\taCache.add(3, IntVal(4, DURSLEEP));\n\taCache.add(5, IntVal(6, DURSLEEP));\n\tassert (aCache.has(1));\n\tassert (aCache.has(3));\n\tassert (aCache.has(5));\n\tassert (aCache.get(1)-\u003evalue == 2);\n\tassert (aCache.get(3)-\u003evalue == 4);\n\tassert (aCache.get(5)-\u003evalue == 6);\n\taCache.clear();\n\tassert (!aCache.has(1));\n\tassert (!aCache.has(3));\n\tassert (!aCache.has(5));\n}\n\n\nvoid UniqueExpireCacheTest::testAccessClear()\n{\n\tUniqueAccessExpireCache\u003cint, DIntVal\u003e aCache;\n\taCache.add(1, DIntVal(2, DURSLEEP));\n\taCache.add(3, DIntVal(4, DURSLEEP));\n\taCache.add(5, DIntVal(6, DURSLEEP));\n\tassert (aCache.has(1));\n\tassert (aCache.has(3));\n\tassert (aCache.has(5));\n\tassert (aCache.get(1)-\u003evalue() == 2);\n\tassert (aCache.get(3)-\u003evalue() == 4);\n\tassert (aCache.get(5)-\u003evalue() == 6);\n\taCache.clear();\n\tassert (!aCache.has(1));\n\tassert (!aCache.has(3));\n\tassert (!aCache.has(5));\n}\n\n\nvoid UniqueExpireCacheTest::testAccessUpdate()\n{\n\tUniqueAccessExpireCache\u003cint, DIntVal\u003e aCache;\n\taCache.add(1, DIntVal(2, DURSLEEP));\n\taCache.add(3, DIntVal(4, DURSLEEP));\n\taCache.add(5, DIntVal(6, DURSLEEP));\n\tassert (aCache.has(1));\n\tassert (aCache.has(3));\n\tassert (aCache.has(5));\n\tassert (aCache.get(1)-\u003evalue() == 2);\n\tThread::sleep(DURSLEEP/2);\n\tassert (aCache.get(1)-\u003evalue() == 2);\n\tThread::sleep(DURSLEEP/2);\n\tassert (aCache.get(1)-\u003evalue() == 2);\n\tThread::sleep(DURSLEEP/2);\n\tassert (aCache.get(1)-\u003evalue() == 2);\n\tassert (!aCache.has(3));\n\tassert (!aCache.has(5));\n\tThread::sleep(DURSLEEP*2);\n\t\n\tassert (!aCache.has(1));\n\tassert (!aCache.has(3));\n\tassert (!aCache.has(5));\n\taCache.remove(666); //must work too\n}\n\n\nvoid UniqueExpireCacheTest::testExpire0()\n{\n\tUniqueExpireCache\u003cint, IntVal\u003e aCache;\n\taCache.add(1, IntVal(2, 0));\n\tassert (!aCache.has(1));\n}\n\n\n\nvoid UniqueExpireCacheTest::testAccessExpire0()\n{\n\tUniqueAccessExpireCache\u003cint, DIntVal\u003e aCache;\n\taCache.add(1, DIntVal(2, Timespan(0, 0)));\n\tassert (!aCache.has(1));\n}\n\n\nvoid UniqueExpireCacheTest::testExpireN()\n{\n\t// 3-1 represents the cache sorted by age, elements get replaced at the end of the list\n\t// 3-1|5 -\u003e 5 gets removed\n\tUniqueExpireCache\u003cint, IntVal\u003e aCache;\n\taCache.add(1, IntVal(2, DURSLEEP)); // 1\n\tassert (aCache.has(1));\n\tSharedPtr\u003cIntVal\u003e tmp = aCache.get(1);\n\tassert (!tmp.isNull());\n\tassert (tmp-\u003evalue == 2);\n\tThread::sleep(DURWAIT);\n\tassert (!aCache.has(1));\n\n\t// tmp must still be valid, access it\n\tassert (tmp-\u003evalue == 2);\n\ttmp = aCache.get(1);\n\tassert (tmp.isNull());\n\n\taCache.add(1, IntVal(2, DURSLEEP)); // 1\n\tThread::sleep(DURHALFSLEEP);\n\taCache.add(3, IntVal(4, DURSLEEP)); // 3-1\n\tassert (aCache.has(1));\n\tassert (aCache.has(3));\n\ttmp = aCache.get(1);\n\tSharedPtr\u003cIntVal\u003e tmp2 = aCache.get(3);\n\tassert (tmp-\u003evalue == 2); \n\tassert (tmp2-\u003evalue == 4);\n\n\tThread::sleep(DURHALFSLEEP+25); //3|1\n\tassert (!aCache.has(1));\n\tassert (aCache.has(3));\n\tassert (tmp-\u003evalue == 2); // 1-3\n\tassert (tmp2-\u003evalue == 4); // 3-1\n\ttmp2 = aCache.get(3);\n\tassert (tmp2-\u003evalue == 4);\n\tThread::sleep(DURHALFSLEEP+25); //3|1\n\tassert (!aCache.has(3));\n\tassert (tmp2-\u003evalue == 4);\n\ttmp = aCache.get(1);\n\ttmp2 = aCache.get(3);\n\tassert (!tmp);\n\tassert (!tmp2);\n\n\t// removing illegal entries should work too\n\taCache.remove(666);\n\n\taCache.clear();\n\tassert (!aCache.has(5));\n\tassert (!aCache.has(3));\n}\n\n\nvoid UniqueExpireCacheTest::testDuplicateAdd()\n{\n\tUniqueExpireCache\u003cint, IntVal\u003e aCache;\n\taCache.add(1, IntVal(2, DURSLEEP)); // 1\n\tassert (aCache.has(1));\n\tassert (aCache.get(1)-\u003evalue == 2);\n\taCache.add(1, IntVal(3, DURSLEEP));\n\tassert (aCache.has(1));\n\tassert (aCache.get(1)-\u003evalue == 3);\n}\n\n\nvoid UniqueExpireCacheTest::testAccessDuplicateAdd()\n{\n\tUniqueAccessExpireCache\u003cint, DIntVal\u003e aCache;\n\taCache.add(1, DIntVal(2, DURSLEEP)); // 1\n\tassert (aCache.has(1));\n\tassert (aCache.get(1)-\u003evalue() == 2);\n\taCache.add(1, DIntVal(3, DURSLEEP));\n\tassert (aCache.has(1));\n\tassert (aCache.get(1)-\u003evalue() == 3);\n}\n\n\nvoid UniqueExpireCacheTest::testExpirationDecorator()\n{\n\ttypedef ExpirationDecorator\u003cint\u003e ExpireInt;\n\tUniqueExpireCache\u003cint, ExpireInt\u003e aCache;\n\taCache.add(1, ExpireInt(2, DURSLEEP)); // 1\n\tassert (aCache.has(1));\n\tassert (aCache.get(1)-\u003evalue() == 2);\n\taCache.add(1, ExpireInt(3, DURSLEEP));\n\tassert (aCache.has(1));\n\tassert (aCache.get(1)-\u003evalue() == 3);\n}\n\n\nvoid UniqueExpireCacheTest::setUp()\n{\n}\n\n\nvoid UniqueExpireCacheTest::tearDown()\n{\n}\n\n\nCppUnit::Test* UniqueExpireCacheTest::suite()\n{\n\tCppUnit::TestSuite* pSuite = new CppUnit::TestSuite(\"UniqueExpireCacheTest\");\n\n\tCppUnit_addTest(pSuite, UniqueExpireCacheTest, testClear);\n\tCppUnit_addTest(pSuite, UniqueExpireCacheTest, testAccessClear);\n\tCppUnit_addTest(pSuite, UniqueExpireCacheTest, testAccessUpdate);\n\tCppUnit_addTest(pSuite, UniqueExpireCacheTest, testExpire0);\n\tCppUnit_addTest(pSuite, UniqueExpireCacheTest, testAccessExpire0);\n\tCppUnit_addTest(pSuite, UniqueExpireCacheTest, testExpireN);\n\tCppUnit_addTest(pSuite, UniqueExpireCacheTest, testDuplicateAdd);\n\tCppUnit_addTest(pSuite, UniqueExpireCacheTest, testAccessDuplicateAdd);\n\tCppUnit_addTest(pSuite, UniqueExpireCacheTest, testExpirationDecorator);\n\n\treturn pSuite;\n}\n"}
{"repo_name":"mapmapteam/mapmap","ref":"refs/heads/develop","path":"src/gui/contrib/qtpropertybrowser/src/qtpropertybrowserutils.cpp","copies":"39","language":"C++","content":"/****************************************************************************\n**\n** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies).\n** Contact: http://www.qt-project.org/legal\n**\n** This file is part of the Qt Solutions component.\n**\n** $QT_BEGIN_LICENSE:BSD$\n** You may use this file under the terms of the BSD license as follows:\n**\n** \"Redistribution and use in source and binary forms, with or without\n** modification, are permitted provided that the following conditions are\n** met:\n**   * Redistributions of source code must retain the above copyright\n**     notice, this list of conditions and the following disclaimer.\n**   * Redistributions in binary form must reproduce the above copyright\n**     notice, this list of conditions and the following disclaimer in\n**     the documentation and/or other materials provided with the\n**     distribution.\n**   * Neither the name of Digia Plc and its Subsidiary(-ies) nor the names\n**     of its contributors may be used to endorse or promote products derived\n**     from this software without specific prior written permission.\n**\n**\n** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n** \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n** OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n** LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\"\n**\n** $QT_END_LICENSE$\n**\n****************************************************************************/\n\n\n#include \"qtpropertybrowserutils_p.h\"\n#include \u003cQApplication\u003e\n#include \u003cQPainter\u003e\n#include \u003cQHBoxLayout\u003e\n#include \u003cQMouseEvent\u003e\n#include \u003cQCheckBox\u003e\n#include \u003cQLineEdit\u003e\n#include \u003cQMenu\u003e\n#include \u003cQStyleOption\u003e\n\n#if QT_VERSION \u003e= 0x040400\nQT_BEGIN_NAMESPACE\n#endif\n\nQtCursorDatabase::QtCursorDatabase()\n{\n    appendCursor(Qt::ArrowCursor, QCoreApplication::translate(\"QtCursorDatabase\", \"Arrow\"),\n                 QIcon(QLatin1String(\":/qt-project.org/qtpropertybrowser/images/cursor-arrow.png\")));\n    appendCursor(Qt::UpArrowCursor, QCoreApplication::translate(\"QtCursorDatabase\", \"Up Arrow\"),\n                 QIcon(QLatin1String(\":/qt-project.org/qtpropertybrowser/images/cursor-uparrow.png\")));\n    appendCursor(Qt::CrossCursor, QCoreApplication::translate(\"QtCursorDatabase\", \"Cross\"),\n                 QIcon(QLatin1String(\":/qt-project.org/qtpropertybrowser/images/cursor-cross.png\")));\n    appendCursor(Qt::WaitCursor, QCoreApplication::translate(\"QtCursorDatabase\", \"Wait\"),\n                 QIcon(QLatin1String(\":/qt-project.org/qtpropertybrowser/images/cursor-wait.png\")));\n    appendCursor(Qt::IBeamCursor, QCoreApplication::translate(\"QtCursorDatabase\", \"IBeam\"),\n                 QIcon(QLatin1String(\":/qt-project.org/qtpropertybrowser/images/cursor-ibeam.png\")));\n    appendCursor(Qt::SizeVerCursor, QCoreApplication::translate(\"QtCursorDatabase\", \"Size Vertical\"),\n                 QIcon(QLatin1String(\":/qt-project.org/qtpropertybrowser/images/cursor-sizev.png\")));\n    appendCursor(Qt::SizeHorCursor, QCoreApplication::translate(\"QtCursorDatabase\", \"Size Horizontal\"),\n                 QIcon(QLatin1String(\":/qt-project.org/qtpropertybrowser/images/cursor-sizeh.png\")));\n    appendCursor(Qt::SizeFDiagCursor, QCoreApplication::translate(\"QtCursorDatabase\", \"Size Backslash\"),\n                 QIcon(QLatin1String(\":/qt-project.org/qtpropertybrowser/images/cursor-sizef.png\")));\n    appendCursor(Qt::SizeBDiagCursor, QCoreApplication::translate(\"QtCursorDatabase\", \"Size Slash\"),\n                 QIcon(QLatin1String(\":/qt-project.org/qtpropertybrowser/images/cursor-sizeb.png\")));\n    appendCursor(Qt::SizeAllCursor, QCoreApplication::translate(\"QtCursorDatabase\", \"Size All\"),\n                 QIcon(QLatin1String(\":/qt-project.org/qtpropertybrowser/images/cursor-sizeall.png\")));\n    appendCursor(Qt::BlankCursor, QCoreApplication::translate(\"QtCursorDatabase\", \"Blank\"),\n                 QIcon());\n    appendCursor(Qt::SplitVCursor, QCoreApplication::translate(\"QtCursorDatabase\", \"Split Vertical\"),\n                 QIcon(QLatin1String(\":/qt-project.org/qtpropertybrowser/images/cursor-vsplit.png\")));\n    appendCursor(Qt::SplitHCursor, QCoreApplication::translate(\"QtCursorDatabase\", \"Split Horizontal\"),\n                 QIcon(QLatin1String(\":/qt-project.org/qtpropertybrowser/images/cursor-hsplit.png\")));\n    appendCursor(Qt::PointingHandCursor, QCoreApplication::translate(\"QtCursorDatabase\", \"Pointing Hand\"),\n                 QIcon(QLatin1String(\":/qt-project.org/qtpropertybrowser/images/cursor-hand.png\")));\n    appendCursor(Qt::ForbiddenCursor, QCoreApplication::translate(\"QtCursorDatabase\", \"Forbidden\"),\n                 QIcon(QLatin1String(\":/qt-project.org/qtpropertybrowser/images/cursor-forbidden.png\")));\n    appendCursor(Qt::OpenHandCursor, QCoreApplication::translate(\"QtCursorDatabase\", \"Open Hand\"),\n                 QIcon(QLatin1String(\":/qt-project.org/qtpropertybrowser/images/cursor-openhand.png\")));\n    appendCursor(Qt::ClosedHandCursor, QCoreApplication::translate(\"QtCursorDatabase\", \"Closed Hand\"),\n                 QIcon(QLatin1String(\":/qt-project.org/qtpropertybrowser/images/cursor-closedhand.png\")));\n    appendCursor(Qt::WhatsThisCursor, QCoreApplication::translate(\"QtCursorDatabase\", \"What's This\"),\n                 QIcon(QLatin1String(\":/qt-project.org/qtpropertybrowser/images/cursor-whatsthis.png\")));\n    appendCursor(Qt::BusyCursor, QCoreApplication::translate(\"QtCursorDatabase\", \"Busy\"),\n                 QIcon(QLatin1String(\":/qt-project.org/qtpropertybrowser/images/cursor-busy.png\")));\n}\n\nvoid QtCursorDatabase::clear()\n{\n    m_cursorNames.clear();\n    m_cursorIcons.clear();\n    m_valueToCursorShape.clear();\n    m_cursorShapeToValue.clear();\n}\n\nvoid QtCursorDatabase::appendCursor(Qt::CursorShape shape, const QString \u0026name, const QIcon \u0026icon)\n{\n    if (m_cursorShapeToValue.contains(shape))\n        return;\n    const int value = m_cursorNames.count();\n    m_cursorNames.append(name);\n    m_cursorIcons.insert(value, icon);\n    m_valueToCursorShape.insert(value, shape);\n    m_cursorShapeToValue.insert(shape, value);\n}\n\nQStringList QtCursorDatabase::cursorShapeNames() const\n{\n    return m_cursorNames;\n}\n\nQMap\u003cint, QIcon\u003e QtCursorDatabase::cursorShapeIcons() const\n{\n    return m_cursorIcons;\n}\n\nQString QtCursorDatabase::cursorToShapeName(const QCursor \u0026cursor) const\n{\n    int val = cursorToValue(cursor);\n    if (val \u003e= 0)\n        return m_cursorNames.at(val);\n    return QString();\n}\n\nQIcon QtCursorDatabase::cursorToShapeIcon(const QCursor \u0026cursor) const\n{\n    int val = cursorToValue(cursor);\n    return m_cursorIcons.value(val);\n}\n\nint QtCursorDatabase::cursorToValue(const QCursor \u0026cursor) const\n{\n#ifndef QT_NO_CURSOR\n    Qt::CursorShape shape = cursor.shape();\n    if (m_cursorShapeToValue.contains(shape))\n        return m_cursorShapeToValue[shape];\n#endif\n    return -1;\n}\n\n#ifndef QT_NO_CURSOR\nQCursor QtCursorDatabase::valueToCursor(int value) const\n{\n    if (m_valueToCursorShape.contains(value))\n        return QCursor(m_valueToCursorShape[value]);\n    return QCursor();\n}\n#endif\n\nQPixmap QtPropertyBrowserUtils::brushValuePixmap(const QBrush \u0026b)\n{\n    QImage img(16, 16, QImage::Format_ARGB32_Premultiplied);\n    img.fill(0);\n\n    QPainter painter(\u0026img);\n    painter.setCompositionMode(QPainter::CompositionMode_Source);\n    painter.fillRect(0, 0, img.width(), img.height(), b);\n    QColor color = b.color();\n    if (color.alpha() != 255) { // indicate alpha by an inset\n        QBrush  opaqueBrush = b;\n        color.setAlpha(255);\n        opaqueBrush.setColor(color);\n        painter.fillRect(img.width() / 4, img.height() / 4,\n                         img.width() / 2, img.height() / 2, opaqueBrush);\n    }\n    painter.end();\n    return QPixmap::fromImage(img);\n}\n\nQIcon QtPropertyBrowserUtils::brushValueIcon(const QBrush \u0026b)\n{\n    return QIcon(brushValuePixmap(b));\n}\n\nQString QtPropertyBrowserUtils::colorValueText(const QColor \u0026c)\n{\n    return QCoreApplication::translate(\"QtPropertyBrowserUtils\", \"[%1, %2, %3] (%4)\")\n           .arg(c.red()).arg(c.green()).arg(c.blue()).arg(c.alpha());\n}\n\nQPixmap QtPropertyBrowserUtils::fontValuePixmap(const QFont \u0026font)\n{\n    QFont f = font;\n    QImage img(16, 16, QImage::Format_ARGB32_Premultiplied);\n    img.fill(0);\n    QPainter p(\u0026img);\n    p.setRenderHint(QPainter::TextAntialiasing, true);\n    p.setRenderHint(QPainter::Antialiasing, true);\n    f.setPointSize(13);\n    p.setFont(f);\n    QTextOption t;\n    t.setAlignment(Qt::AlignCenter);\n    p.drawText(QRect(0, 0, 16, 16), QString(QLatin1Char('A')), t);\n    return QPixmap::fromImage(img);\n}\n\nQIcon QtPropertyBrowserUtils::fontValueIcon(const QFont \u0026f)\n{\n    return QIcon(fontValuePixmap(f));\n}\n\nQString QtPropertyBrowserUtils::fontValueText(const QFont \u0026f)\n{\n    return QCoreApplication::translate(\"QtPropertyBrowserUtils\", \"[%1, %2]\")\n           .arg(f.family()).arg(f.pointSize());\n}\n\n\nQtBoolEdit::QtBoolEdit(QWidget *parent) :\n    QWidget(parent),\n    m_checkBox(new QCheckBox(this)),\n    m_textVisible(true)\n{\n    QHBoxLayout *lt = new QHBoxLayout;\n    if (QApplication::layoutDirection() == Qt::LeftToRight)\n        lt-\u003esetContentsMargins(4, 0, 0, 0);\n    else\n        lt-\u003esetContentsMargins(0, 0, 4, 0);\n    lt-\u003eaddWidget(m_checkBox);\n    setLayout(lt);\n    connect(m_checkBox, SIGNAL(toggled(bool)), this, SIGNAL(toggled(bool)));\n    setFocusProxy(m_checkBox);\n    m_checkBox-\u003esetText(tr(\"True\"));\n}\n\nvoid QtBoolEdit::setTextVisible(bool textVisible)\n{\n    if (m_textVisible == textVisible)\n        return;\n\n    m_textVisible = textVisible;\n    if (m_textVisible)\n        m_checkBox-\u003esetText(isChecked() ? tr(\"True\") : tr(\"False\"));\n    else\n        m_checkBox-\u003esetText(QString());\n}\n\nQt::CheckState QtBoolEdit::checkState() const\n{\n    return m_checkBox-\u003echeckState();\n}\n\nvoid QtBoolEdit::setCheckState(Qt::CheckState state)\n{\n    m_checkBox-\u003esetCheckState(state);\n}\n\nbool QtBoolEdit::isChecked() const\n{\n    return m_checkBox-\u003eisChecked();\n}\n\nvoid QtBoolEdit::setChecked(bool c)\n{\n    m_checkBox-\u003esetChecked(c);\n    if (!m_textVisible)\n        return;\n    m_checkBox-\u003esetText(isChecked() ? tr(\"True\") : tr(\"False\"));\n}\n\nbool QtBoolEdit::blockCheckBoxSignals(bool block)\n{\n    return m_checkBox-\u003eblockSignals(block);\n}\n\nvoid QtBoolEdit::mousePressEvent(QMouseEvent *event)\n{\n    if (event-\u003ebuttons() == Qt::LeftButton) {\n        m_checkBox-\u003eclick();\n        event-\u003eaccept();\n    } else {\n        QWidget::mousePressEvent(event);\n    }\n}\n\nvoid QtBoolEdit::paintEvent(QPaintEvent *)\n{\n    QStyleOption opt;\n    opt.init(this);\n    QPainter p(this);\n    style()-\u003edrawPrimitive(QStyle::PE_Widget, \u0026opt, \u0026p, this);\n}\n\n\n\nQtKeySequenceEdit::QtKeySequenceEdit(QWidget *parent)\n    : QWidget(parent), m_num(0), m_lineEdit(new QLineEdit(this))\n{\n    QHBoxLayout *layout = new QHBoxLayout(this);\n    layout-\u003eaddWidget(m_lineEdit);\n    layout-\u003esetMargin(0);\n    m_lineEdit-\u003einstallEventFilter(this);\n    m_lineEdit-\u003esetReadOnly(true);\n    m_lineEdit-\u003esetFocusProxy(this);\n    setFocusPolicy(m_lineEdit-\u003efocusPolicy());\n    setAttribute(Qt::WA_InputMethodEnabled);\n}\n\nbool QtKeySequenceEdit::eventFilter(QObject *o, QEvent *e)\n{\n    if (o == m_lineEdit \u0026\u0026 e-\u003etype() == QEvent::ContextMenu) {\n        QContextMenuEvent *c = static_cast\u003cQContextMenuEvent *\u003e(e);\n        QMenu *menu = m_lineEdit-\u003ecreateStandardContextMenu();\n        const QList\u003cQAction *\u003e actions = menu-\u003eactions();\n        QListIterator\u003cQAction *\u003e itAction(actions);\n        while (itAction.hasNext()) {\n            QAction *action = itAction.next();\n            action-\u003esetShortcut(QKeySequence());\n            QString actionString = action-\u003etext();\n            const int pos = actionString.lastIndexOf(QLatin1Char('\\t'));\n            if (pos \u003e 0)\n                actionString.remove(pos, actionString.length() - pos);\n            action-\u003esetText(actionString);\n        }\n        QAction *actionBefore = 0;\n        if (actions.count() \u003e 0)\n            actionBefore = actions[0];\n        QAction *clearAction = new QAction(tr(\"Clear Shortcut\"), menu);\n        menu-\u003einsertAction(actionBefore, clearAction);\n        menu-\u003einsertSeparator(actionBefore);\n        clearAction-\u003esetEnabled(!m_keySequence.isEmpty());\n        connect(clearAction, SIGNAL(triggered()), this, SLOT(slotClearShortcut()));\n        menu-\u003eexec(c-\u003eglobalPos());\n        delete menu;\n        e-\u003eaccept();\n        return true;\n    }\n\n    return QWidget::eventFilter(o, e);\n}\n\nvoid QtKeySequenceEdit::slotClearShortcut()\n{\n    if (m_keySequence.isEmpty())\n        return;\n    setKeySequence(QKeySequence());\n    emit keySequenceChanged(m_keySequence);\n}\n\nvoid QtKeySequenceEdit::handleKeyEvent(QKeyEvent *e)\n{\n    int nextKey = e-\u003ekey();\n    if (nextKey == Qt::Key_Control || nextKey == Qt::Key_Shift ||\n            nextKey == Qt::Key_Meta || nextKey == Qt::Key_Alt ||\n            nextKey == Qt::Key_Super_L || nextKey == Qt::Key_AltGr)\n        return;\n\n    nextKey |= translateModifiers(e-\u003emodifiers(), e-\u003etext());\n    int k0 = m_keySequence[0];\n    int k1 = m_keySequence[1];\n    int k2 = m_keySequence[2];\n    int k3 = m_keySequence[3];\n    switch (m_num) {\n        case 0: k0 = nextKey; k1 = 0; k2 = 0; k3 = 0; break;\n        case 1: k1 = nextKey; k2 = 0; k3 = 0; break;\n        case 2: k2 = nextKey; k3 = 0; break;\n        case 3: k3 = nextKey; break;\n        default: break;\n    }\n    ++m_num;\n    if (m_num \u003e 3)\n        m_num = 0;\n    m_keySequence = QKeySequence(k0, k1, k2, k3);\n    m_lineEdit-\u003esetText(m_keySequence.toString(QKeySequence::NativeText));\n    e-\u003eaccept();\n    emit keySequenceChanged(m_keySequence);\n}\n\nvoid QtKeySequenceEdit::setKeySequence(const QKeySequence \u0026sequence)\n{\n    if (sequence == m_keySequence)\n        return;\n    m_num = 0;\n    m_keySequence = sequence;\n    m_lineEdit-\u003esetText(m_keySequence.toString(QKeySequence::NativeText));\n}\n\nQKeySequence QtKeySequenceEdit::keySequence() const\n{\n    return m_keySequence;\n}\n\nint QtKeySequenceEdit::translateModifiers(Qt::KeyboardModifiers state, const QString \u0026text) const\n{\n    int result = 0;\n    if ((state \u0026 Qt::ShiftModifier) \u0026\u0026 (text.size() == 0 || !text.at(0).isPrint() || text.at(0).isLetter() || text.at(0).isSpace()))\n        result |= Qt::SHIFT;\n    if (state \u0026 Qt::ControlModifier)\n        result |= Qt::CTRL;\n    if (state \u0026 Qt::MetaModifier)\n        result |= Qt::META;\n    if (state \u0026 Qt::AltModifier)\n        result |= Qt::ALT;\n    return result;\n}\n\nvoid QtKeySequenceEdit::focusInEvent(QFocusEvent *e)\n{\n    m_lineEdit-\u003eevent(e);\n    m_lineEdit-\u003eselectAll();\n    QWidget::focusInEvent(e);\n}\n\nvoid QtKeySequenceEdit::focusOutEvent(QFocusEvent *e)\n{\n    m_num = 0;\n    m_lineEdit-\u003eevent(e);\n    QWidget::focusOutEvent(e);\n}\n\nvoid QtKeySequenceEdit::keyPressEvent(QKeyEvent *e)\n{\n    handleKeyEvent(e);\n    e-\u003eaccept();\n}\n\nvoid QtKeySequenceEdit::keyReleaseEvent(QKeyEvent *e)\n{\n    m_lineEdit-\u003eevent(e);\n}\n\nvoid QtKeySequenceEdit::paintEvent(QPaintEvent *)\n{\n    QStyleOption opt;\n    opt.init(this);\n    QPainter p(this);\n    style()-\u003edrawPrimitive(QStyle::PE_Widget, \u0026opt, \u0026p, this);\n}\n\nbool QtKeySequenceEdit::event(QEvent *e)\n{\n    if (e-\u003etype() == QEvent::Shortcut ||\n            e-\u003etype() == QEvent::ShortcutOverride  ||\n            e-\u003etype() == QEvent::KeyRelease) {\n        e-\u003eaccept();\n        return true;\n    }\n    return QWidget::event(e);\n}\n\n\n\n\n#if QT_VERSION \u003e= 0x040400\nQT_END_NAMESPACE\n#endif\n"}
{"repo_name":"yantrabuddhi/FreeCAD","ref":"refs/heads/master","path":"src/3rdParty/salomesmesh/src/Driver/Driver_Document.cpp","copies":"29","language":"C++","content":"//  Copyright (C) 2007-2008  CEA/DEN, EDF R\u0026D, OPEN CASCADE\n//\n//  Copyright (C) 2003-2007  OPEN CASCADE, EADS/CCR, LIP6, CEA/DEN,\n//  CEDRAT, EDF R\u0026D, LEG, PRINCIPIA R\u0026D, BUREAU VERITAS\n//\n//  This library is free software; you can redistribute it and/or\n//  modify it under the terms of the GNU Lesser General Public\n//  License as published by the Free Software Foundation; either\n//  version 2.1 of the License.\n//\n//  This library is distributed in the hope that it will be useful,\n//  but WITHOUT ANY WARRANTY; without even the implied warranty of\n//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n//  Lesser General Public License for more details.\n//\n//  You should have received a copy of the GNU Lesser General Public\n//  License along with this library; if not, write to the Free Software\n//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA\n//\n//  See http://www.salome-platform.org/ or email : webmaster.salome@opencascade.com\n//\n#include \"Driver_Document.h\"\n\nDriver_Document::Driver_Document():\n  myDocument(NULL)\n{}\n\n\nvoid Driver_Document::SetFile(const std::string\u0026 theFileName)\n{\n  myFile = theFileName;\n}\n\n\nvoid Driver_Document::SetDocument(SMESHDS_Document * theDocument)\n{\n  myDocument = theDocument;\n}\n"}
{"repo_name":"thivod/forgottenserver","ref":"refs/heads/master","path":"src/trashholder.cpp","copies":"7","language":"C++","content":"/**\n * The Forgotten Server - a free and open-source MMORPG server emulator\n * Copyright (C) 2014  Mark Samman \u003cmark.samman@gmail.com\u003e\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n\n#include \"otpch.h\"\n\n#include \"trashholder.h\"\n#include \"game.h\"\n\nextern Game g_game;\n\nTrashHolder::TrashHolder(uint16_t _type) : Item(_type)\n{\n\t//\n}\n\nTrashHolder::~TrashHolder()\n{\n\t//\n}\n\nReturnValue TrashHolder::__queryAdd(int32_t, const Thing*, uint32_t, uint32_t, Creature*) const\n{\n\treturn RET_NOERROR;\n}\n\nReturnValue TrashHolder::__queryMaxCount(int32_t, const Thing*, uint32_t count, uint32_t\u0026 maxQueryCount, uint32_t) const\n{\n\tmaxQueryCount = std::max\u003cuint32_t\u003e(1, count);\n\treturn RET_NOERROR;\n}\n\nReturnValue TrashHolder::__queryRemove(const Thing*, uint32_t, uint32_t) const\n{\n\treturn RET_NOTPOSSIBLE;\n}\n\nCylinder* TrashHolder::__queryDestination(int32_t\u0026, const Thing*, Item**, uint32_t\u0026)\n{\n\treturn this;\n}\n\nvoid TrashHolder::__addThing(Thing* thing)\n{\n\treturn __addThing(0, thing);\n}\n\nvoid TrashHolder::__addThing(int32_t, Thing* thing)\n{\n\tItem* item = thing-\u003egetItem();\n\tif (!item) {\n\t\treturn;\n\t}\n\n\tif (item == this || !item-\u003ehasProperty(CONST_PROP_MOVEABLE)) {\n\t\treturn;\n\t}\n\n\tif (item-\u003eisHangable() \u0026\u0026 isGroundTile()) {\n\t\tTile* tile = dynamic_cast\u003cTile*\u003e(getParent());\n\t\tif (tile \u0026\u0026 tile-\u003ehasFlag(TILESTATE_SUPPORTS_HANGABLE)) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tg_game.internalRemoveItem(item);\n\n\tconst ItemType\u0026 it = Item::items[getID()];\n\tif (it.magicEffect != CONST_ME_NONE) {\n\t\tg_game.addMagicEffect(getPosition(), it.magicEffect);\n\t}\n}\n\nvoid TrashHolder::__updateThing(Thing*, uint16_t, uint32_t)\n{\n\t//\n}\n\nvoid TrashHolder::__replaceThing(uint32_t, Thing*)\n{\n\t//\n}\n\nvoid TrashHolder::__removeThing(Thing*, uint32_t)\n{\n\t//\n}\n\nvoid TrashHolder::postAddNotification(Thing* thing, const Cylinder* oldParent, int32_t index, cylinderlink_t)\n{\n\tgetParent()-\u003epostAddNotification(thing, oldParent, index, LINK_PARENT);\n}\n\nvoid TrashHolder::postRemoveNotification(Thing* thing, const Cylinder* newParent, int32_t index, bool isCompleteRemoval, cylinderlink_t)\n{\n\tgetParent()-\u003epostRemoveNotification(thing, newParent, index, isCompleteRemoval, LINK_PARENT);\n}\n"}
{"repo_name":"jerrys123111/pcsx2","ref":"refs/heads/master","path":"plugins/GSdx_legacy/linux_replay.cpp","copies":"41","language":"C++","content":"/*\n *\tCopyright (C) 2011-2012 Hainaut gregory\n *\n *  This Program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  This Program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with GNU Make; see the file COPYING.  If not, write to\n *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA USA.\n *  http://www.gnu.org/copyleft/gpl.html\n *\n */\n\n#include \"stdafx.h\"\n#include \u003cdlfcn.h\u003e\n\nstatic void* handle;\n\nvoid help()\n{\n\tfprintf(stderr, \"Loader gs file\\n\");\n\tfprintf(stderr, \"ARG1 GSdx plugin\\n\");\n\tfprintf(stderr, \"ARG2 .gs file\\n\");\n\tfprintf(stderr, \"ARG3 Ini directory\\n\");\n\tif (handle) {\n\t\tdlclose(handle);\n\t}\n\texit(1);\n}\n\nchar* read_env(const char* var) {\n\tchar* v = getenv(var);\n\tif (!v) {\n\t\tfprintf(stderr, \"Failed to get %s\\n\", var);\n\t\thelp();\n\t}\n\treturn v;\n}\n\nint main ( int argc, char *argv[] )\n{\n\tif (argc \u003c 1) help();\n\n\tchar* plugin;\n\tchar* gs;\n\tif (argc \u003e 2) {\n\t\tplugin = argv[1];\n\t\tgs = argv[2];\n\t} else {\n\t\tplugin = read_env(\"GSDUMP_SO\");\n\t\tgs = argv[1];\n\t}\n\n\thandle = dlopen(plugin, RTLD_LAZY|RTLD_GLOBAL);\n\tif (handle == NULL) {\n\t\tfprintf(stderr, \"Failed to dlopen plugin %s\\n\", plugin);\n\t\thelp();\n\t}\n\n\t__attribute__((stdcall)) void (*GSsetSettingsDir_ptr)(const char*);\n\t__attribute__((stdcall)) void (*GSReplay_ptr)(char*, int);\n\n\t*(void**)(\u0026GSsetSettingsDir_ptr) = dlsym(handle, \"GSsetSettingsDir\");\n\t*(void**)(\u0026GSReplay_ptr) = dlsym(handle, \"GSReplay\");\n\n\tif (argc == 2) {\n\t\tchar *ini = read_env(\"GSDUMP_CONF\");\n\n\t\tGSsetSettingsDir_ptr(ini);\n\n\t} else if (argc == 4) {\n\t\t(void)GSsetSettingsDir_ptr(argv[3]);\n\n\t} else if ( argc == 3) {\n#ifdef XDG_STD\n\t\tchar *val = read_env(\"HOME\");\n\n\t\tstd::string ini_dir(val);\n\t\tini_dir += \"/.config/pcsx2/inis\";\n\n\t\tGSsetSettingsDir_ptr(ini_dir.c_str());\n#else\n\t\tfprintf(stderr, \"default ini dir only supported on XDG\\n\");\n\t\thelp();\n#endif\n\t}\n\n\tGSReplay_ptr(gs, 12);\n\n\tif (handle) {\n\t\tdlclose(handle);\n\t}\n}\n"}
{"repo_name":"arangodb/arangodb","ref":"refs/heads/devel","path":"3rdParty/boost/1.71.0/libs/hana/example/chain.cpp","copies":"6","language":"C++","content":"// Copyright Louis Dionne 2013-2017\n// Distributed under the Boost Software License, Version 1.0.\n// (See accompanying file LICENSE.md or copy at http://boost.org/LICENSE_1_0.txt)\n\n#include \u003cboost/hana/assert.hpp\u003e\n#include \u003cboost/hana/chain.hpp\u003e\n#include \u003cboost/hana/config.hpp\u003e\n#include \u003cboost/hana/equal.hpp\u003e\n#include \u003cboost/hana/optional.hpp\u003e\nnamespace hana = boost::hana;\n\n\nBOOST_HANA_CONSTEXPR_LAMBDA auto deref = [](auto x) -\u003e decltype(*x) {\n    return *x;\n};\n\nBOOST_HANA_CONSTEXPR_LAMBDA auto age = [](auto x) -\u003e decltype(x.age) {\n    return x.age;\n};\n\nBOOST_HANA_CONSTEXPR_LAMBDA auto f = [](auto x) {\n    return hana::chain(hana::sfinae(deref)(x), hana::sfinae(age));\n};\n\nstruct Person {\n    unsigned int age;\n    // ...\n};\n\nint main() {\n    constexpr Person john{30};\n\n    // Can't dereference a non-pointer.\n    BOOST_HANA_CONSTANT_CHECK(f(john) == hana::nothing);\n\n    // `int` has no member named `age`.\n    BOOST_HANA_CONSTANT_CHECK(f(1) == hana::nothing);\n\n    // All is good.\n    BOOST_HANA_CONSTEXPR_CHECK(f(\u0026john) == hana::just(30u));\n}\n"}
{"repo_name":"naucoin/CTK","ref":"refs/heads/master","path":"Libs/Widgets/Testing/Cpp/ctkExampleUseOfWorkflowWidgetUsingSignalsAndSlots.cpp","copies":"24","language":"C++","content":"/*=========================================================================\n\n  Library:   CTK\n\n  Copyright (c) Kitware Inc.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  http://www.apache.org/licenses/LICENSE-2.0.txt\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n  =========================================================================*/\n\n// QT includes\n#include \u003cQApplication\u003e\n#include \u003cQTimer\u003e\n\n// CTK includes\n#include \"ctkWorkflow.h\"\n#include \"ctkWorkflowTabWidget.h\"\n#include \"ctkWorkflowWidgetStep.h\"\n#include \"ctkWorkflowGroupBox.h\"\n#include \"ctkExampleWorkflowWidgetStepUsingSignalsAndSlots.h\"\n\n// STD includes\n#include \u003ccstdlib\u003e\n#include \u003ciostream\u003e\n\n///\n/// Simple of example of how to setup a workflow using custom steps\n/// that were created by implementing the step's functions within a\n/// class deriving from QObject, and that communicate with the\n/// workflow using signals and slots.\n/// See: ctkExampleWorkflowWidgetStepUsingSignalsAndSlots for an\n/// example of how to setup the custom steps.\n\n//-----------------------------------------------------------------------------\nint ctkExampleUseOfWorkflowWidgetUsingSignalsAndSlots(int argc, char * argv [] )\n{\n  QApplication app(argc, argv);\n\n  // this boolean is used in setHideWidgetsOfNonCurrentSteps() below\n  // false: when a widget does not belong to the current step, it is\n  // hidden\n  // true: when a widget does not belong to the current step, it is\n  // shown, but disabled\n  bool hideWidgets = false;\n\n  // create the workflow\n  ctkWorkflow* workflow = new ctkWorkflow;\n\n  // create the workflow's UI component\n  ctkWorkflowTabWidget* workflowWidget = new ctkWorkflowTabWidget;\n  workflowWidget-\u003esetWorkflow(workflow);\n  ctkWorkflowGroupBox* groupBox = workflowWidget-\u003eworkflowGroupBox();\n  groupBox-\u003esetPreText(\"I am some pre-text\");\n  groupBox-\u003esetPostText(\"I am some post-text\");\n  groupBox-\u003esetHideWidgetsOfNonCurrentSteps(hideWidgets);\n\n  // create and add the first workflow step\n  ctkWorkflowWidgetStep* testStep1 = new ctkWorkflowWidgetStep(\"Step 1\");\n  testStep1-\u003esetName(\"Step 1\");\n  testStep1-\u003esetDescription(\"I am in step 1\");\n  // can specify the name of the tab\n  workflowWidget-\u003eassociateStepWithLabel(testStep1, \"name 1\");\n\n  // create and add the second workflow step\n  ctkWorkflowWidgetStep* testStep2 = new ctkWorkflowWidgetStep(\"Step 2\");\n  testStep2-\u003esetName(\"Step 2\");\n  testStep2-\u003esetDescription(\"I am in step 2\");\n  // a new tab is automatically created\n  workflowWidget-\u003eassociateStepWithLabel(testStep2, \"name 2\");\n\n  // create and add a third workflow step\n  ctkWorkflowWidgetStep* testStep3 = new ctkWorkflowWidgetStep(\"Step 3\");\n  testStep3-\u003esetName(\"Step 3\");\n  testStep3-\u003esetDescription(\"I am in step 3\");\n  // can place a step on a tab that was previously created by\n  // specifying its index\n  workflowWidget-\u003eassociateStepWithPage(testStep3, 1, \"name 3\");\n\n  // add the steps to the workflow\n  workflow-\u003eaddTransition(testStep1, testStep2);\n  workflow-\u003eaddTransition(testStep2, testStep3);\n\n  // create the qObjects that implement the required functions for\n  // each step, and communicate with the workflow using signals and slots\n  ctkExampleWorkflowWidgetStepUsingSignalsAndSlots* qObject1 =\n      new ctkExampleWorkflowWidgetStepUsingSignalsAndSlots(testStep1);\n  ctkExampleWorkflowWidgetStepUsingSignalsAndSlots* qObject2 =\n      new ctkExampleWorkflowWidgetStepUsingSignalsAndSlots(testStep2);\n  ctkExampleWorkflowWidgetStepUsingSignalsAndSlots* qObject3 =\n      new ctkExampleWorkflowWidgetStepUsingSignalsAndSlots(testStep3);\n\n  // set the widget for each qObject\n  qObject1-\u003esetWidget(testStep1-\u003estepArea());\n  qObject2-\u003esetWidget(testStep2-\u003estepArea());\n  qObject3-\u003esetWidget(testStep3-\u003estepArea());\n\n  // use the qObjects for validation\n  QObject::connect(testStep1-\u003ectkWorkflowStepQObject(), SIGNAL(invokeValidateCommand(QString)), qObject1, SLOT(validate(QString)));\n  QObject::connect(testStep2-\u003ectkWorkflowStepQObject(), SIGNAL(invokeValidateCommand(QString)), qObject2, SLOT(validate(QString)));\n  QObject::connect(testStep3-\u003ectkWorkflowStepQObject(), SIGNAL(invokeValidateCommand(QString)), qObject3, SLOT(validate(QString)));\n\n  // use the qObjects for entry processing\n  QObject::connect(testStep1-\u003ectkWorkflowStepQObject(), SIGNAL(invokeOnEntryCommand(const ctkWorkflowStep*,ctkWorkflowInterstepTransition::InterstepTransitionType)), qObject1, SLOT(onEntry(const ctkWorkflowStep*,ctkWorkflowInterstepTransition::InterstepTransitionType)));\n  QObject::connect(testStep2-\u003ectkWorkflowStepQObject(), SIGNAL(invokeOnEntryCommand(const ctkWorkflowStep*,ctkWorkflowInterstepTransition::InterstepTransitionType)), qObject2, SLOT(onEntry(const ctkWorkflowStep*,ctkWorkflowInterstepTransition::InterstepTransitionType)));\n  QObject::connect(testStep3-\u003ectkWorkflowStepQObject(), SIGNAL(invokeOnEntryCommand(const ctkWorkflowStep*,ctkWorkflowInterstepTransition::InterstepTransitionType)), qObject3, SLOT(onEntry(const ctkWorkflowStep*,ctkWorkflowInterstepTransition::InterstepTransitionType)));\n\n  // use the qObjects for exit processing\n  QObject::connect(testStep1-\u003ectkWorkflowStepQObject(), SIGNAL(invokeOnExitCommand(const ctkWorkflowStep*,ctkWorkflowInterstepTransition::InterstepTransitionType)), qObject1, SLOT(onExit(const ctkWorkflowStep*,ctkWorkflowInterstepTransition::InterstepTransitionType)));\n  QObject::connect(testStep2-\u003ectkWorkflowStepQObject(), SIGNAL(invokeOnExitCommand(const ctkWorkflowStep*,ctkWorkflowInterstepTransition::InterstepTransitionType)), qObject2, SLOT(onExit(const ctkWorkflowStep*,ctkWorkflowInterstepTransition::InterstepTransitionType)));\n  QObject::connect(testStep3-\u003ectkWorkflowStepQObject(), SIGNAL(invokeOnExitCommand(const ctkWorkflowStep*,ctkWorkflowInterstepTransition::InterstepTransitionType)), qObject3, SLOT(onExit(const ctkWorkflowStep*,ctkWorkflowInterstepTransition::InterstepTransitionType)));\n\n  // use the qObjects for populating the stepWidgetsList\n  QObject::connect(testStep1-\u003ectkWorkflowStepQObject(), SIGNAL(invokeCreateUserInterfaceCommand()), qObject1, SLOT(createUserInterface()));\n  QObject::connect(qObject1, SIGNAL(createUserInterfaceComplete()), testStep1-\u003ectkWorkflowStepQObject(), SIGNAL(showUserInterfaceComplete()));\n  QObject::connect(testStep2-\u003ectkWorkflowStepQObject(), SIGNAL(invokeCreateUserInterfaceCommand()), qObject2, SLOT(createUserInterface()));\n  QObject::connect(qObject2, SIGNAL(createUserInterfaceComplete()), testStep2-\u003ectkWorkflowStepQObject(), SIGNAL(showUserInterfaceComplete()));\n  QObject::connect(testStep3-\u003ectkWorkflowStepQObject(), SIGNAL(invokeCreateUserInterfaceCommand()), qObject3, SLOT(createUserInterface()));\n  QObject::connect(qObject3, SIGNAL(createUserInterfaceComplete()), testStep3-\u003ectkWorkflowStepQObject(), SIGNAL(showUserInterfaceComplete()));\n\n  testStep1-\u003esetHasValidateCommand(1);\n  testStep1-\u003esetHasOnEntryCommand(1);\n  testStep1-\u003esetHasOnExitCommand(1);\n  testStep1-\u003esetHasCreateUserInterfaceCommand(1);\n\n  testStep2-\u003esetHasValidateCommand(1);\n  testStep2-\u003esetHasOnEntryCommand(1);\n  testStep2-\u003esetHasOnExitCommand(1);\n  testStep2-\u003esetHasCreateUserInterfaceCommand(1);\n\n  testStep3-\u003esetHasValidateCommand(1);\n  testStep3-\u003esetHasOnEntryCommand(1);\n  testStep3-\u003esetHasOnExitCommand(1);\n  testStep3-\u003esetHasCreateUserInterfaceCommand(1);\n\n  // testStep1 is the initial step\n  workflow-\u003esetInitialStep(testStep1);\n\n  // testStep3 will be a finish step\n  // - will perform the processing associated with entering and\n  // leaving each step, using the default values supplied\n  // - if successful: brings you back to the step where you requested\n  // to go to the finish step, so that you can begin customization\n  // using user inputs if desired\n  // - if unsuccessful: leaves you in the step of failure, so that you\n  // can attempt to recify things from there; prints an error message\n  // at the bottom of the widget.  To see this behavior:\n  // 1) \"Next\" to step 2\n  // 2) change step 2's value to something invalid (ex. 0)\n  // 3) \"Back\" to step 1\n  // 4) \"finish\" - attempts to go to step 3, but leaves you in step 2\n\n  // start the workflow\n  workflow-\u003estart();\n  workflowWidget-\u003eshow();\n  // change this value (500) to increase the time that the widget is\n  // shown\n  QTimer::singleShot(500, \u0026app, SLOT(quit()));\n  app.exec();\n\n  // stop the workflow\n  workflow-\u003estop();\n  QTimer::singleShot(100, \u0026app, SLOT(quit()));\n  app.exec();\n\n  // handles deletion of the workflowWidget, workflow, steps, states\n  // and transitions\n  delete workflowWidget;\n\n  return EXIT_SUCCESS;\n}\n"}
{"repo_name":"fstudio/Phoenix","ref":"refs/heads/master","path":"test/Experimental/libcxx/test/std/strings/char.traits/char.traits.specializations/char.traits.specializations.char16_t/eof.pass.cpp","copies":"37","language":"C++","content":"//===----------------------------------------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n// \u003cstring\u003e\n\n// template\u003c\u003e struct char_traits\u003cchar16_t\u003e\n\n// static constexpr int_type eof();\n\n#include \u003cstring\u003e\n#include \u003ccassert\u003e\n\nint main()\n{\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\n    std::char_traits\u003cchar16_t\u003e::int_type i = std::char_traits\u003cchar16_t\u003e::eof();\n#endif\n}\n"}
{"repo_name":"dysonltd/gts","ref":"refs/heads/develop","path":"app/src/tools/core/components/FloorPlanning.cpp","copies":"2","language":"C++","content":"/*\r\n * Copyright (C) 2007-2013 Dyson Technology Ltd, all rights reserved.\r\n *\r\n * This program is free software: you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation, either version 3 of the License, or\r\n * (at your option) any later version.\r\n *\r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program.  If not, see \u003chttp://www.gnu.org/licenses/\u003e.\r\n *\r\n */\r\n\r\n#include \"RoomsCollection.h\"\r\n#include \"CamerasCollection.h\"\r\n#include \"CameraPositionsCollection.h\"\r\n#include \"CalibrationSchema.h\"\r\n#include \"ExtrinsicCalibrationSchema.h\"\r\n#include \"CameraPositionSchema.h\"\r\n#include \"RoomLayoutSchema.h\"\r\n#include \"FloorPlanSchema.h\"\r\n#include \"CalibrationAlgorithm.h\"\r\n#include \"WbConfigTools.h\"\r\n#include \"WbConfig.h\"\r\n#include \"GroundPlaneUtility.h\"\r\n#include \"OpenCvUtility.h\"\r\n#include \"RobotMetrics.h\"\r\n#include \"CameraCalibration.h\"\r\n#include \"FileUtilities.h\"\r\n#include \"FileDialogs.h\"\r\n#include \"Message.h\"\r\n#include \"Logging.h\"\r\n\r\n#include \u003cQFileDialog\u003e\r\n#include \u003cQtGlobal\u003e\r\n\r\n#include \u003copencv/cv.h\u003e\r\n#include \u003copencv/highgui.h\u003e\r\n\r\n#include \u003ciostream\u003e\r\n#include \u003calgorithm\u003e\r\n\r\nnamespace FloorPlanning\r\n{\r\n    bool LoadFile( WbConfig config, KeyId cameraPosition, IplImage** camImg, QString fileName, CvPoint2D32f* offset, bool unWarp )\r\n    {\r\n        bool successful = true;\r\n\r\n        // Get configuration information\r\n        Collection camerasCollection( CamerasCollection() );\r\n        Collection cameraPositionsCollection( CameraPositionsCollection() );\r\n\r\n        camerasCollection.SetConfig( config );\r\n        cameraPositionsCollection.SetConfig( config );\r\n\r\n        const KeyId camPosId = cameraPosition;\r\n\r\n        LOG_INFO(QObject::tr(\"Camera position id: %1\").arg(camPosId));\r\n\r\n        const WbConfig camPosConfig = cameraPositionsCollection.ElementById( camPosId );\r\n\r\n        if (camPosConfig.IsNull()) successful = false;\r\n\r\n        CvMat* cameraMtx = cvCreateMat( 3, 3, CV_32F );\r\n        CvMat* distortionCoeffs = cvCreateMat( 5, 1, CV_32F );\r\n        CvMat* inverseCoeffs = cvCreateMat( 5, 1, CV_32F );\r\n\r\n        CvMat* rot = cvCreateMat( 3, 3, CV_32F );\r\n        CvMat* trans = cvCreateMat( 1, 3, CV_32F );\r\n\r\n        if (successful)\r\n        {\r\n            const KeyId camId = camPosConfig.GetKeyValue(CameraPositionSchema::cameraIdKey).ToKeyId();\r\n\r\n            LOG_INFO(QObject::tr(\"Camera id: %1\").arg(camId));\r\n\r\n            WbConfig cameraConfig = camerasCollection.ElementById( camId );\r\n\r\n            if (cameraConfig.IsNull()) successful = false;\r\n\r\n            if (successful)\r\n            {\r\n                // Intrinsic Parameters\r\n                const WbConfig cameraIntrisicConfig( cameraConfig.GetSubConfig( CalibrationSchema::schemaName ) );\r\n\r\n                if (cameraIntrisicConfig.IsNull()) successful = false;\r\n\r\n                if (successful)\r\n                {\r\n                    const bool calibrationWasSuccessful = cameraIntrisicConfig\r\n                                        .GetKeyValue( CalibrationSchema::calibrationSuccessfulKey )\r\n                                        .ToBool();\r\n                    const bool cameraMtxValid = cameraIntrisicConfig\r\n                                    .GetKeyValue( CalibrationSchema::cameraMatrixKey )\r\n                                    .ToCvMat( *cameraMtx );\r\n                    const bool distortionCoeffsValid = cameraIntrisicConfig\r\n                                    .GetKeyValue( CalibrationSchema::distortionCoefficientsKey )\r\n                                    .ToCvMat( *distortionCoeffs );\r\n                    const bool inverseCoeffsValid = cameraIntrisicConfig\r\n                                    .GetKeyValue( CalibrationSchema::invDistortionCoefficientsKey )\r\n                                    .ToCvMat( *inverseCoeffs );\r\n\r\n                    successful = calibrationWasSuccessful \u0026\u0026\r\n                                 cameraMtxValid \u0026\u0026\r\n                                 distortionCoeffsValid \u0026\u0026\r\n                                 inverseCoeffsValid;\r\n                }\r\n\r\n                // Extrinsic Parameters\r\n                const WbConfig cameraExtrisicConfig(camPosConfig.GetSubConfig(ExtrinsicCalibrationSchema::schemaName));\r\n\r\n                if (cameraExtrisicConfig.IsNull()) successful = false;\r\n\r\n                if (successful)\r\n                {\r\n                    const bool rotMatValid = cameraExtrisicConfig\r\n                                    .GetKeyValue( ExtrinsicCalibrationSchema::rotationMatrixKey )\r\n                                    .ToCvMat( *rot );\r\n                    const bool transValid = cameraExtrisicConfig\r\n                                    .GetKeyValue( ExtrinsicCalibrationSchema::translationKey )\r\n                                    .ToCvMat( *trans );\r\n\r\n                    successful = rotMatValid \u0026\u0026 transValid;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (successful)\r\n        {\r\n            // Load file\r\n            IplImage* imgGrey = cvLoadImage( fileName.toAscii(), CV_LOAD_IMAGE_GRAYSCALE );\r\n\r\n            if (unWarp)\r\n            {\r\n                *camImg = GroundPlaneUtility::unwarpGroundPlane( imgGrey,\r\n                                                                 cameraMtx,\r\n                                                                 distortionCoeffs,\r\n                                                                 inverseCoeffs,\r\n                                                                 rot,\r\n                                                                 trans,\r\n                                                                 offset );\r\n            }\r\n            else\r\n            {\r\n                *camImg = cvCloneImage(imgGrey);\r\n            }\r\n\r\n            cvReleaseImage( \u0026imgGrey );\r\n        }\r\n\r\n        cvReleaseMat( \u0026cameraMtx );\r\n        cvReleaseMat( \u0026distortionCoeffs );\r\n        cvReleaseMat( \u0026inverseCoeffs );\r\n\r\n        cvReleaseMat( \u0026rot );\r\n        cvReleaseMat( \u0026trans );\r\n\r\n        return successful;\r\n    }\r\n\r\n    bool CheckMappingIsComplete(WbConfig config)\r\n    {\r\n        bool allMapped = true;\r\n\r\n        // for each camera,\r\n        //    for each mapping,\r\n        //       if camera1 = camera OR camera2 = camera\r\n        //          found = true;\r\n        //          break;\r\n        //    if !found\r\n        //       break\r\n        // return found\r\n\r\n        const WbConfig roomLayoutConfig(config.GetParent().GetSubConfig( RoomLayoutSchema::schemaName ) );\r\n        const QStringList cameraPositionIds(roomLayoutConfig\r\n                                            .GetKeyValue(RoomLayoutSchema::cameraPositionIdsKey)\r\n                                            .ToQStringList() );\r\n\r\n        const WbKeyValues::ValueIdPairList cameraMappingIds = config.GetKeyValues( FloorPlanSchema::homographyKey );\r\n\r\n        for ( int n = 0; n \u003c cameraPositionIds.size(); ++n )\r\n        {\r\n            const KeyId camPosId = cameraPositionIds.at( n );\r\n\r\n            bool found = false;\r\n\r\n            LOG_INFO(QObject::tr(\"Checking mapping for %1.\").arg(camPosId));\r\n\r\n            for (WbKeyValues::ValueIdPairList::const_iterator it = cameraMappingIds.begin(); it != cameraMappingIds.end(); ++it)\r\n            {\r\n                const KeyId camera1Id( config.GetKeyValue( FloorPlanSchema::camera1IdKey, it-\u003eid ).ToKeyId() );\r\n                const KeyId camera2Id( config.GetKeyValue( FloorPlanSchema::camera2IdKey, it-\u003eid ).ToKeyId() );\r\n\r\n                if ((camPosId == camera1Id) || (camPosId == camera2Id))\r\n                {\r\n                    found = true;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (!found)\r\n            {\r\n                allMapped = false;\r\n                break;\r\n            }\r\n        }\r\n\r\n        return allMapped;\r\n    }\r\n\r\n    bool IsBase(WbConfig config, KeyId camId)\r\n    {\r\n        //  for each mapping,\r\n        //    if camera1 == camera\r\n        //      base = true\r\n\r\n        const WbKeyValues::ValueIdPairList cameraMappingIds = config.GetKeyValues( FloorPlanSchema::homographyKey );\r\n\r\n        bool base = false;\r\n\r\n        for (WbKeyValues::ValueIdPairList::const_iterator it = cameraMappingIds.begin(); it != cameraMappingIds.end(); ++it)\r\n        {\r\n            const KeyId camera1Id( config.GetKeyValue( FloorPlanSchema::camera1IdKey, it-\u003eid ).ToKeyId() );\r\n\r\n            if (camId == camera1Id)\r\n            {\r\n                base = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        return base;\r\n    }\r\n\r\n    bool IsRef(WbConfig config, KeyId camId)\r\n    {\r\n        //  for each mapping,\r\n        //    if camera2 == camera\r\n        //      ref = true\r\n\r\n        const WbKeyValues::ValueIdPairList cameraMappingIds = config.GetKeyValues( FloorPlanSchema::homographyKey );\r\n\r\n        bool ref = false;\r\n\r\n        for (WbKeyValues::ValueIdPairList::const_iterator it = cameraMappingIds.begin(); it != cameraMappingIds.end(); ++it)\r\n        {\r\n            const KeyId camera2Id( config.GetKeyValue( FloorPlanSchema::camera2IdKey, it-\u003eid ).ToKeyId() );\r\n\r\n            if (camId == camera2Id)\r\n            {\r\n                ref = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        return ref;\r\n    }\r\n\r\n    std::vector\u003cKeyId\u003e FindRoot(WbConfig config)\r\n    {\r\n        std::vector\u003cKeyId\u003e rootCamera;\r\n\r\n        // for each camera,\r\n        //    for each mapping,\r\n        //       if camera2 == camera\r\n        //          root = false\r\n        //    if root\r\n        //       add to set\r\n\r\n        const WbConfig roomLayoutConfig(config.GetParent().GetSubConfig( RoomLayoutSchema::schemaName ) );\r\n        const QStringList cameraPositionIds(roomLayoutConfig\r\n                                            .GetKeyValue(RoomLayoutSchema::cameraPositionIdsKey)\r\n                                            .ToQStringList() );\r\n\r\n        const WbKeyValues::ValueIdPairList cameraMappingIds = config.GetKeyValues( FloorPlanSchema::homographyKey );\r\n\r\n        for ( int n = 0; n \u003c cameraPositionIds.size(); ++n )\r\n        {\r\n            const KeyId camPosId = cameraPositionIds.at( n );\r\n\r\n            bool root = true;\r\n\r\n            for (WbKeyValues::ValueIdPairList::const_iterator it = cameraMappingIds.begin(); it != cameraMappingIds.end(); ++it)\r\n            {\r\n                const KeyId camera1Id( config.GetKeyValue( FloorPlanSchema::camera1IdKey, it-\u003eid ).ToKeyId() );\r\n                const KeyId camera2Id( config.GetKeyValue( FloorPlanSchema::camera2IdKey, it-\u003eid ).ToKeyId() );\r\n\r\n                if (camPosId == camera2Id)\r\n                {\r\n                    root = false;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (root \u0026\u0026 IsBase(config, camPosId))\r\n            {\r\n                rootCamera.push_back(camPosId);\r\n            }\r\n        }\r\n\r\n        return rootCamera;\r\n    }\r\n\r\n    std::vector\u003cKeyId\u003e FindChain(WbConfig config, KeyId camId, KeyId rootId, std::vector\u003cKeyId\u003e mappingChain)\r\n    {\r\n        const WbKeyValues::ValueIdPairList cameraMappingIds = config.GetKeyValues( FloorPlanSchema::homographyKey );\r\n\r\n        for (WbKeyValues::ValueIdPairList::const_iterator it = cameraMappingIds.begin(); it != cameraMappingIds.end(); ++it)\r\n        {\r\n            const KeyId camera1Id( config.GetKeyValue( FloorPlanSchema::camera1IdKey, it-\u003eid ).ToKeyId() );\r\n            const KeyId camera2Id( config.GetKeyValue( FloorPlanSchema::camera2IdKey, it-\u003eid ).ToKeyId() );\r\n\r\n            LOG_INFO(QObject::tr(\"Camera1 id = %1.\").arg(camera1Id));\r\n            LOG_INFO(QObject::tr(\"Camera2 id = %1.\").arg(camera2Id));\r\n\r\n            if (camId == camera2Id)\r\n            {\r\n                if (std::find(mappingChain.begin(), mappingChain.end(), camera1Id) == mappingChain.end())\r\n                {\r\n                    mappingChain.push_back(camera1Id);\r\n\r\n                    if (camera1Id != rootId)\r\n                    {\r\n                        LOG_INFO(QObject::tr(\"Find chain for %1 - %2.\").arg(camera1Id)\r\n                                                                       .arg(rootId));\r\n\r\n                        mappingChain = FindChain(config, camera1Id, rootId, mappingChain);\r\n                    }\r\n\r\n                    if (mappingChain.back() == rootId)\r\n                    {\r\n                        LOG_INFO(\"Found.\");\r\n\r\n                        break;\r\n                    }\r\n                    else\r\n                    {\r\n                        mappingChain.pop_back();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return mappingChain;\r\n    }\r\n\r\n    bool CheckRootMapping(WbConfig config, KeyId rootId)\r\n    {\r\n        bool allMapped = true;\r\n\r\n        // for each camera in root,\r\n        //   for each camera\r\n        //      if camera /= root\r\n        //         if !FindChain (camera, root)\r\n        //             = false;\r\n        //            break;\r\n        //   if found\r\n        //      theRoot = root\r\n        //      break\r\n        //   else\r\n\r\n        const WbConfig roomLayoutConfig(config.GetParent().GetSubConfig( RoomLayoutSchema::schemaName ) );\r\n        const QStringList cameraPositionIds(roomLayoutConfig\r\n                                            .GetKeyValue(RoomLayoutSchema::cameraPositionIdsKey)\r\n                                            .ToQStringList() );\r\n\r\n        const WbKeyValues::ValueIdPairList cameraMappingIds = config.GetKeyValues( FloorPlanSchema::homographyKey );\r\n        for ( int n = 0; n \u003c cameraPositionIds.size(); ++n )\r\n        {\r\n            const KeyId camPosId = cameraPositionIds.at( n );\r\n\r\n            if ((camPosId != rootId) \u0026\u0026 IsRef(config, camPosId))\r\n            {\r\n                LOG_INFO(QObject::tr(\"Find chain for %1 - %2.\").arg(camPosId)\r\n                                                               .arg(rootId));\r\n\r\n                std::vector\u003cKeyId\u003e chain = FindChain(config, camPosId, rootId, std::vector\u003cKeyId\u003e());\r\n\r\n                if (chain.size() == 0)\r\n                {\r\n                    LOG_INFO(\"Not found.\");\r\n\r\n                    allMapped = false;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        return allMapped;\r\n    }\r\n\r\n    void ComputeTransform(WbConfig config, KeyId refId, std::vector\u003cKeyId\u003e chain, CvMat* transform)\r\n    {\r\n        const WbKeyValues::ValueIdPairList cameraMappingIds = config.GetKeyValues( FloorPlanSchema::homographyKey );\r\n\r\n        for (std::vector\u003cKeyId\u003e::iterator elt = chain.begin(); elt != chain.end(); ++elt)\r\n        {\r\n            for (WbKeyValues::ValueIdPairList::const_iterator it = cameraMappingIds.begin(); it != cameraMappingIds.end(); ++it)\r\n            {\r\n                const KeyId camera1Id( config.GetKeyValue( FloorPlanSchema::camera1IdKey, it-\u003eid ).ToKeyId() );\r\n                const KeyId camera2Id( config.GetKeyValue( FloorPlanSchema::camera2IdKey, it-\u003eid ).ToKeyId() );\r\n\r\n                if ((camera1Id == *elt) \u0026\u0026 (camera2Id == refId))\r\n                {\r\n                    CvMat* homography = cvCreateMat( 3, 3, CV_32F );\r\n\r\n                    const bool homographyValid = config\r\n                                    .GetKeyValue( FloorPlanSchema::homographyKey, it-\u003eid )\r\n                                    .ToCvMat( *homography );\r\n                    Q_UNUSED(homographyValid);\r\n\r\n                    CvMat* tmp = cvCreateMat( 3, 3, CV_32F );\r\n                    cvMatMul( homography, transform, tmp );\r\n\r\n                    cvmSet(transform,0,0, cvmGet(tmp,0,0));\r\n                    cvmSet(transform,0,1, cvmGet(tmp,0,1));\r\n                    cvmSet(transform,0,2, cvmGet(tmp,0,2));\r\n                    cvmSet(transform,1,0, cvmGet(tmp,1,0));\r\n                    cvmSet(transform,1,1, cvmGet(tmp,1,1));\r\n                    cvmSet(transform,1,2, cvmGet(tmp,1,2));\r\n                    cvmSet(transform,2,0, cvmGet(tmp,2,0));\r\n                    cvmSet(transform,2,1, cvmGet(tmp,2,1));\r\n                    cvmSet(transform,2,2, cvmGet(tmp,2,2));\r\n\r\n                    cvReleaseMat(\u0026tmp);\r\n                    cvReleaseMat(\u0026homography);\r\n\r\n                    refId = *elt;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n"}
{"repo_name":"alessonrenato/TrinityCore","ref":"refs/heads/6.x","path":"src/server/game/Battlegrounds/Zones/BattlegroundAB.cpp","copies":"19","language":"C++","content":"/*\n * Copyright (C) 2008-2015 TrinityCore \u003chttp://www.trinitycore.org/\u003e\n * Copyright (C) 2005-2009 MaNGOS \u003chttp://getmangos.com/\u003e\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the\n * Free Software Foundation; either version 2 of the License, or (at your\n * option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n * more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program. If not, see \u003chttp://www.gnu.org/licenses/\u003e.\n */\n\n#include \"BattlegroundAB.h\"\n#include \"WorldPacket.h\"\n#include \"BattlegroundMgr.h\"\n#include \"Creature.h\"\n#include \"Language.h\"\n#include \"Player.h\"\n#include \"Util.h\"\n#include \"WorldSession.h\"\n\nBattlegroundAB::BattlegroundAB()\n{\n    m_IsInformedNearVictory = false;\n    m_BuffChange = true;\n    BgObjects.resize(BG_AB_OBJECT_MAX);\n    BgCreatures.resize(BG_AB_ALL_NODES_COUNT + 5);//+5 for aura triggers\n\n    for (uint8 i = 0; i \u003c BG_AB_DYNAMIC_NODES_COUNT; ++i)\n    {\n        m_Nodes[i] = 0;\n        m_prevNodes[i] = 0;\n        m_NodeTimers[i] = 0;\n        m_BannerTimers[i].timer = 0;\n        m_BannerTimers[i].type = 0;\n        m_BannerTimers[i].teamIndex = 0;\n    }\n\n    for (uint8 i = 0; i \u003c BG_TEAMS_COUNT; ++i)\n    {\n        m_lastTick[i] = 0;\n        m_HonorScoreTics[i] = 0;\n        m_ReputationScoreTics[i] = 0;\n        m_TeamScores500Disadvantage[i] = false;\n    }\n\n    m_HonorTics = 0;\n    m_ReputationTics = 0;\n\n    StartMessageIds[BG_STARTING_EVENT_FIRST]  = LANG_BG_AB_START_TWO_MINUTES;\n    StartMessageIds[BG_STARTING_EVENT_SECOND] = LANG_BG_AB_START_ONE_MINUTE;\n    StartMessageIds[BG_STARTING_EVENT_THIRD]  = LANG_BG_AB_START_HALF_MINUTE;\n    StartMessageIds[BG_STARTING_EVENT_FOURTH] = LANG_BG_AB_HAS_BEGUN;\n}\n\nBattlegroundAB::~BattlegroundAB() { }\n\nvoid BattlegroundAB::PostUpdateImpl(uint32 diff)\n{\n    if (GetStatus() == STATUS_IN_PROGRESS)\n    {\n        int team_points[BG_TEAMS_COUNT] = { 0, 0 };\n\n        for (int node = 0; node \u003c BG_AB_DYNAMIC_NODES_COUNT; ++node)\n        {\n            // 3 sec delay to spawn new banner instead previous despawned one\n            if (m_BannerTimers[node].timer)\n            {\n                if (m_BannerTimers[node].timer \u003e diff)\n                    m_BannerTimers[node].timer -= diff;\n                else\n                {\n                    m_BannerTimers[node].timer = 0;\n                    _CreateBanner(node, m_BannerTimers[node].type, m_BannerTimers[node].teamIndex, false);\n                }\n            }\n\n            // 1-minute to occupy a node from contested state\n            if (m_NodeTimers[node])\n            {\n                if (m_NodeTimers[node] \u003e diff)\n                    m_NodeTimers[node] -= diff;\n                else\n                {\n                    m_NodeTimers[node] = 0;\n                    // Change from contested to occupied !\n                    uint8 teamIndex = m_Nodes[node]-1;\n                    m_prevNodes[node] = m_Nodes[node];\n                    m_Nodes[node] += 2;\n                    // burn current contested banner\n                    _DelBanner(node, BG_AB_NODE_TYPE_CONTESTED, teamIndex);\n                    // create new occupied banner\n                    _CreateBanner(node, BG_AB_NODE_TYPE_OCCUPIED, teamIndex, true);\n                    _SendNodeUpdate(node);\n                    _NodeOccupied(node, (teamIndex == 0) ? ALLIANCE:HORDE);\n                    // Message to chatlog\n\n                    if (teamIndex == 0)\n                    {\n                        // FIXME: team and node names not localized\n                        SendMessage2ToAll(LANG_BG_AB_NODE_TAKEN, CHAT_MSG_BG_SYSTEM_ALLIANCE, NULL, LANG_BG_AB_ALLY, _GetNodeNameId(node));\n                        PlaySoundToAll(BG_AB_SOUND_NODE_CAPTURED_ALLIANCE);\n                    }\n                    else\n                    {\n                        // FIXME: team and node names not localized\n                        SendMessage2ToAll(LANG_BG_AB_NODE_TAKEN, CHAT_MSG_BG_SYSTEM_HORDE, NULL, LANG_BG_AB_HORDE, _GetNodeNameId(node));\n                        PlaySoundToAll(BG_AB_SOUND_NODE_CAPTURED_HORDE);\n                    }\n                }\n            }\n\n            for (int team = 0; team \u003c BG_TEAMS_COUNT; ++team)\n                if (m_Nodes[node] == team + BG_AB_NODE_TYPE_OCCUPIED)\n                    ++team_points[team];\n        }\n\n        // Accumulate points\n        for (int team = 0; team \u003c BG_TEAMS_COUNT; ++team)\n        {\n            int points = team_points[team];\n            if (!points)\n                continue;\n\n            m_lastTick[team] += diff;\n\n            if (m_lastTick[team] \u003e BG_AB_TickIntervals[points])\n            {\n                m_lastTick[team] -= BG_AB_TickIntervals[points];\n                m_TeamScores[team] += BG_AB_TickPoints[points];\n                m_HonorScoreTics[team] += BG_AB_TickPoints[points];\n                m_ReputationScoreTics[team] += BG_AB_TickPoints[points];\n\n                if (m_ReputationScoreTics[team] \u003e= m_ReputationTics)\n                {\n                    (team == TEAM_ALLIANCE) ? RewardReputationToTeam(509, 10, ALLIANCE) : RewardReputationToTeam(510, 10, HORDE);\n                    m_ReputationScoreTics[team] -= m_ReputationTics;\n                }\n\n                if (m_HonorScoreTics[team] \u003e= m_HonorTics)\n                {\n                    RewardHonorToTeam(GetBonusHonorFromKill(1), (team == TEAM_ALLIANCE) ? ALLIANCE : HORDE);\n                    m_HonorScoreTics[team] -= m_HonorTics;\n                }\n\n                if (!m_IsInformedNearVictory \u0026\u0026 m_TeamScores[team] \u003e BG_AB_WARNING_NEAR_VICTORY_SCORE)\n                {\n                    if (team == TEAM_ALLIANCE)\n                        SendMessageToAll(LANG_BG_AB_A_NEAR_VICTORY, CHAT_MSG_BG_SYSTEM_NEUTRAL);\n                    else\n                        SendMessageToAll(LANG_BG_AB_H_NEAR_VICTORY, CHAT_MSG_BG_SYSTEM_NEUTRAL);\n                    PlaySoundToAll(BG_AB_SOUND_NEAR_VICTORY);\n                    m_IsInformedNearVictory = true;\n                }\n\n                if (m_TeamScores[team] \u003e BG_AB_MAX_TEAM_SCORE)\n                    m_TeamScores[team] = BG_AB_MAX_TEAM_SCORE;\n\n                if (team == TEAM_ALLIANCE)\n                    UpdateWorldState(BG_AB_OP_RESOURCES_ALLY, m_TeamScores[team]);\n                else if (team == TEAM_HORDE)\n                    UpdateWorldState(BG_AB_OP_RESOURCES_HORDE, m_TeamScores[team]);\n                // update achievement flags\n                // we increased m_TeamScores[team] so we just need to check if it is 500 more than other teams resources\n                uint8 otherTeam = (team + 1) % BG_TEAMS_COUNT;\n                if (m_TeamScores[team] \u003e m_TeamScores[otherTeam] + 500)\n                    m_TeamScores500Disadvantage[otherTeam] = true;\n            }\n        }\n\n        // Test win condition\n        if (m_TeamScores[TEAM_ALLIANCE] \u003e= BG_AB_MAX_TEAM_SCORE)\n            EndBattleground(ALLIANCE);\n        else if (m_TeamScores[TEAM_HORDE] \u003e= BG_AB_MAX_TEAM_SCORE)\n            EndBattleground(HORDE);\n    }\n}\n\nvoid BattlegroundAB::StartingEventCloseDoors()\n{\n    // despawn banners, auras and buffs\n    for (int obj = BG_AB_OBJECT_BANNER_NEUTRAL; obj \u003c BG_AB_DYNAMIC_NODES_COUNT * 8; ++obj)\n        SpawnBGObject(obj, RESPAWN_ONE_DAY);\n    for (int i = 0; i \u003c BG_AB_DYNAMIC_NODES_COUNT * 3; ++i)\n        SpawnBGObject(BG_AB_OBJECT_SPEEDBUFF_STABLES + i, RESPAWN_ONE_DAY);\n\n    // Starting doors\n    DoorClose(BG_AB_OBJECT_GATE_A);\n    DoorClose(BG_AB_OBJECT_GATE_H);\n    SpawnBGObject(BG_AB_OBJECT_GATE_A, RESPAWN_IMMEDIATELY);\n    SpawnBGObject(BG_AB_OBJECT_GATE_H, RESPAWN_IMMEDIATELY);\n\n    // Starting base spirit guides\n    _NodeOccupied(BG_AB_SPIRIT_ALIANCE, ALLIANCE);\n    _NodeOccupied(BG_AB_SPIRIT_HORDE, HORDE);\n}\n\nvoid BattlegroundAB::StartingEventOpenDoors()\n{\n    // spawn neutral banners\n    for (int banner = BG_AB_OBJECT_BANNER_NEUTRAL, i = 0; i \u003c 5; banner += 8, ++i)\n        SpawnBGObject(banner, RESPAWN_IMMEDIATELY);\n    for (int i = 0; i \u003c BG_AB_DYNAMIC_NODES_COUNT; ++i)\n    {\n        //randomly select buff to spawn\n        uint8 buff = urand(0, 2);\n        SpawnBGObject(BG_AB_OBJECT_SPEEDBUFF_STABLES + buff + i * 3, RESPAWN_IMMEDIATELY);\n    }\n    DoorOpen(BG_AB_OBJECT_GATE_A);\n    DoorOpen(BG_AB_OBJECT_GATE_H);\n\n    // Achievement: Let's Get This Done\n    StartTimedAchievement(ACHIEVEMENT_TIMED_TYPE_EVENT, AB_EVENT_START_BATTLE);\n}\n\nvoid BattlegroundAB::AddPlayer(Player* player)\n{\n    Battleground::AddPlayer(player);\n    PlayerScores[player-\u003eGetGUID()] = new BattlegroundABScore(player-\u003eGetGUID(), player-\u003eGetBGTeam());\n}\n\nvoid BattlegroundAB::RemovePlayer(Player* /*player*/, ObjectGuid /*guid*/, uint32 /*team*/)\n{\n}\n\nvoid BattlegroundAB::HandleAreaTrigger(Player* player, uint32 trigger, bool entered)\n{\n    if (GetStatus() != STATUS_IN_PROGRESS)\n        return;\n\n    switch (trigger)\n    {\n        case 3948:                                          // Arathi Basin Alliance Exit.\n            if (player-\u003eGetTeam() != ALLIANCE)\n                player-\u003eGetSession()-\u003eSendNotification(\"Only The Alliance can use that portal\");\n            else\n                player-\u003eLeaveBattleground();\n            break;\n        case 3949:                                          // Arathi Basin Horde Exit.\n            if (player-\u003eGetTeam() != HORDE)\n                player-\u003eGetSession()-\u003eSendNotification(\"Only The Horde can use that portal\");\n            else\n                player-\u003eLeaveBattleground();\n            break;\n        case 3866:                                          // Stables\n        case 3869:                                          // Gold Mine\n        case 3867:                                          // Farm\n        case 3868:                                          // Lumber Mill\n        case 3870:                                          // Black Smith\n        case 4020:                                          // Unk1\n        case 4021:                                          // Unk2\n        case 4674:                                          // Unk3\n            //break;\n        default:\n            Battleground::HandleAreaTrigger(player, trigger, entered);\n            break;\n    }\n}\n\n/*  type: 0-neutral, 1-contested, 3-occupied\n    teamIndex: 0-ally, 1-horde                        */\nvoid BattlegroundAB::_CreateBanner(uint8 node, uint8 type, uint8 teamIndex, bool delay)\n{\n    // Just put it into the queue\n    if (delay)\n    {\n        m_BannerTimers[node].timer = 2000;\n        m_BannerTimers[node].type = type;\n        m_BannerTimers[node].teamIndex = teamIndex;\n        return;\n    }\n\n    uint8 obj = node*8 + type + teamIndex;\n\n    SpawnBGObject(obj, RESPAWN_IMMEDIATELY);\n\n    // handle aura with banner\n    if (!type)\n        return;\n    obj = node * 8 + ((type == BG_AB_NODE_TYPE_OCCUPIED) ? (5 + teamIndex) : 7);\n    SpawnBGObject(obj, RESPAWN_IMMEDIATELY);\n}\n\nvoid BattlegroundAB::_DelBanner(uint8 node, uint8 type, uint8 teamIndex)\n{\n    uint8 obj = node*8 + type + teamIndex;\n    SpawnBGObject(obj, RESPAWN_ONE_DAY);\n\n    // handle aura with banner\n    if (!type)\n        return;\n    obj = node * 8 + ((type == BG_AB_NODE_TYPE_OCCUPIED) ? (5 + teamIndex) : 7);\n    SpawnBGObject(obj, RESPAWN_ONE_DAY);\n}\n\nint32 BattlegroundAB::_GetNodeNameId(uint8 node)\n{\n    switch (node)\n    {\n        case BG_AB_NODE_STABLES:    return LANG_BG_AB_NODE_STABLES;\n        case BG_AB_NODE_BLACKSMITH: return LANG_BG_AB_NODE_BLACKSMITH;\n        case BG_AB_NODE_FARM:       return LANG_BG_AB_NODE_FARM;\n        case BG_AB_NODE_LUMBER_MILL:return LANG_BG_AB_NODE_LUMBER_MILL;\n        case BG_AB_NODE_GOLD_MINE:  return LANG_BG_AB_NODE_GOLD_MINE;\n        default:\n            ABORT();\n    }\n    return 0;\n}\n\nvoid BattlegroundAB::FillInitialWorldStates(WorldPackets::WorldState::InitWorldStates\u0026 packet)\n{\n    const uint8 plusArray[] = {0, 2, 3, 0, 1};\n\n    // Node icons\n    for (uint8 node = 0; node \u003c BG_AB_DYNAMIC_NODES_COUNT; ++node)\n        packet.Worldstates.emplace_back(uint32(BG_AB_OP_NODEICONS[node]), int32((m_Nodes[node] == 0) ? 1 : 0));\n\n    // Node occupied states\n    for (uint8 node = 0; node \u003c BG_AB_DYNAMIC_NODES_COUNT; ++node)\n        for (uint8 i = 1; i \u003c BG_AB_DYNAMIC_NODES_COUNT; ++i)\n            packet.Worldstates.emplace_back(uint32(BG_AB_OP_NODESTATES[node] + plusArray[i]), int32((m_Nodes[node] == i) ? 1 : 0));\n\n    // How many bases each team owns\n    uint8 ally = 0, horde = 0;\n    for (uint8 node = 0; node \u003c BG_AB_DYNAMIC_NODES_COUNT; ++node)\n        if (m_Nodes[node] == BG_AB_NODE_STATUS_ALLY_OCCUPIED)\n            ++ally;\n        else if (m_Nodes[node] == BG_AB_NODE_STATUS_HORDE_OCCUPIED)\n            ++horde;\n\n    packet.Worldstates.emplace_back(uint32(BG_AB_OP_OCCUPIED_BASES_ALLY), int32(ally));\n    packet.Worldstates.emplace_back(uint32(BG_AB_OP_OCCUPIED_BASES_HORDE), int32(horde));\n\n    // Team scores\n    packet.Worldstates.emplace_back(uint32(BG_AB_OP_RESOURCES_MAX), int32(BG_AB_MAX_TEAM_SCORE));\n    packet.Worldstates.emplace_back(uint32(BG_AB_OP_RESOURCES_WARNING), int32(BG_AB_WARNING_NEAR_VICTORY_SCORE));\n    packet.Worldstates.emplace_back(uint32(BG_AB_OP_RESOURCES_ALLY), int32(m_TeamScores[TEAM_ALLIANCE]));\n    packet.Worldstates.emplace_back(uint32(BG_AB_OP_RESOURCES_HORDE), int32(m_TeamScores[TEAM_HORDE]));\n\n    // other unknown\n    packet.Worldstates.emplace_back(uint32(0x745), 0x2);\n}\n\nvoid BattlegroundAB::_SendNodeUpdate(uint8 node)\n{\n    // Send node owner state update to refresh map icons on client\n    const uint8 plusArray[] = {0, 2, 3, 0, 1};\n\n    if (m_prevNodes[node])\n        UpdateWorldState(BG_AB_OP_NODESTATES[node] + plusArray[m_prevNodes[node]], 0);\n    else\n        UpdateWorldState(BG_AB_OP_NODEICONS[node], 0);\n\n    UpdateWorldState(BG_AB_OP_NODESTATES[node] + plusArray[m_Nodes[node]], 1);\n\n    // How many bases each team owns\n    uint8 ally = 0, horde = 0;\n    for (uint8 i = 0; i \u003c BG_AB_DYNAMIC_NODES_COUNT; ++i)\n        if (m_Nodes[i] == BG_AB_NODE_STATUS_ALLY_OCCUPIED)\n            ++ally;\n        else if (m_Nodes[i] == BG_AB_NODE_STATUS_HORDE_OCCUPIED)\n            ++horde;\n\n    UpdateWorldState(BG_AB_OP_OCCUPIED_BASES_ALLY, ally);\n    UpdateWorldState(BG_AB_OP_OCCUPIED_BASES_HORDE, horde);\n}\n\nvoid BattlegroundAB::_NodeOccupied(uint8 node, Team team)\n{\n    if (!AddSpiritGuide(node, BG_AB_SpiritGuidePos[node], GetTeamIndexByTeamId(team)))\n        TC_LOG_ERROR(\"bg.battleground\", \"Failed to spawn spirit guide! point: %u, team: %u, \", node, team);\n\n    if (node \u003e= BG_AB_DYNAMIC_NODES_COUNT)//only dynamic nodes, no start points\n        return;\n\n    uint8 capturedNodes = 0;\n    for (uint8 i = 0; i \u003c BG_AB_DYNAMIC_NODES_COUNT; ++i)\n        if (m_Nodes[i] == GetTeamIndexByTeamId(team) + BG_AB_NODE_TYPE_OCCUPIED \u0026\u0026 !m_NodeTimers[i])\n            ++capturedNodes;\n\n    if (capturedNodes \u003e= 5)\n        CastSpellOnTeam(SPELL_AB_QUEST_REWARD_5_BASES, team);\n    if (capturedNodes \u003e= 4)\n        CastSpellOnTeam(SPELL_AB_QUEST_REWARD_4_BASES, team);\n\n    Creature* trigger = !BgCreatures[node + 7] ? GetBGCreature(node + 7) : NULL; // 0-6 spirit guides\n    if (!trigger)\n        trigger = AddCreature(WORLD_TRIGGER, node+7, BG_AB_NodePositions[node], GetTeamIndexByTeamId(team));\n\n    //add bonus honor aura trigger creature when node is accupied\n    //cast bonus aura (+50% honor in 25yards)\n    //aura should only apply to players who have accupied the node, set correct faction for trigger\n    if (trigger)\n    {\n        trigger-\u003esetFaction(team == ALLIANCE ? 84 : 83);\n        trigger-\u003eCastSpell(trigger, SPELL_HONORABLE_DEFENDER_25Y, false);\n    }\n}\n\nvoid BattlegroundAB::_NodeDeOccupied(uint8 node)\n{\n    if (node \u003e= BG_AB_DYNAMIC_NODES_COUNT)\n        return;\n\n    //remove bonus honor aura trigger creature when node is lost\n    if (node \u003c BG_AB_DYNAMIC_NODES_COUNT)//only dynamic nodes, no start points\n        DelCreature(node+7);//NULL checks are in DelCreature! 0-6 spirit guides\n\n    RelocateDeadPlayers(BgCreatures[node]);\n\n    DelCreature(node);\n\n    // buff object isn't despawned\n}\n\n/* Invoked if a player used a banner as a gameobject */\nvoid BattlegroundAB::EventPlayerClickedOnFlag(Player* source, GameObject* /*target_obj*/)\n{\n    if (GetStatus() != STATUS_IN_PROGRESS)\n        return;\n\n    uint8 node = BG_AB_NODE_STABLES;\n    GameObject* obj = GetBgMap()-\u003eGetGameObject(BgObjects[node*8+7]);\n    while ((node \u003c BG_AB_DYNAMIC_NODES_COUNT) \u0026\u0026 ((!obj) || (!source-\u003eIsWithinDistInMap(obj, 10))))\n    {\n        ++node;\n        obj = GetBgMap()-\u003eGetGameObject(BgObjects[node*8+BG_AB_OBJECT_AURA_CONTESTED]);\n    }\n\n    if (node == BG_AB_DYNAMIC_NODES_COUNT)\n    {\n        // this means our player isn't close to any of banners - maybe cheater ??\n        return;\n    }\n\n    TeamId teamIndex = GetTeamIndexByTeamId(source-\u003eGetTeam());\n\n    // Check if player really could use this banner, not cheated\n    if (!(m_Nodes[node] == 0 || teamIndex == m_Nodes[node]%2))\n        return;\n\n    source-\u003eRemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_ENTER_PVP_COMBAT);\n    uint32 sound = 0;\n    // If node is neutral, change to contested\n    if (m_Nodes[node] == BG_AB_NODE_TYPE_NEUTRAL)\n    {\n        UpdatePlayerScore(source, SCORE_BASES_ASSAULTED, 1);\n        m_prevNodes[node] = m_Nodes[node];\n        m_Nodes[node] = teamIndex + 1;\n        // burn current neutral banner\n        _DelBanner(node, BG_AB_NODE_TYPE_NEUTRAL, 0);\n        // create new contested banner\n        _CreateBanner(node, BG_AB_NODE_TYPE_CONTESTED, teamIndex, true);\n        _SendNodeUpdate(node);\n        m_NodeTimers[node] = BG_AB_FLAG_CAPTURING_TIME;\n\n        // FIXME: team and node names not localized\n        if (teamIndex == 0)\n            SendMessage2ToAll(LANG_BG_AB_NODE_CLAIMED, CHAT_MSG_BG_SYSTEM_ALLIANCE, source, _GetNodeNameId(node), LANG_BG_AB_ALLY);\n        else\n            SendMessage2ToAll(LANG_BG_AB_NODE_CLAIMED, CHAT_MSG_BG_SYSTEM_HORDE, source, _GetNodeNameId(node), LANG_BG_AB_HORDE);\n\n        sound = BG_AB_SOUND_NODE_CLAIMED;\n    }\n    // If node is contested\n    else if ((m_Nodes[node] == BG_AB_NODE_STATUS_ALLY_CONTESTED) || (m_Nodes[node] == BG_AB_NODE_STATUS_HORDE_CONTESTED))\n    {\n        // If last state is NOT occupied, change node to enemy-contested\n        if (m_prevNodes[node] \u003c BG_AB_NODE_TYPE_OCCUPIED)\n        {\n            UpdatePlayerScore(source, SCORE_BASES_ASSAULTED, 1);\n            m_prevNodes[node] = m_Nodes[node];\n            m_Nodes[node] = teamIndex + BG_AB_NODE_TYPE_CONTESTED;\n            // burn current contested banner\n            _DelBanner(node, BG_AB_NODE_TYPE_CONTESTED, !teamIndex);\n            // create new contested banner\n            _CreateBanner(node, BG_AB_NODE_TYPE_CONTESTED, teamIndex, true);\n            _SendNodeUpdate(node);\n            m_NodeTimers[node] = BG_AB_FLAG_CAPTURING_TIME;\n\n            // FIXME: node names not localized\n            if (teamIndex == TEAM_ALLIANCE)\n                SendMessage2ToAll(LANG_BG_AB_NODE_ASSAULTED, CHAT_MSG_BG_SYSTEM_ALLIANCE, source, _GetNodeNameId(node));\n            else\n                SendMessage2ToAll(LANG_BG_AB_NODE_ASSAULTED, CHAT_MSG_BG_SYSTEM_HORDE, source, _GetNodeNameId(node));\n        }\n        // If contested, change back to occupied\n        else\n        {\n            UpdatePlayerScore(source, SCORE_BASES_DEFENDED, 1);\n            m_prevNodes[node] = m_Nodes[node];\n            m_Nodes[node] = teamIndex + BG_AB_NODE_TYPE_OCCUPIED;\n            // burn current contested banner\n            _DelBanner(node, BG_AB_NODE_TYPE_CONTESTED, !teamIndex);\n            // create new occupied banner\n            _CreateBanner(node, BG_AB_NODE_TYPE_OCCUPIED, teamIndex, true);\n            _SendNodeUpdate(node);\n            m_NodeTimers[node] = 0;\n            _NodeOccupied(node, (teamIndex == TEAM_ALLIANCE) ? ALLIANCE:HORDE);\n\n            // FIXME: node names not localized\n            if (teamIndex == TEAM_ALLIANCE)\n                SendMessage2ToAll(LANG_BG_AB_NODE_DEFENDED, CHAT_MSG_BG_SYSTEM_ALLIANCE, source, _GetNodeNameId(node));\n            else\n                SendMessage2ToAll(LANG_BG_AB_NODE_DEFENDED, CHAT_MSG_BG_SYSTEM_HORDE, source, _GetNodeNameId(node));\n        }\n        sound = (teamIndex == TEAM_ALLIANCE) ? BG_AB_SOUND_NODE_ASSAULTED_ALLIANCE : BG_AB_SOUND_NODE_ASSAULTED_HORDE;\n    }\n    // If node is occupied, change to enemy-contested\n    else\n    {\n        UpdatePlayerScore(source, SCORE_BASES_ASSAULTED, 1);\n        m_prevNodes[node] = m_Nodes[node];\n        m_Nodes[node] = teamIndex + BG_AB_NODE_TYPE_CONTESTED;\n        // burn current occupied banner\n        _DelBanner(node, BG_AB_NODE_TYPE_OCCUPIED, !teamIndex);\n        // create new contested banner\n        _CreateBanner(node, BG_AB_NODE_TYPE_CONTESTED, teamIndex, true);\n        _SendNodeUpdate(node);\n        _NodeDeOccupied(node);\n        m_NodeTimers[node] = BG_AB_FLAG_CAPTURING_TIME;\n\n        // FIXME: node names not localized\n        if (teamIndex == TEAM_ALLIANCE)\n            SendMessage2ToAll(LANG_BG_AB_NODE_ASSAULTED, CHAT_MSG_BG_SYSTEM_ALLIANCE, source, _GetNodeNameId(node));\n        else\n            SendMessage2ToAll(LANG_BG_AB_NODE_ASSAULTED, CHAT_MSG_BG_SYSTEM_HORDE, source, _GetNodeNameId(node));\n\n        sound = (teamIndex == TEAM_ALLIANCE) ? BG_AB_SOUND_NODE_ASSAULTED_ALLIANCE : BG_AB_SOUND_NODE_ASSAULTED_HORDE;\n    }\n\n    // If node is occupied again, send \"X has taken the Y\" msg.\n    if (m_Nodes[node] \u003e= BG_AB_NODE_TYPE_OCCUPIED)\n    {\n        // FIXME: team and node names not localized\n        if (teamIndex == TEAM_ALLIANCE)\n            SendMessage2ToAll(LANG_BG_AB_NODE_TAKEN, CHAT_MSG_BG_SYSTEM_ALLIANCE, NULL, LANG_BG_AB_ALLY, _GetNodeNameId(node));\n        else\n            SendMessage2ToAll(LANG_BG_AB_NODE_TAKEN, CHAT_MSG_BG_SYSTEM_HORDE, NULL, LANG_BG_AB_HORDE, _GetNodeNameId(node));\n    }\n    PlaySoundToAll(sound);\n}\n\nuint32 BattlegroundAB::GetPrematureWinner()\n{\n    // How many bases each team owns\n    uint8 ally = 0, horde = 0;\n    for (uint8 i = 0; i \u003c BG_AB_DYNAMIC_NODES_COUNT; ++i)\n        if (m_Nodes[i] == BG_AB_NODE_STATUS_ALLY_OCCUPIED)\n            ++ally;\n        else if (m_Nodes[i] == BG_AB_NODE_STATUS_HORDE_OCCUPIED)\n            ++horde;\n\n    if (ally \u003e horde)\n        return ALLIANCE;\n    else if (horde \u003e ally)\n        return HORDE;\n\n    // If the values are equal, fall back to the original result (based on number of players on each team)\n    return Battleground::GetPrematureWinner();\n}\n\nbool BattlegroundAB::SetupBattleground()\n{\n    for (int i = 0; i \u003c BG_AB_DYNAMIC_NODES_COUNT; ++i)\n    {\n        if (!AddObject(BG_AB_OBJECT_BANNER_NEUTRAL + 8*i, BG_AB_OBJECTID_NODE_BANNER_0 + i, BG_AB_NodePositions[i], 0, 0, std::sin(BG_AB_NodePositions[i].GetOrientation()/2), std::cos(BG_AB_NodePositions[i].GetOrientation()/2), RESPAWN_ONE_DAY)\n            || !AddObject(BG_AB_OBJECT_BANNER_CONT_A + 8*i, BG_AB_OBJECTID_BANNER_CONT_A, BG_AB_NodePositions[i], 0, 0, std::sin(BG_AB_NodePositions[i].GetOrientation()/2), std::cos(BG_AB_NodePositions[i].GetOrientation()/2), RESPAWN_ONE_DAY)\n            || !AddObject(BG_AB_OBJECT_BANNER_CONT_H + 8*i, BG_AB_OBJECTID_BANNER_CONT_H, BG_AB_NodePositions[i], 0, 0, std::sin(BG_AB_NodePositions[i].GetOrientation()/2), std::cos(BG_AB_NodePositions[i].GetOrientation()/2), RESPAWN_ONE_DAY)\n            || !AddObject(BG_AB_OBJECT_BANNER_ALLY + 8*i, BG_AB_OBJECTID_BANNER_A, BG_AB_NodePositions[i], 0, 0, std::sin(BG_AB_NodePositions[i].GetOrientation()/2), std::cos(BG_AB_NodePositions[i].GetOrientation()/2), RESPAWN_ONE_DAY)\n            || !AddObject(BG_AB_OBJECT_BANNER_HORDE + 8*i, BG_AB_OBJECTID_BANNER_H, BG_AB_NodePositions[i], 0, 0, std::sin(BG_AB_NodePositions[i].GetOrientation()/2), std::cos(BG_AB_NodePositions[i].GetOrientation()/2), RESPAWN_ONE_DAY)\n            || !AddObject(BG_AB_OBJECT_AURA_ALLY + 8*i, BG_AB_OBJECTID_AURA_A, BG_AB_NodePositions[i], 0, 0, std::sin(BG_AB_NodePositions[i].GetOrientation()/2), std::cos(BG_AB_NodePositions[i].GetOrientation()/2), RESPAWN_ONE_DAY)\n            || !AddObject(BG_AB_OBJECT_AURA_HORDE + 8*i, BG_AB_OBJECTID_AURA_H, BG_AB_NodePositions[i], 0, 0, std::sin(BG_AB_NodePositions[i].GetOrientation()/2), std::cos(BG_AB_NodePositions[i].GetOrientation()/2), RESPAWN_ONE_DAY)\n            || !AddObject(BG_AB_OBJECT_AURA_CONTESTED + 8*i, BG_AB_OBJECTID_AURA_C, BG_AB_NodePositions[i], 0, 0, std::sin(BG_AB_NodePositions[i].GetOrientation()/2), std::cos(BG_AB_NodePositions[i].GetOrientation()/2), RESPAWN_ONE_DAY))\n        {\n            TC_LOG_ERROR(\"sql.sql\", \"BatteGroundAB: Failed to spawn some object Battleground not created!\");\n            return false;\n        }\n    }\n\n    if (!AddObject(BG_AB_OBJECT_GATE_A, BG_AB_OBJECTID_GATE_A, BG_AB_DoorPositions[0][0], BG_AB_DoorPositions[0][1], BG_AB_DoorPositions[0][2], BG_AB_DoorPositions[0][3], BG_AB_DoorPositions[0][4], BG_AB_DoorPositions[0][5], BG_AB_DoorPositions[0][6], BG_AB_DoorPositions[0][7], RESPAWN_IMMEDIATELY)\n        || !AddObject(BG_AB_OBJECT_GATE_H, BG_AB_OBJECTID_GATE_H, BG_AB_DoorPositions[1][0], BG_AB_DoorPositions[1][1], BG_AB_DoorPositions[1][2], BG_AB_DoorPositions[1][3], BG_AB_DoorPositions[1][4], BG_AB_DoorPositions[1][5], BG_AB_DoorPositions[1][6], BG_AB_DoorPositions[1][7], RESPAWN_IMMEDIATELY))\n    {\n        TC_LOG_ERROR(\"sql.sql\", \"BatteGroundAB: Failed to spawn door object Battleground not created!\");\n        return false;\n    }\n\n    //buffs\n    for (int i = 0; i \u003c BG_AB_DYNAMIC_NODES_COUNT; ++i)\n    {\n        if (!AddObject(BG_AB_OBJECT_SPEEDBUFF_STABLES + 3 * i, Buff_Entries[0], BG_AB_BuffPositions[i][0], BG_AB_BuffPositions[i][1], BG_AB_BuffPositions[i][2], BG_AB_BuffPositions[i][3], 0, 0, std::sin(BG_AB_BuffPositions[i][3]/2), std::cos(BG_AB_BuffPositions[i][3]/2), RESPAWN_ONE_DAY)\n            || !AddObject(BG_AB_OBJECT_SPEEDBUFF_STABLES + 3 * i + 1, Buff_Entries[1], BG_AB_BuffPositions[i][0], BG_AB_BuffPositions[i][1], BG_AB_BuffPositions[i][2], BG_AB_BuffPositions[i][3], 0, 0, std::sin(BG_AB_BuffPositions[i][3]/2), std::cos(BG_AB_BuffPositions[i][3]/2), RESPAWN_ONE_DAY)\n            || !AddObject(BG_AB_OBJECT_SPEEDBUFF_STABLES + 3 * i + 2, Buff_Entries[2], BG_AB_BuffPositions[i][0], BG_AB_BuffPositions[i][1], BG_AB_BuffPositions[i][2], BG_AB_BuffPositions[i][3], 0, 0, std::sin(BG_AB_BuffPositions[i][3]/2), std::cos(BG_AB_BuffPositions[i][3]/2), RESPAWN_ONE_DAY))\n            TC_LOG_ERROR(\"sql.sql\", \"BatteGroundAB: Failed to spawn buff object!\");\n    }\n\n    return true;\n}\n\nvoid BattlegroundAB::Reset()\n{\n    //call parent's class reset\n    Battleground::Reset();\n\n    m_TeamScores[TEAM_ALLIANCE]          = 0;\n    m_TeamScores[TEAM_HORDE]             = 0;\n    m_lastTick[TEAM_ALLIANCE]            = 0;\n    m_lastTick[TEAM_HORDE]               = 0;\n    m_HonorScoreTics[TEAM_ALLIANCE]      = 0;\n    m_HonorScoreTics[TEAM_HORDE]         = 0;\n    m_ReputationScoreTics[TEAM_ALLIANCE] = 0;\n    m_ReputationScoreTics[TEAM_HORDE]    = 0;\n    m_IsInformedNearVictory                 = false;\n    bool isBGWeekend = sBattlegroundMgr-\u003eIsBGWeekend(GetTypeID());\n    m_HonorTics = (isBGWeekend) ? BG_AB_ABBGWeekendHonorTicks : BG_AB_NotABBGWeekendHonorTicks;\n    m_ReputationTics = (isBGWeekend) ? BG_AB_ABBGWeekendReputationTicks : BG_AB_NotABBGWeekendReputationTicks;\n    m_TeamScores500Disadvantage[TEAM_ALLIANCE] = false;\n    m_TeamScores500Disadvantage[TEAM_HORDE]    = false;\n\n    for (uint8 i = 0; i \u003c BG_AB_DYNAMIC_NODES_COUNT; ++i)\n    {\n        m_Nodes[i] = 0;\n        m_prevNodes[i] = 0;\n        m_NodeTimers[i] = 0;\n        m_BannerTimers[i].timer = 0;\n    }\n\n    for (uint8 i = 0; i \u003c BG_AB_ALL_NODES_COUNT + 5; ++i)//+5 for aura triggers\n        if (!BgCreatures[i].IsEmpty())\n            DelCreature(i);\n}\n\nvoid BattlegroundAB::EndBattleground(uint32 winner)\n{\n    // Win reward\n    if (winner == ALLIANCE)\n        RewardHonorToTeam(GetBonusHonorFromKill(1), ALLIANCE);\n    if (winner == HORDE)\n        RewardHonorToTeam(GetBonusHonorFromKill(1), HORDE);\n    // Complete map_end rewards (even if no team wins)\n    RewardHonorToTeam(GetBonusHonorFromKill(1), HORDE);\n    RewardHonorToTeam(GetBonusHonorFromKill(1), ALLIANCE);\n\n    Battleground::EndBattleground(winner);\n}\n\nWorldSafeLocsEntry const* BattlegroundAB::GetClosestGraveYard(Player* player)\n{\n    TeamId teamIndex = GetTeamIndexByTeamId(player-\u003eGetTeam());\n\n    // Is there any occupied node for this team?\n    std::vector\u003cuint8\u003e nodes;\n    for (uint8 i = 0; i \u003c BG_AB_DYNAMIC_NODES_COUNT; ++i)\n        if (m_Nodes[i] == teamIndex + 3)\n            nodes.push_back(i);\n\n    WorldSafeLocsEntry const* good_entry = NULL;\n    // If so, select the closest node to place ghost on\n    if (!nodes.empty())\n    {\n        float plr_x = player-\u003eGetPositionX();\n        float plr_y = player-\u003eGetPositionY();\n\n        float mindist = 999999.0f;\n        for (uint8 i = 0; i \u003c nodes.size(); ++i)\n        {\n            WorldSafeLocsEntry const*entry = sWorldSafeLocsStore.LookupEntry(BG_AB_GraveyardIds[nodes[i]]);\n            if (!entry)\n                continue;\n            float dist = (entry-\u003eLoc.X - plr_x)*(entry-\u003eLoc.X - plr_x)+(entry-\u003eLoc.Y - plr_y)*(entry-\u003eLoc.Y - plr_y);\n            if (mindist \u003e dist)\n            {\n                mindist = dist;\n                good_entry = entry;\n            }\n        }\n        nodes.clear();\n    }\n    // If not, place ghost on starting location\n    if (!good_entry)\n        good_entry = sWorldSafeLocsStore.LookupEntry(BG_AB_GraveyardIds[teamIndex+5]);\n\n    return good_entry;\n}\n\nbool BattlegroundAB::UpdatePlayerScore(Player* player, uint32 type, uint32 value, bool doAddHonor)\n{\n    if (!Battleground::UpdatePlayerScore(player, type, value, doAddHonor))\n        return false;\n\n    switch (type)\n    {\n        case SCORE_BASES_ASSAULTED:\n            player-\u003eUpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_BG_OBJECTIVE_CAPTURE, AB_OBJECTIVE_ASSAULT_BASE);\n            break;\n        case SCORE_BASES_DEFENDED:\n            player-\u003eUpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_BG_OBJECTIVE_CAPTURE, AB_OBJECTIVE_DEFEND_BASE);\n            break;\n        default:\n            break;\n    }\n    return true;\n}\n\nbool BattlegroundAB::IsAllNodesControlledByTeam(uint32 team) const\n{\n    uint32 count = 0;\n    for (int i = 0; i \u003c BG_AB_DYNAMIC_NODES_COUNT; ++i)\n        if ((team == ALLIANCE \u0026\u0026 m_Nodes[i] == BG_AB_NODE_STATUS_ALLY_OCCUPIED) ||\n            (team == HORDE    \u0026\u0026 m_Nodes[i] == BG_AB_NODE_STATUS_HORDE_OCCUPIED))\n            ++count;\n\n    return count == BG_AB_DYNAMIC_NODES_COUNT;\n}\n\nbool BattlegroundAB::CheckAchievementCriteriaMeet(uint32 criteriaId, Player const* player, Unit const* target, uint32 miscvalue)\n{\n    switch (criteriaId)\n    {\n        case BG_CRITERIA_CHECK_RESILIENT_VICTORY:\n            return m_TeamScores500Disadvantage[GetTeamIndexByTeamId(player-\u003eGetTeam())];\n    }\n\n    return Battleground::CheckAchievementCriteriaMeet(criteriaId, player, target, miscvalue);\n}\n"}
{"repo_name":"bombehub/PPR_PPV","ref":"refs/heads/master","path":"Snap-3.0/snap-exp/test-dev/ExplicitStringTableTest2.cpp","copies":"1","language":"C++","content":"#include \"Snap.h\"\n#include \u003ccstring\u003e\n#include \"BenchmarkUtilities.h\"\n\n/*\nThis test measures the performance of loading and performing join and select of the StackOverflow tags dataset when\nusing explicit string storage (i.e. no string pool). To be compared with performance of the same set of operations \nby TTable (ExplicitStringTableTest1).\n*/\n\n\nint main(int argc, char** argv){\n  TBool debug = false;\n  TStr TagsFnm = \"/lfs/madmax4/0/yonathan/tags\";\n  if(debug){ TagsFnm = \"/lfs/madmax4/0/yonathan/tags_small\";}\n  Schema TagS; \n  TagS.Add(TPair\u003cTStr,TAttrType\u003e(\"UserId\", atInt));\n  TagS.Add(TPair\u003cTStr,TAttrType\u003e(\"Tag\", atStr));\n\t\n  float ft_max;\n  float mu_max;\n\n  timeval timer4;\n  gettimeofday(\u0026timer4, NULL);\n  double t1 = timer4.tv_sec + (timer4.tv_usec/1000000.0);\n  PExplicitStringTable ES_Tags = ExplicitStringTable::LoadSS(TagS, TagsFnm + \".tsv\");\n  gettimeofday(\u0026timer4, NULL);\n  double t2 = timer4.tv_sec + (timer4.tv_usec/1000000.0);\n  printf(\"Time to load tags table: %f\\n\", t2 - t1);\n  printf(\"Table Size:\\n\");\n  ES_Tags-\u003ePrintSize();\n  getmaxcpumem(\u0026ft_max, \u0026mu_max);\n  printf(\"time: %0.3f seconds, memory: %0.3f MB\\n\", ft_max, mu_max);\n  printf(\"\\n\");\n\t\n  timeval timer6;\n  gettimeofday(\u0026timer6, NULL);\n  t1 = timer6.tv_sec + (timer6.tv_usec/1000000.0);\n  PExplicitStringTable ES_TagsJoinUser = ES_Tags-\u003eSelfJoin(\"UserId\");\n  gettimeofday(\u0026timer6, NULL);\n  t2 = timer6.tv_sec + (timer6.tv_usec/1000000.0);\n  printf(\"Time to join on user id column: %f\\n\", t2 - t1);\n  printf(\"Table Size:\\n\");\n  ES_TagsJoinUser-\u003ePrintSize();\n  if(debug){ ES_TagsJoinUser-\u003eSaveSS(TagsFnm + \"_join_user_es.tsv\");}\n  getmaxcpumem(\u0026ft_max, \u0026mu_max);\n  printf(\"time: %0.3f seconds, memory: %0.3f MB\\n\", ft_max, mu_max);\n  printf(\"\\n\");\n\t\n  timeval timer7;\n  gettimeofday(\u0026timer7, NULL);\n  t1 = timer7.tv_sec + (timer7.tv_usec/1000000.0);\n  PExplicitStringTable ES_JavaTags = ExplicitStringTable::New(TagS);\n  TIntV SelectedRows1;\n  if(debug){\n  \tES_Tags-\u003eSelectAtomicConst(TStr(\"Tag\"), TStr(\"c#\"), EQ, SelectedRows1, ES_JavaTags, false, true);\n  } else{\n  \tES_Tags-\u003eSelectAtomicConst(TStr(\"Tag\"), TStr(\"java\"), EQ, SelectedRows1, ES_JavaTags, false, true);\n  }\n  gettimeofday(\u0026timer7, NULL);\n  t2 = timer7.tv_sec + (timer7.tv_usec/1000000.0);\n  printf(\"Time to select java users: %f\\n\", t2 - t1);\n  printf(\"Table Size:\\n\");\n  ES_JavaTags-\u003ePrintSize();\n  if(debug){ ES_JavaTags-\u003eSaveSS(TagsFnm + \"_select_es.tsv\");}\n  getmaxcpumem(\u0026ft_max, \u0026mu_max);\n  printf(\"time: %0.3f seconds, memory: %0.3f MB\\n\", ft_max, mu_max);\n  printf(\"\\n\");\n\t\n  return 0;\n}"}
{"repo_name":"braingl/braingl","ref":"refs/heads/master","path":"src/algos/sdthread.cpp","copies":"5","language":"C++","content":"/*\n * sdthread.cpp\n *\n *  Created on: Jul 22, 2013\n *      Author: schurade\n */\n\n#include \"sdthread.h\"\n\n#include \"../data/datasets/datasetdwi.h\"\n\n#include \"../gui/gl/glfunctions.h\"\n\nSDThread::SDThread( DatasetDWI* ds, int id  ) :\n    m_dataset( ds ),\n    m_id( id )\n{\n    m_dwi = ds-\u003egetData();\n    m_bvals = ds-\u003egetBvals();\n    m_bvecs = ds-\u003egetBvecs();\n\n    int nx = ds-\u003eproperties( \"maingl\" ).get( Fn::Property::D_NX ).toInt();\n    int ny = ds-\u003eproperties( \"maingl\" ).get( Fn::Property::D_NY ).toInt();\n    int nz = ds-\u003eproperties( \"maingl\" ).get( Fn::Property::D_NZ ).toInt();\n    m_blockSize = nx * ny *nz;\n}\n\nSDThread::~SDThread()\n{\n}\n\nvoid SDThread::run()\n{\n    int numThreads = GLFunctions::idealThreadCount;\n    int progressCounter = 0;\n\n    for ( int i = m_id; i \u003c m_blockSize;  i += numThreads )\n    {\n        calcSD( i );\n\n        ++progressCounter;\n        if ( progressCounter == 100 )\n        {\n            emit( progress() );\n            progressCounter = 0;\n        }\n    }\n    emit( finished() );\n}\n\nColumnVector SDThread::calcSD( int id )\n{\n    return ColumnVector( 20 );\n}\n"}
{"repo_name":"BillHally/boo","ref":"refs/heads/master","path":"lib/antlr-2.7.5/lib/cpp/src/TreeParser.cpp","copies":"21","language":"C++","content":"/* ANTLR Translator Generator\n * Project led by Terence Parr at http://www.jGuru.com\n * Software rights: http://www.antlr.org/license.html\n *\n * $Id: //depot/code/org.antlr/release/antlr-2.7.5/lib/cpp/src/TreeParser.cpp#1 $\n */\n\n#include \u003ciostream\u003e\n\n#include \"antlr/TreeParser.hpp\"\n#include \"antlr/ASTNULLType.hpp\"\n\n#ifdef ANTLR_CXX_SUPPORTS_NAMESPACE\nnamespace antlr {\n#endif\n\n/** The AST Null object; the parsing cursor is set to this when\n *  it is found to be null.  This way, we can test the\n *  token type of a node without having to have tests for null\n *  everywhere.\n */\nRefAST TreeParser::ASTNULL(new ASTNULLType);\n\n/** Parser error-reporting function can be overridden in subclass */\nvoid TreeParser::reportError(const RecognitionException\u0026 ex)\n{\n\tANTLR_USE_NAMESPACE(std)cerr \u003c\u003c ex.toString().c_str() \u003c\u003c ANTLR_USE_NAMESPACE(std)endl;\n}\n\n/** Parser error-reporting function can be overridden in subclass */\nvoid TreeParser::reportError(const ANTLR_USE_NAMESPACE(std)string\u0026 s)\n{\n\tANTLR_USE_NAMESPACE(std)cerr \u003c\u003c \"error: \" \u003c\u003c s.c_str() \u003c\u003c ANTLR_USE_NAMESPACE(std)endl;\n}\n\n/** Parser warning-reporting function can be overridden in subclass */\nvoid TreeParser::reportWarning(const ANTLR_USE_NAMESPACE(std)string\u0026 s)\n{\n\tANTLR_USE_NAMESPACE(std)cerr \u003c\u003c \"warning: \" \u003c\u003c s.c_str() \u003c\u003c ANTLR_USE_NAMESPACE(std)endl;\n}\n\n/** Procedure to write out an indent for traceIn and traceOut */\nvoid TreeParser::traceIndent()\n{\n\tfor( int i = 0; i \u003c traceDepth; i++ )\n\t\tANTLR_USE_NAMESPACE(std)cout \u003c\u003c \" \";\n}\n\nvoid TreeParser::traceIn(const char* rname, RefAST t)\n{\n\ttraceDepth++;\n\ttraceIndent();\n\n\tANTLR_USE_NAMESPACE(std)cout \u003c\u003c \"\u003e \" \u003c\u003c rname\n\t\t\t\u003c\u003c \"(\" \u003c\u003c (t ? t-\u003etoString().c_str() : \"null\") \u003c\u003c \")\"\n\t\t\t\u003c\u003c ((inputState-\u003eguessing\u003e0)?\" [guessing]\":\"\")\n\t\t\t\u003c\u003c ANTLR_USE_NAMESPACE(std)endl;\n}\n\nvoid TreeParser::traceOut(const char* rname, RefAST t)\n{\n\ttraceIndent();\n\n\tANTLR_USE_NAMESPACE(std)cout \u003c\u003c \"\u003c \" \u003c\u003c rname\n\t\t\t\u003c\u003c \"(\" \u003c\u003c (t ? t-\u003etoString().c_str() : \"null\") \u003c\u003c \")\"\n\t\t\t\u003c\u003c ((inputState-\u003eguessing\u003e0)?\" [guessing]\":\"\")\n\t\t\t\u003c\u003c ANTLR_USE_NAMESPACE(std)endl;\n\n\ttraceDepth--;\n}\n\n#ifdef ANTLR_CXX_SUPPORTS_NAMESPACE\n}\n#endif\n"}
{"repo_name":"austinzheng/swift","ref":"refs/heads/master","path":"lib/SILOptimizer/IPO/LetPropertiesOpts.cpp","copies":"4","language":"C++","content":"//===--- LetPropertiesOpts.cpp - Optimize let properties ------------------===//\n//\n// This source file is part of the Swift.org open source project\n//\n// Copyright (c) 2014 - 2017 Apple Inc. and the Swift project authors\n// Licensed under Apache License v2.0 with Runtime Library Exception\n//\n// See https://swift.org/LICENSE.txt for license information\n// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors\n//\n//===----------------------------------------------------------------------===//\n// Promote values of non-static let properties initialized by means\n// of constant values of simple types into their uses.\n//\n// For any given non-static let property this optimization is only possible\n// if this pass can prove that it has analyzed all assignments of an initial\n// value to this property and all those assignments assign the same value\n// to this property.\n//===----------------------------------------------------------------------===//\n\n#define DEBUG_TYPE \"let-properties-opt\"\n#include \"swift/SIL/DebugUtils.h\"\n#include \"swift/SIL/InstructionUtils.h\"\n#include \"swift/SIL/SILBasicBlock.h\"\n#include \"swift/SIL/SILInstruction.h\"\n#include \"swift/SIL/SILLinkage.h\"\n#include \"swift/SILOptimizer/PassManager/Passes.h\"\n#include \"swift/SILOptimizer/PassManager/Transforms.h\"\n#include \"swift/SILOptimizer/Utils/Local.h\"\n#include \"llvm/ADT/MapVector.h\"\n#include \"llvm/Support/CommandLine.h\"\n#include \"llvm/Support/Debug.h\"\nusing namespace swift;\n\nnamespace {\n\nusing InstructionList = SmallVector\u003cSILInstruction *, 8\u003e;\n\nstruct InitSequence {\n  InstructionList Instructions;\n  SILValue Result;\n\n  bool isValid() const {\n    return (bool) Result;\n  }\n};\n\n/// Promote values of non-static let properties initialized by means\n/// of constant values of simple types into their uses.\n///\n/// TODO: Don't occupy any storage for such let properties with constant\n/// initializers.\n///\n/// Note: Storage from a let property can only be removed if this\n/// property can never be referenced from another module.\n\nclass LetPropertiesOpt {\n  SILModule *Module;\n\n  typedef SmallVector\u003cVarDecl *, 4\u003e Properties;\n\n  llvm::SetVector\u003cSILFunction *\u003e ChangedFunctions;\n\n  // Map each let property to a set of instructions accessing it.\n  llvm::MapVector\u003cVarDecl *, InstructionList\u003e AccessMap;\n  // Map each let property to the instruction sequence which initializes it.\n  llvm::MapVector\u003cVarDecl *, InitSequence\u003e InitMap;\n  // Properties in this set should not be processed by this pass\n  // anymore.\n  llvm::SmallPtrSet\u003cVarDecl *, 16\u003e SkipProcessing;\n  // Types in this set should not be processed by this pass\n  // anymore.\n  llvm::SmallPtrSet\u003cNominalTypeDecl *, 16\u003e SkipTypeProcessing;\n  // Properties in this set cannot be removed.\n  llvm::SmallPtrSet\u003cVarDecl *, 16\u003e CannotRemove;\n  // Set of let properties in a given nominal type.\n  llvm::MapVector\u003cNominalTypeDecl *, Properties\u003e NominalTypeLetProperties;\n  // Set of properties which already fulfill all conditions, except\n  // the available of constant, statically known initializer.\n  llvm::SmallPtrSet\u003cVarDecl *, 16\u003e PotentialConstantLetProperty;\n\npublic:\n  LetPropertiesOpt(SILModule *M): Module(M) {}\n\n  void run(SILModuleTransform *T);\n\nprotected:\n  bool isConstantLetProperty(VarDecl *Property);\n  void collectPropertyAccess(SILInstruction *I, VarDecl *Property, bool NonRemovable);\n  void collectStructPropertiesAccess(StructInst *SI, bool NonRemovable);\n  void optimizeLetPropertyAccess(VarDecl *SILG, const InitSequence \u0026Init);\n  bool analyzeInitValue(SILInstruction *I, VarDecl *Prop);\n};\n\n/// Helper class to copy only a set of SIL instructions providing in the\n/// constructor.\nclass InitSequenceCloner : public SILClonerWithScopes\u003cInitSequenceCloner\u003e {\n  friend class SILInstructionVisitor\u003cInitSequenceCloner\u003e;\n  friend class SILCloner\u003cInitSequenceCloner\u003e;\n\n  const InitSequence \u0026Init;\n  SILInstruction *DestIP;\n\npublic:\n  InitSequenceCloner(const InitSequence \u0026init, SILInstruction *destIP)\n    : SILClonerWithScopes(*destIP-\u003egetFunction()), Init(init), DestIP(destIP) {}\n\n  void process(SILInstruction *I) { visit(I); }\n\n  SILBasicBlock *remapBasicBlock(SILBasicBlock *BB) { return BB; }\n\n  SILValue getMappedValue(SILValue Value) {\n    return SILCloner\u003cInitSequenceCloner\u003e::getMappedValue(Value);\n  }\n\n  void postProcess(SILInstruction *orig, SILInstruction *cloned) {\n    DestIP-\u003egetParent()-\u003epush_front(cloned);\n    cloned-\u003emoveBefore(DestIP);\n    SILClonerWithScopes\u003cInitSequenceCloner\u003e::postProcess(orig, cloned);\n  }\n\n  /// Clone all the instructions from Insns into the destination function,\n  /// immediately before the destination block, and return the value of\n  /// the result.\n  SILValue clone() {\n    for (auto I : Init.Instructions)\n      process(I);\n    return getMappedValue(Init.Result);\n  }\n};\n\n} // end anonymous namespace\n\n#ifndef NDEBUG\n// For debugging only.\nstatic raw_ostream \u0026operator\u003c\u003c(raw_ostream \u0026OS, const VarDecl \u0026decl) {\n  auto *Ty = dyn_cast\u003cNominalTypeDecl\u003e(decl.getDeclContext());\n  if (Ty)\n    OS \u003c\u003c Ty-\u003egetName() \u003c\u003c \"::\";\n  OS \u003c\u003c decl.getName();\n  return OS;\n}\n#endif\n\n/// Optimize access to the let property, which is known\n/// to have a constant value. Replace all loads from the\n/// property by its constant value.\nvoid LetPropertiesOpt::optimizeLetPropertyAccess(VarDecl *Property,\n                                                 const InitSequence \u0026init) {\n  assert(init.isValid());\n\n  if (SkipProcessing.count(Property))\n    return;\n\n  auto *Ty = dyn_cast\u003cNominalTypeDecl\u003e(Property-\u003egetDeclContext());\n  if (SkipTypeProcessing.count(Ty))\n    return;\n\n  LLVM_DEBUG(llvm::dbgs() \u003c\u003c \"Replacing access to property '\" \u003c\u003c *Property\n                          \u003c\u003c \"' by its constant initializer\\n\");\n\n  auto PropertyAccess = Property-\u003egetEffectiveAccess();\n  auto TypeAccess = Ty-\u003egetEffectiveAccess();\n  auto CanRemove = false;\n\n  // Check if a given let property can be removed, because it\n  // is not accessible elsewhere. This can happen if this property\n  // is private or if it is internal and WMO mode is used.\n  if (TypeAccess \u003c= AccessLevel::FilePrivate ||\n      PropertyAccess \u003c= AccessLevel::FilePrivate\n      || ((TypeAccess \u003c= AccessLevel::Internal ||\n          PropertyAccess \u003c= AccessLevel::Internal) \u0026\u0026\n          Module-\u003eisWholeModule())) {\n    CanRemove = true;\n    LLVM_DEBUG(llvm::dbgs() \u003c\u003c \"Storage for property '\" \u003c\u003c *Property\n                            \u003c\u003c \"' can be eliminated\\n\");\n  }\n\n  if (CannotRemove.count(Property))\n    CanRemove = false;\n\n  if (!AccessMap.count(Property)) {\n    LLVM_DEBUG(llvm::dbgs() \u003c\u003c \"Property '\" \u003c\u003c *Property \u003c\u003c\"' is never read\\n\");\n    if (CanRemove) {\n      // TODO: Remove the let property, because it is never accessed.\n    }\n    return;\n  }\n\n  auto \u0026Loads = AccessMap[Property];\n\n  unsigned NumReplaced = 0;\n\n  for (auto Load: Loads) {\n    SILFunction *F = Load-\u003egetFunction();\n\n    // A helper function to copy the initializer into the target function\n    // at the target insertion point.\n    auto cloneInitAt = [\u0026](SILInstruction *insertionPoint) -\u003e SILValue {\n      InitSequenceCloner cloner(init, insertionPoint);\n      return cloner.clone();\n    };\n\n    // Look for any instructions accessing let properties.\n    if (isa\u003cRefElementAddrInst\u003e(Load) || isa\u003cStructElementAddrInst\u003e(Load)\n        || isa\u003cBeginAccessInst\u003e(Load)) {\n      auto proj = cast\u003cSingleValueInstruction\u003e(Load);\n\n      // Copy the initializer into the function\n      // Replace the access to a let property by the value\n      // computed by this initializer.\n      SILValue clonedInit = cloneInitAt(proj);\n      SILBuilderWithScope B(proj);\n      for (auto UI = proj-\u003euse_begin(), E = proj-\u003euse_end(); UI != E;) {\n        auto *User = UI-\u003egetUser();\n        ++UI;\n\n        if (isIncidentalUse(User))\n          continue;\n\n        // A nested begin_access will be mapped as a separate \"Load\".\n        if (isa\u003cBeginAccessInst\u003e(User))\n          continue;\n\n        if (isa\u003cStoreInst\u003e(User))\n          continue;\n\n        replaceLoadSequence(User, clonedInit, B);\n        eraseUsesOfInstruction(User);\n        User-\u003eeraseFromParent();\n        ++NumReplaced;\n      }\n      ChangedFunctions.insert(F);\n    } else if (auto proj = dyn_cast\u003cStructExtractInst\u003e(Load)) {\n      // Copy the initializer into the function\n      // Replace the access to a let property by the value\n      // computed by this initializer.\n      SILValue clonedInit = cloneInitAt(proj);\n      proj-\u003ereplaceAllUsesWith(clonedInit);\n      LLVM_DEBUG(llvm::dbgs() \u003c\u003c \"Access to \" \u003c\u003c *Property \u003c\u003c\" was replaced:\\n\";\n            clonedInit-\u003edumpInContext());\n\n      proj-\u003eeraseFromParent();\n      ++NumReplaced;\n      ChangedFunctions.insert(F);\n    }\n  }\n\n  LLVM_DEBUG(llvm::dbgs() \u003c\u003c \"Access to \" \u003c\u003c *Property \u003c\u003c \" was replaced \"\n                          \u003c\u003c NumReplaced \u003c\u003c \" time(s)\\n\");\n\n  if (CanRemove) {\n    // TODO: Remove the let property, because it is never accessed.\n  }\n}\n\n/// Compare two SILValues structurally.\nstatic bool isStructurallyIdentical(SILValue LHS, SILValue RHS) {\n  if (LHS == RHS)\n    return true;\n\n  if (LHS-\u003egetType() != RHS-\u003egetType())\n    return false;\n\n  auto lResult = LHS-\u003egetDefiningInstructionResult();\n  auto rResult = RHS-\u003egetDefiningInstructionResult();\n  assert(lResult \u0026\u0026 rResult \u0026\u0026\n         \"operands of instructions approved by analyzeStaticInitializer \"\n         \"should always be defined by instructions\");\n  return (lResult-\u003eResultIndex == rResult-\u003eResultIndex \u0026\u0026\n          lResult-\u003eInstruction-\u003eisIdenticalTo(rResult-\u003eInstruction,\n                                              isStructurallyIdentical));\n};\n\n/// Compare two sequences of SIL instructions. They should be structurally\n/// equivalent.\nstatic bool isSameInitSequence(const InitSequence \u0026LHS,\n                               const InitSequence \u0026RHS) {\n  assert(LHS.isValid() \u0026\u0026 RHS.isValid());\n  // This will recursively check all the instructions.  It's possible\n  // that they'll be composed slightly differently, but it shouldn't matter.\n  return isStructurallyIdentical(LHS.Result, RHS.Result);\n}\n\n/// Check if a given let property can be assigned externally.\nstatic bool isAssignableExternally(VarDecl *Property, SILModule *Module) {\n  if (Module-\u003eisVisibleExternally(Property)) {\n    // If at least one of the properties of the enclosing type cannot be\n    // used externally, then no initializer can be implemented externally as\n    // it wouldn't be able to initialize such a property.\n    // More over, for classes, only the class itself can initialize its\n    // let properties. Subclasses and extensions cannot do it.\n    // For structs, external extensions may initialize let properties. But to do\n    // that they need to be able to initialize all properties, i.e. all\n    // properties should be accessible by the extension.\n\n    auto *Ty = dyn_cast\u003cNominalTypeDecl\u003e(Property-\u003egetDeclContext());\n\n    // Initializer for a let property of a class cannot exist externally.\n    // It cannot be defined by an extension or a derived class.\n    if (isa\u003cClassDecl\u003e(Ty))\n      return false;\n\n    // Check if there are any private properties or any internal properties and\n    // it is a whole module compilation. In this case, no external initializer\n    // may exist.\n    for (auto SP : Ty-\u003egetStoredProperties()) {\n      auto storedPropertyAccess = SP-\u003egetEffectiveAccess();\n      if (storedPropertyAccess \u003c= AccessLevel::FilePrivate ||\n          (storedPropertyAccess \u003c= AccessLevel::Internal \u0026\u0026\n           Module-\u003eisWholeModule())) {\n       LLVM_DEBUG(llvm::dbgs() \u003c\u003c \"Property \" \u003c\u003c *Property\n                               \u003c\u003c \" cannot be set externally\\n\");\n       return false;\n      }\n    }\n\n    LLVM_DEBUG(llvm::dbgs() \u003c\u003c \"Property \" \u003c\u003c *Property\n                            \u003c\u003c \" can be used externally\\n\");\n    return true;\n  }\n\n  return false;\n}\n\n// Checks if a given property may have any unknown uses which cannot\n// be analyzed by this pass.\nstatic bool mayHaveUnknownUses(VarDecl *Property, SILModule *Module) {\n  if (Property-\u003egetDeclContext()-\u003egetParentModule() !=\n      Module-\u003egetSwiftModule()) {\n    LLVM_DEBUG(llvm::dbgs() \u003c\u003c \"Property \" \u003c\u003c *Property\n                            \u003c\u003c \" is defined in a different module\\n\");\n    // We don't see the bodies of initializers from a different module\n    // unless all of them are fragile.\n    // TODO: Support fragile initializers.\n    return true;\n  }\n\n  // If let properties can be assigned externally, we don't know\n  // the values they may get.\n  if (isAssignableExternally(Property, Module)) {\n    return true;\n  }\n\n  return false;\n}\n\n\n/// Check if a given property is a non-static let property\n/// with known constant value.\nbool LetPropertiesOpt::isConstantLetProperty(VarDecl *Property) {\n  // Process only non-static let properties here.\n  if (!Property-\u003eisLet() || Property-\u003eisStatic())\n    return false;\n\n  // Do not re-process already known properties.\n  if (SkipProcessing.count(Property))\n    return false;\n\n  // If these checks were performed already, no need to\n  // repeat them.\n  if (PotentialConstantLetProperty.count(Property))\n    return true;\n\n  // Check the visibility of this property. If its visibility\n  // implies that this optimization pass cannot analyze all uses,\n  // don't process it.\n  if (mayHaveUnknownUses(Property, Module)) {\n    LLVM_DEBUG(llvm::dbgs() \u003c\u003c \"Property '\" \u003c\u003c *Property\n                            \u003c\u003c \"' may have unknown uses\\n\");\n    SkipProcessing.insert(Property);\n    return false;\n  }\n\n  LLVM_DEBUG(llvm::dbgs() \u003c\u003c \"Property '\" \u003c\u003c *Property\n                          \u003c\u003c \"' has no unknown uses\\n\");\n\n  // Only properties of simple types can be optimized.\n  if (!isSimpleType(Module-\u003eTypes.getLoweredType(Property-\u003egetType()), *Module)) {\n     LLVM_DEBUG(llvm::dbgs() \u003c\u003c \"Property '\" \u003c\u003c *Property\n                             \u003c\u003c \"' is not of trivial type\\n\");\n    SkipProcessing.insert(Property);\n    return false;\n  }\n\n  PotentialConstantLetProperty.insert(Property);\n\n  return true;\n}\n\nstatic bool isProjectionOfProperty(SILValue addr, VarDecl *Property) {\n  if (auto *REA = dyn_cast\u003cRefElementAddrInst\u003e(addr)) {\n    return REA-\u003egetField() == Property;\n  }\n  if (auto *SEA = dyn_cast\u003cStructElementAddrInst\u003e(addr)) {\n    return SEA-\u003egetField() == Property;\n  }\n  return false;\n}\n\n// Analyze the init value being stored by the instruction into a property.\nbool\nLetPropertiesOpt::analyzeInitValue(SILInstruction *I, VarDecl *Property) {\n  SILValue value;\n  if (auto SI = dyn_cast\u003cStructInst\u003e(I)) {\n    value = SI-\u003egetFieldValue(Property);\n  } else if (auto SI = dyn_cast\u003cStoreInst\u003e(I)) {\n    auto Dest = stripAddressAccess(SI-\u003egetDest());\n\n    assert(isProjectionOfProperty(stripAddressAccess(SI-\u003egetDest()), Property)\n           \u0026\u0026 \"Store instruction should store into a proper let property\");\n    (void) Dest;\n    value = SI-\u003egetSrc();\n  }\n\n  // Check if it's just a copy from another instance of the struct.\n  if (auto *LI = dyn_cast\u003cLoadInst\u003e(value)) {\n    SILValue addr = LI-\u003egetOperand();\n    if (isProjectionOfProperty(addr, Property))\n      return true;\n  }\n\n  // Bail if a value of a property is not a statically known constant init.\n  InitSequence sequence;\n  sequence.Result = value;\n  if (!analyzeStaticInitializer(value, sequence.Instructions))\n    return false;\n\n  auto \u0026cachedSequence = InitMap[Property];\n  if (cachedSequence.isValid() \u0026\u0026\n      !isSameInitSequence(cachedSequence, sequence)) {\n    // The found init value is different from the already seen init value.\n    return false;\n  } else {\n    LLVM_DEBUG(llvm::dbgs() \u003c\u003c \"The value of property '\" \u003c\u003c *Property\n                            \u003c\u003c \"' is statically known so far\\n\");\n    // Remember the statically known value.\n    cachedSequence = std::move(sequence);\n    return true;\n  }\n}\n\n// Analyze the 'struct' instruction and check if it initializes\n// any let properties by statically known constant initializers.\nvoid LetPropertiesOpt::collectStructPropertiesAccess(StructInst *SI,\n                                                     bool NonRemovable) {\n  auto structDecl = SI-\u003egetStructDecl();\n  // Check if this struct has any let properties.\n\n  // Bail, if this struct is known to contain nothing interesting.\n  if (SkipTypeProcessing.count(structDecl))\n    return;\n\n  // Get the set of let properties defined by this struct.\n  if (!NominalTypeLetProperties.count(structDecl)) {\n    // Compute the let properties of this struct.\n    SmallVector\u003cVarDecl *, 4\u003e LetProps;\n\n    for (auto Prop : structDecl-\u003egetStoredProperties()) {\n      if (!isConstantLetProperty(Prop))\n        continue;\n      LetProps.push_back(Prop);\n    }\n\n    if (LetProps.empty()) {\n      // No interesting let properties in this struct.\n      SkipTypeProcessing.insert(structDecl);\n      return;\n    }\n\n    NominalTypeLetProperties[structDecl] = LetProps;\n    LLVM_DEBUG(llvm::dbgs() \u003c\u003c \"Computed set of let properties for struct '\"\n                            \u003c\u003c structDecl-\u003egetName() \u003c\u003c \"'\\n\");\n  }\n\n  auto \u0026Props = NominalTypeLetProperties[structDecl];\n\n  LLVM_DEBUG(llvm::dbgs() \u003c\u003c \"Found a struct instruction initializing some \"\n                             \"let properties: \";\n             SI-\u003edumpInContext());\n  // Figure out the initializing sequence for each\n  // of the properties.\n  for (auto Prop : Props) {\n    if (SkipProcessing.count(Prop))\n      continue;\n    SILValue PropValue = SI-\u003egetOperandForField(Prop)-\u003eget();\n    LLVM_DEBUG(llvm::dbgs() \u003c\u003c \"Check the value of property '\" \u003c\u003c *Prop\n                            \u003c\u003c \"' :\" \u003c\u003c PropValue \u003c\u003c \"\\n\");\n    if (!analyzeInitValue(SI, Prop)) {\n      SkipProcessing.insert(Prop);\n      LLVM_DEBUG(llvm::dbgs() \u003c\u003c \"The value of a let property '\" \u003c\u003c *Prop\n                              \u003c\u003c \"' is not statically known\\n\");\n    }\n    (void) PropValue;\n  }\n}\n\n/// Check if I is a sequence of projections followed by a load.\n/// Since it is supposed to be a load from a let property with\n/// statically known constant initializer, only struct_element_addr\n/// and tuple_element_addr projections are considered.\nstatic bool isValidPropertyLoad(SILInstruction *I) {\n  if (isa\u003cLoadInst\u003e(I))\n    return true;\n\n  if (isa\u003cStructElementAddrInst\u003e(I) || isa\u003cTupleElementAddrInst\u003e(I)) {\n    auto projection = cast\u003cSingleValueInstruction\u003e(I);\n    for (auto Use : getNonDebugUses(projection)) {\n      if (isIncidentalUse(Use-\u003egetUser()))\n        continue;\n      if (!isValidPropertyLoad(Use-\u003egetUser()))\n        return false;\n    }\n    return true;\n  }\n\n  return false;\n}\n\n\n/// Remember where this property is accessed.\nvoid LetPropertiesOpt::collectPropertyAccess(SILInstruction *I,\n                                             VarDecl *Property,\n                                             bool NonRemovable) {\n  if (!isConstantLetProperty(Property))\n    return;\n\n  LLVM_DEBUG(llvm::dbgs() \u003c\u003c \"Collecting property access for property '\"\n                          \u003c\u003c *Property \u003c\u003c \"':\\n\";\n             llvm::dbgs() \u003c\u003c \"The instructions are:\\n\"; I-\u003edumpInContext());\n\n  if (isa\u003cRefElementAddrInst\u003e(I) || isa\u003cStructElementAddrInst\u003e(I)\n      || isa\u003cBeginAccessInst\u003e(I)) {\n    // Check if there is a store to this property.\n    auto projection = cast\u003cSingleValueInstruction\u003e(I);\n    for (auto Use : getNonDebugUses(projection)) {\n      auto *User = Use-\u003egetUser();\n      if (isIncidentalUse(User))\n        continue;\n\n      // Each begin_access is analyzed as a separate property access. Do not\n      // consider a begin_access a use of the current projection.\n      if (isa\u003cBeginAccessInst\u003e(User))\n        continue;\n\n      if (auto *SI = dyn_cast\u003cStoreInst\u003e(User)) {\n        // There is a store into this property.\n        // Analyze the assigned value and check if it is a constant\n        // statically known initializer.\n        if (SI-\u003egetDest() != projection || !analyzeInitValue(SI, Property)) {\n          SkipProcessing.insert(Property);\n          return;\n        }\n        continue;\n      }\n\n      // Follow the chain of projections and check if it ends up with a load.\n      // If this is not the case, it is potentially a store into sub-property\n      // of a property.\n      // We cannot handle such cases yet, so bail.\n      if (!isValidPropertyLoad(User)) {\n        SkipProcessing.insert(Property);\n        return;\n      }\n    }\n  }\n\n  AccessMap[Property].push_back(I);\n  // If any property is marked as non-removable, their initialization\n  // and storage cannot be completely removed. But their constant\n  // values can still be propagated into their uses whenever possible.\n  if (NonRemovable)\n    CannotRemove.insert(Property);\n}\n\nvoid LetPropertiesOpt::run(SILModuleTransform *T) {\n  // Collect property access information for the whole module.\n  for (auto \u0026F : *Module) {\n    // Take into account even those functions that should not be\n    // optimized, because they may contain access to the let\n    // properties.\n    bool NonRemovable = !F.shouldOptimize();\n\n    for (auto \u0026BB : F) {\n      for (auto \u0026I : BB)\n        // Look for any instructions accessing let properties.\n        // It includes referencing this specific property (both reads and\n        // stores), as well as implicit stores by means of e.g.\n        // a struct instruction.\n        if (auto *BAI = dyn_cast\u003cBeginAccessInst\u003e(\u0026I)) {\n          if (auto *REAI =\n                  dyn_cast\u003cRefElementAddrInst\u003e(stripAddressAccess(BAI))) {\n            collectPropertyAccess(BAI, REAI-\u003egetField(), NonRemovable);\n          }\n        } else if (auto *REAI = dyn_cast\u003cRefElementAddrInst\u003e(\u0026I)) {\n          collectPropertyAccess(REAI, REAI-\u003egetField(), NonRemovable);\n        } else if (auto *SEI = dyn_cast\u003cStructExtractInst\u003e(\u0026I)) {\n          collectPropertyAccess(SEI, SEI-\u003egetField(), NonRemovable);\n        }  else if (auto *SEAI = dyn_cast\u003cStructElementAddrInst\u003e(\u0026I)) {\n          collectPropertyAccess(SEAI, SEAI-\u003egetField(), NonRemovable);\n        } else if (auto *SI = dyn_cast\u003cStructInst\u003e(\u0026I)) {\n          collectStructPropertiesAccess(SI, NonRemovable);\n        }\n    }\n  }\n\n  for (auto \u0026Init: InitMap) {\n    optimizeLetPropertyAccess(Init.first, Init.second);\n  }\n\n  for (SILFunction *ChangedFn : ChangedFunctions) {\n    // Program flow is not changed by this pass.\n    T-\u003einvalidateAnalysis(ChangedFn,\n                          SILAnalysis::InvalidationKind::Instructions);\n  }\n}\n\nnamespace {\nclass LetPropertiesOptPass : public SILModuleTransform\n{\n  void run() override {\n    LetPropertiesOpt(getModule()).run(this);\n  }\n\n};\n} // end anonymous namespace\n\nSILTransform *swift::createLetPropertiesOpt() {\n  return new LetPropertiesOptPass();\n}\n"}
{"repo_name":"ostash/qt-creator-i18n-uk","ref":"refs/heads/2.5","path":"src/plugins/help/xbelsupport.cpp","copies":"7","language":"C++","content":"/**************************************************************************\n**\n** This file is part of Qt Creator\n**\n** Copyright (c) 2012 Nokia Corporation and/or its subsidiary(-ies).\n**\n** Contact: Nokia Corporation (qt-info@nokia.com)\n**\n**\n** GNU Lesser General Public License Usage\n**\n** This file may be used under the terms of the GNU Lesser General Public\n** License version 2.1 as published by the Free Software Foundation and\n** appearing in the file LICENSE.LGPL included in the packaging of this file.\n** Please review the following information to ensure the GNU Lesser General\n** Public License version 2.1 requirements will be met:\n** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.\n**\n** In addition, as a special exception, Nokia gives you certain additional\n** rights. These rights are described in the Nokia Qt LGPL Exception\n** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.\n**\n** Other Usage\n**\n** Alternatively, this file may be used in accordance with the terms and\n** conditions contained in a signed written agreement between you and Nokia.\n**\n** If you have questions regarding the use of this file, please contact\n** Nokia at qt-info@nokia.com.\n**\n**************************************************************************/\n\n#include \"xbelsupport.h\"\n#include \"bookmarkmanager.h\"\n\n#include \u003cQCoreApplication\u003e\n\nusing namespace Help::Internal;\n\nstruct Bookmark {\n    QString title;\n    QString url;\n    bool folded;\n};\n\nXbelWriter::XbelWriter(BookmarkModel *model)\n    : QXmlStreamWriter()\n    , treeModel(model)\n{\n    setAutoFormatting(true);\n}\n\nvoid XbelWriter::writeToFile(QIODevice *device)\n{\n    setDevice(device);\n\n    writeStartDocument();\n    writeDTD(QLatin1String(\"\u003c!DOCTYPE xbel\u003e\"));\n    writeStartElement(QLatin1String(\"xbel\"));\n    writeAttribute(QLatin1String(\"version\"), QLatin1String(\"1.0\"));\n\n    QStandardItem *root = treeModel-\u003einvisibleRootItem();\n    for (int i = 0; i \u003c root-\u003erowCount(); ++i)\n        writeData(root-\u003echild(i));\n\n    writeEndDocument();\n}\n\nvoid XbelWriter::writeData(QStandardItem *child)\n{\n    Bookmark entry;\n    entry.title = child-\u003edata(Qt::DisplayRole).toString();\n    entry.url = child-\u003edata(Qt::UserRole + 10).toString();\n\n    if (entry.url == QLatin1String(\"Folder\")) {\n        writeStartElement(QLatin1String(\"folder\"));\n\n        entry.folded = !child-\u003edata(Qt::UserRole + 11).toBool();\n        writeAttribute(QLatin1String(\"folded\"),\n            entry.folded ? QLatin1String(\"yes\") : QLatin1String(\"no\"));\n\n        writeTextElement(QLatin1String(\"title\"), entry.title);\n\n        for (int i = 0; i \u003c child-\u003erowCount(); ++i)\n            writeData(child-\u003echild(i));\n\n        writeEndElement();\n    } else {\n        writeStartElement(QLatin1String(\"bookmark\"));\n        writeAttribute(QLatin1String(\"href\"), entry.url);\n        writeTextElement(QLatin1String(\"title\"), entry.title);\n        writeEndElement();\n    }\n}\n\n\n// #pragma mark -- XbelReader\n\n\nXbelReader::XbelReader(BookmarkModel *tree, BookmarkModel *list)\n    : QXmlStreamReader()\n    , treeModel(tree)\n    , listModel(list)\n{\n    bookmarkIcon = QIcon(QLatin1String(\":/help/images/bookmark.png\"));\n    folderIcon = QApplication::style()-\u003estandardIcon(QStyle::SP_DirClosedIcon);\n}\n\nbool XbelReader::readFromFile(QIODevice *device)\n{\n    setDevice(device);\n\n    while (!atEnd()) {\n        readNext();\n\n        if (isStartElement()) {\n            if (name() == QLatin1String(\"xbel\")\n                \u0026\u0026 attributes().value(QLatin1String(\"version\"))\n                    == QLatin1String(\"1.0\")) {\n                readXBEL();\n            } else {\n                raiseError(QCoreApplication::translate(\"Help::Internal::XbelReader\", \"The file is not an XBEL version 1.0 file.\"));\n            }\n        }\n    }\n\n    return !error();\n}\n\nvoid XbelReader::readXBEL()\n{\n    while (!atEnd()) {\n        readNext();\n\n        if (isEndElement())\n            break;\n\n        if (isStartElement()) {\n            if (name() == QLatin1String(\"folder\"))\n                readFolder(0);\n            else if (name() == QLatin1String(\"bookmark\"))\n                readBookmark(0);\n            else\n                readUnknownElement();\n        }\n    }\n}\n\nvoid XbelReader::readUnknownElement()\n{\n    while (!atEnd()) {\n        readNext();\n\n        if (isEndElement())\n            break;\n\n        if (isStartElement())\n            readUnknownElement();\n    }\n}\n\nvoid XbelReader::readFolder(QStandardItem *item)\n{\n    QStandardItem *folder = createChildItem(item);\n    folder-\u003esetIcon(folderIcon);\n    folder-\u003esetData(QLatin1String(\"Folder\"), Qt::UserRole + 10);\n\n    bool expanded =\n        (attributes().value(QLatin1String(\"folded\")) != QLatin1String(\"no\"));\n    folder-\u003esetData(expanded, Qt::UserRole + 11);\n\n    while (!atEnd()) {\n        readNext();\n\n        if (isEndElement())\n            break;\n\n        if (isStartElement()) {\n            if (name() == QLatin1String(\"title\"))\n                folder-\u003esetText(readElementText());\n            else if (name() == QLatin1String(\"folder\"))\n                readFolder(folder);\n            else if (name() == QLatin1String(\"bookmark\"))\n                readBookmark(folder);\n            else\n                readUnknownElement();\n        }\n    }\n}\n\nvoid XbelReader::readBookmark(QStandardItem *item)\n{\n    QStandardItem *bookmark = createChildItem(item);\n    bookmark-\u003esetIcon(bookmarkIcon);\n    bookmark-\u003esetText(QCoreApplication::translate(\"Help::Internal::XbelReader\", \"Unknown title\"));\n    bookmark-\u003esetData(attributes().value(QLatin1String(\"href\")).toString(),\n        Qt::UserRole + 10);\n\n    while (!atEnd()) {\n        readNext();\n\n        if (isEndElement())\n            break;\n\n        if (isStartElement()) {\n            if (name() == QLatin1String(\"title\"))\n                bookmark-\u003esetText(readElementText());\n            else\n                readUnknownElement();\n        }\n    }\n\n    listModel-\u003eappendRow(bookmark-\u003eclone());\n}\n\nQStandardItem *XbelReader::createChildItem(QStandardItem *item)\n{\n    QStandardItem *childItem = new QStandardItem();\n    childItem-\u003esetEditable(false);\n\n    if (item)\n        item-\u003eappendRow(childItem);\n    else\n        treeModel-\u003eappendRow(childItem);\n\n    return childItem;\n}\n"}
{"repo_name":"TTimo/doom3.gpl","ref":"refs/heads/master","path":"neo/tools/materialeditor/MaterialDef.cpp","copies":"58","language":"C++","content":"/*\n===========================================================================\n\nDoom 3 GPL Source Code\nCopyright (C) 1999-2011 id Software LLC, a ZeniMax Media company. \n\nThis file is part of the Doom 3 GPL Source Code (?Doom 3 Source Code?).  \n\nDoom 3 Source Code is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nDoom 3 Source Code is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Doom 3 Source Code.  If not, see \u003chttp://www.gnu.org/licenses/\u003e.\n\nIn addition, the Doom 3 Source Code is also subject to certain additional terms. You should have received a copy of these additional terms immediately following the terms and conditions of the GNU General Public License which accompanied the Doom 3 Source Code.  If not, please request a copy in writing from id Software at the address below.\n\nIf you have questions concerning this license or the applicable additional terms, you may contact in writing id Software LLC, c/o ZeniMax Media Inc., Suite 120, Rockville, Maryland 20850 USA.\n\n===========================================================================\n*/\n#include \"../../idlib/precompiled.h\"\n#pragma hdrstop\n\n#include \"MaterialDef.h\"\n\n\n/**\n* Constructor.\n*/\nMaterialDef::MaterialDef(void) {\n\ttype = 0;\n\tquotes = false;\n}\n\n/**\n* Destructor.\n*/\nMaterialDef::~MaterialDef(void) {\n}\n\n/**\n* Returns view specific data associated with the material definition.\n*/\nDWORD MaterialDef::GetViewData(const char* viewName) {\n\tDWORD* value = NULL;\n\tviewData.Get(viewName, \u0026value);\n\treturn *value;\n}\n\n/**\n* Sets view specific data for the material definition.\n*/\nvoid MaterialDef::SetViewData(const char* viewName, DWORD value) {\n\tviewData.Set(viewName, value);\n}\n\n#define MATERIAL_DEF_FILE \"MaterialEditorDefs.med\"\n\nMaterialDefList MaterialDefManager::materialDefs[MaterialDefManager::MATERIAL_DEF_NUM];\n\n\n/**\n* Loads the material definition file instatiates MaterialDef objects for each definition\n* and groups the definitions.\n*/\nvoid MaterialDefManager::InitializeMaterialDefLists() {\n\t\n\tchar\t*buffer;\n\tint length = fileSystem-\u003eReadFile( MATERIAL_DEF_FILE, (void **)\u0026buffer);\n\n\tif ( length == -1 ) {\n\t\tcommon-\u003eError( \"Couldn't load material editor definition: %s\", MATERIAL_DEF_FILE );\n\t\treturn;\n\t}\n\n\tidLexer src;\n\tif ( !src.LoadMemory( buffer, length, MATERIAL_DEF_FILE ) ) {\n\t\tcommon-\u003eError( \"Couldn't parse %s\", MATERIAL_DEF_FILE );\n\t\tfileSystem-\u003eFreeFile(buffer);\n\t}\n\n\n\tInitializeMaterialDefList(\u0026src, \"materialprops\", \u0026materialDefs[MATERIAL_DEF_MATERIAL]);\n\tInitializeMaterialDefList(\u0026src, \"stageprops\", \u0026materialDefs[MATERIAL_DEF_STAGE]);\n\tInitializeMaterialDefList(\u0026src, \"specialmapstageprops\", \u0026materialDefs[MATERIAL_DEF_SPECIAL_STAGE]);\n\n\tfileSystem-\u003eFreeFile(buffer);\n}\n\n/**\n* Loads a single type of material attributes and adds them to the supplied MaterialDefList object.\n* @param src The idLexer object that contains the file.\n* @param typeName The name of the attribute grouping to search for in the file.\n* @param list The MaterialDefList object to append the MaterialDef instances to.\n*/\nvoid MaterialDefManager::InitializeMaterialDefList(idLexer* src, const char* typeName, MaterialDefList* list) {\n\n\tidToken token;\n\n\tsrc-\u003eReset();\n\tsrc-\u003eSkipUntilString(typeName);\n\tsrc-\u003eSkipUntilString(\"{\");\n\n\twhile(1) {\n\t\tif ( !src-\u003eExpectAnyToken( \u0026token ) ) {\n\t\t\t//Todo: Add some error checking here\n\t\t\treturn;\n\t\t}\n\n\t\tif ( token == \"}\" ) {\n\t\t\tbreak;\n\t\t}\n\n\t\tMaterialDef* newProp = new MaterialDef();\n\n\t\tif(!token.Icmp(\"TYPE_GROUP\")) {\n\t\t\tnewProp-\u003etype = MaterialDef::MATERIAL_DEF_TYPE_GROUP;\n\t\t} else if(!token.Icmp(\"TYPE_BOOL\")) {\n\t\t\tnewProp-\u003etype = MaterialDef::MATERIAL_DEF_TYPE_BOOL;\n\t\t} else if(!token.Icmp(\"TYPE_STRING\")) {\n\t\t\tnewProp-\u003etype = MaterialDef::MATERIAL_DEF_TYPE_STRING;\n\t\t} else if(!token.Icmp(\"TYPE_FLOAT\")) {\n\t\t\tnewProp-\u003etype = MaterialDef::MATERIAL_DEF_TYPE_FLOAT;\n\t\t} else if(!token.Icmp(\"TYPE_INT\")) {\n\t\t\tnewProp-\u003etype = MaterialDef::MATERIAL_DEF_TYPE_INT;\n\t\t}\n\n\t\t//Skip the ,\n\t\tsrc-\u003eReadToken(\u0026token);\n\n\t\t//Read Dict Name\n\t\tsrc-\u003eReadToken(\u0026token);\n\t\tnewProp-\u003edictName = token;\n\n\t\t//Skip the ,\n\t\tsrc-\u003eReadToken(\u0026token);\n\n\t\t//Read Display Name\n\t\tsrc-\u003eReadToken(\u0026token);\n\t\tnewProp-\u003edisplayName = token;\n\n\t\t//Skip the ,\n\t\tsrc-\u003eReadToken(\u0026token);\n\n\t\t//Read Display Info\n\t\tsrc-\u003eReadToken(\u0026token);\n\t\tnewProp-\u003edisplayInfo = token;\n\n\t\t//Type Specific Data\n\t\tif(newProp-\u003etype == MaterialDef::MATERIAL_DEF_TYPE_STRING) {\n\n\t\t\tnewProp-\u003equotes = false;\n\n\t\t\t//Skip the ,\n\t\t\tsrc-\u003eReadToken(\u0026token);\n\n\t\t\t//Read validate flag\n\t\t\tsrc-\u003eReadToken(\u0026token);\n\t\t\tif(token == \"1\") {\n\t\t\t\tnewProp-\u003equotes = true;\n\t\t\t}\n\t\t}\n\n\t\tsrc-\u003eSkipRestOfLine();\n\n\t\tlist-\u003eAppend(newProp);\n\t}\n}\n\n/**\n* Destroys all MaterialDef instances and clears the material attribute grouping lists.\n*/\nvoid MaterialDefManager::DestroyMaterialDefLists() {\n\t\n\tfor(int i = 0; i \u003c MATERIAL_DEF_NUM; i++) {\n\t\tfor(int j = 0; j \u003c materialDefs[i].Num(); j++) {\n\t\t\tdelete materialDefs[i][j];\n\t\t}\n\t\tmaterialDefs[i].Clear();\n\t}\n}\n\n/**\n* Returns the MaterialDefList for the specified attribute grouping.\n* @param type The attribute grouping for which to retreive the attribute list.\n*/\nMaterialDefList* MaterialDefManager::GetMaterialDefs(int type) {\n\tif(type \u003e= 0 \u0026\u0026 type \u003c MATERIAL_DEF_NUM) {\n\t\treturn \u0026materialDefs[type];\n\t}\n\treturn NULL;\n}"}
{"repo_name":"HofiOne/xbmc","ref":"refs/heads/master","path":"xbmc/settings/dialogs/GUIDialogLibExportSettings.cpp","copies":"3","language":"C++","content":"/*\n*      Copyright (C) 2005-2014 Team XBMC\n*      http://kodi.tv\n*\n*  This Program is free software; you can redistribute it and/or modify\n*  it under the terms of the GNU General Public License as published by\n*  the Free Software Foundation; either version 2, or (at your option)\n*  any later version.\n*\n*  This Program is distributed in the hope that it will be useful,\n*  but WITHOUT ANY WARRANTY; without even the implied warranty of\n*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n*  GNU General Public License for more details.\n*\n*  You should have received a copy of the GNU General Public License\n*  along with XBMC; see the file COPYING.  If not, see\n*  \u003chttp://www.gnu.org/licenses/\u003e.\n*\n*/\n\n#include \u003cmap\u003e\n#include \u003cmemory\u003e\n#include \u003cstring\u003e\n#include \u003cutility\u003e\n#include \u003cvector\u003e\n\n#include \u003climits.h\u003e\n\n#include \"GUIDialogLibExportSettings.h\"\n#include \"dialogs/GUIDialogFileBrowser.h\"\n#include \"guilib/GUIComponent.h\"\n#include \"guilib/GUIWindowManager.h\"\n#include \"guilib/LocalizeStrings.h\"\n#include \"messaging/helpers/DialogHelper.h\"\n#include \"messaging/helpers/DialogOKHelper.h\"\n#include \"ServiceBroker.h\"\n#include \"settings/SettingUtils.h\"\n#include \"settings/lib/Setting.h\"\n#include \"settings/Settings.h\"\n#include \"settings/windows/GUIControlSettings.h\"\n#include \"storage/MediaManager.h\"\n#include \"Util.h\"\n#include \"utils/log.h\"\n#include \"utils/URIUtils.h\"\n#include \"filesystem/Directory.h\"\n\nusing namespace ADDON;\nusing namespace KODI::MESSAGING;\n\nusing KODI::MESSAGING::HELPERS::DialogResponse;\n\nCGUIDialogLibExportSettings::CGUIDialogLibExportSettings()\n  : CGUIDialogSettingsManualBase(WINDOW_DIALOG_LIBEXPORT_SETTINGS, \"DialogSettings.xml\"),\n  m_destinationChecked(false)\n{ }\n\nbool CGUIDialogLibExportSettings::Show(CLibExportSettings\u0026 settings)\n{\n  CGUIDialogLibExportSettings *dialog = CServiceBroker::GetGUI()-\u003eGetWindowManager().GetWindow\u003cCGUIDialogLibExportSettings\u003e(WINDOW_DIALOG_LIBEXPORT_SETTINGS);\n  if (!dialog)\n    return false;\n\n  // Get current export settings from service broker\n  dialog-\u003em_settings.SetExportType(CServiceBroker::GetSettings().GetInt(CSettings::SETTING_MUSICLIBRARY_EXPORT_FILETYPE));\n  dialog-\u003em_settings.m_strPath = CServiceBroker::GetSettings().GetString(CSettings::SETTING_MUSICLIBRARY_EXPORT_FOLDER);\n  dialog-\u003em_settings.SetItemsToExport(CServiceBroker::GetSettings().GetInt(CSettings::SETTING_MUSICLIBRARY_EXPORT_ITEMS));\n  dialog-\u003em_settings.m_unscraped = CServiceBroker::GetSettings().GetBool(CSettings::SETTING_MUSICLIBRARY_EXPORT_UNSCRAPED);\n  dialog-\u003em_settings.m_artwork = CServiceBroker::GetSettings().GetBool(CSettings::SETTING_MUSICLIBRARY_EXPORT_ARTWORK);\n  dialog-\u003em_settings.m_skipnfo = CServiceBroker::GetSettings().GetBool(CSettings::SETTING_MUSICLIBRARY_EXPORT_SKIPNFO);\n  dialog-\u003em_settings.m_overwrite = CServiceBroker::GetSettings().GetBool(CSettings::SETTING_MUSICLIBRARY_EXPORT_OVERWRITE);\n\n  dialog-\u003em_destinationChecked = false;\n  dialog-\u003eOpen();\n\n  bool confirmed = dialog-\u003eIsConfirmed();\n  if (confirmed)\n  {\n    // Return the new settings (saved by service broker but avoids re-reading)\n    settings = dialog-\u003em_settings;\n  }\n  return confirmed;\n}\n\nvoid CGUIDialogLibExportSettings::OnInitWindow()\n{\n  CGUIDialogSettingsManualBase::OnInitWindow();\n}\n\nvoid CGUIDialogLibExportSettings::OnSettingChanged(std::shared_ptr\u003cconst CSetting\u003e setting)\n{\n  if (!setting)\n    return;\n\n  CGUIDialogSettingsManualBase::OnSettingChanged(setting);\n\n  const std::string \u0026settingId = setting-\u003eGetId();\n\n  if (settingId == CSettings::SETTING_MUSICLIBRARY_EXPORT_FILETYPE)\n  {\n    m_settings.SetExportType(std::static_pointer_cast\u003cconst CSettingInt\u003e(setting)-\u003eGetValue());\n    SetupView();\n    SetFocus(CSettings::SETTING_MUSICLIBRARY_EXPORT_FILETYPE);\n  }\n  else if (settingId == CSettings::SETTING_MUSICLIBRARY_EXPORT_FOLDER)\n  {\n    m_settings.m_strPath = std::static_pointer_cast\u003cconst CSettingString\u003e(setting)-\u003eGetValue();\n    UpdateButtons();\n  }\n  else if (settingId == CSettings::SETTING_MUSICLIBRARY_EXPORT_OVERWRITE)\n    m_settings.m_overwrite = std::static_pointer_cast\u003cconst CSettingBool\u003e(setting)-\u003eGetValue();\n  else if (settingId == CSettings::SETTING_MUSICLIBRARY_EXPORT_ITEMS)\n    m_settings.SetItemsToExport(GetExportItemsFromSetting(setting));\n  else if (settingId == CSettings::SETTING_MUSICLIBRARY_EXPORT_ARTWORK)\n  {\n    m_settings.m_artwork = std::static_pointer_cast\u003cconst CSettingBool\u003e(setting)-\u003eGetValue();\n    ToggleState(CSettings::SETTING_MUSICLIBRARY_EXPORT_SKIPNFO, m_settings.m_artwork);\n  }\n  else if (settingId == CSettings::SETTING_MUSICLIBRARY_EXPORT_UNSCRAPED)\n    m_settings.m_unscraped = std::static_pointer_cast\u003cconst CSettingBool\u003e(setting)-\u003eGetValue();\n  else if (settingId == CSettings::SETTING_MUSICLIBRARY_EXPORT_SKIPNFO)\n    m_settings.m_skipnfo = std::static_pointer_cast\u003cconst CSettingBool\u003e(setting)-\u003eGetValue();\n}\n\nvoid CGUIDialogLibExportSettings::OnSettingAction(std::shared_ptr\u003cconst CSetting\u003e setting)\n{\n  if (setting == NULL)\n    return;\n\n  CGUIDialogSettingsManualBase::OnSettingAction(setting);\n\n  const std::string \u0026settingId = setting-\u003eGetId();\n\n  if (settingId == CSettings::SETTING_MUSICLIBRARY_EXPORT_FOLDER)\n  {\n    VECSOURCES shares;\n    g_mediaManager.GetLocalDrives(shares);\n    g_mediaManager.GetNetworkLocations(shares);\n    g_mediaManager.GetRemovableDrives(shares);\n    std::string strDirectory = m_settings.m_strPath;\n    if (!strDirectory.empty())\n    {\n      URIUtils::AddSlashAtEnd(strDirectory);\n      bool bIsSource;\n      if (CUtil::GetMatchingSource(strDirectory, shares, bIsSource) \u003c 0) // path is outside shares - add it as a separate one\n      {\n        CMediaSource share;\n        share.strName = g_localizeStrings.Get(13278);\n        share.strPath = strDirectory;\n        shares.push_back(share);\n      }\n    }\n    else\n      strDirectory = \"default location\";\n\n    if (CGUIDialogFileBrowser::ShowAndGetDirectory(shares, g_localizeStrings.Get(661), strDirectory, true))\n    {\n      if (!strDirectory.empty())\n      {\n        m_destinationChecked = true;\n        m_settings.m_strPath = strDirectory;\n        SetLabel2(CSettings::SETTING_MUSICLIBRARY_EXPORT_FOLDER, strDirectory);\n        SetFocus(CSettings::SETTING_MUSICLIBRARY_EXPORT_FOLDER);\n      }\n    }\n    UpdateButtons();\n  }\n}\n\nbool CGUIDialogLibExportSettings::OnMessage(CGUIMessage\u0026 message)\n{\n  switch (message.GetMessage())\n  {\n    case GUI_MSG_CLICKED:\n    {\n      int iControl = message.GetSenderId();\n      if (iControl == CONTROL_SETTINGS_OKAY_BUTTON)\n      {\n        OnOK();\n        return true;\n      }\n    }\n    break;\n  }\n  return CGUIDialogSettingsManualBase::OnMessage(message);\n}\n\nvoid CGUIDialogLibExportSettings::OnOK()\n{\n  // Validate destination folder\n  if (m_settings.IsToLibFolders())\n  {\n    // Check artist info folder setting\n    std::string path = CServiceBroker::GetSettings().GetString(CSettings::SETTING_MUSICLIBRARY_ARTISTSFOLDER);\n    if (path.empty())\n    {\n      //\"Unable to export to library folders as the system artist information folder setting is empty\"\n      //Settings (YES) button takes user to enter the artist info folder setting\n      if (HELPERS::ShowYesNoDialogText(20223, 38317, 186, 10004) == DialogResponse::YES)\n      {\n        m_confirmed = false;\n        Close();\n        CServiceBroker::GetGUI()-\u003eGetWindowManager().ActivateWindow(WINDOW_SETTINGS_MEDIA, CSettings::SETTING_MUSICLIBRARY_ARTISTSFOLDER);\n      }\n      return;\n    }\n  }\n  else if (!m_destinationChecked)\n  {\n    // ELIBEXPORT_SINGLEFILE or LIBEXPORT_SEPARATEFILES\n    // Check that destination folder exists\n    if (!XFILE::CDirectory::Exists(m_settings.m_strPath))\n    {\n      HELPERS::ShowOKDialogText(CVariant{ 38300 }, CVariant{ 38318 });\n      return;\n    }\n  }\n  m_confirmed = true;\n  Save();\n  Close();\n}\n\nvoid CGUIDialogLibExportSettings::Save()\n{\n  CLog::Log(LOGINFO, \"CGUIDialogMusicExportSettings: Save() called\");\n  CServiceBroker::GetSettings().SetInt(CSettings::SETTING_MUSICLIBRARY_EXPORT_FILETYPE, m_settings.GetExportType());\n  CServiceBroker::GetSettings().SetString(CSettings::SETTING_MUSICLIBRARY_EXPORT_FOLDER, m_settings.m_strPath);\n  CServiceBroker::GetSettings().SetInt(CSettings::SETTING_MUSICLIBRARY_EXPORT_ITEMS, m_settings.GetItemsToExport());\n  CServiceBroker::GetSettings().SetBool(CSettings::SETTING_MUSICLIBRARY_EXPORT_UNSCRAPED, m_settings.m_unscraped);\n  CServiceBroker::GetSettings().SetBool(CSettings::SETTING_MUSICLIBRARY_EXPORT_OVERWRITE, m_settings.m_overwrite);\n  CServiceBroker::GetSettings().SetBool(CSettings::SETTING_MUSICLIBRARY_EXPORT_ARTWORK, m_settings.m_artwork);\n  CServiceBroker::GetSettings().SetBool(CSettings::SETTING_MUSICLIBRARY_EXPORT_SKIPNFO, m_settings.m_skipnfo);\n  CServiceBroker::GetSettings().Save();\n}\n\nvoid CGUIDialogLibExportSettings::SetupView()\n{\n  CGUIDialogSettingsManualBase::SetupView();\n  SetHeading(38300);\n\n  SET_CONTROL_HIDDEN(CONTROL_SETTINGS_CUSTOM_BUTTON);\n  SET_CONTROL_LABEL(CONTROL_SETTINGS_OKAY_BUTTON, 38319);\n  SET_CONTROL_LABEL(CONTROL_SETTINGS_CANCEL_BUTTON, 222);\n\n  SetLabel2(CSettings::SETTING_MUSICLIBRARY_EXPORT_FOLDER, m_settings.m_strPath);\n\n  if (m_settings.IsSingleFile())\n  {\n    ToggleState(CSettings::SETTING_MUSICLIBRARY_EXPORT_FOLDER, true);\n    ToggleState(CSettings::SETTING_MUSICLIBRARY_EXPORT_OVERWRITE, false);\n    ToggleState(CSettings::SETTING_MUSICLIBRARY_EXPORT_ARTWORK, false);\n    ToggleState(CSettings::SETTING_MUSICLIBRARY_EXPORT_SKIPNFO, false);\n  }\n  else if (m_settings.IsSeparateFiles())\n  {\n    ToggleState(CSettings::SETTING_MUSICLIBRARY_EXPORT_FOLDER, true);\n    ToggleState(CSettings::SETTING_MUSICLIBRARY_EXPORT_OVERWRITE, true);\n    ToggleState(CSettings::SETTING_MUSICLIBRARY_EXPORT_ARTWORK, true);\n    ToggleState(CSettings::SETTING_MUSICLIBRARY_EXPORT_SKIPNFO, m_settings.m_artwork);\n  }\n  else // To library folders\n  {\n    ToggleState(CSettings::SETTING_MUSICLIBRARY_EXPORT_FOLDER, false);\n    ToggleState(CSettings::SETTING_MUSICLIBRARY_EXPORT_OVERWRITE, true);\n    ToggleState(CSettings::SETTING_MUSICLIBRARY_EXPORT_ARTWORK, true);\n    ToggleState(CSettings::SETTING_MUSICLIBRARY_EXPORT_SKIPNFO, m_settings.m_artwork);\n  }\n  UpdateButtons();\n}\n\nvoid CGUIDialogLibExportSettings::UpdateButtons()\n{\n  // Enable Export button when destination folder has a path (but may not exist)\n  bool enableExport(true);\n  if (m_settings.IsSingleFile() ||\n      m_settings.IsSeparateFiles())\n    enableExport = !m_settings.m_strPath.empty();\n \n  CONTROL_ENABLE_ON_CONDITION(CONTROL_SETTINGS_OKAY_BUTTON, enableExport);\n  if (!enableExport)\n    SetFocus(CSettings::SETTING_MUSICLIBRARY_EXPORT_FOLDER);\n}\n\nvoid CGUIDialogLibExportSettings::InitializeSettings()\n{\n  CGUIDialogSettingsManualBase::InitializeSettings();\n\n  std::shared_ptr\u003cCSettingCategory\u003e category = AddCategory(\"exportsettings\", -1);\n  if (!category)\n  {\n    CLog::Log(LOGERROR, \"CGUIDialogLibExportSettings: unable to setup settings\");\n    return;\n  }\n\n  std::shared_ptr\u003cCSettingGroup\u003e groupDetails = AddGroup(category);\n  if (!groupDetails)\n  {\n    CLog::Log(LOGERROR, \"CGUIDialogLibExportSettings: unable to setup settings\");\n    return;\n  }\n\n  TranslatableIntegerSettingOptions entries;\n\n  entries.push_back(std::make_pair(38301, ELIBEXPORT_SINGLEFILE));\n  entries.push_back(std::make_pair(38302, ELIBEXPORT_SEPARATEFILES));\n  entries.push_back(std::make_pair(38303, ELIBEXPORT_TOLIBRARYFOLDER));\n  AddList(groupDetails, CSettings::SETTING_MUSICLIBRARY_EXPORT_FILETYPE, 38304, SettingLevel::Basic, m_settings.GetExportType(), entries, 38304); // \"Choose kind of export output\"\n  AddButton(groupDetails, CSettings::SETTING_MUSICLIBRARY_EXPORT_FOLDER, 38305, SettingLevel::Basic);\n  \n  entries.clear();\n  entries.push_back(std::make_pair(132, ELIBEXPORT_ALBUMS));  //ablums\n  entries.push_back(std::make_pair(38043, ELIBEXPORT_ALBUMARTISTS)); //album artists\n  entries.push_back(std::make_pair(38312, ELIBEXPORT_SONGARTISTS)); //song artists\n  entries.push_back(std::make_pair(38313, ELIBEXPORT_OTHERARTISTS)); //other artists\n  AddList(groupDetails, CSettings::SETTING_MUSICLIBRARY_EXPORT_ITEMS, 38306, SettingLevel::Basic, m_settings.GetExportItems(), entries, 133, 1);\n\n  AddToggle(groupDetails, CSettings::SETTING_MUSICLIBRARY_EXPORT_UNSCRAPED, 38308, SettingLevel::Basic, m_settings.m_unscraped);\n  AddToggle(groupDetails, CSettings::SETTING_MUSICLIBRARY_EXPORT_ARTWORK, 38307, SettingLevel::Basic, m_settings.m_artwork);\n  AddToggle(groupDetails, CSettings::SETTING_MUSICLIBRARY_EXPORT_SKIPNFO, 38309, SettingLevel::Basic, m_settings.m_skipnfo);\n  AddToggle(groupDetails, CSettings::SETTING_MUSICLIBRARY_EXPORT_OVERWRITE, 38310, SettingLevel::Basic, m_settings.m_overwrite); \n}\n\nvoid CGUIDialogLibExportSettings::SetLabel2(const std::string \u0026settingid, const std::string \u0026label)\n{\n  BaseSettingControlPtr settingControl = GetSettingControl(settingid);\n  if (settingControl != NULL \u0026\u0026 settingControl-\u003eGetControl() != NULL)\n    SET_CONTROL_LABEL2(settingControl-\u003eGetID(), label);\n}\n\n\nvoid CGUIDialogLibExportSettings::ToggleState(const std::string \u0026 settingid, bool enabled)\n{\n  BaseSettingControlPtr settingControl = GetSettingControl(settingid);\n  if (settingControl != NULL \u0026\u0026 settingControl-\u003eGetControl() != NULL)\n  {\n    if (enabled)\n      CONTROL_ENABLE(settingControl-\u003eGetID());\n    else\n      CONTROL_DISABLE(settingControl-\u003eGetID());\n  }\n}\n\nvoid CGUIDialogLibExportSettings::SetFocus(const std::string \u0026settingid)\n{\n  BaseSettingControlPtr settingControl = GetSettingControl(settingid);\n  if (settingControl != NULL \u0026\u0026 settingControl-\u003eGetControl() != NULL)\n    SET_CONTROL_FOCUS(settingControl-\u003eGetID(), 0);\n}\n\nint CGUIDialogLibExportSettings::GetExportItemsFromSetting(SettingConstPtr setting)\n{\n  std::shared_ptr\u003cconst CSettingList\u003e settingList = std::static_pointer_cast\u003cconst CSettingList\u003e(setting);\n  if (settingList-\u003eGetElementType() != SettingType::Integer)\n  {\n    CLog::Log(LOGERROR, \"CGUIDialogLibExportSettings::%s - wrong items element type\", __FUNCTION__);\n    return 0;\n  }\n  int exportitems = 0;\n  std::vector\u003cCVariant\u003e list = CSettingUtils::GetList(settingList);\n  for (const auto \u0026value : list)\n  {\n    if (!value.isInteger())\n    {\n      CLog::Log(LOGERROR, \"CGUIDialogLibExportSettings::%s - wrong items value type\", __FUNCTION__);\n      return 0;\n    }\n    exportitems += value.asInteger();\n  }\n  return exportitems;\n}\n"}
{"repo_name":"slicer4ever/Lightwave","ref":"refs/heads/master","path":"Engine/Source/C++11/LWEProtocols/LWEProtocolWebSocketSecure.cpp","copies":"1","language":"C++","content":"#include \"LWEProtocols/LWEProtocolWebSocketSecure.h\"\r\n#include \"LWEProtocols/LWEProtocolHTTP.h\"\r\n#include \u003cLWNetwork/LWSocket.h\u003e\r\n#include \u003cLWNetwork/LWProtocolManager.h\u003e\r\n#include \u003cLWCore/LWAllocator.h\u003e\r\n#include \u003cLWCore/LWCrypto.h\u003e\r\n#include \u003cLWCore/LWText.h\u003e\r\n#include \u003cLWCore/LWByteBuffer.h\u003e\r\n#include \u003ciostream\u003e\r\n\r\n\r\nbool LWEProtocolWebSocketSecure::ProcessRead(LWSocket \u0026Socket, const char *Buffer, uint32_t BufferLen) {\r\n\tchar Buf[256];\r\n\tchar BufB[256];\r\n\tLWEWebSocket *WebSocket = (LWEWebSocket*)Socket.GetProtocolData(m_wProtocolID);\r\n\tif (!WebSocket) {\r\n\t\tLWEHttpRequest Request;\r\n\t\tuint32_t Error = 0;\r\n\t\tError = Request.Deserialize(Buffer, BufferLen) ? 0 : 1;\r\n\t\tError = Error ? Error : (*Request.m_SecWebSockKey \u0026\u0026 Request.m_WebSockVersion == LWEWEBSOCKET_SUPPVER \u0026\u0026 Request.UpgradeConnection()) ? 0 : 2;\r\n\t\tif (!Error \u0026\u0026 *Request.m_SecWebSockProto) {\r\n\t\t\tbool ValidProtocol = false;\r\n\t\t\tif (*m_SubProtocol) {\r\n\t\t\t\tuint32_t ProtocolLen = (uint32_t)strlen(m_SubProtocol);\r\n\t\t\t\tfor (const char *C = Request.m_SecWebSockProto; C \u0026\u0026 !ValidProtocol; C = LWText::FirstToken(C, ',')) {\r\n\t\t\t\t\tC = LWText::NextWord(*C == ',' ? C + 1 : C, true);\r\n\t\t\t\t\tValidProtocol = LWText::Compare(C, m_SubProtocol, ProtocolLen);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (!ValidProtocol) Error = 3;\r\n\t\t}\r\n\t\tif (Error) {\r\n\t\t\tstd::cout \u003c\u003c \"Buffer:\" \u003c\u003c std::endl \u003c\u003c Buffer \u003c\u003c std::endl;\r\n\t\t\tif (Error == 1) std::cout \u003c\u003c \"Error deserializing websocket request.\" \u003c\u003c std::endl;\r\n\t\t\telse if (Error == 2) std::cout \u003c\u003c \"Error Headers did not include correct websocket data.\" \u003c\u003c std::endl;\r\n\t\t\telse if (Error == 3) std::cout \u003c\u003c \"Error protocol asked for is not supported.\" \u003c\u003c std::endl;\r\n\t\t\tSocket.MarkClosable();\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tWebSocket = m_Allocator.Allocate\u003cLWEWebSocket\u003e(nullptr, nullptr);\r\n\t\tWebSocket-\u003em_Socket = \u0026Socket;\r\n\t\t*Buf = '\\0';\r\n\t\tstrncat(Buf, Request.m_SecWebSockKey, sizeof(Buf));\r\n\t\tstrncat(Buf, LWEWEBSOCKET_GUID, sizeof(Buf));\r\n\t\tLWCrypto::HashSHA1(Buf, (uint32_t)strlen(Buf), BufB);\r\n\t\tuint32_t *uBuf = (uint32_t*)BufB; //Order swap bytes before encoding.\r\n\t\tfor (uint32_t i = 0; i \u003c 5; i++) uBuf[i] = (uBuf[i] \u0026 0xFF) \u003c\u003c 24 | (uBuf[i] \u0026 0xFF00) \u003c\u003c 8 | (uBuf[i] \u0026 0xFF0000) \u003e\u003e 8 | (uBuf[i] \u0026 0xFF000000) \u003e\u003e 24;\r\n\t\tuint32_t Len = LWCrypto::Base64Encode(BufB, 20, WebSocket-\u003em_SecKey, sizeof(WebSocket-\u003em_SecKey));\r\n\t\tWebSocket-\u003em_SecKey[Len] = '\\0';\r\n\t\tWebSocket-\u003eSetSecProtocols(m_SubProtocol);\r\n\t\tWebSocket-\u003eSetHost(Request.m_Host);\r\n\t\tWebSocket-\u003eSetPath(Request.m_Path);\r\n\t\tWebSocket-\u003eSetOrigin(Request.m_Origin);\r\n\t\tWebSocket-\u003em_Flag |= LWEWebSocket::CONNECTING_SERVER;\r\n\t\tSocket.SetProtocolData(m_wProtocolID, WebSocket);\r\n\t\tPushOutPacket(nullptr, 0, WebSocket, LWEWebPacket::CONTROL_CONNECT);\r\n\t\treturn true;\r\n\t}\r\n\tif (!WebSocket-\u003eIsConnected()) {\r\n\t\tif (WebSocket-\u003eGetConnectStatus() == LWEWebSocket::CONNECTING_CLIENT) {\r\n\t\t\tLWEHttpRequest Request;\r\n\t\t\tuint32_t Error = 0;\r\n\t\t\tError = Request.Deserialize(Buffer, BufferLen) ? 0 : 1;\r\n\t\t\tError = Error ? Error : ((*Request.m_SecWebSockKey \u0026\u0026 Request.m_Status == LWEHttpRequest::SwitchingProtocols) ? 0 : 2);\r\n\t\t\t//we should probably also validate the key....\r\n\r\n\t\t\tif (Error) {\r\n\t\t\t\tstd::cout \u003c\u003c \"Buffer:\" \u003c\u003c std::endl \u003c\u003c Buffer \u003c\u003c std::endl;\r\n\t\t\t\tif (Error == 1) std::cout \u003c\u003c \"Error deserializing websocket request.\" \u003c\u003c std::endl;\r\n\t\t\t\telse if (Error == 2) std::cout \u003c\u003c \"Error headers did not include correct websocket data.\" \u003c\u003c std::endl;\r\n\t\t\t\tSocket.MarkClosable();\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\tWebSocket-\u003em_Flag = (WebSocket-\u003em_Flag\u0026~LWEWebSocket::CONNECTING_CLIENT) | LWEWebSocket::CONNECTED_CLIENT;\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\tchar IPBuf[32];\r\n\tLWSocket::MakeAddress(Socket.GetRemoteIP(), IPBuf, sizeof(IPBuf));\r\n\tif (BufferLen \u003e 100) {}\r\n\tLWEWebPacket *OPack;\r\n\tuint32_t Target;\r\n\tuint32_t ReservePos;\r\n\tuint32_t o = 0;\r\n\twhile (o != BufferLen) {\r\n\t\tuint32_t Res = WebSocket-\u003em_ActivePacket.Deserialize(Buffer + o, BufferLen - o, m_Allocator);\r\n\t\tif (Res == -1) {\r\n\t\t\tstd::cout \u003c\u003c \"Error deserializing data.\" \u003c\u003c std::endl;\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\to += Res;\r\n\t\tif (!WebSocket-\u003em_ActivePacket.Finished()) continue;\r\n\t\tif (WebSocket-\u003em_ActivePacket.m_DataLen != WebSocket-\u003em_ActivePacket.m_DataPos) continue;\r\n\t\tif (WebSocket-\u003em_ActivePacket.GetOp() == LWEWebPacket::CONTROL_CLOSED) {\r\n\t\t\tWebSocket-\u003em_ActivePacket.WorkFinished();\r\n\t\t\tSocket.MarkClosable();\r\n\t\t\treturn true;\r\n\t\t} else if (WebSocket-\u003em_ActivePacket.GetOp() == LWEWebPacket::CONTROL_PING) {\r\n\t\t\tWebSocket-\u003em_ActivePacket.WorkFinished();\r\n\t\t\tPushOutPacket(nullptr, 0, WebSocket, LWEWebPacket::CONTROL_PONG);\r\n\t\t\tcontinue;\r\n\t\t} else if (WebSocket-\u003em_ActivePacket.GetOp() == LWEWebPacket::CONTROL_PONG) {\r\n\t\t\tWebSocket-\u003em_ActivePacket.WorkFinished();\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tWebSocket-\u003em_ActivePacket.m_WebSocket = WebSocket;\r\n\t\tif (!m_InPackets.PushStart(\u0026OPack, Target, ReservePos)) return false;\r\n\t\t*OPack = std::move(WebSocket-\u003em_ActivePacket);\r\n\t\tm_InPackets.PushFinished(Target, ReservePos);\r\n\t}\r\n\treturn true;\r\n}\r\n\r\nLWProtocol \u0026LWEProtocolWebSocketSecure::SocketClosed(LWSocket \u0026Socket, LWProtocolManager *Manager) {\r\n\tLWEProtocolTLS::SocketClosed(Socket, Manager);\r\n\tLWEWebSocket *WebSock = (LWEWebSocket*)Socket.GetProtocolData(m_wProtocolID);\r\n\tbool Del = true;\r\n\tif (m_WebSocketClosedCallback) Del = m_WebSocketClosedCallback(Socket, WebSock, Manager);\r\n\tif (WebSock) WebSock-\u003em_Socket = nullptr;\r\n\tif (Del) LWAllocator::Destroy(WebSock);\r\n\treturn *this;\r\n}\r\n\r\nLWProtocol \u0026LWEProtocolWebSocketSecure::SocketChanged(LWSocket \u0026Prev, LWSocket \u0026New, LWProtocolManager *Manager) {\r\n\tLWEProtocolTLS::SocketChanged(Prev, New, Manager);\r\n\tLWEWebSocket *WebSocket = (LWEWebSocket*)Prev.GetProtocolData(m_wProtocolID);\r\n\tNew.SetProtocolData(m_wProtocolID, Prev.GetProtocolData(m_wProtocolID));\r\n\tif (WebSocket) WebSocket-\u003em_Socket = \u0026New;\r\n\tif (m_WebSocketChangedCallback) m_WebSocketChangedCallback(Prev, New, WebSocket, Manager);\r\n\treturn *this;\r\n}\r\n\r\nLWProtocol \u0026LWEProtocolWebSocketSecure::ProcessTLSData(LWSocket \u0026Socket, const char *Data, uint32_t DataLen) {\r\n\tProcessRead(Socket, Data, DataLen);\r\n\treturn *this;\r\n}\r\n\r\nLWEProtocolWebSocketSecure \u0026LWEProtocolWebSocketSecure::ProcessOutPackets(void) {\r\n\tchar Buffer[1024 * 64];\r\n\tLWEWebPacket *Pack;\r\n\tuint32_t Target;\r\n\tuint32_t ReservePos;\r\n\twhile (m_OutPackets.PopStart(\u0026Pack, Target, ReservePos)) {\r\n\t\tLWEWebPacket RPack = std::move(*Pack);\r\n\t\tm_OutPackets.PopFinshed(Target, ReservePos);\r\n\t\tLWEWebSocket *Sock = RPack.m_WebSocket;\r\n\t\tif (!Sock-\u003eIsConnected() \u0026\u0026 (RPack.m_ControlFlag\u0026LWEWebPacket::CONTROL_CONNECT)) {\r\n\t\t\tif (!Sock-\u003em_Socket) return *this;\r\n\t\t\tLWEHttpRequest Request;\r\n\t\t\tRequest.SetWebSockKey(Sock-\u003em_SecKey);\r\n\t\t\tRequest.SetWebSockProto(m_SubProtocol);\r\n\t\t\tRequest.m_Flag |= LWEHttpRequest::ConnectionUpgrade | LWEHttpRequest::UpgradeWebSock;\r\n\t\t\tRequest.m_Status = Sock-\u003eGetConnectStatus() == LWEWebSocket::CONNECTING_SERVER ? LWEHttpRequest::SwitchingProtocols : 0;\r\n\t\t\tif (Sock-\u003eGetConnectStatus() == LWEWebSocket::CONNECTING_CLIENT) {\r\n\t\t\t\tRequest.SetHost(Sock-\u003em_Host).SetPath(Sock-\u003em_Path).SetOrigin(Sock-\u003em_Origin);\r\n\t\t\t\tRequest.m_WebSockVersion = LWEWEBSOCKET_SUPPVER;\r\n\t\t\t} else Sock-\u003em_Flag = (Sock-\u003em_Flag\u0026~LWEWebSocket::CONNECTING_SERVER) | LWEWebSocket::CONNECTED_SERVER;\r\n\t\t\tuint32_t Len = Request.Serialize(Buffer, sizeof(Buffer), Sock-\u003eGetConnectStatus() == LWEWebSocket::CONNECTED_CLIENT ? m_UserAgent : m_Server);\r\n\t\t\tstd::cout \u003c\u003c \"Sending headers!\" \u003c\u003c std::endl;\r\n\t\t\tuint32_t Res = Send(*Sock-\u003em_Socket, Buffer, Len);\r\n\t\t\tif(Res==-1){\r\n\t\t\t\tstd::cout \u003c\u003c \"Error sending data.\" \u003c\u003c std::endl;\r\n\t\t\t\treturn *this;\r\n\t\t\t}\r\n\t\t\tif (!Res) {\r\n\t\t\t\tif (Sock-\u003eGetConnectStatus() == LWEWebSocket::CONNECTED_SERVER) Sock-\u003em_Flag = (Sock-\u003em_Flag\u0026~LWEWebSocket::CONNECTING_SERVER) | LWEWebSocket::CONNECTING_SERVER;\r\n\t\t\t\tPushOutPacket(nullptr, 0, Sock, LWEWebPacket::CONTROL_CONNECT);\r\n\t\t\t\treturn *this; //break and let some time pass before we try again.\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (RPack.m_ControlFlag\u0026LWEWebPacket::CONTROL_CONNECT) continue; //discard as this was just to complete the upgrade transaction.\r\n\t\tif (!Sock-\u003eIsConnected()) {\r\n\t\t\tif (!m_OutPackets.PushStart(\u0026Pack, Target, ReservePos)) {\r\n\t\t\t\tstd::cout \u003c\u003c \"Error re-inserting packet.\" \u003c\u003c std::endl;\r\n\t\t\t\treturn *this;\r\n\t\t\t}\r\n\t\t\t*Pack = std::move(RPack);\r\n\t\t\tm_OutPackets.PushFinished(Target, ReservePos);\r\n\t\t\treturn *this; //break and let some time pass before we try again.\r\n\t\t}\r\n\t\tstd::cout \u003c\u003c \"Sending data: \" \u003c\u003c RPack.GetOp() \u003c\u003c \" Len: \" \u003c\u003c RPack.m_DataLen \u003c\u003c \" Fin: \" \u003c\u003c RPack.m_ControlFlag \u003c\u003c std::endl;\r\n\t\tLWSocket *rSock = RPack.m_WebSocket-\u003em_Socket;\r\n\t\tif (!rSock) continue;\r\n\t\tuint32_t Len = RPack.Serialize(Buffer, sizeof(Buffer), Sock-\u003eGetConnectStatus() == LWEWebSocket::CONNECTED_CLIENT);\r\n\t\tstd::cout \u003c\u003c \"Serialized: \" \u003c\u003c Len \u003c\u003c std::endl;\r\n\t\tuint32_t Res = Send(*rSock, Buffer, Len);\r\n\t\tif (Res==-1){\r\n\t\t\tstd::cout \u003c\u003c \"Error sending data.\" \u003c\u003c std::endl;\r\n\t\t\treturn *this;\r\n\t\t}\r\n\t\tif (!Res) {\r\n\t\t\tif (!m_OutPackets.PushStart(\u0026Pack, Target, ReservePos)) {\r\n\t\t\t\tstd::cout \u003c\u003c \"Error re-inserting packet.\" \u003c\u003c std::endl;\r\n\t\t\t\treturn *this;\r\n\t\t\t}\r\n\t\t\t*Pack = std::move(RPack);\r\n\t\t\tm_OutPackets.PushFinished(Target, ReservePos);\r\n\t\t}\r\n\t}\r\n\treturn *this;\r\n}\r\n\r\n\r\nLWEWebSocket *LWEProtocolWebSocketSecure::OpenSocket(const char *URI, uint32_t ProtocolID, const char *Origin) {\r\n\tchar Host[256];\r\n\tchar Path[256];\r\n\tchar Protocol[256];\r\n\tuint16_t Port = LWEHttpRequest::ParseURI(URI, Host, sizeof(Host), nullptr, Path, sizeof(Path), nullptr, Protocol, sizeof(Protocol), nullptr);\r\n\tLWSocket Sock;\r\n\tuint32_t Err = LWSocket::CreateSocket(Sock, Host, Port, LWSocket::Tcp, ProtocolID);\r\n\tif (Err) {\r\n\t\tstd::cout \u003c\u003c \"Error creating socket: \" \u003c\u003c Err \u003c\u003c std::endl;\r\n\t\treturn nullptr;\r\n\t}\r\n\tLWSocket *S = m_Manager-\u003ePushSocket(Sock);\r\n\tLWEWebSocket *WebSock = m_Allocator.Allocate\u003cLWEWebSocket\u003e(URI, Origin);\r\n\tWebSock-\u003em_Flag |= LWEWebSocket::CONNECTING_CLIENT;\r\n\tWebSock-\u003eGenerateKey(m_KeySeed++);\r\n\tS-\u003eSetProtocolData(m_wProtocolID, WebSock);\r\n\tWebSock-\u003em_Socket = S;\r\n\r\n\tPushOutPacket(nullptr, 0, WebSock, LWEWebPacket::CONTROL_CONNECT);\r\n\treturn WebSock;\r\n}\r\n\r\nbool LWEProtocolWebSocketSecure::PushOutPacket(const char *Buffer, uint32_t BufferLen, LWEWebSocket *Socket, uint32_t ControlFlag) {\r\n\tLWEWebPacket *Pack;\r\n\tuint32_t Target;\r\n\tuint32_t ReservePos;\r\n\tif (!m_OutPackets.PushStart(\u0026Pack, Target, ReservePos)) return false;\r\n\t*Pack = LWEWebPacket(Buffer, BufferLen, m_Allocator, ControlFlag | LWEWebPacket::CONTROL_FINISHED, Socket);\r\n\tm_OutPackets.PushFinished(Target, ReservePos);\r\n\treturn true;\r\n}\r\n\r\nbool LWEProtocolWebSocketSecure::GetNextPacket(LWEWebPacket \u0026Packet) {\r\n\tLWEWebPacket *Pack;\r\n\tuint32_t Target;\r\n\tuint32_t ReservePos;\r\n\tif (!m_InPackets.PopStart(\u0026Pack, Target, ReservePos)) return false;\r\n\tPacket = std::move(*Pack);\r\n\tm_InPackets.PopFinshed(Target, ReservePos);\r\n\treturn true;\r\n}\r\n\r\nLWEProtocolWebSocketSecure \u0026LWEProtocolWebSocketSecure::SetServer(const char *Server) {\r\n\t*m_Server = '\\0';\r\n\tstrncat(m_Server, Server, sizeof(m_Server));\r\n\treturn *this;\r\n}\r\n\r\nLWEProtocolWebSocketSecure \u0026LWEProtocolWebSocketSecure::SetUserAgent(const char *Agent) {\r\n\t*m_UserAgent = '\\0';\r\n\tstrncat(m_UserAgent, Agent, sizeof(m_UserAgent));\r\n\treturn *this;\r\n}\r\n\r\nLWEProtocolWebSocketSecure \u0026LWEProtocolWebSocketSecure::SetSubProtocol(const char *SubProtocol) {\r\n\t*m_SubProtocol = '\\0';\r\n\tstrncat(m_SubProtocol, SubProtocol, sizeof(m_SubProtocol));\r\n\treturn *this;\r\n}\r\n\r\nLWEProtocolWebSocketSecure \u0026LWEProtocolWebSocketSecure::SetWebSocketClosedCallback(std::function\u003cbool(LWSocket \u0026, LWEWebSocket*, LWProtocolManager*)\u003e WebSocketClosedCallback) {\r\n\tm_WebSocketClosedCallback = WebSocketClosedCallback;\r\n\treturn *this;\r\n}\r\n\r\nLWEProtocolWebSocketSecure \u0026LWEProtocolWebSocketSecure::SetWebSocketChangedCallback(std::function\u003cvoid(LWSocket \u0026, LWSocket \u0026, LWEWebSocket *, LWProtocolManager *)\u003e WebSocketChangedCallback) {\r\n\tm_WebSocketChangedCallback = WebSocketChangedCallback;\r\n\treturn *this;\r\n}\r\n\r\nLWEProtocolWebSocketSecure::LWEProtocolWebSocketSecure(uint32_t ProtocolID, uint32_t TLSProtocolID, LWAllocator \u0026Allocator, LWProtocolManager *Manager, const char *CertFile, const char *KeyFile) : LWEProtocolTLS(TLSProtocolID, Allocator, CertFile, KeyFile), m_wProtocolID(ProtocolID), m_Allocator(Allocator), m_Manager(Manager), m_KeySeed(0) {\r\n\t*m_Server = *m_UserAgent = *m_SubProtocol = '\\0';\r\n\tm_WebSocketClosedCallback = nullptr;\r\n\tm_WebSocketChangedCallback = nullptr;\r\n}"}
{"repo_name":"cndpost/cppidioms","ref":"refs/heads/master","path":"bft/bft.cpp","copies":"1","language":"C++","content":"#include \u003ciostream\u003e\n#include \u003cvector\u003e\n#include \u003cqueue\u003e\n\nusing namespace std;\n\nclass Tree;\nclass Tree\n{\n   public:\n   char data;\n   bool visited;\n   std::vector\u003cTree*\u003e children;\n};\n\n\nvoid bft(Tree *root)\n{\n\n  if (root == NULL) return;\n  if ( root-\u003evisited) return;\n  root-\u003evisited  = true;\n  printf(\"%c \\n\", root-\u003edata);\n  std::queue\u003cTree *\u003e *newQue = new std::queue\u003cTree *\u003e();\n  int Size = root-\u003echildren.size();\n  for (int i=0;i\u003cSize; i++) \n  {\n\tTree *child = root-\u003echildren[i];\n        if (child != NULL)\n        newQue-\u003epush(child);\n  } \n\n  for (int i=0; i\u003cSize; i++)\n  {\n\tTree* child = newQue-\u003efront();\n        if (child != NULL)\n        bft(child);\n        newQue-\u003epop();\n  }\n\n//  root-\u003evisited  = true;\n//  printf(\"%c \\n\", root-\u003edata);\n  return;\n\n};\n\nvoid insert(Tree *root, char data)\n{\n  Tree *newTree = new Tree();\n  newTree-\u003edata = data;\n  newTree-\u003evisited = false;\n  //newTree-\u003echildren = NULL;\n  root-\u003echildren.push_back(newTree);\n  return;\n};\n\nint main()\n{\n\tTree* root = new Tree();\n\troot-\u003edata = 'a';\n\n        Tree* leftChild = new Tree{};\n        leftChild-\u003edata = 'b';\n        Tree* rightChild = new Tree();\n        rightChild-\u003edata = 'c';\n        root-\u003echildren.push_back(leftChild);\n        root-\u003echildren.push_back(rightChild);\n\n        cout \u003c\u003c \"start doing BFT in one way \" \u003c\u003c endl;\n        bft(root);\n\n        //above lines can also be written as\n        delete root;\n        root = new Tree();\n        root-\u003edata = 'a';\n        insert(root, 'd');\n        insert(root, 'e');        \n \n\n        cout \u003c\u003c \"start doing BFT in 2nd way\" \u003c\u003c endl;\n        bft(root);\n        cout \u003c\u003c \"done DFT \" \u003c\u003c endl;\n\t\n\treturn 0;\n}\n\n\n"}
{"repo_name":"quickhand/Prosit","ref":"refs/heads/master","path":"src/highlighter.cpp","copies":"1","language":"C++","content":"/***********************************************************************\n *\n * Copyright (C) 2009, 2010 Graeme Gott \u003cgraeme@gottcode.org\u003e\n * Copyright (C) 2010 Marc Lajoie \u003cmanorapide@gmail.com\u003e\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see \u003chttp://www.gnu.org/licenses/\u003e.\n *\n ***********************************************************************/\n\n#include \"highlighter.h\"\n\n#include \"block_stats.h\"\n#include \"dictionary.h\"\n#include \"spell_checker.h\"\n#include \"editor.h\"\n#include \u003cQAction\u003e\n#include \u003cQContextMenuEvent\u003e\n#include \u003cQEvent\u003e\n#include \u003cQMenu\u003e\n#include \u003cQTextEdit\u003e\n#include \u003ciostream\u003e\n#include \u003cQAbstractTextDocumentLayout\u003e\n#include \u003cQTextLayout\u003e\n//-----------------------------------------------------------------------------\n\nHighlighter::Highlighter(Editor* text, Dictionary* dictionary)\n\t: QSyntaxHighlighter(text-\u003edocument()),\n\tm_dictionary(dictionary),\n\tm_text(text),\n\tm_enabled(true),\n\tm_misspelled(\"#ff0000\")\n{\n\tconnect(m_text, SIGNAL(cursorPositionChanged()), this, SLOT(cursorPositionChanged()));\n\n\tm_text-\u003eviewport()-\u003einstallEventFilter(this);\n\tm_add_action = new QAction(tr(\"Add\"), this);\n\tm_check_action = new QAction(tr(\"Check Spelling...\"), this);\n}\n\n//-----------------------------------------------------------------------------\n\nbool Highlighter::enabled() const\n{\n\treturn m_enabled;\n}\n\n//-----------------------------------------------------------------------------\n\nQColor Highlighter::misspelledColor() const\n{\n\treturn m_misspelled;\n}\n\n//-----------------------------------------------------------------------------\n\nvoid Highlighter::setEnabled(bool enabled)\n{\n\tm_enabled = enabled;\n\trehighlight();\n}\n\n//-----------------------------------------------------------------------------\n\nvoid Highlighter::setMisspelledColor(const QColor\u0026 color)\n{\n\tm_misspelled = color;\n\trehighlight();\n}\n\n//-----------------------------------------------------------------------------\n\nbool Highlighter::eventFilter(QObject* watched, QEvent* event)\n{\n\tif (watched != m_text-\u003eviewport() || event-\u003etype() != QEvent::ContextMenu || !m_enabled) {\n\t\treturn QSyntaxHighlighter::eventFilter(watched, event);\n\t} else {\n\t\t// Check spelling of text block under mouse\n\t\tQContextMenuEvent* context_event = static_cast\u003cQContextMenuEvent*\u003e(event);\n\t\tm_start_cursor = m_text-\u003ecursorForPosition(context_event-\u003epos());\n\t\tQTextBlock block = m_start_cursor.block();\n\t\tint cursor = m_start_cursor.position() - block.position();\n\n\t\tbool under_mouse = false;\n\t\tQStringRef word;\n\t\tQVector\u003cQStringRef\u003e words = static_cast\u003cBlockStats*\u003e(block.userData())-\u003emisspelled();\n\t\tfor (int i = 0; i \u003c words.count(); ++i) {\n\t\t\tword = words.at(i);\n\t\t\tint delta = cursor - word.position();\n\t\t\tif (delta \u003e= 0 \u0026\u0026 delta \u003c= word.length()) {\n\t\t\t\tunder_mouse = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!under_mouse) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\t// Select misspelled word\n\t\t\tm_cursor = m_start_cursor;\n\t\t\tm_cursor.setPosition(word.position() + block.position());\n\t\t\tm_cursor.setPosition(m_cursor.position() + word.length(), QTextCursor::KeepAnchor);\n\t\t\tm_word = m_cursor.selectedText();\n\t\t\tm_text-\u003esetTextCursor(m_cursor);\n\n\t\t\t// List suggestions in context menu\n\t\t\tQMenu* menu = new QMenu;\n\t\t\tQStringList guesses = m_dictionary-\u003esuggestions(m_word);\n\t\t\tif (!guesses.isEmpty()) {\n\t\t\t\tforeach (const QString\u0026 guess, guesses) {\n                                        menu-\u003eaddAction(guess);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tQAction* none_action = menu-\u003eaddAction(tr(\"(No suggestions found)\"));\n\t\t\t\tnone_action-\u003esetEnabled(false);\n\t\t\t}\n\t\t\tmenu-\u003eaddSeparator();\n\t\t\tmenu-\u003eaddAction(m_add_action);\n\t\t\tmenu-\u003eaddSeparator();\n\t\t\tmenu-\u003eaddAction(m_check_action);\n\n\t\t\t// Show menu\n\t\t\tconnect(menu, SIGNAL(triggered(QAction*)), this, SLOT(suggestion(QAction*)));\n\t\t\tmenu-\u003eexec(context_event-\u003eglobalPos());\n\t\t\tdelete menu;\n\n\t\t\treturn true;\n\t\t}\n\t}\n}\n\n//-----------------------------------------------------------------------------\n\nvoid Highlighter::highlightBlock(const QString\u0026 text)\n{\n        QTextCharFormat hformat;\n        QTextBlockFormat blockformat=currentBlock().blockFormat();\n        if(blockformat.hasProperty(QTextFormat::UserProperty))\n        {\n            hformat.setProperty(QTextFormat::FontWeight,blockformat.property(QTextFormat::FontWeight));\n            hformat.setProperty(QTextFormat::FontItalic,blockformat.property(QTextFormat::FontItalic));\n            hformat.setProperty(QTextFormat::FontSizeAdjustment,blockformat.property(QTextFormat::FontSizeAdjustment));\n            setFormat(0,text.length(),hformat);\n        }\n\n\tif (!m_enabled) {\n\t\treturn;\n\t}\n\t\n\tint cursor = m_text-\u003etextCursor().position() - currentBlock().position();\n\tBlockStats* stats = static_cast\u003cBlockStats*\u003e(currentBlockUserData());\n\tif (!stats) {\n\t\tstats = new BlockStats(text, m_dictionary);\n\t\tsetCurrentBlockUserData(stats);\n\t}\n\n        QTextCharFormat error;\n\terror.setUnderlineColor(m_misspelled);\n\terror.setUnderlineStyle(QTextCharFormat::SpellCheckUnderline);\n        error.merge(hformat);\n\tQVector\u003cQStringRef\u003e words = stats-\u003emisspelled();\n\tfor (int i = 0; i \u003c words.count(); ++i) {\n\t\tconst QStringRef\u0026 word = words.at(i);\n\t\tint delta = cursor - word.position();\n\t\tif (delta \u003c 0 || delta \u003e word.length()) {\n\t\t\tsetFormat(word.position(), word.length(), error);\n\t\t}\n\t}\n}\n\n//-----------------------------------------------------------------------------\n\nvoid Highlighter::cursorPositionChanged()\n{\n\tQTextBlock current = m_text-\u003etextCursor().block();\n\tif (m_current != current) {\n\t\tif (m_current.isValid() \u0026\u0026 m_text-\u003edocument()-\u003eblockCount() \u003e m_current.blockNumber()) {\n\t\t\trehighlightBlock(m_current);\n\t\t}\n\t\tm_current = current;\n \t}\n\trehighlightBlock(m_current);\n}\n\n//-----------------------------------------------------------------------------\n\nvoid Highlighter::suggestion(QAction* action)\n{\n\tif (action == m_add_action) {\n\t\tm_text-\u003esetTextCursor(m_start_cursor);\n\t\tm_dictionary-\u003eadd(m_word);\n\t} else if (action == m_check_action) {\n\t\tm_text-\u003esetTextCursor(m_start_cursor);\n\t\tSpellChecker::checkDocument(m_text);\n\t} else {\n\t\tm_cursor.insertText(action-\u003etext());\n\t}\n}\n\n//-----------------------------------------------------------------------------\n"}
{"repo_name":"thiphariel/navitia","ref":"refs/heads/dev","path":"source/kraken/tests/data_manager_test.cpp","copies":"13","language":"C++","content":"/* Copyright © 2001-2014, Canal TP and/or its affiliates. All rights reserved.\n  \nThis file is part of Navitia,\n    the software to build cool stuff with public transport.\n \nHope you'll enjoy and contribute to this project,\n    powered by Canal TP (www.canaltp.fr).\nHelp us simplify mobility and open public transport:\n    a non ending quest to the responsive locomotion way of traveling!\n  \nLICENCE: This program is free software; you can redistribute it and/or modify\nit under the terms of the GNU Affero General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n   \nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\nGNU Affero General Public License for more details.\n   \nYou should have received a copy of the GNU Affero General Public License\nalong with this program. If not, see \u003chttp://www.gnu.org/licenses/\u003e.\n  \nStay tuned using\ntwitter @navitia \nIRC #navitia on freenode\nhttps://groups.google.com/d/forum/navitia\nwww.navitia.io\n*/\n\n#define BOOST_TEST_DYN_LINK\n#define BOOST_TEST_MODULE data_manager_test\n#include \u003cboost/test/unit_test.hpp\u003e\n#include \u003cboost/optional.hpp\u003e\n\n#include \"kraken/data_manager.h\"\n#include \u003catomic\u003e\n\n//mock of navitia::type::Data class\nclass Data{\n    public:\n        bool load(const std::string\u0026,\n                  const boost::optional\u003cstd::string\u003e\u0026,\n                  const std::vector\u003cstd::string\u003e\u0026) {\n            return load_status;\n        }\n        mutable std::atomic\u003cbool\u003e is_connected_to_rabbitmq;\n        static bool load_status;\n        static bool destructor_called;\n        size_t data_identifier;\n\n        Data(size_t data_identifier=0):\n            data_identifier(data_identifier)\n        {is_connected_to_rabbitmq = false;}\n\n        ~Data(){Data::destructor_called = true;}\n};\nbool Data::load_status = true;\nbool Data::destructor_called = false;\n\nstruct fixture{\n    fixture(){\n        Data::load_status = true;\n        Data::destructor_called = false;\n    }\n};\n\nBOOST_FIXTURE_TEST_SUITE(s, fixture)\n\nBOOST_AUTO_TEST_CASE(get_data){\n    DataManager\u003cData\u003e data_manager;\n    auto data = data_manager.get_data();\n    BOOST_REQUIRE(data);\n    BOOST_CHECK_EQUAL(Data::destructor_called, false);\n}\n\nBOOST_AUTO_TEST_CASE(load_success){\n    DataManager\u003cData\u003e data_manager;\n    auto first_data = data_manager.get_data();\n    BOOST_CHECK_EQUAL(first_data, data_manager.get_data());\n    BOOST_CHECK(data_manager.load(\"\"));\n    auto second_data = data_manager.get_data();\n    BOOST_CHECK_NE(first_data, second_data);\n    BOOST_CHECK_EQUAL(Data::destructor_called, false);\n}\n\nBOOST_AUTO_TEST_CASE(load_fail){\n    DataManager\u003cData\u003e data_manager;\n    auto first_data = data_manager.get_data();\n    BOOST_CHECK_EQUAL(first_data, data_manager.get_data());\n    Data::load_status = false;\n    BOOST_CHECK(! data_manager.load(\"\"));\n    Data::load_status = true;\n    auto second_data = data_manager.get_data();\n    BOOST_CHECK_EQUAL(first_data, second_data);\n}\n\nBOOST_AUTO_TEST_CASE(destructor_called){\n    DataManager\u003cData\u003e data_manager;\n    {\n        auto first_data = data_manager.get_data();\n        BOOST_CHECK_EQUAL(first_data, data_manager.get_data());\n        BOOST_CHECK(data_manager.load(\"\"));\n        auto second_data = data_manager.get_data();\n        BOOST_CHECK_NE(first_data, second_data);\n        BOOST_CHECK_EQUAL(Data::destructor_called, false);\n        first_data = boost::shared_ptr\u003cData\u003e();\n    }\n    BOOST_CHECK_EQUAL(Data::destructor_called, true);\n    BOOST_CHECK(data_manager.get_data());\n}\n\nBOOST_AUTO_TEST_SUITE_END()\n"}
{"repo_name":"fedech/ldpc_sim","ref":"refs/heads/master","path":"src/Simulation.cpp","copies":"1","language":"C++","content":"/*\n * Simulation.cpp\n *\n *  Created on: Nov 29, 2014\n *      Author: fede\n */\n\n#include \u003ciostream\u003e\n#include \u003cfstream\u003e\n#include \u003cstring\u003e\n#include \u003cboost/numeric/ublas/matrix.hpp\u003e\n#include \u003cboost/random.hpp\u003e\n#include \u003cboost/random/normal_distribution.hpp\u003e\n#include \"LDPCEncoder.h\"\n#include \"LDPCDecoder.h\"\n\nint main() {\n\t/*\n\t * CODES:\n\t * 6/3 (toy matrix)\n\t * 648/324,432,486,540\n\t * 1296/648,864,972,1080\n\t * 1944/972,1296,1458,1620\n\t */\n\n\t//Code parameters\n\tint n = 648;\n\tint k = 432;\n\tint p = n - k;\n\tstd::string file = \"n648r23\";\n\n\t//Modulation and decoding parameters\n\tint passes = 50;\n\tbool qam = true;\n\tint symbols = 4;\n\n\t//Simulation parameters\n\tdouble step = 0.25;\n\tint minsnr = 0;\n\tdouble maxsnr = 4.1;\n\tint maxPackets = 1E6;\n\tint minErrors = 100;\n\tint printInterval = maxPackets / 1000;\n\n\t//Input/output parameters\n\tstd::string matrixFolder = \"./matrices/\";\n\tstd::string extIn = \".csv\";\n\tstd::string resultsFolder = \"./results/\";\n\tstd::string extOut = \".dat\";\n\tstd::string encoding = matrixFolder + \"enc\" + file + extIn;\n\tstd::string decoding = matrixFolder + \"dec\" + file + extIn;\n\tstd::stringstream ss;\n\tif (qam) {\n\t\tss \u003c\u003c \"qam\" \u003c\u003c symbols;\n\t}\n\tss \u003c\u003c \"_\" \u003c\u003c passes;\n\tstd::string output = resultsFolder + file + ss.str() + extOut;\n\n\t//Input and output initialization\n\tstd::ifstream enc;\n\tenc.open(encoding.c_str());\n\tstd::ifstream dec;\n\tdec.open(decoding.c_str());\n\tstd::ofstream out;\n\tout.open(output.c_str());\n\tout \u003c\u003c \"#LDPC, n = \" \u003c\u003c n \u003c\u003c \", k = \" \u003c\u003c k \u003c\u003c \"\\n\";\n\tout \u003c\u003c \"#SNR (dB) - BER - PER\\n\";\n\n\t//Vector and matrix creation\n\tstd::vector\u003cdouble\u003e snrdb;\n\tstd::vector\u003cint\u003e errors;\n\tstd::vector\u003cint\u003e pktErrors;\n\tstd::vector\u003cint\u003e packets;\n\tboost::numeric::ublas::matrix\u003cint\u003e parityMatrix(p, n);\n\tboost::numeric::ublas::matrix\u003cint\u003e encodingMatrix(n, k);\n\n\t//Encoding and decoding systematic matrix reading\n\tfor (int i = 0; i \u003c p; i++) {\n\t\tfor (int j = 0; j \u003c n; j++) {\n\t\t\tdec \u003e\u003e parityMatrix(i, j);\n\t\t}\n\t}\n\tfor (int i = 0; i \u003c n; i++) {\n\t\tfor (int j = 0; j \u003c k; j++) {\n\t\t\tenc \u003e\u003e encodingMatrix(i, j);\n\t\t}\n\t}\n\n\t//Vector initialization\n\tfor (double snr = minsnr; snr \u003c maxsnr; snr += step) {\n\t\tsnrdb.push_back(snr);\n\t\terrors.push_back(0);\n\t\tpktErrors.push_back(0);\n\t\tpackets.push_back(0);\n\t}\n\n\t//Gaussian RNG initialization\n\tboost::mt19937 rng = boost::mt19937(time(0));\n\tboost::variate_generator\u003cboost::mt19937\u0026, boost::normal_distribution\u003c\u003e \u003e generator(\n\t\t\trng, boost::normal_distribution\u003c\u003e());\n\n\t//Encoder and decoder creation\n\tLDPCEncoder *encoder = new LDPCEncoder(k, n, encodingMatrix, symbols);\n\tLDPCDecoder *decoder = new LDPCDecoder(k, n, parityMatrix, passes, symbols);\n\n\tstd::cout \u003c\u003c std::time(NULL) \u003c\u003c \"Created!\\n\";\n\n\tboost::numeric::ublas::matrix\u003cdouble\u003e results(snrdb.size(), 26);\n\n\tfor (int i = 0; i \u003c snrdb.size(); i++) {\n\t\tfor (int j = 0; j \u003c 26; j++) {\n\t\t\tresults(i, j) = 0;\n\t\t}\n\t}\n\n\t//Simulation cycle\n\tfor (int packet = 0; packet \u003c maxPackets; packet++) {\n\t\tif (packet % printInterval == 0) {\n\t\t\tstd::cout \u003c\u003c packet \u003c\u003c \" \" \u003c\u003c std::time(NULL) \u003c\u003c \"\\n\";\n\t\t}\n\t\tstd::vector\u003cint\u003e uncoded;\n\t\tstd::vector\u003cdouble\u003e w;\n\t\tstd::vector\u003cdouble\u003e w_q;\n\n\t\t//Noise and input sequence generation\n\t\tfor (int i = 0; i \u003c n; i++) {\n\t\t\tw.push_back(generator());\n\t\t\tif (qam) {\n\t\t\t\tw_q.push_back(generator());\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i \u003c k; i++) {\n\t\t\tuncoded.push_back(rand() % 2);\n\t\t}\n\n\t\t//Encoding\n\t\tstd::vector\u003cint\u003e coded = encoder-\u003eencode(uncoded);\n\t\tint counter = 0;\n\n\t\t//Packet sending and decoding\n\t\tfor (double snr = minsnr; snr \u003c maxsnr; snr += step) {\n\t\t\tif (packets.at(counter) == 0) {\n\t\t\t\tdouble n0 = 1 / pow(10, snr / 10) / log2(symbols) / 2;\n\n\t\t\t\tstd::vector\u003cdouble\u003e received;\n\t\t\t\tstd::vector\u003cLDPCEncoder::symbol\u003e modulated;\n\n\t\t\t\tif (!qam) {\n\t\t\t\t\t//Channel simulation (AWGN)\n\t\t\t\t\tfor (int i = 0; i \u003c n; i++) {\n\t\t\t\t\t\tdouble rec = 2 * coded.at(i) - 1 + w.at(i) * sqrt(n0);\n\t\t\t\t\t\treceived.push_back(rec);\n\t\t\t\t\t}\n\n\t\t\t\t\t//LLR computation\n\t\t\t\t\tfor (int i = 0; i \u003c n; i++) {\n\t\t\t\t\t\tdouble llr = -2 * received.at(i) / n0;\n\t\t\t\t\t\treceived.at(i) = llr;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tmodulated = encoder-\u003emodulate(coded);\n\t\t\t\t\tstd::vector\u003cdouble\u003e phase;\n\t\t\t\t\tstd::vector\u003cdouble\u003e quad;\n\t\t\t\t\t//Channel simulation (AWGN)\n\t\t\t\t\tfor (int i = 0; i \u003c modulated.size(); i++) {\n\t\t\t\t\t\tphase.push_back(\n\t\t\t\t\t\t\t\tmodulated.at(i).phase + w.at(i) * sqrt(n0));\n\t\t\t\t\t\tquad.push_back(\n\t\t\t\t\t\t\t\tmodulated.at(i).quad + w_q.at(i) * sqrt(n0));\n\t\t\t\t\t}\n\n\t\t\t\t\t//LLR computation\n\t\t\t\t\treceived = decoder-\u003edeModLlr(phase, quad, n0);\n\t\t\t\t}\n\n\t\t\t\twhile (received.size() \u003e n) {\n\t\t\t\t\treceived.pop_back();\n\t\t\t\t}\n\n\t\t\t\t//Decoding\n\t\t\t\t//std::vector\u003cint\u003e decoded = decoder-\u003edecode(received,results,counter,uncoded);\n\t\t\t\tstd::vector\u003cint\u003e decoded = decoder-\u003edecode(received);\n\t\t\t\t//Error checking\n\t\t\t\tint error = 0;\n\t\t\t\tbool correct = true;\n\n\t\t\t\tfor (int i = 0; i \u003c k; i++) {\n\t\t\t\t\tif (decoded.at(i) != coded.at(i)) {\n\t\t\t\t\t\tif (correct) {\n\t\t\t\t\t\t\tcorrect = false;\n\t\t\t\t\t\t\tpktErrors.at(counter)++;}\n\t\t\t\t\t\terror++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\terrors.at(counter) += error;\n\n\t\t\t\tif (pktErrors.at(counter) \u003e minErrors) {\n\t\t\t\t\tpackets.at(counter) = packet + 1;\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tcounter++;\n\t\t}\n\t}\n\n\tstd::cout \u003c\u003c std::time(NULL) \u003c\u003c \"Finished!\\n\";\n\n\t//Output calculation\n\tint counter = 0;\n\tfor (double snr = minsnr; snr \u003c maxsnr; snr += step) {\n\t\tdouble nPackets = maxPackets;\n\t\tif (packets.at(counter) != 0) {\n\t\t\tnPackets = packets.at(counter);\n\t\t}\n\t\tdouble per = pktErrors.at(counter) / nPackets;\n\t\tdouble ber = errors.at(counter) / (nPackets * k);\n\t\tout \u003c\u003c snr \u003c\u003c \" \" \u003c\u003c ber \u003c\u003c \" \" \u003c\u003c per \u003c\u003c \"\\n\";\n\t\tcounter++;\n\t}\n\n//\tstd::ofstream outres;\n//\tstd::string resFile=\"results.txt\";\n//\toutres.open(resFile.c_str());\n//\n//\tfor (int i=0;i\u003csnrdb.size();i++){\n//\t\tfor(int j=1;j\u003c26;j++){\n//\t\t\toutres\u003c\u003cresults(i,j)/(double)packets.at(i)\u003c\u003c\" \";\n//\t\t}\n//\t\toutres\u003c\u003c\"\\n\";\n//\t}\n\n\t//Cleanup\n\tenc.close();\n\tdec.close();\n\tout.close();\n\tdelete encoder;\n\tdelete decoder;\n\n}\n\n"}
{"repo_name":"wayfinder/Wayfinder-S60-Navigator","ref":"refs/heads/master","path":"CPP/Shared/GuiProt/GeneralParamReceiver.cpp","copies":"1","language":"C++","content":"/*\r\n  Copyright (c) 1999 - 2010, Vodafone Group Services Ltd\r\n  All rights reserved.\r\n\r\n  Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\r\n\r\n  * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\r\n  * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\r\n  * Neither the name of the Vodafone Group Services Ltd nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\r\n\r\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. \r\n*/\r\n\r\n#include \"arch.h\"\r\n#include \"GuiProt/GuiParameterEnums.h\"\r\n#include \"GuiProt/GuiProtEnums.h\"\r\n#include \"GuiProt/GuiProtMess.h\"\r\n#include \"GuiProt/GeneralParamReceiver.h\"\r\n#include \"GuiProt/GuiProtMessageHandler.h\"\r\n#include \"GenericSettingsData.h\"\r\n\r\nnamespace isab {\r\n\r\nGeneralParamReceiver::~GeneralParamReceiver()\r\n{\r\n   /* Deregister from general parameter messages. */\r\n   m_guiProtHandler-\u003eDeregisterReceiver(this,\r\n         isab::GuiProtEnums::SET_GENERAL_PARAMETER);\r\n   m_guiProtHandler-\u003eDeregisterReceiver(this,\r\n         isab::GuiProtEnums::GET_GENERAL_PARAMETER);\r\n}\r\n\r\nvoid\r\nGeneralParamReceiver::init()\r\n{\r\n   m_guiProtHandler-\u003eRegisterReceiver(this,\r\n         isab::GuiProtEnums::SET_GENERAL_PARAMETER);\r\n   m_guiProtHandler-\u003eRegisterReceiver(this,\r\n         isab::GuiProtEnums::GET_GENERAL_PARAMETER);\r\n}\r\n\r\nbool\r\nGeneralParamReceiver::decodedParamNoValue(uint32 paramId)\r\n{\r\n   /* Parameter was unset. */\r\n   /* Set default value if needed. */\r\n\r\n   return false;\r\n}\r\nbool\r\nGeneralParamReceiver::decodedParamValue(uint32 paramId,\r\n         const float* data, int32 numEntries)\r\n{\r\n   return false;\r\n}\r\nbool\r\nGeneralParamReceiver::decodedParamValue(uint32 paramId,\r\n         const uint8* data, int32 numEntries)\r\n{\r\n   return false;\r\n}\r\nbool\r\nGeneralParamReceiver::decodedParamValue(uint32 paramId,\r\n         const char** data, int32 numEntries)\r\n{\r\n   return false;\r\n}\r\nbool\r\nGeneralParamReceiver::decodedParamValue(uint32 paramId,\r\n         const int32* data, int32 numEntries)\r\n{\r\n   switch (paramId) {\r\n      case GuiProtEnums::paramAutoReroute:\r\n      {\r\n         m_settingsData-\u003em_autoReroute = data[0];\r\n      } break;\r\n      case GuiProtEnums::paramBacklightStrategy:\r\n      {\r\n         m_settingsData-\u003em_backlightStrategy = data[0];\r\n      } break;\r\n      case GuiProtEnums::paramAutoTracking:\r\n      {\r\n         m_settingsData-\u003em_autoTracking = data[0];\r\n      } break;\r\n      case GuiProtEnums::paramDistanceMode:\r\n      {\r\n         m_settingsData-\u003em_distanceMode = data[0];\r\n      } break;\r\n      case GuiProtEnums::paramFavoriteShow:\r\n      {\r\n         m_settingsData-\u003em_favoriteShowInMap = data[0];\r\n      } break;\r\n      case GuiProtEnums::paramHighways:\r\n      {\r\n         m_settingsData-\u003em_routeHighways = data[0];\r\n      } break;\r\n      case GuiProtEnums::paramTollRoads:\r\n      {\r\n         m_settingsData-\u003em_routeTollRoads = data[0];\r\n      } break;\r\n      case GuiProtEnums::paramTimeDist:\r\n      {\r\n         m_settingsData-\u003em_routeCostType = data[0];\r\n      } break;\r\n      case GuiProtEnums::paramTrackingLevel:\r\n      {\r\n         m_settingsData-\u003em_trackingLevel = data[0];\r\n      } break;\r\n      case GuiProtEnums::paramTransportationType:\r\n      {\r\n         m_settingsData-\u003em_transportationType = data[0];\r\n      } break;\r\n      case GuiProtEnums::paramTurnSoundsLevel:\r\n      {\r\n         m_settingsData-\u003em_turnSoundsLevel = data[0];\r\n      } break;\r\n      case GuiProtEnums::userTrafficUpdatePeriod:\r\n      {\r\n         int32 val = data[0];\r\n         // Lower bits are time in minutes.\r\n         m_settingsData-\u003em_trafficUpdatePeriod = 0xbfffffff \u0026 val;\r\n         m_settingsData-\u003em_trafficOldUpdatePeriod = 0xbfffffff \u0026 val;\r\n         // Second highest bit is on/off, but inverted,\r\n         // ie. set when off.\r\n         m_settingsData-\u003em_trafficUpdate = 0x40000000 \u0026 val ? 0 : 1;\r\n         m_settingsData-\u003em_trafficOldUpdate = 0x40000000 \u0026 val ? 0 : 1;\r\n      } break;\r\n      case GuiProtEnums::paramAutomaticRouteOnSMSDest:\r\n      {\r\n         m_settingsData-\u003em_autoRouteOnSMSDest = data[0];\r\n      } break;\r\n      case GuiProtEnums::paramKeepSMSDestInInbox:\r\n      {\r\n         m_settingsData-\u003em_keepSMSDestInInbox = data[0];\r\n      } break;\r\n      case GuiProtEnums::paramStoreSMSDestInMyDest:\r\n      {\r\n         m_settingsData-\u003em_storeSMSDestInFavorites = data[0];\r\n      } break;\r\n      case GuiProtEnums::paramPositionSymbol:\r\n      {\r\n         m_settingsData-\u003em_positionSymbol = data[0];\r\n      } break;\r\n      case GuiProtEnums::paramCheckForUpdates:\r\n      {\r\n         m_settingsData-\u003em_checkForUpdates = data[0];\r\n      } break;\r\n      default:\r\n      /* Unknown. */\r\n      return false; // Signal as not handled.\r\n      break;\r\n   }\r\n\r\n   return true; // Signal as handled.\r\n}\r\n   \r\nbool\r\nGeneralParamReceiver::GuiProtReceiveMessage(class GuiProtMess *mess)\r\n{\r\n   GuiProtEnums::MessageType type = mess-\u003egetMessageType();\r\n\r\n   if (type == GuiProtEnums::GET_GENERAL_PARAMETER) {\r\n      isab::GeneralParameterMess* gpm =\r\n            (isab::GeneralParameterMess *)mess;\r\n      return decodedParamNoValue(gpm-\u003egetParamId());\r\n   } else if (type == GuiProtEnums::SET_GENERAL_PARAMETER) {\r\n      isab::GeneralParameterMess* gpm =\r\n            (isab::GeneralParameterMess *)mess;\r\n      switch (gpm-\u003egetParamType()) {\r\n         case isab::GuiProtEnums::paramTypeInt32:\r\n            return decodedParamValue(gpm-\u003egetParamId(),\r\n                  gpm-\u003egetIntegerData(), gpm-\u003egetNumEntries());\r\n            break;\r\n         case isab::GuiProtEnums::paramTypeFloat:\r\n            return decodedParamValue(gpm-\u003egetParamId(),\r\n                  gpm-\u003egetFloatData(), gpm-\u003egetNumEntries());\r\n            break;\r\n         case isab::GuiProtEnums::paramTypeBinary:\r\n            return decodedParamValue(gpm-\u003egetParamId(),\r\n                  gpm-\u003egetBinaryData(), gpm-\u003egetNumEntries());\r\n            break;\r\n         case isab::GuiProtEnums::paramTypeString:\r\n            return decodedParamValue(gpm-\u003egetParamId(),\r\n                  (const char**)gpm-\u003egetStringData(), gpm-\u003egetNumEntries());\r\n            break;\r\n         default:\r\n         case isab::GuiProtEnums::paramTypeInvalid:\r\n            return false;\r\n            break;\r\n      }\r\n   }\r\n   return false;\r\n}\r\n\r\n}\r\n\r\n\r\n"}
{"repo_name":"lassoan/CTK","ref":"refs/heads/master","path":"Libs/Core/ctkWorkflowStep.cpp","copies":"6","language":"C++","content":"/*=========================================================================\n\n  Library:   CTK\n\n  Copyright (c) Kitware Inc.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  http://www.apache.org/licenses/LICENSE-2.0.txt\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n  =========================================================================*/\n\n// Qt includes\n#include \u003cQDebug\u003e\n#include \u003cQMetaType\u003e\n#include \u003cQObject\u003e\n#include \u003cQState\u003e\n\n// CTK includes\n#include \"ctkWorkflowStep.h\"\n#include \"ctkWorkflowStep_p.h\"\n#include \"ctkWorkflow.h\"\n#include \"ctkLogger.h\"\n\n// STD includes\n#include \u003ciostream\u003e\n\n//--------------------------------------------------------------------------\nstatic ctkLogger logger(\"org.commontk.core.ctkWorkflowStep\");\n//--------------------------------------------------------------------------\n\n// --------------------------------------------------------------------------\n// ctkWorkflowStepPrivate methods\n\n// --------------------------------------------------------------------------\nctkWorkflowStepPrivate::ctkWorkflowStepPrivate(ctkWorkflowStep\u0026 object)\n  :q_ptr(\u0026object)\n{\n  qRegisterMetaType\u003cctkWorkflowStep*\u003e(\"ctkWorkflowStep*\");\n  this-\u003eWorkflow = 0;\n\n  this-\u003eWidgetType = false;\n\n  this-\u003eHasValidateCommand = false;\n  this-\u003eHasOnEntryCommand = false;\n  this-\u003eHasOnExitCommand = false;\n\n  // Create state\n  this-\u003eProcessingState = new QState();\n  this-\u003eValidationState = new QState();\n\n  // Create 'validation' transition\n  this-\u003eValidationTransition =\n      new ctkWorkflowIntrastepTransition(ctkWorkflowIntrastepTransition::ValidationTransition);\n  this-\u003eValidationTransition-\u003esetTargetState(this-\u003eValidationState);\n  this-\u003eProcessingState-\u003eaddTransition(this-\u003eValidationTransition);\n\n  // Create 'failed validation' transation\n  this-\u003eValidationFailedTransition = 0;\n  this-\u003eValidationFailedTransition =\n      new ctkWorkflowIntrastepTransition(ctkWorkflowIntrastepTransition::ValidationFailedTransition);\n  this-\u003eValidationFailedTransition-\u003esetTargetState(this-\u003eProcessingState);\n  this-\u003eValidationState-\u003eaddTransition(this-\u003eValidationFailedTransition);\n}\n\n// --------------------------------------------------------------------------\nctkWorkflowStepPrivate::~ctkWorkflowStepPrivate()\n{\n  if (!this-\u003eValidationState.isNull())\n    {\n    delete this-\u003eValidationState;\n    }\n  if (!this-\u003eProcessingState.isNull())\n    {\n    delete this-\u003eProcessingState;\n    }\n\n  // If we delete the states, then Qt will handle deleting the transitions\n}\n\n// --------------------------------------------------------------------------\nvoid ctkWorkflowStepPrivate::validationCompleteInternal(bool validationResults, const QString\u0026 branchId)const\n{\n  emit validationComplete(validationResults, branchId);\n}\n\n// --------------------------------------------------------------------------\nvoid ctkWorkflowStepPrivate::onEntryCompleteInternal()const\n{\n  emit onEntryComplete();\n}\n\n// --------------------------------------------------------------------------\nvoid ctkWorkflowStepPrivate::onExitCompleteInternal()const\n{\n  emit onExitComplete();\n}\n\n// --------------------------------------------------------------------------\nvoid ctkWorkflowStepPrivate::invokeValidateCommandInternal(const QString\u0026 desiredBranchId)const\n{\n  emit invokeValidateCommand(desiredBranchId);\n}\n\n// --------------------------------------------------------------------------\nvoid ctkWorkflowStepPrivate::invokeOnEntryCommandInternal(const ctkWorkflowStep* comingFrom, const ctkWorkflowInterstepTransition::InterstepTransitionType transitionType)const\n{\n  emit invokeOnEntryCommand(comingFrom, transitionType);\n}\n\n// --------------------------------------------------------------------------\nvoid ctkWorkflowStepPrivate::invokeOnExitCommandInternal(const ctkWorkflowStep* goingTo, const ctkWorkflowInterstepTransition::InterstepTransitionType transitionType)const\n{\n  emit invokeOnExitCommand(goingTo, transitionType);\n}\n\n// --------------------------------------------------------------------------\n// ctkWorkflowStep methods\n\n// --------------------------------------------------------------------------\nctkWorkflowStep::ctkWorkflowStep(): d_ptr(new ctkWorkflowStepPrivate(*this))\n{\n}\n\n// --------------------------------------------------------------------------\nctkWorkflowStep::ctkWorkflowStep(const QString\u0026 newId)\n  : d_ptr(new ctkWorkflowStepPrivate(*this))\n{\n  Q_D(ctkWorkflowStep);\n  d-\u003eId = newId;\n}\n\n// --------------------------------------------------------------------------\nctkWorkflowStep::ctkWorkflowStep(ctkWorkflowStepPrivate * pimpl,\n                                 const QString\u0026 newId):d_ptr(pimpl)\n{\n  Q_D(ctkWorkflowStep);\n  d-\u003eId = newId;\n}\n\n// --------------------------------------------------------------------------\nctkWorkflowStep::~ctkWorkflowStep()\n{\n}\n\n// --------------------------------------------------------------------------\nCTK_GET_CPP(ctkWorkflowStep, ctkWorkflow*, workflow, Workflow);\nCTK_SET_CPP(ctkWorkflowStep, ctkWorkflow*, setWorkflow, Workflow);\n\n// --------------------------------------------------------------------------\nCTK_GET_CPP(ctkWorkflowStep, QString, id, Id);\n\n// --------------------------------------------------------------------------\nvoid ctkWorkflowStep::setId(const QString\u0026 newId)\n{\n  Q_D(ctkWorkflowStep);\n  if (d-\u003eWorkflow \u0026\u0026 d-\u003eWorkflow-\u003ehasStep(newId) \u0026\u0026 !this-\u003eid().isEmpty())\n    {\n    logger.error(QString(\"ctkWorkflowStep - Failed to change id from '%1' to '%2' - \"\n                         \"Step already added to a workflow !\").arg(this-\u003eid()).arg(newId));\n    return;\n    }\n  d-\u003eId = newId;\n}\n\n// --------------------------------------------------------------------------\nCTK_GET_CPP(ctkWorkflowStep, QString, name, Name);\nCTK_SET_CPP(ctkWorkflowStep, const QString\u0026, setName, Name);\n\n// --------------------------------------------------------------------------\nCTK_GET_CPP(ctkWorkflowStep, QString, description, Description);\nCTK_SET_CPP(ctkWorkflowStep, const QString\u0026, setDescription, Description);\n\n// --------------------------------------------------------------------------\nCTK_GET_CPP(ctkWorkflowStep, QString, statusText, StatusText);\nCTK_SET_CPP(ctkWorkflowStep, const QString\u0026, setStatusText, StatusText);\n\n// --------------------------------------------------------------------------\nCTK_GET_CPP(ctkWorkflowStep, bool, hasValidateCommand, HasValidateCommand);\nCTK_SET_CPP(ctkWorkflowStep, bool, setHasValidateCommand, HasValidateCommand);\n\n// --------------------------------------------------------------------------\nCTK_GET_CPP(ctkWorkflowStep, bool, hasOnEntryCommand, HasOnEntryCommand);\nCTK_SET_CPP(ctkWorkflowStep, bool, setHasOnEntryCommand, HasOnEntryCommand);\n\n// --------------------------------------------------------------------------\nCTK_GET_CPP(ctkWorkflowStep, bool, hasOnExitCommand, HasOnExitCommand);\nCTK_SET_CPP(ctkWorkflowStep, bool, setHasOnExitCommand, HasOnExitCommand);\n\n// --------------------------------------------------------------------------\nCTK_GET_CPP(ctkWorkflowStep, QState*, processingState, ProcessingState);\nCTK_GET_CPP(ctkWorkflowStep, QState*, validationState, ValidationState);\n\n// --------------------------------------------------------------------------\nCTK_GET_CPP(ctkWorkflowStep, ctkWorkflowIntrastepTransition*, validationTransition, ValidationTransition);\nCTK_GET_CPP(ctkWorkflowStep, ctkWorkflowIntrastepTransition*,\n            validationFailedTransition, ValidationFailedTransition);\n\n// --------------------------------------------------------------------------\nCTK_GET_CPP(ctkWorkflowStep, bool, isWidgetType, WidgetType);\n\n// --------------------------------------------------------------------------\nQObject* ctkWorkflowStep::ctkWorkflowStepQObject()\n{\n  Q_D(ctkWorkflowStep);\n  return d;\n}\n\n// --------------------------------------------------------------------------\nvoid ctkWorkflowStep::validationComplete(bool validationResults, const QString\u0026 branchId)const\n{\n  Q_D(const ctkWorkflowStep);\n  d-\u003evalidationCompleteInternal(validationResults, branchId);\n}\n\n// --------------------------------------------------------------------------\nvoid ctkWorkflowStep::onEntryComplete()const\n{\n  Q_D(const ctkWorkflowStep);\n  d-\u003eonEntryCompleteInternal();\n}\n\n// --------------------------------------------------------------------------\nvoid ctkWorkflowStep::onExitComplete()const\n{\n  Q_D(const ctkWorkflowStep);\n  d-\u003eonExitCompleteInternal();\n}\n\n// --------------------------------------------------------------------------\nvoid ctkWorkflowStep::invokeValidateCommand(const QString\u0026 desiredBranchId)const\n{\n  Q_D(const ctkWorkflowStep);\n  d-\u003einvokeValidateCommandInternal(desiredBranchId);\n}\n\n// --------------------------------------------------------------------------\nvoid ctkWorkflowStep::invokeOnEntryCommand(const ctkWorkflowStep* comingFrom, const ctkWorkflowInterstepTransition::InterstepTransitionType transitionType)const\n{\n  Q_D(const ctkWorkflowStep);\n  d-\u003einvokeOnEntryCommandInternal(comingFrom, transitionType);\n}\n\n// --------------------------------------------------------------------------\nvoid ctkWorkflowStep::invokeOnExitCommand(const ctkWorkflowStep* goingTo, const ctkWorkflowInterstepTransition::InterstepTransitionType transitionType)const\n{\n  Q_D(const ctkWorkflowStep);\n  d-\u003einvokeOnExitCommandInternal(goingTo, transitionType);\n}\n\n// --------------------------------------------------------------------------\nvoid ctkWorkflowStep::validate(const QString\u0026 desiredBranchId)\n{\n  Q_D(ctkWorkflowStep);\n  logger.info(QString(\"validate - validating the input from %1\").arg(d-\u003eName));\n\n  this-\u003evalidationComplete(true, desiredBranchId);\n}\n\n\n// --------------------------------------------------------------------------\nvoid ctkWorkflowStep::onEntry(const ctkWorkflowStep* comingFrom,\n                              const ctkWorkflowInterstepTransition::InterstepTransitionType transitionType)\n{\n  Q_UNUSED(comingFrom);\n  Q_UNUSED(transitionType);\n\n  // Signals that we are finished\n  this-\u003eonEntryComplete();\n}\n\n// --------------------------------------------------------------------------\nvoid ctkWorkflowStep::onExit(const ctkWorkflowStep* goingTo,\n                             const ctkWorkflowInterstepTransition::InterstepTransitionType transitionType)\n{\n  Q_UNUSED(goingTo);\n  Q_UNUSED(transitionType);\n\n // Signals that we are finished\n this-\u003eonExitComplete();\n}\n"}
{"repo_name":"hbwhlklive/color-emoji.skia","ref":"refs/heads/master","path":"src/ports/SkGlobalInitialization_chromium.cpp","copies":"47","language":"C++","content":"/*\n * Copyright 2011 Google Inc.\n *\n * Use of this source code is governed by a BSD-style license that can be\n * found in the LICENSE file.\n */\n\n#include \"SkBitmapProcShader.h\"\n#include \"SkBlurImageFilter.h\"\n#include \"SkBlurMaskFilter.h\"\n#include \"SkColorFilter.h\"\n#include \"SkCornerPathEffect.h\"\n#include \"SkDashPathEffect.h\"\n#include \"SkGradientShader.h\"\n#include \"SkLayerDrawLooper.h\"\n#include \"SkMallocPixelRef.h\"\n#include \"SkXfermode.h\"\n#include \"SkMagnifierImageFilter.h\"\n\nvoid SkFlattenable::InitializeFlattenables() {\n\n    SK_DEFINE_FLATTENABLE_REGISTRAR_ENTRY(SkBitmapProcShader)\n    SK_DEFINE_FLATTENABLE_REGISTRAR_ENTRY(SkBlurImageFilter)\n    SK_DEFINE_FLATTENABLE_REGISTRAR_ENTRY(SkCornerPathEffect)\n    SK_DEFINE_FLATTENABLE_REGISTRAR_ENTRY(SkDashPathEffect)\n    SK_DEFINE_FLATTENABLE_REGISTRAR_ENTRY(SkLayerDrawLooper)\n    SK_DEFINE_FLATTENABLE_REGISTRAR_ENTRY(SkMallocPixelRef)\n    SK_DEFINE_FLATTENABLE_REGISTRAR_ENTRY(SkMagnifierImageFilter)\n\n    SkBlurMaskFilter::InitializeFlattenables();\n    SkColorFilter::InitializeFlattenables();\n    SkGradientShader::InitializeFlattenables();\n    SkXfermode::InitializeFlattenables();\n}\n"}
{"repo_name":"circa-one/OpenJK-Alt","ref":"refs/heads/master","path":"code/cgame/cg_marks.cpp","copies":"24","language":"C++","content":"/*\n===========================================================================\nCopyright (C) 1999 - 2005, Id Software, Inc.\nCopyright (C) 2000 - 2013, Raven Software, Inc.\nCopyright (C) 2001 - 2013, Activision, Inc.\nCopyright (C) 2013 - 2015, OpenJK contributors\n\nThis file is part of the OpenJK source code.\n\nOpenJK is free software; you can redistribute it and/or modify it\nunder the terms of the GNU General Public License version 2 as\npublished by the Free Software Foundation.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, see \u003chttp://www.gnu.org/licenses/\u003e.\n===========================================================================\n*/\n\n// cg_marks.c -- wall marks\n\n#include \"cg_headers.h\"\n\n\n#include \"cg_media.h\"\n\n/*\n===================================================================\n\nMARK POLYS\n\n===================================================================\n*/\n\n\nmarkPoly_t\tcg_activeMarkPolys;\t\t\t// double linked list\nmarkPoly_t\t*cg_freeMarkPolys;\t\t\t// single linked list\nmarkPoly_t\tcg_markPolys[MAX_MARK_POLYS];\n\n/*\n===================\nCG_InitMarkPolys\n\nThis is called at startup and for tournement restarts\n===================\n*/\nvoid\tCG_InitMarkPolys( void ) {\n\tint\t\ti;\n\n\tmemset( cg_markPolys, 0, sizeof(cg_markPolys) );\n\n\tcg_activeMarkPolys.nextMark = \u0026cg_activeMarkPolys;\n\tcg_activeMarkPolys.prevMark = \u0026cg_activeMarkPolys;\n\tcg_freeMarkPolys = cg_markPolys;\n\tfor ( i = 0 ; i \u003c MAX_MARK_POLYS - 1 ; i++ ) {\n\t\tcg_markPolys[i].nextMark = \u0026cg_markPolys[i+1];\n\t}\n}\n\n\n/*\n==================\nCG_FreeMarkPoly\n==================\n*/\nvoid CG_FreeMarkPoly( markPoly_t *le ) {\n\tif ( !le-\u003eprevMark ) {\n\t\tCG_Error( \"CG_FreeLocalEntity: not active\" );\n\t}\n\n\t// remove from the doubly linked active list\n\tle-\u003eprevMark-\u003enextMark = le-\u003enextMark;\n\tle-\u003enextMark-\u003eprevMark = le-\u003eprevMark;\n\n\t// the free list is only singly linked\n\tle-\u003enextMark = cg_freeMarkPolys;\n\tcg_freeMarkPolys = le;\n}\n\n/*\n===================\nCG_AllocMark\n\nWill allways succeed, even if it requires freeing an old active mark\n===================\n*/\nmarkPoly_t\t*CG_AllocMark( void ) {\n\tmarkPoly_t\t*le;\n\tint time;\n\n\tif ( !cg_freeMarkPolys ) {\n\t\t// no free entities, so free the one at the end of the chain\n\t\t// remove the oldest active entity\n\t\ttime = cg_activeMarkPolys.prevMark-\u003etime;\n\t\twhile (cg_activeMarkPolys.prevMark \u0026\u0026 time == cg_activeMarkPolys.prevMark-\u003etime) {\n\t\t\tCG_FreeMarkPoly( cg_activeMarkPolys.prevMark );\n\t\t}\n\t}\n\n\tle = cg_freeMarkPolys;\n\tcg_freeMarkPolys = cg_freeMarkPolys-\u003enextMark;\n\n\tmemset( le, 0, sizeof( *le ) );\n\n\t// link into the active list\n\tle-\u003enextMark = cg_activeMarkPolys.nextMark;\n\tle-\u003eprevMark = \u0026cg_activeMarkPolys;\n\tcg_activeMarkPolys.nextMark-\u003eprevMark = le;\n\tcg_activeMarkPolys.nextMark = le;\n\treturn le;\n}\n\n\n\n/*\n=================\nCG_ImpactMark\n\norigin should be a point within a unit of the plane\ndir should be the plane normal\n\ntemporary marks will not be stored or randomly oriented, but immediately\npassed to the renderer.\n=================\n*/\n#define\tMAX_MARK_FRAGMENTS\t128\n#define\tMAX_MARK_POINTS\t\t384\n\nvoid CG_ImpactMark( qhandle_t markShader, const vec3_t origin, const vec3_t dir, float orientation, float red,\n\tfloat green, float blue, float alpha, qboolean alphaFade, float radius, qboolean temporary )\n{\n\tvec3_t\t\t\taxis[3];\n\tfloat\t\t\ttexCoordScale;\n\tvec3_t\t\t\toriginalPoints[4];\n\tbyte\t\t\tcolors[4];\n\tint\t\t\t\ti, j;\n\tint\t\t\t\tnumFragments;\n\tmarkFragment_t\tmarkFragments[MAX_MARK_FRAGMENTS], *mf;\n\tvec3_t\t\t\tmarkPoints[MAX_MARK_POINTS];\n\tvec3_t\t\t\tprojection;\n\n\tif ( !cg_addMarks.integer ) {\n\t\treturn;\n\t}\n\n\tif ( radius \u003c= 0 ) {\n\t\tCG_Error( \"CG_ImpactMark called with \u003c= 0 radius\" );\n\t}\n\n\t// create the texture axis\n\tVectorNormalize2( dir, axis[0] );\n\tPerpendicularVector( axis[1], axis[0] );\n\tRotatePointAroundVector( axis[2], axis[0], axis[1], orientation );\n\tCrossProduct( axis[0], axis[2], axis[1] );\n\n\ttexCoordScale = 0.5 * 1.0 / radius;\n\n\t// create the full polygon\n\tfor ( i = 0 ; i \u003c 3 ; i++ ) {\n\t\toriginalPoints[0][i] = origin[i] - radius * axis[1][i] - radius * axis[2][i];\n\t\toriginalPoints[1][i] = origin[i] + radius * axis[1][i] - radius * axis[2][i];\n\t\toriginalPoints[2][i] = origin[i] + radius * axis[1][i] + radius * axis[2][i];\n\t\toriginalPoints[3][i] = origin[i] - radius * axis[1][i] + radius * axis[2][i];\n\t}\n\n\t// get the fragments\n\tVectorScale( dir, -20, projection );\n\tnumFragments = cgi_CM_MarkFragments( 4, (const float (*)[3])originalPoints,\n\t\t\t\t\tprojection, MAX_MARK_POINTS, markPoints[0],\n\t\t\t\t\tMAX_MARK_FRAGMENTS, markFragments );\n\n\tcolors[0] = red * 255;\n\tcolors[1] = green * 255;\n\tcolors[2] = blue * 255;\n\tcolors[3] = alpha * 255;\n\n\tfor ( i = 0, mf = markFragments ; i \u003c numFragments ; i++, mf++ ) {\n\t\tpolyVert_t\t*v;\n\t\tpolyVert_t\tverts[MAX_VERTS_ON_POLY];\n\t\tmarkPoly_t\t*mark;\n\n\t\t// we have an upper limit on the complexity of polygons\n\t\t// that we store persistantly\n\t\tif ( mf-\u003enumPoints \u003e MAX_VERTS_ON_POLY ) {\n\t\t\tmf-\u003enumPoints = MAX_VERTS_ON_POLY;\n\t\t}\n\t\tfor ( j = 0, v = verts ; j \u003c mf-\u003enumPoints ; j++, v++ ) {\n\t\t\tvec3_t delta;\n\n\t\t\tVectorCopy( markPoints[mf-\u003efirstPoint + j], v-\u003exyz );\n\n\t\t\tVectorSubtract( v-\u003exyz, origin, delta );\n\t\t\tv-\u003est[0] = 0.5f + DotProduct( delta, axis[1] ) * texCoordScale;\n\t\t\tv-\u003est[1] = 0.5f + DotProduct( delta, axis[2] ) * texCoordScale;\n\t\t\tfor ( int k = 0; k \u003c 4; k++ ) {\n\t\t\t\tv-\u003emodulate[k] = colors[k];\n\t\t\t}\n\t\t}\n\n\t\t// if it is a temporary (shadow) mark, add it immediately and forget about it\n\t\tif ( temporary ) {\n\t\t\tcgi_R_AddPolyToScene( markShader, mf-\u003enumPoints, verts );\n\t\t\tcontinue;\n\t\t}\n\n\t\t// otherwise save it persistantly\n\t\tmark = CG_AllocMark();\n\t\tmark-\u003etime = cg.time;\n\t\tmark-\u003ealphaFade = alphaFade;\n\t\tmark-\u003emarkShader = markShader;\n\t\tmark-\u003epoly.numVerts = mf-\u003enumPoints;\n\t\tmark-\u003ecolor[0] = colors[0];//red;\n\t\tmark-\u003ecolor[1] = colors[1];//green;\n\t\tmark-\u003ecolor[2] = colors[2];//blue;\n\t\tmark-\u003ecolor[3] = colors[3];//alpha;\n\t\tmemcpy( mark-\u003everts, verts, mf-\u003enumPoints * sizeof( verts[0] ) );\n\t}\n}\n\n\n/*\n===============\nCG_AddMarks\n===============\n*/\n#define\tMARK_TOTAL_TIME\t\t10000\n#define\tMARK_FADE_TIME\t\t1000\n\nvoid CG_AddMarks( void ) {\n\tint\t\t\tj;\n\tmarkPoly_t\t*mp, *next;\n\tint\t\t\tt;\n\tint\t\t\tfade;\n\n\tif ( !cg_addMarks.integer ) {\n\t\treturn;\n\t}\n\n\tmp = cg_activeMarkPolys.nextMark;\n\tfor ( ; mp != \u0026cg_activeMarkPolys ; mp = next ) {\n\t\t// grab next now, so if the local entity is freed we\n\t\t// still have it\n\t\tnext = mp-\u003enextMark;\n\n\t\t// see if it is time to completely remove it\n\t\tif ( cg.time \u003e mp-\u003etime + MARK_TOTAL_TIME ) {\n\t\t\tCG_FreeMarkPoly( mp );\n\t\t\tcontinue;\n\t\t}\n\n\t\t// fade all marks out with time\n\t\tt = mp-\u003etime + MARK_TOTAL_TIME - cg.time;\n\t\tif ( t \u003c MARK_FADE_TIME ) {\n\t\t\tfade = 255 * t / MARK_FADE_TIME;\n\t\t\tif ( mp-\u003ealphaFade ) {\n\t\t\t\tfor ( j = 0 ; j \u003c mp-\u003epoly.numVerts ; j++ ) {\n\t\t\t\t\tmp-\u003everts[j].modulate[3] = fade;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfloat f = (float)t / MARK_FADE_TIME;\n\t\t\t\tfor ( j = 0 ; j \u003c mp-\u003epoly.numVerts ; j++ ) {\n\t\t\t\t\tmp-\u003everts[j].modulate[0] = mp-\u003ecolor[0] * f;\n\t\t\t\t\tmp-\u003everts[j].modulate[1] = mp-\u003ecolor[1] * f;\n\t\t\t\t\tmp-\u003everts[j].modulate[2] = mp-\u003ecolor[2] * f;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor ( j = 0 ; j \u003c mp-\u003epoly.numVerts ; j++ ) {\n\t\t\t\tmp-\u003everts[j].modulate[0] = mp-\u003ecolor[0];\n\t\t\t\tmp-\u003everts[j].modulate[1] = mp-\u003ecolor[1];\n\t\t\t\tmp-\u003everts[j].modulate[2] = mp-\u003ecolor[2];\n\t\t\t}\n\t\t}\n\n\n\t\tcgi_R_AddPolyToScene( mp-\u003emarkShader, mp-\u003epoly.numVerts, mp-\u003everts );\n\t}\n}\n\n"}
{"repo_name":"yuhangwang/spii","ref":"refs/heads/master","path":"thirdparty/Eigen/demos/opengl/icosphere.cpp","copies":"304","language":"C++","content":"// This file is part of Eigen, a lightweight C++ template library\n// for linear algebra.\n//\n// Copyright (C) 2008 Gael Guennebaud \u003cgael.guennebaud@inria.fr\u003e\n//\n// This Source Code Form is subject to the terms of the Mozilla\n// Public License v. 2.0. If a copy of the MPL was not distributed\n// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n#include \"icosphere.h\"\n\n#include \u003cGL/gl.h\u003e\n#include \u003cmap\u003e\n\nusing namespace Eigen;\n\n//--------------------------------------------------------------------------------\n// icosahedron data\n//--------------------------------------------------------------------------------\n#define X .525731112119133606\n#define Z .850650808352039932\n\nstatic GLfloat vdata[12][3] = {\n   {-X, 0.0, Z}, {X, 0.0, Z}, {-X, 0.0, -Z}, {X, 0.0, -Z},\n   {0.0, Z, X}, {0.0, Z, -X}, {0.0, -Z, X}, {0.0, -Z, -X},\n   {Z, X, 0.0}, {-Z, X, 0.0}, {Z, -X, 0.0}, {-Z, -X, 0.0}\n};\n\nstatic GLint tindices[20][3] = {\n   {0,4,1}, {0,9,4}, {9,5,4}, {4,5,8}, {4,8,1},\n   {8,10,1}, {8,3,10}, {5,3,8}, {5,2,3}, {2,7,3},\n   {7,10,3}, {7,6,10}, {7,11,6}, {11,0,6}, {0,1,6},\n   {6,1,10}, {9,0,11}, {9,11,2}, {9,2,5}, {7,2,11} };\n//--------------------------------------------------------------------------------\n\nIcoSphere::IcoSphere(unsigned int levels)\n{\n  // init with an icosahedron\n  for (int i = 0; i \u003c 12; i++)\n    mVertices.push_back(Map\u003cVector3f\u003e(vdata[i]));\n  mIndices.push_back(new std::vector\u003cint\u003e);\n  std::vector\u003cint\u003e\u0026 indices = *mIndices.back();\n  for (int i = 0; i \u003c 20; i++)\n  {\n    for (int k = 0; k \u003c 3; k++)\n      indices.push_back(tindices[i][k]);\n  }\n  mListIds.push_back(0);\n\n  while(mIndices.size()\u003clevels)\n    _subdivide();\n}\n\nconst std::vector\u003cint\u003e\u0026 IcoSphere::indices(int level) const\n{\n  while (level\u003e=int(mIndices.size()))\n    const_cast\u003cIcoSphere*\u003e(this)-\u003e_subdivide();\n  return *mIndices[level];\n}\n\nvoid IcoSphere::_subdivide(void)\n{\n  typedef unsigned long long Key;\n  std::map\u003cKey,int\u003e edgeMap;\n  const std::vector\u003cint\u003e\u0026 indices = *mIndices.back();\n  mIndices.push_back(new std::vector\u003cint\u003e);\n  std::vector\u003cint\u003e\u0026 refinedIndices = *mIndices.back();\n  int end = indices.size();\n  for (int i=0; i\u003cend; i+=3)\n  {\n    int ids0[3],  // indices of outer vertices\n        ids1[3];  // indices of edge vertices\n    for (int k=0; k\u003c3; ++k)\n    {\n      int k1 = (k+1)%3;\n      int e0 = indices[i+k];\n      int e1 = indices[i+k1];\n      ids0[k] = e0;\n      if (e1\u003ee0)\n        std::swap(e0,e1);\n      Key edgeKey = Key(e0) | (Key(e1)\u003c\u003c32);\n      std::map\u003cKey,int\u003e::iterator it = edgeMap.find(edgeKey);\n      if (it==edgeMap.end())\n      {\n        ids1[k] = mVertices.size();\n        edgeMap[edgeKey] = ids1[k];\n        mVertices.push_back( (mVertices[e0]+mVertices[e1]).normalized() );\n      }\n      else\n        ids1[k] = it-\u003esecond;\n    }\n    refinedIndices.push_back(ids0[0]); refinedIndices.push_back(ids1[0]); refinedIndices.push_back(ids1[2]);\n    refinedIndices.push_back(ids0[1]); refinedIndices.push_back(ids1[1]); refinedIndices.push_back(ids1[0]);\n    refinedIndices.push_back(ids0[2]); refinedIndices.push_back(ids1[2]); refinedIndices.push_back(ids1[1]);\n    refinedIndices.push_back(ids1[0]); refinedIndices.push_back(ids1[1]); refinedIndices.push_back(ids1[2]);\n  }\n  mListIds.push_back(0);\n}\n\nvoid IcoSphere::draw(int level)\n{\n  while (level\u003e=int(mIndices.size()))\n    const_cast\u003cIcoSphere*\u003e(this)-\u003e_subdivide();\n  if (mListIds[level]==0)\n  {\n    mListIds[level] = glGenLists(1);\n    glNewList(mListIds[level], GL_COMPILE);\n      glVertexPointer(3, GL_FLOAT, 0, mVertices[0].data());\n      glNormalPointer(GL_FLOAT, 0, mVertices[0].data());\n      glEnableClientState(GL_VERTEX_ARRAY);\n      glEnableClientState(GL_NORMAL_ARRAY);\n      glDrawElements(GL_TRIANGLES, mIndices[level]-\u003esize(), GL_UNSIGNED_INT, \u0026(mIndices[level]-\u003eat(0)));\n      glDisableClientState(GL_VERTEX_ARRAY);\n      glDisableClientState(GL_NORMAL_ARRAY);\n    glEndList();\n  }\n  glCallList(mListIds[level]);\n}\n\n\n"}
{"repo_name":"yinchunlong/abelkhan-1","ref":"refs/heads/master","path":"ext/c++/thirdpart/c++/boost/libs/math/reporting/accuracy/test_ibeta.cpp","copies":"28","language":"C++","content":"//  Copyright John Maddock 2006-15.\n//  Copyright Paul A. Bristow 2007\n//  Use, modification and distribution are subject to the\n//  Boost Software License, Version 1.0. (See accompanying file\n//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n\n#include \"bindings.hpp\"\n#include \"../../test/test_ibeta.hpp\"\n#include \u003cboost/math/special_functions/beta.hpp\u003e\n\nBOOST_AUTO_TEST_CASE_EXPECTED_FAILURES(test_main, 10000);\n\nBOOST_AUTO_TEST_CASE(test_main)\n{\n   BOOST_MATH_CONTROL_FP;\n\n   error_stream_replacer rep;\n\n#ifdef TYPE_TO_TEST\n\n   test_beta(static_cast\u003cTYPE_TO_TEST\u003e(0), NAME_OF_TYPE_TO_TEST);\n\n#else\n   bool test_float = false;\n   bool test_double = false;\n   bool test_long_double = false;\n\n   if(std::numeric_limits\u003clong double\u003e::digits == std::numeric_limits\u003cdouble\u003e::digits)\n   {\n      //\n      // Don't bother with long double, it's the same as double:\n      //\n      if(BOOST_MATH_PROMOTE_FLOAT_POLICY == false)\n         test_float = true;\n      test_double = true;\n   }\n   else\n   {\n      if(BOOST_MATH_PROMOTE_FLOAT_POLICY == false)\n         test_float = true;\n      if(BOOST_MATH_PROMOTE_DOUBLE_POLICY == false)\n         test_double = true;\n      test_long_double = true;\n   }\n\n#ifdef ALWAYS_TEST_DOUBLE\n   test_double = true;\n#endif\n\n   if(test_float)\n      test_beta(0.0f, \"float\");\n   if(test_double)\n      test_beta(0.0, \"double\");\n   if(test_long_double)\n      test_beta(0.0L, \"long double\");\n#ifdef BOOST_MATH_USE_FLOAT128\n   //test_beta(0.0Q, \"__float128\");\n#endif\n\n\n#endif\n}\n\n"}
{"repo_name":"kyoungchinseo/aws-sdk-cpp","ref":"refs/heads/master","path":"aws-cpp-sdk-s3/source/model/Delete.cpp","copies":"5","language":"C++","content":"/*\n* Copyright 2010-2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\").\n* You may not use this file except in compliance with the License.\n* A copy of the License is located at\n*\n*  http://aws.amazon.com/apache2.0\n*\n* or in the \"license\" file accompanying this file. This file is distributed\n* on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n* express or implied. See the License for the specific language governing\n* permissions and limitations under the License.\n*/\n#include \u003caws/s3/model/Delete.h\u003e\n#include \u003caws/core/utils/xml/XmlSerializer.h\u003e\n#include \u003caws/core/utils/StringUtils.h\u003e\n#include \u003caws/core/utils/memory/stl/AWSStringStream.h\u003e\n\n#include \u003cutility\u003e\n\nusing namespace Aws::S3::Model;\nusing namespace Aws::Utils::Xml;\nusing namespace Aws::Utils;\n\nDelete::Delete() : \n    m_objectsHasBeenSet(false),\n    m_quiet(false),\n    m_quietHasBeenSet(false)\n{\n}\n\nDelete::Delete(const XmlNode\u0026 xmlNode) : \n    m_objectsHasBeenSet(false),\n    m_quiet(false),\n    m_quietHasBeenSet(false)\n{\n  *this = xmlNode;\n}\n\nDelete\u0026 Delete::operator =(const XmlNode\u0026 xmlNode)\n{\n  XmlNode resultNode = xmlNode;\n\n  if(!resultNode.IsNull())\n  {\n    XmlNode objectsNode = resultNode.FirstChild(\"Objects\");\n    if(!objectsNode.IsNull())\n    {\n      XmlNode objectsMember = objectsNode;\n      while(!objectsMember.IsNull())\n      {\n        m_objects.push_back(objectsMember);\n        objectsMember = objectsMember.NextNode(\"Object\");\n      }\n\n      m_objectsHasBeenSet = true;\n    }\n    XmlNode quietNode = resultNode.FirstChild(\"Quiet\");\n    if(quietNode.IsNull())\n    {\n      quietNode = resultNode;\n    }\n\n    if(!quietNode.IsNull())\n    {\n      m_quiet = StringUtils::ConvertToBool(StringUtils::Trim(quietNode.GetText().c_str()).c_str());\n      m_quietHasBeenSet = true;\n    }\n  }\n\n  return *this;\n}\n\nvoid Delete::AddToNode(XmlNode\u0026 parentNode) const\n{\n  Aws::StringStream ss;\n  if(m_objectsHasBeenSet)\n  {\n   for(const auto\u0026 item : m_objects)\n   {\n     XmlNode objectsNode = parentNode.CreateChildElement(\"Object\");\n     item.AddToNode(objectsNode);\n   }\n  }\n\n  if(m_quietHasBeenSet)\n  {\n   XmlNode quietNode = parentNode.CreateChildElement(\"Object\");\n  ss \u003c\u003c m_quiet;\n   quietNode.SetText(ss.str());\n  ss.str(\"\");\n  }\n\n}\n"}
{"repo_name":"pcolby/libqtaws","ref":"refs/heads/master","path":"src/ssm/describeinstancepatchstatesresponse.cpp","copies":"1","language":"C++","content":"/*\n    Copyright 2013-2018 Paul Colby\n\n    This file is part of QtAws.\n\n    QtAws is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    QtAws is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with the QtAws.  If not, see \u003chttp://www.gnu.org/licenses/\u003e.\n*/\n\n#include \"describeinstancepatchstatesresponse.h\"\n#include \"describeinstancepatchstatesresponse_p.h\"\n\n#include \u003cQDebug\u003e\n#include \u003cQNetworkReply\u003e\n#include \u003cQXmlStreamReader\u003e\n\nnamespace QtAws {\nnamespace SSM {\n\n/*!\n * \\class QtAws::SSM::DescribeInstancePatchStatesResponse\n * \\brief The DescribeInstancePatchStatesResponse class provides an interace for SSM DescribeInstancePatchStates responses.\n *\n * \\inmodule QtAwsSSM\n *\n *  \u003cfullname\u003eAWS Systems Manager\u003c/fullname\u003e\n * \n *  AWS Systems Manager is a collection of capabilities that helps you automate management tasks such as collecting system\n *  inventory, applying operating system (OS) patches, automating the creation of Amazon Machine Images (AMIs), and\n *  configuring operating systems (OSs) and applications at scale. Systems Manager lets you remotely and securely manage the\n *  configuration of your managed instances. A \u003ci\u003emanaged instance\u003c/i\u003e is any Amazon EC2 instance or on-premises machine in\n *  your hybrid environment that has been configured for Systems\n * \n *  Manager\u003e\n * \n *  This reference is intended to be used with the \u003ca\n *  href=\"http://docs.aws.amazon.com/systems-manager/latest/userguide/\"\u003eAWS Systems Manager User\n * \n *  Guide\u003c/a\u003e\u003e\n * \n *  To get started, verify prerequisites and configure managed instances. For more information, see \u003ca\n *  href=\"http://docs.aws.amazon.com/systems-manager/latest/userguide/systems-manager-setting-up.html\"\u003eSystems Manager\n *  Prerequisites\u003c/a\u003e in the \u003ci\u003eAWS Systems Manager User\n * \n *  Guide\u003c/i\u003e\u003e\n * \n *  For information about other API actions you can perform on Amazon EC2 instances, see the \u003ca\n *  href=\"http://docs.aws.amazon.com/AWSEC2/latest/APIReference/\"\u003eAmazon EC2 API Reference\u003c/a\u003e. For information about how to\n *  use a Query API, see \u003ca href=\"http://docs.aws.amazon.com/AWSEC2/latest/APIReference/making-api-requests.html\"\u003eMaking API\n *  Requests\u003c/a\u003e.\n *\n * \\sa SsmClient::describeInstancePatchStates\n */\n\n/*!\n * Constructs a DescribeInstancePatchStatesResponse object for \\a reply to \\a request, with parent \\a parent.\n */\nDescribeInstancePatchStatesResponse::DescribeInstancePatchStatesResponse(\n        const DescribeInstancePatchStatesRequest \u0026request,\n        QNetworkReply * const reply,\n        QObject * const parent)\n    : SsmResponse(new DescribeInstancePatchStatesResponsePrivate(this), parent)\n{\n    setRequest(new DescribeInstancePatchStatesRequest(request));\n    setReply(reply);\n}\n\n/*!\n * \\reimp\n */\nconst DescribeInstancePatchStatesRequest * DescribeInstancePatchStatesResponse::request() const\n{\n    Q_D(const DescribeInstancePatchStatesResponse);\n    return static_cast\u003cconst DescribeInstancePatchStatesRequest *\u003e(d-\u003erequest);\n}\n\n/*!\n * \\reimp\n * Parses a successful SSM DescribeInstancePatchStates \\a response.\n */\nvoid DescribeInstancePatchStatesResponse::parseSuccess(QIODevice \u0026response)\n{\n    //Q_D(DescribeInstancePatchStatesResponse);\n    QXmlStreamReader xml(\u0026response);\n    /// @todo\n}\n\n/*!\n * \\class QtAws::SSM::DescribeInstancePatchStatesResponsePrivate\n * \\brief The DescribeInstancePatchStatesResponsePrivate class provides private implementation for DescribeInstancePatchStatesResponse.\n * \\internal\n *\n * \\inmodule QtAwsSSM\n */\n\n/*!\n * Constructs a DescribeInstancePatchStatesResponsePrivate object with public implementation \\a q.\n */\nDescribeInstancePatchStatesResponsePrivate::DescribeInstancePatchStatesResponsePrivate(\n    DescribeInstancePatchStatesResponse * const q) : SsmResponsePrivate(q)\n{\n\n}\n\n/*!\n * Parses a SSM DescribeInstancePatchStates response element from \\a xml.\n */\nvoid DescribeInstancePatchStatesResponsePrivate::parseDescribeInstancePatchStatesResponse(QXmlStreamReader \u0026xml)\n{\n    Q_ASSERT(xml.name() == QLatin1String(\"DescribeInstancePatchStatesResponse\"));\n    Q_UNUSED(xml) ///\u003c @todo\n}\n\n} // namespace SSM\n} // namespace QtAws\n"}
{"repo_name":"lunastorm/wissbi","ref":"refs/heads/master","path":"3rd_party/libcxx/test/strings/basic.string/string.modifiers/string_append/pointer.pass.cpp","copies":"2","language":"C++","content":"//===----------------------------------------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n// \u003cstring\u003e\n\n// basic_string\u003ccharT,traits,Allocator\u003e\u0026 append(const charT* s);\n\n#include \u003cstring\u003e\n#include \u003cstdexcept\u003e\n#include \u003ccassert\u003e\n\ntemplate \u003cclass S\u003e\nvoid\ntest(S s, const typename S::value_type* str, S expected)\n{\n    s.append(str);\n    assert(s.__invariants());\n    assert(s == expected);\n}\n\nint main()\n{\n    typedef std::string S;\n    test(S(), \"\", S());\n    test(S(), \"12345\", S(\"12345\"));\n    test(S(), \"12345678901234567890\", S(\"12345678901234567890\"));\n\n    test(S(\"12345\"), \"\", S(\"12345\"));\n    test(S(\"12345\"), \"12345\", S(\"1234512345\"));\n    test(S(\"12345\"), \"1234567890\", S(\"123451234567890\"));\n\n    test(S(\"12345678901234567890\"), \"\", S(\"12345678901234567890\"));\n    test(S(\"12345678901234567890\"), \"12345\", S(\"1234567890123456789012345\"));\n    test(S(\"12345678901234567890\"), \"12345678901234567890\",\n         S(\"1234567890123456789012345678901234567890\"));\n}\n"}
{"repo_name":"ChameleonOS/android_external_skia","ref":"refs/heads/kitkat","path":"tests/PathOpsAngleTest.cpp","copies":"18","language":"C++","content":"/*\n * Copyright 2013 Google Inc.\n *\n * Use of this source code is governed by a BSD-style license that can be\n * found in the LICENSE file.\n */\n#include \"PathOpsTestCommon.h\"\n#include \"SkOpSegment.h\"\n#include \"SkTArray.h\"\n#include \"Test.h\"\n\nstatic const SkPoint cubics[][4] = {\n/* 0 */    {{0, 1}, {2, 6}, {4, 2}, {5, 3}},\n/* 1 */    {{10, 234}, {10, 229.581726f}, {13.5817204f, 226}, {18, 226}},\n/* 2 */    {{132, 11419}, {130.89543151855469f, 11419}, {130, 11418.1044921875f}, {130, 11417}},\n/* 3 */    {{130.04275512695312f, 11417.4130859375f}, {130.23307800292969f, 11418.3193359375f},\n                    {131.03709411621094f, 11419}, {132, 11419}},\n/* 4 */    {{0,1}, {0,5}, {4,1}, {6,4}},\n/* 5 */    {{1,5}, {4,6}, {1,0}, {4,0}},\n/* 6 */    {{0,1}, {0,4}, {5,1}, {6,4}},\n/* 7 */    {{0,1}, {1,2}, {1,0}, {6,1}},\n/* 8 */    {{0,3}, {0,1}, {2,0}, {1,0}},\n/* 9 */    {{189,7}, {189,5.3431458473205566f}, {190.3431396484375f,4}, {192,4}},\n/* 10 */   {{0,1}, {1,3}, {1,0}, {6,4}},\n/* 11 */   {{0,1}, {2,3}, {2,1}, {4,3}},\n/* 12 */   {{1,2}, {3,4}, {1,0}, {3,2}},\n/* 13 */   {{0,1}, {4,6}, {4,3}, {5,4}},\n/* 14 */   {{806,11419}, {806.962890625f,11419}, {807.76690673828125f,11418.3193359375f}, {807.957275390625f,11417.4130859375f}},\n/* 15 */   {{808,11417}, {808,11418.1044921875f}, {807.10455322265625f,11419}, {806,11419}},\n/* 16 */   {{132,11419}, {130.89543151855469f,11419}, {130,11418.1044921875f}, {130,11417}},\n/* 17 */   {{130.04275512695312f,11417.4130859375f}, {130.23312377929687f,11418.3193359375f}, {131.03707885742187f,11419}, {132,11419}},\n/* 18 */   {{1006.6951293945312f,291}, {1023.263671875f,291}, {1033.8402099609375f,304.43145751953125f}, {1030.318359375f,321}},\n};\n\nstatic const SkPoint quads[][3] = {\n/* 0 */    {{12.3423996f, 228.342407f}, {10, 230.686295f}, {10, 234}},\n/* 1 */    {{304.24319458007812f,591.75677490234375f}, {306,593.51470947265625f}, {306,596}},\n/* 2 */    {{0,0}, {3,1}, {0,3}},\n/* 3 */    {{0,1}, {3,1}, {0,2}},\n};\n\nstatic const SkPoint lines[][2] = {\n/* 0 */    {{6, 2}, {2, 4}},\n/* 1 */    {{306,617}, {306,590}},\n/* 2 */    {{306,596}, {306,617}},\n/* 3 */    {{6,4}, {0,1}},\n/* 4 */    {{6,1}, {0,1}},\n/* 5 */    {{1,0}, {0,3}},\n/* 6 */    {{246,4}, {189,4}},\n/* 7 */    {{192,4}, {243,4}},\n/* 8 */    {{4,3}, {0,1}},\n/* 9 */    {{3,2}, {1,2}},\n/* 10 */   {{6,4}, {3,4}},\n/* 11 */   {{979.30487060546875f,561}, {1036.695068359375f,291}},\n};\n\nstruct SortSet {\n    const SkPoint* ptData;\n    int ptCount;\n    double tStart;\n    double tEnd;\n    SkPoint endPt;\n};\n\nstatic const SortSet set1[] = {\n    {cubics[0], 4, 0.66666987081928919, 0.875, {0, 0}},\n    {lines[0], 2, 0.574070336, 0.388888889, {0, 0}},\n    {cubics[0], 4, 0.66666987081928919, 0.4050371120499307, {0, 0}},\n    {lines[0], 2, 0.574070336, 0.9140625, {0, 0}},\n};\n\nstatic const SortSet set1a[] = {\n    {cubics[0], 4, 0.666666667, 0.405037112, {4.58007812f,2.83203125f}},\n    {lines[0], 2, 0.574074074, 0.9140625, {4.44444466f,2.77777767f}},\n};\n\nstatic const SortSet set2[] = {\n    {cubics[0], 4, 0.666666667, 0.875, {0, 0}},\n    {lines[0], 2, 0.574074074, 0.388888889, {0, 0}},\n    {cubics[0], 4, 0.666666667, 0.405037112, {0, 0}},\n    {lines[0], 2, 0.574074074, 0.9140625, {0, 0}},\n};\n\nstatic const SortSet set3[] = {\n    {cubics[1], 4, 0, 1, {0, 0}},\n    {quads[0], 3, 1, 0, {0, 0}},\n};\n\nstatic const SortSet set4[] = {\n    {cubics[2], 4, 0.812114222, 1, {0, 0}},\n    {cubics[3], 4, 0.0684734759, 0, {0, 0}},\n};\n\nstatic const SortSet set5[] = {\n    {lines[1], 2, 0.777777778, 1, {0, 0}},\n    {quads[1], 3, 1, 4.34137342e-06, {0, 0}},\n    {lines[2], 2, 0, 1, {0, 0}},\n};\n\nstatic const SortSet set5a[] = {\n    {lines[1], 2, 0.777777778, 1, {306,590}},\n    {quads[1], 3, 1, 4.34137342e-06, {304.243195f,591.756775f}},\n    {lines[2], 2, 0, 1, {306,617}},\n};\n\nstatic const SortSet set6[] = {\n    {lines[3], 2, 0.407407407, 0.554627832, {0, 0}},\n    {cubics[4], 4, 0.666666667, 0.548022446, {0, 0}},\n    {lines[3], 2, 0.407407407, 0, {0, 0}},\n    {cubics[4], 4, 0.666666667, 1, {0, 0}},\n};\n\nstatic const SortSet set6a[] = {\n    {lines[3], 2, 0.407407407, 0.554627832, {2.6722331f,2.33611655f}},\n    {cubics[4], 4, 0.666666667, 0.548022446, {2.61642241f,2.83718514f}},\n    {lines[3], 2, 0.407407407, 0, {6,4}},\n    {cubics[4], 4, 0.666666667, 1, {6,4}},\n};\n\nstatic const SortSet set7[] = {\n    {cubics[5], 4, 0.545233342, 0.545454545, {0, 0}},\n    {cubics[6], 4, 0.484938134, 0.484805744, {0, 0}},\n    {cubics[5], 4, 0.545233342, 0, {0, 0}},\n    {cubics[6], 4, 0.484938134, 0.545454545, {0, 0}},\n};\n\nstatic const SortSet set8[] = {\n    {cubics[7], 4, 0.5, 0.522986744, {0, 0}},\n    {lines[4], 2, 0.75, 1, {0, 0}},\n    {cubics[7], 4, 0.5, 0, {0, 0}},\n    {lines[4], 2, 0.75, 0.737654321, {0, 0}},\n};\n\nstatic const SortSet set8a[] = {\n    {cubics[7], 4, 0.5, 0.522986744, {1.60668361f,0.965592742f}},\n    {lines[4], 2, 0.75, 1, {0,1}},\n    {cubics[7], 4, 0.5, 0, {0,1}},\n    {lines[4], 2, 0.75, 0.737654321, {1.57407403f,1}},\n};\n\nstatic const SortSet set9[] = {\n    {cubics[8], 4, 0.4, 1, {0, 0}},\n    {lines[5], 2, 0.36, 0, {0, 0}},\n    {cubics[8], 4, 0.4, 0.394675838, {0, 0}},\n    {lines[5], 2, 0.36, 0.363999782, {0, 0}},\n};\n\nstatic const SortSet set10[] = {\n    {lines[6], 2, 0.947368421, 1, {0, 0}},\n    {cubics[9], 4, 1, 0.500000357, {0, 0}},\n    {lines[7], 2, 0, 1, {0, 0}},\n};\n\nstatic const SortSet set11[] = {\n    {lines[3], 2, 0.75, 1, {0, 0}},\n    {cubics[10], 4, 0.5, 0.228744269, {0, 0}},\n    {lines[3], 2, 0.75, 0.627112191, {0, 0}},\n    {cubics[10], 4, 0.5, 0.6339746, {0, 0}},\n};\n\nstatic const SortSet set12[] = {\n    {cubics[12], 4, 0.5, 1, {0, 0}},\n    {lines[8], 2, 0.5, 1, {0, 0}},\n    {cubics[11], 4, 0.5, 0, {0, 0}},\n    {lines[9], 2, 0.5, 1, {0, 0}},\n    {cubics[12], 4, 0.5, 0, {0, 0}},\n    {lines[8], 2, 0.5, 0, {0, 0}},\n    {cubics[11], 4, 0.5, 1, {0, 0}},\n    {lines[9], 2, 0.5, 0, {0, 0}},\n};\n\nstatic const SortSet set13[] = {\n    {cubics[13], 4, 0.5, 0.400631046, {0, 0}},\n    {lines[10], 2, 0.791666667, 0.928, {0, 0}},\n    {lines[10], 2, 0.791666667, 0.333333333, {0, 0}},\n    {cubics[13], 4, 0.5, 0.866666667, {0, 0}},\n};\n\nstatic const SortSet set14[] = {\n    {quads[2], 3, 0.5, 0.310102051, {0, 0}},\n    {quads[3], 3, 0.5, 0.2, {0, 0}},\n    {quads[3], 3, 0.5, 0.770156212, {0, 0}},\n    {quads[2], 3, 0.5, 0.7, {0, 0}},\n};\n\nstatic const SortSet set15[] = {\n    {cubics[14], 4, 0.93081374, 1, {0, 0}},\n    {cubics[15], 4, 0.188518131, 0, {0, 0}},\n    {cubics[14], 4, 0.93081374, 0, {0, 0}},\n};\n\nstatic const SortSet set16[] = {\n    {cubics[17], 4, 0.0682619216, 0, {130.042755f,11417.4131f}},\n    {cubics[16], 4, 0.812302088, 1, {130,11417}},\n    {cubics[17], 4, 0.0682619216, 1, {132,11419}},\n};\n\nstatic const SortSet set17[] = {\n    {lines[11], 2, 0.888889581, 1, {0, 0}},\n    {cubics[18], 4, 0.999996241, 0, {0, 0}},\n    {lines[11], 2, 0.888889581, 0, {0, 0}},\n    {cubics[18], 4, 0.999996241, 1, {0, 0}},\n};\n\nstruct SortSetTests {\n    const char* name;\n    const SortSet* set;\n    size_t count;\n    SkPoint startPt;\n};\n\n#define TEST_ENTRY(name) #name, name, SK_ARRAY_COUNT(name)\n\nstatic const SortSetTests tests[] = {\n    { TEST_ENTRY(set17), {0, 0}},\n    { TEST_ENTRY(set16), {130.090179f,11417.5957f} },\n//    { TEST_ENTRY(set15), {0, 0}},\n    { TEST_ENTRY(set14), {0, 0}},\n    { TEST_ENTRY(set13), {0, 0}},\n    { TEST_ENTRY(set12), {0, 0}},\n    { TEST_ENTRY(set11), {0, 0}},\n    { TEST_ENTRY(set10), {0, 0}},\n    { TEST_ENTRY(set9), {0, 0}},\n    { TEST_ENTRY(set6a), {3.55555558f,2.77777767f} },\n    { TEST_ENTRY(set8a), {1.5f,1} },\n    { TEST_ENTRY(set8), {0, 0}},\n    { TEST_ENTRY(set7), {0, 0}},\n    { TEST_ENTRY(set6a), {3.55555558f,2.77777767f} },\n    { TEST_ENTRY(set6), {0, 0}},\n    { TEST_ENTRY(set5a), {306,596} },\n    { TEST_ENTRY(set5), {0, 0}},\n//    { TEST_ENTRY(set4), {0, 0}},\n    { TEST_ENTRY(set3), {0, 0}},\n    { TEST_ENTRY(set2), {0, 0}},\n//    { TEST_ENTRY(set1a), {3.70370364f,3.14814806f} },\n    { TEST_ENTRY(set1), {0, 0}},\n};\n\n#undef TEST_ENTRY\n\nstatic void setup(const SortSet* set, const size_t idx,\n        SkOpSegment* seg, int* ts, const SkPoint\u0026 startPt) {\n    SkPoint start, end;\n    const SkPoint* data = set[idx].ptData;\n    bool useIntersectPt = startPt.fX != 0 || startPt.fY != 0;\n    if (useIntersectPt) {\n        start = startPt;\n        end = set[idx].endPt;\n    }\n    switch(set[idx].ptCount) {\n        case 2: {\n            SkASSERT(ValidPoints(data, 2));\n            seg-\u003eaddLine(data, false, false);\n            SkDLine dLine;\n            dLine.set(set[idx].ptData);\n            SkASSERT(ValidLine(dLine));\n            if (useIntersectPt) {\n                break;\n            }\n            start = dLine.ptAtT(set[idx].tStart).asSkPoint();\n            end = dLine.ptAtT(set[idx].tEnd).asSkPoint();\n            } break;\n        case 3: {\n            SkASSERT(ValidPoints(data, 3));\n            seg-\u003eaddQuad(data, false, false);\n            SkDQuad dQuad;\n            dQuad.set(set[idx].ptData);\n            SkASSERT(ValidQuad(dQuad));\n             if (useIntersectPt) {\n                break;\n            }\n            start = dQuad.ptAtT(set[idx].tStart).asSkPoint();\n            end = dQuad.ptAtT(set[idx].tEnd).asSkPoint();\n            } break;\n        case 4: {\n            SkASSERT(ValidPoints(data, 4));\n            seg-\u003eaddCubic(data, false, false);\n            SkDCubic dCubic;\n            dCubic.set(set[idx].ptData);\n            SkASSERT(ValidCubic(dCubic));\n            if (useIntersectPt) {\n                break;\n            }\n            start = dCubic.ptAtT(set[idx].tStart).asSkPoint();\n            end = dCubic.ptAtT(set[idx].tEnd).asSkPoint();\n            } break;\n    }\n    double tStart = set[idx].tStart;\n    double tEnd = set[idx].tEnd;\n    seg-\u003eaddT(NULL, start, tStart);\n    seg-\u003eaddT(NULL, end, tEnd);\n    if (tStart != 0 \u0026\u0026 tEnd != 0) {\n        seg-\u003eaddT(NULL, set[idx].ptData[0], 0);\n    }\n    if (tStart != 1 \u0026\u0026 tEnd != 1) {\n        seg-\u003eaddT(NULL, set[idx].ptData[set[idx].ptCount - 1], 1);\n    }\n    int tIndex = 0;\n    ts[0] = 0;\n    ts[1] = 1;\n    do {\n        if (seg-\u003et(tIndex) == set[idx].tStart) {\n            ts[0] = tIndex;\n        }\n        if (seg-\u003et(tIndex) == set[idx].tEnd) {\n            ts[1] = tIndex;\n        }\n        if (seg-\u003et(tIndex) \u003e= 1) {\n            break;\n        }\n    } while (++tIndex);\n}\n\nstatic void testOne(skiatest::Reporter* reporter, const SortSetTests\u0026 test) {\n    SkTDArray\u003cSkOpAngle\u003e angles;\n    bool unsortable = false;\n    bool unorderable = false;\n    SkTArray\u003cSkOpSegment\u003e segs;\n    for (size_t idx = 0; idx \u003c test.count; ++idx) {\n        int ts[2];\n        const SortSet* set = test.set;\n        SkOpSegment\u0026 seg = segs.push_back();\n        setup(set, idx, \u0026seg, ts, test.startPt);\n        SkOpAngle* angle = angles.append();\n        angle-\u003eset(\u0026seg, ts[0], ts[1]);\n#if DEBUG_ANGLE\n        angle-\u003esetID(idx);\n#endif\n        if (angle-\u003eunsortable()) {\n#if DEBUG_ANGLE\n            SkDebugf(\"%s test[%s]:  angle[%d] unsortable\\n\", __FUNCTION__, test.name, idx);\n#endif\n            unsortable = true;\n        }\n        if (angle-\u003eunorderable()) {\n#if DEBUG_ANGLE\n            SkDebugf(\"%s test[%s]:  angle[%d] unorderable\\n\", __FUNCTION__, test.name, idx);\n#endif\n            unorderable = true;\n        }\n        reporter-\u003ebumpTestCount();\n    }\n    if (unsortable || unorderable) {\n        return;\n    }\n#if DEBUG_ANGLE\n    SkDebugf(\"%s test[%s]\\n\", __FUNCTION__, test.name);\n#endif\n    for (size_t idxL = 0; idxL \u003c test.count; ++idxL) {\n        const SkOpAngle\u0026 first = angles[idxL];\n        for (size_t idxG = 0; idxG \u003c test.count; ++idxG) {\n            if (idxL == idxG) {\n                continue;\n            }\n            const SkOpAngle\u0026 second = angles[idxG];\n            bool compare = first \u003c second;\n            if (idxL \u003c idxG) {\n                if (!compare) {\n                    SkDebugf(\"%s test[%s]:  first[%d] \u003e second[%d]\\n\", __FUNCTION__,\n                            test.name,  idxL,  idxG);\n                    compare = first \u003c second;\n                }\n                REPORTER_ASSERT(reporter, compare);\n            } else {\n                SkASSERT(idxL \u003e idxG);\n                if (compare) {\n                    SkDebugf(\"%s test[%s]:  first[%d] \u003c second[%d]\\n\", __FUNCTION__,\n                            test.name,  idxL,  idxG);\n                    compare = first \u003c second;\n                }\n                REPORTER_ASSERT(reporter, !compare);\n            }\n            compare = second \u003c first;\n            if (idxL \u003c idxG) {\n                if (compare) {\n                    SkDebugf(\"%s test[%s]:  second[%d] \u003c first[%d]\\n\", __FUNCTION__,\n                            test.name,  idxL,  idxG);\n                    compare = second \u003c first;\n                }\n                REPORTER_ASSERT(reporter, !compare);\n            } else {\n                SkASSERT(idxL \u003e idxG);\n                if (!compare) {\n                    SkDebugf(\"%s test[%s]:  second[%d] \u003e first[%d]\\n\", __FUNCTION__,\n                            test.name,  idxL,  idxG);\n                    compare = second \u003c first;\n                }\n                REPORTER_ASSERT(reporter, compare);\n            }\n        }\n    }\n}\n\nstatic void PathOpsAngleTest(skiatest::Reporter* reporter) {\n    for (size_t index = 0; index \u003c SK_ARRAY_COUNT(tests); ++index) {\n        const SortSetTests\u0026 test = tests[index];\n        testOne(reporter, test);\n        reporter-\u003ebumpTestCount();\n    }\n}\n\nstatic void PathOpsAngleTestOne(skiatest::Reporter* reporter) {\n    size_t index = 0;\n    const SortSetTests\u0026 test = tests[index];\n    testOne(reporter, test);\n}\n\n#if 0\nstatic int find_slop(double x, double y, double rx, double ry) {\n    int slopBits = 0;\n    bool less1, less2;\n    double absX = fabs(x);\n    double absY = fabs(y);\n    double length = absX \u003c absY ? absX / 2 + absY : absX + absY / 2;\n    int exponent;\n    (void) frexp(length, \u0026exponent);\n    double epsilon = ldexp(FLT_EPSILON, exponent);\n    do {\n        // get the length as the larger plus half the smaller (both same signs)\n        // find the ulps of the length\n        // compute the offsets from there\n        double xSlop = epsilon * slopBits;\n        double ySlop = x * y \u003c 0 ? -xSlop : xSlop; // OPTIMIZATION: use copysign / _copysign ?\n        double x1 = x - xSlop;\n        double y1 = y + ySlop;\n        double x_ry1 = x1 * ry;\n        double rx_y1 = rx * y1;\n        less1 = x_ry1 \u003c rx_y1;\n        double x2 = x + xSlop;\n        double y2 = y - ySlop;\n        double x_ry2 = x2 * ry;\n        double rx_y2 = rx * y2;\n        less2 = x_ry2 \u003c rx_y2;\n    } while (less1 == less2 \u0026\u0026 ++slopBits);\n    return slopBits;\n}\n\n// from http://stackoverflow.com/questions/1427422/cheap-algorithm-to-find-measure-of-angle-between-vectors\nstatic double diamond_angle(double y, double x)\n{\n    if (y \u003e= 0)\n        return (x \u003e= 0 ? y/(x+y) : 1-x/(-x+y));\n    else\n        return (x \u003c 0 ? 2-y/(-x-y) : 3+x/(x-y));\n}\n\nstatic const double slopTests[][4] = {\n   // x                      y                       rx                      ry\n    {-0.058554756452593892, -0.18804585843827226, -0.018568569646021160, -0.059615294434479438},\n    {-0.0013717412948608398, 0.0041152238845825195, -0.00045837944195925573, 0.0013753175735478074},\n    {-2.1033774145221198, -1.4046019261273715e-008, -0.70062688352066704, -1.2706324683777995e-008},\n};\n\nstatic void PathOpsAngleFindSlop(skiatest::Reporter* reporter) {\n    for (size_t index = 0; index \u003c SK_ARRAY_COUNT(slopTests); ++index) {\n        const double* slopTest = slopTests[index];\n        double x = slopTest[0];\n        double y = slopTest[1];\n        double rx = slopTest[2];\n        double ry = slopTest[3];\n        SkDebugf(\"%s  xy %d=%d\\n\", __FUNCTION__, (int) index, find_slop(x, y, rx, ry));\n        SkDebugf(\"%s rxy %d=%d\\n\", __FUNCTION__, (int) index, find_slop(rx, ry, x, y));\n        double angle = diamond_angle(y, x);\n        double rAngle = diamond_angle(ry, rx);\n        double diff = fabs(angle - rAngle);\n        SkDebugf(\"%s diamond xy=%1.9g rxy=%1.9g diff=%1.9g factor=%d\\n\", __FUNCTION__,\n                angle, rAngle, diff, (int) (diff / FLT_EPSILON));\n\n    }\n}\n#endif\n\n#include \"TestClassDef.h\"\nDEFINE_TESTCLASS_SHORT(PathOpsAngleTest)\n\nDEFINE_TESTCLASS_SHORT(PathOpsAngleTestOne)\n\n// DEFINE_TESTCLASS_SHORT(PathOpsAngleFindSlop)\n"}
{"repo_name":"attilahorvath/phantomjs","ref":"refs/heads/master","path":"src/qt/qtwebkit/Source/JavaScriptCore/llint/LLIntEntrypoints.cpp","copies":"118","language":"C++","content":"/*\n * Copyright (C) 2012 Apple Inc. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. \n */\n\n#include \"config.h\"\n#include \"LLIntEntrypoints.h\"\n\n#if ENABLE(LLINT)\n\n#include \"JITCode.h\"\n#include \"VM.h\"\n#include \"JSObject.h\"\n#include \"LLIntThunks.h\"\n#include \"LowLevelInterpreter.h\"\n\n\nnamespace JSC { namespace LLInt {\n\nvoid getFunctionEntrypoint(VM\u0026 vm, CodeSpecializationKind kind, JITCode\u0026 jitCode, MacroAssemblerCodePtr\u0026 arityCheck)\n{\n    if (!vm.canUseJIT()) {\n        if (kind == CodeForCall) {\n            jitCode = JITCode(MacroAssemblerCodeRef::createLLIntCodeRef(llint_function_for_call_prologue), JITCode::InterpreterThunk);\n            arityCheck = MacroAssemblerCodePtr::createLLIntCodePtr(llint_function_for_call_arity_check);\n            return;\n        }\n\n        ASSERT(kind == CodeForConstruct);\n        jitCode = JITCode(MacroAssemblerCodeRef::createLLIntCodeRef(llint_function_for_construct_prologue), JITCode::InterpreterThunk);\n        arityCheck = MacroAssemblerCodePtr::createLLIntCodePtr(llint_function_for_construct_arity_check);\n        return;\n    }\n    \n#if ENABLE(JIT)\n    if (kind == CodeForCall) {\n        jitCode = JITCode(vm.getCTIStub(functionForCallEntryThunkGenerator), JITCode::InterpreterThunk);\n        arityCheck = vm.getCTIStub(functionForCallArityCheckThunkGenerator).code();\n        return;\n    }\n\n    ASSERT(kind == CodeForConstruct);\n    jitCode = JITCode(vm.getCTIStub(functionForConstructEntryThunkGenerator), JITCode::InterpreterThunk);\n    arityCheck = vm.getCTIStub(functionForConstructArityCheckThunkGenerator).code();\n#endif // ENABLE(JIT)\n}\n\nvoid getEvalEntrypoint(VM\u0026 vm, JITCode\u0026 jitCode)\n{\n    if (!vm.canUseJIT()) {\n        jitCode = JITCode(MacroAssemblerCodeRef::createLLIntCodeRef(llint_eval_prologue), JITCode::InterpreterThunk);\n        return;\n    }\n#if ENABLE(JIT)    \n    jitCode = JITCode(vm.getCTIStub(evalEntryThunkGenerator), JITCode::InterpreterThunk);\n#endif\n}\n\nvoid getProgramEntrypoint(VM\u0026 vm, JITCode\u0026 jitCode)\n{\n    if (!vm.canUseJIT()) {\n        jitCode = JITCode(MacroAssemblerCodeRef::createLLIntCodeRef(llint_program_prologue), JITCode::InterpreterThunk);\n        return;\n    }\n#if ENABLE(JIT)\n    jitCode = JITCode(vm.getCTIStub(programEntryThunkGenerator), JITCode::InterpreterThunk);\n#endif\n}\n\n} } // namespace JSC::LLInt\n\n#endif // ENABLE(LLINT)\n"}
{"repo_name":"cppisfun/GameEngine","ref":"refs/heads/master","path":"foreign/boost/libs/multi_array/example/subview2.cpp","copies":"10","language":"C++","content":"// Copyright 2002 The Trustees of Indiana University.\r\n\r\n// Use, modification and distribution is subject to the Boost Software \r\n// License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at\r\n// http://www.boost.org/LICENSE_1_0.txt)\r\n\r\n//  Boost.MultiArray Library\r\n//  Authors: Ronald Garcia\r\n//           Jeremy Siek\r\n//           Andrew Lumsdaine\r\n//  See http://www.boost.org/libs/multi_array for documentation.\r\n\r\n\r\n#include \"boost/multi_array.hpp\"\r\n#include \"boost/cstdlib.hpp\"\r\n\r\nint\r\nmain()\r\n{\r\n  using boost::extents;\r\n  using boost::indices;\r\n  typedef boost::multi_array\u003cint,3\u003e array;\r\n\r\n  int data[] = {\r\n    0,1,2,3,\r\n    4,5,6,7,\r\n    8,9,10,11,\r\n\r\n    12,13,14,15,\r\n    16,17,18,19,\r\n    20,21,22,23\r\n  };\r\n  const int data_size=24;\r\n\r\n  array myarray(extents[2][3][4]);\r\n  myarray.assign(data,data+data_size);\r\n\r\n  //\r\n  // array_view dims:\r\n  // [base,stride,bound)\r\n  // [0,1,2), [1,1,3), [0,2,4) \r\n  // \r\n\r\n  typedef boost::multi_array_types::index_range range;\r\n  array::array_view\u003c3\u003e::type myview =\r\n    myarray[indices[range(0,2)][range(1,3)][range(0,4,2)]];\r\n\r\n  for (array::index i = 0; i != 2; ++i)\r\n    for (array::index j = 0; j != 2; ++j)\r\n      for (array::index k = 0; k != 2; ++k) \r\n        assert(myview[i][j][k] == myarray[i][j+1][k*2]);\r\n\r\n  return boost::exit_success;\r\n}\r\n"}
{"repo_name":"EdisonCodeKeeper/hacker-rank","ref":"refs/heads/master","path":"practice/mathematics/geometry/meeting-point/meeting-point.cpp","copies":"3","language":"C++","content":"#include \u003ciostream\u003e\n#include \u003cvector\u003e\n#include \u003calgorithm\u003e\n\nusing namespace std;\n\n#define M 100\n\nbool pair_compare(const pair\u003cint, long long\u003e \u0026a, const pair\u003cint, long long\u003e \u0026b) {\n    return a.second == b.second ? a.first \u003c b.first : a.second \u003c b.second;\n}\n\nint main() {\n    int N;\n    cin \u003e\u003e N;\n    vector\u003cpair\u003clong long, long long\u003e \u003e pos;\n    long long avg_x = 0, avg_y = 0;\n    for (int i = 0; i \u003c N; ++i) {\n        int x, y;\n        cin \u003e\u003e x \u003e\u003e y;\n        pos.push_back(make_pair(x, y));\n        avg_x += x;\n        avg_y += y;\n    }\n    avg_x /= N, avg_y /= N;\n    vector\u003cpair\u003cint, long long\u003e \u003e ans;\n    for (int i = 0; i \u003c N; ++i) {\n        long long dis = max(abs(pos[i].first - avg_x), abs(pos[i].second - avg_y));\n        ans.push_back(make_pair(i, dis));\n    }\n    sort(ans.begin(), ans.end(), pair_compare);\n    long long ret = 1e16;\n    for (int i = 0; i \u003c min(M, int(ans.size())); ++i) {\n        long long tmp = 0;\n        for (int j = 0; j \u003c N; ++j)\n            tmp += max(abs(pos[j].first - pos[ans[i].first].first), abs(pos[j].second - pos[ans[i].first].second));\n        ret = min(ret, tmp);\n    }\n    cout \u003c\u003c ret \u003c\u003c endl;\n    return 0;\n}\n"}
{"repo_name":"GreenDamTan/ppsspp","ref":"refs/heads/master","path":"Core/MIPS/x86/Asm.cpp","copies":"19","language":"C++","content":"// Copyright (C) 2003 Dolphin Project.\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, version 2.0 or later versions.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\tSee the\n// GNU General Public License 2.0 for more details.\n\n// A copy of the GPL 2.0 should have been included with the program.\n// If not, see http://www.gnu.org/licenses/\n\n// Official SVN repository and contact information can be found at\n// http://code.google.com/p/dolphin-emu/\n\n#include \"math/math_util.h\"\n\n#include \"ABI.h\"\n#include \"x64Emitter.h\"\n\n#include \"Core/Core.h\"\n#include \"Core/MemMap.h\"\n#include \"Core/System.h\"\n#include \"Core/MIPS/MIPS.h\"\n#include \"Core/CoreTiming.h\"\n#include \"Common/MemoryUtil.h\"\n\n#include \"Core/MIPS/JitCommon/JitCommon.h\"\n#include \"Core/MIPS/x86/Asm.h\"\n#include \"Core/MIPS/x86/Jit.h\"\n\nusing namespace Gen;\nusing namespace X64JitConstants;\n\n//TODO - make an option\n//#if _DEBUG\nstatic bool enableDebug = false; \n//#else\n//\t\tbool enableDebug = false; \n//#endif\n\n//static bool enableStatistics = false; //unused?\n\n//GLOBAL STATIC ALLOCATIONS x86\n//EAX - ubiquitous scratch register - EVERYBODY scratches this\n//EBP - Pointer to fpr/gpr regs\n\n//GLOBAL STATIC ALLOCATIONS x64\n//EAX - ubiquitous scratch register - EVERYBODY scratches this\n//RBX - Base pointer of memory\n//R14 - Pointer to fpr/gpr regs\n//R15 - Pointer to array of block pointers\n\nextern volatile CoreState coreState;\n\nvoid ImHere()\n{\n\tDEBUG_LOG(CPU, \"JIT Here: %08x\", currentMIPS-\u003epc);\n}\n\nvoid AsmRoutineManager::Generate(MIPSState *mips, MIPSComp::Jit *jit, MIPSComp::JitOptions *jo)\n{\n\tenterCode = AlignCode16();\n\tABI_PushAllCalleeSavedRegsAndAdjustStack();\n#ifdef _M_X64\n\t// Two statically allocated registers.\n\tMOV(64, R(MEMBASEREG), ImmPtr(Memory::base));\n\tuintptr_t jitbase = (uintptr_t)jit-\u003eGetBasePtr();\n\tif (jitbase \u003e 0x7FFFFFFFULL)\n\t{\n\t\tMOV(64, R(JITBASEREG), ImmPtr(jit-\u003eGetBasePtr()));\n\t\tjo-\u003ereserveR15ForAsm = true;\n\t}\n#endif\n\t// From the start of the FP reg, a single byte offset can reach all GPR + all FPR (but no VFPUR)\n\tMOV(PTRBITS, R(CTXREG), ImmPtr(\u0026mips-\u003ef[0]));\n\n\touterLoop = GetCodePtr();\n\t\tjit-\u003eRestoreRoundingMode(true, this);\n\t\tABI_CallFunction(reinterpret_cast\u003cvoid *\u003e(\u0026CoreTiming::Advance));\n\t\tjit-\u003eApplyRoundingMode(true, this);\n\t\tFixupBranch skipToRealDispatch = J(); //skip the sync and compare first time\n\n\t\tdispatcherCheckCoreState = GetCodePtr();\n\n\t\t// The result of slice decrementation should be in flags if somebody jumped here\n\t\t// IMPORTANT - We jump on negative, not carry!!!\n\t\tFixupBranch bailCoreState = J_CC(CC_S, true);\n\n\t\tCMP(32, M(\u0026coreState), Imm32(0));\n\t\tFixupBranch badCoreState = J_CC(CC_NZ, true);\n\t\tFixupBranch skipToRealDispatch2 = J(); //skip the sync and compare first time\n\n\t\tdispatcher = GetCodePtr();\n\n\t\t\t// The result of slice decrementation should be in flags if somebody jumped here\n\t\t\t// IMPORTANT - We jump on negative, not carry!!!\n\t\t\tFixupBranch bail = J_CC(CC_S, true);\n\n\t\t\tSetJumpTarget(skipToRealDispatch);\n\t\t\tSetJumpTarget(skipToRealDispatch2);\n\n\t\t\tdispatcherNoCheck = GetCodePtr();\n\n\t\t\tMOV(32, R(EAX), M(\u0026mips-\u003epc));\n\t\t\tdispatcherInEAXNoCheck = GetCodePtr();\n\n#ifdef _M_IX86\n\t\t\tAND(32, R(EAX), Imm32(Memory::MEMVIEW32_MASK));\n\t\t\t_assert_msg_(CPU, Memory::base != 0, \"Memory base bogus\");\n\t\t\tMOV(32, R(EAX), MDisp(EAX, (u32)Memory::base));\n#elif _M_X64\n\t\t\tMOV(32, R(EAX), MComplex(MEMBASEREG, RAX, SCALE_1, 0));\n#endif\n\t\t\tMOV(32, R(EDX), R(EAX));\n\t\t\t_assert_msg_(JIT, MIPS_JITBLOCK_MASK == 0xFF000000, \"Hardcoded assumption of emuhack mask\");\n\t\t\tSHR(32, R(EDX), Imm8(24));\n\t\t\tCMP(32, R(EDX), Imm8(MIPS_EMUHACK_OPCODE \u003e\u003e 24));\n\t\t\tFixupBranch notfound = J_CC(CC_NE);\n\t\t\t\tif (enableDebug)\n\t\t\t\t{\n\t\t\t\t\tADD(32, M(\u0026mips-\u003edebugCount), Imm8(1));\n\t\t\t\t}\n\t\t\t\t//grab from list and jump to it\n\t\t\t\tAND(32, R(EAX), Imm32(MIPS_EMUHACK_VALUE_MASK));\n#ifdef _M_IX86\n\t\t\t\tADD(32, R(EAX), ImmPtr(jit-\u003eGetBasePtr()));\n#elif _M_X64\n\t\t\t\tif (jo-\u003ereserveR15ForAsm)\n\t\t\t\t\tADD(64, R(RAX), R(JITBASEREG));\n\t\t\t\telse\n\t\t\t\t\tADD(64, R(EAX), Imm32(jitbase));\n#endif\n\t\t\t\tJMPptr(R(EAX));\n\t\t\tSetJumpTarget(notfound);\n\n\t\t\t//Ok, no block, let's jit\n\t\t\tjit-\u003eRestoreRoundingMode(true, this);\n\t\t\tABI_CallFunction(\u0026MIPSComp::JitAt);\n\t\t\tjit-\u003eApplyRoundingMode(true, this);\n\t\t\tJMP(dispatcherNoCheck, true); // Let's just dispatch again, we'll enter the block since we know it's there.\n\n\t\tSetJumpTarget(bail);\n\t\tSetJumpTarget(bailCoreState);\n\n\t\tCMP(32, M(\u0026coreState), Imm32(0));\n\t\tJ_CC(CC_Z, outerLoop, true);\n\n\tSetJumpTarget(badCoreState);\n\tjit-\u003eRestoreRoundingMode(true, this);\n\tABI_PopAllCalleeSavedRegsAndAdjustStack();\n\tRET();\n\n\tbreakpointBailout = GetCodePtr();\n\tjit-\u003eRestoreRoundingMode(true, this);\n\tABI_PopAllCalleeSavedRegsAndAdjustStack();\n\tRET();\n}\n"}
{"repo_name":"rexim/beatwave","ref":"refs/heads/master","path":"test/core/testanimated.cpp","copies":"1","language":"C++","content":"#define CATCH_CONFIG_MAIN\n#include \u003ccatch.hpp\u003e\n#include \u003ccore/animated.hpp\u003e\n\nTEST_CASE(\"Animating object with nullptr should not crash the app\", \"[animated]\") {\n    Animated\u003cint\u003e x(10);\n    x.animate(nullptr);\n}\n"}
{"repo_name":"h0tw1r3/mame","ref":"refs/heads/master","path":"src/mame/video/mikromik.cpp","copies":"9","language":"C++","content":"// license:BSD-3-Clause\n// copyright-holders:Curt Coder\n#include \"includes/mikromik.h\"\n\n#define HORIZONTAL_CHARACTER_PIXELS 10\n\n//-------------------------------------------------\n//  i8275 crtc display pixels\n//-------------------------------------------------\n\nI8275_DRAW_CHARACTER_MEMBER( mm1_state::crtc_display_pixels )\n{\n\tUINT8 romdata = m_char_rom-\u003ebase()[(charcode \u003c\u003c 4) | linecount];\n\n\tint gpa0 = BIT(gpa, 0);     // general purpose attribute 0\n\tint llen = m_llen;          // light enable\n\tint compl_in = rvv;         // reverse video\n\tint hlt_in = hlgt;          // highlight;\n\tint color;                  // 0 = black, 1 = dk green, 2 = lt green; on MikroMikko 1, \"highlight\" is actually the darker shade of green\n\tint i, qh, video_in;\n\n\tint d7 = BIT(romdata, 7);   // save MSB (1 indicates that this is a Visual Attribute or Special Code instead of a normal display character)\n\tint d6 = BIT(romdata, 6);   // save also first and last char bitmap bits before shifting out the MSB\n\tint d0 = BIT(romdata, 0);\n\tUINT8 data = (romdata \u003c\u003c 1) | (d7 \u0026 d0); // get rid of MSB, duplicate LSB for special characters\n\n\tif (y \u003c 360 || x \u003e= HORIZONTAL_CHARACTER_PIXELS || compl_in == 0) // leftmost char on the 25th row is never displayed on actual MikroMikko 1 HW if it's inversed\n\t{\n\t\tif (HORIZONTAL_CHARACTER_PIXELS == 10)\n\t\t{\n\t\t\t// Hack to stretch 8 pixels wide character bitmap to 10 pixels on screen.\n\t\t\t// This was needed because high res graphics use 800 pixels wide bitmap but\n\t\t\t// 80 chars * 8 pixels is only 640 -\u003e characters would cover only 80% of the screen width.\n\t\t\t// Step 1: Instead of 8, set MCFG_I8275_CHARACTER_WIDTH(10) at the end of this file\n\t\t\t// Step 2: Make sure i8275_device::recompute_parameters() is called in i8275_device::device_start()\n\t\t\t// Step 3: Fill in missing 2 pixels in the screen bitmap by repeating last column of the char bitmap\n\t\t\t// (works better with MikroMikko 1 font than duplicating the first and the last column)\n\t\t\tqh = d7 \u0026 d6; // extend pixels on the right side only if there were two adjacent ones before shifting out the MSB\n\t\t\tvideo_in = ((((d7 \u0026 llen) | (vsp ? 0 : 1)) \u0026 (gpa0 ? 0 : 1)) \u0026 qh) | lten;\n\t\t\tcolor = (hlt_in ? 1 : 2) * (video_in ^ compl_in);\n\t\t\tbitmap.pix32(y, x + 8) = m_palette-\u003epen(color);\n\t\t\tbitmap.pix32(y, x + 9) = m_palette-\u003epen(color);\n\t\t}\n\n\t\tfor (i = 0; i \u003c 8; ++i) // ...and now the actual character bitmap bits for this scanline\n\t\t{\n\t\t\tqh = BIT(data, i);\n\t\t\tvideo_in = ((((d7 \u0026 llen) | (vsp ? 0 : 1)) \u0026 (gpa0 ? 0 : 1)) \u0026 qh) | lten;\n\t\t\tcolor = (hlt_in ? 1 : 2)*(video_in ^ compl_in);\n\t\t\tbitmap.pix32(y, x + i) = m_palette-\u003epen(color);\n\t\t}\n\t}\n}\n\n\n//-------------------------------------------------\n//  ADDRESS_MAP( mm1_upd7220_map )\n//-------------------------------------------------\n\nstatic ADDRESS_MAP_START( mm1_upd7220_map, AS_0, 16, mm1_state )\n\tADDRESS_MAP_GLOBAL_MASK(0x7fff)\n\tAM_RANGE(0x0000, 0x7fff) AM_RAM AM_SHARE(\"video_ram\")\nADDRESS_MAP_END\n\n\n//-------------------------------------------------\n//  UPD7220_INTERFACE( hgdc_intf )\n//-------------------------------------------------\n\nUPD7220_DISPLAY_PIXELS_MEMBER( mm1_state::hgdc_display_pixels )\n{\n\tUINT16 data = m_video_ram[address \u003e\u003e 1];\n\tfor (int i = 0; i \u003c 16; i++)\n\t{\n\t\tif (BIT(data, i)) bitmap.pix32(y, x + i) = m_palette-\u003epen(2);\n\t}\n}\n\n\nUINT32 mm1_state::screen_update(screen_device \u0026screen, bitmap_rgb32 \u0026bitmap, const rectangle \u0026cliprect)\n{\n\t/* text */\n\tm_crtc-\u003escreen_update(screen, bitmap, cliprect);\n\n\t/* graphics */\n\tm_hgdc-\u003escreen_update(screen, bitmap, cliprect);\n\n\treturn 0;\n}\n\n\n//-------------------------------------------------\n//  gfx_layout charlayout\n//-------------------------------------------------\n\nstatic const gfx_layout charlayout =\n{\n\t8, 16,\n\tRGN_FRAC(1,1),\n\t1,\n\t{ 0 },\n\t{ 7, 6, 5, 4, 3, 2, 1, 0 },\n\t{  0*8,  1*8,  2*8,  3*8,  4*8,  5*8,  6*8,  7*8,\n\t\t8*8,  9*8, 10*8, 11*8, 12*8, 13*8, 14*8, 15*8 },\n\t8*16\n};\n\n\n//-------------------------------------------------\n//  GFXDECODE( mm1 )\n//-------------------------------------------------\n\nstatic GFXDECODE_START( mm1 )\n\tGFXDECODE_ENTRY( \"chargen\", 0, charlayout, 0, 1 )\nGFXDECODE_END\n\nPALETTE_INIT_MEMBER( mm1_state, mm1 )\n{\n\tpalette.set_pen_color(0, rgb_t(0x00,0x00,0x00));\n\tpalette.set_pen_color(1, rgb_t(0x00,0x7F,0x0A)); // dark green (\"highlight\" mode color)\n\tpalette.set_pen_color(2, rgb_t(0x08,0xD0,0x1A)); // bright green (normal color)\n}\n\n\n//-------------------------------------------------\n//  MACHINE_CONFIG_FRAGMENT( mm1m6_video )\n//-------------------------------------------------\n\nMACHINE_CONFIG_FRAGMENT( mm1m6_video )\n\tMCFG_SCREEN_ADD( SCREEN_TAG, RASTER )\n\tMCFG_SCREEN_REFRESH_RATE( 50 )\n\tMCFG_SCREEN_UPDATE_DRIVER(mm1_state, screen_update)\n\tMCFG_SCREEN_SIZE( 800, 375 ) // (25 text rows * 15 vertical pixels / character)\n\tMCFG_SCREEN_VISIBLE_AREA( 0, 800-1, 0, 375-1 )\n\t//MCFG_SCREEN_RAW_PARAMS(XTAL_18_720MHz, ...)\n\n\tMCFG_GFXDECODE_ADD(\"gfxdecode\", \"palette\", mm1)\n\tMCFG_PALETTE_ADD(\"palette\", 3)\n\tMCFG_PALETTE_INIT_OWNER(mm1_state, mm1)\n\n\tMCFG_DEVICE_ADD(I8275_TAG, I8275, XTAL_18_720MHz/8)\n\tMCFG_I8275_CHARACTER_WIDTH(HORIZONTAL_CHARACTER_PIXELS)\n\tMCFG_I8275_DRAW_CHARACTER_CALLBACK_OWNER(mm1_state, crtc_display_pixels)\n\tMCFG_I8275_DRQ_CALLBACK(DEVWRITELINE(I8237_TAG, am9517a_device, dreq0_w))\n\tMCFG_I8275_VRTC_CALLBACK(DEVWRITELINE(UPD7220_TAG, upd7220_device, ext_sync_w))\n\tMCFG_VIDEO_SET_SCREEN(SCREEN_TAG)\n\n\tMCFG_DEVICE_ADD(UPD7220_TAG, UPD7220, XTAL_18_720MHz/8)\n\tMCFG_DEVICE_ADDRESS_MAP(AS_0, mm1_upd7220_map)\n\tMCFG_UPD7220_DISPLAY_PIXELS_CALLBACK_OWNER(mm1_state, hgdc_display_pixels)\n\tMCFG_VIDEO_SET_SCREEN(SCREEN_TAG)\nMACHINE_CONFIG_END\n"}
{"repo_name":"deadcoda/arg3db","ref":"refs/heads/master","path":"src/sqlite/resultset.cpp","copies":"4","language":"C++","content":"#include \"resultset.h\"\n#include \"../exception.h\"\n#include \"row.h\"\n#include \"session.h\"\n\nusing namespace std;\n\nnamespace coda\n{\n    namespace db\n    {\n        namespace sqlite\n        {\n            resultset::resultset(const std::shared_ptr\u003csqlite::session\u003e \u0026sess, const shared_ptr\u003csqlite3_stmt\u003e \u0026stmt)\n                : stmt_(stmt), sess_(sess), status_(-1)\n            {\n                if (sess_ == nullptr) {\n                    throw database_exception(\"No database provided to sqlite3 resultset\");\n                }\n\n                if (stmt_ == nullptr) {\n                    throw database_exception(\"no statement provided to sqlite3 resultset\");\n                }\n            }\n\n            resultset::resultset(resultset \u0026\u0026other)\n                : stmt_(std::move(other.stmt_)), sess_(std::move(other.sess_)), status_(other.status_)\n            {\n                other.sess_ = nullptr;\n                other.stmt_ = nullptr;\n            }\n\n            resultset::~resultset()\n            {\n            }\n\n            resultset \u0026resultset::operator=(resultset \u0026\u0026other)\n            {\n                stmt_ = std::move(other.stmt_);\n                sess_ = std::move(other.sess_);\n                status_ = other.status_;\n                other.sess_ = nullptr;\n                other.stmt_ = nullptr;\n\n                return *this;\n            }\n\n            bool resultset::is_valid() const noexcept\n            {\n                return stmt_ != nullptr \u0026\u0026 stmt_;\n            }\n\n            bool resultset::next()\n            {\n                if (!is_valid()) {\n                    return false;\n                }\n\n                if (status_ == SQLITE_DONE) {\n                    return false;\n                }\n\n                status_ = sqlite3_step(stmt_.get());\n\n                return status_ == SQLITE_ROW;\n            }\n\n            void resultset::reset()\n            {\n                if (!is_valid()) {\n                    //resultset::reset database not open\n                    return;\n                }\n\n                if (sqlite3_reset(stmt_.get()) != SQLITE_OK) {\n                    throw database_exception(sess_-\u003elast_error());\n                }\n                status_ = -1;\n            }\n\n            resultset::row_type resultset::current_row()\n            {\n                return row_type(make_shared\u003crow\u003e(sess_, stmt_));\n            }\n        }\n    }\n}\n"}
{"repo_name":"fbergmann/libSEDML","ref":"refs/heads/master","path":"sedml/SedDocument.cpp","copies":"2","language":"C++","content":"/**\n * @file:   SedDocument.cpp\n * @brief:  Implementation of the SedDocument class\n * @author: Frank T. Bergmann\n *\n * \u003c!--------------------------------------------------------------------------\n * This file is part of libSEDML.  Please visit http://sed-ml.org for more\n * information about SED-ML. The latest version of libSEDML can be found on\n * github: https://github.com/fbergmann/libSEDML/\n *\n * Copyright (c) 2013-2016, Frank T. Bergmann\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n * ------------------------------------------------------------------------ --\u003e\n */\n\n\n#include \u003csedml/SedDocument.h\u003e\n#include \u003csedml/SedTypes.h\u003e\n#include \u003csbml/xml/XMLInputStream.h\u003e\n\n\nusing namespace std;\n\n\nLIBSEDML_CPP_NAMESPACE_BEGIN\n\n\n/*\n * Creates a new SedDocument with the given level, version, and package version.\n */\nSedDocument::SedDocument(unsigned int level, unsigned int version)\n  : SedBase(level, version)\n  , mLevel(SEDML_INT_MAX)\n  , mIsSetLevel(false)\n  , mVersion(SEDML_INT_MAX)\n  , mIsSetVersion(false)\n  , mDataDescriptions(level, version)\n  , mSimulations(level, version)\n  , mModels(level, version)\n  , mTasks(level, version)\n  , mDataGenerators(level, version)\n  , mOutputs(level, version)\n\n{\n  mLevel = level;\n  mIsSetLevel = true;\n  mVersion = version;\n  mIsSetVersion = true;\n\n  setSedDocument(this);\n\n  // set an SedNamespaces derived object of this package\n  setSedNamespacesAndOwn(new SedNamespaces(level, version));\n\n  // connect to child objects\n  connectToChild();\n}\n\n\n/*\n * Creates a new SedDocument with the given SedNamespaces object.\n */\nSedDocument::SedDocument(SedNamespaces* sedns)\n  : SedBase(sedns)\n  , mLevel(SEDML_INT_MAX)\n  , mIsSetLevel(false)\n  , mVersion(SEDML_INT_MAX)\n  , mIsSetVersion(false)\n  , mDataDescriptions(sedns)\n  , mSimulations(sedns)\n  , mModels(sedns)\n  , mTasks(sedns)\n  , mDataGenerators(sedns)\n  , mOutputs(sedns)\n\n{\n  mLevel = sedns-\u003egetLevel();\n  mIsSetLevel = true;\n  mVersion = sedns-\u003egetVersion();\n  mIsSetVersion = true;\n\n  setSedDocument(this);\n\n  // set the element namespace of this object\n  setElementNamespace(sedns-\u003egetURI());\n\n  // connect to child objects\n  connectToChild();\n}\n\n\n/*\n * Copy constructor for SedDocument.\n */\nSedDocument::SedDocument(const SedDocument\u0026 orig)\n  : SedBase(orig)\n{\n  setSedDocument(this);\n\n  mLevel  = orig.mLevel;\n  mIsSetLevel  = orig.mIsSetLevel;\n  mVersion  = orig.mVersion;\n  mIsSetVersion  = orig.mIsSetVersion;\n  mDataDescriptions  = orig.mDataDescriptions;\n  mSimulations  = orig.mSimulations;\n  mModels  = orig.mModels;\n  mTasks  = orig.mTasks;\n  mDataGenerators  = orig.mDataGenerators;\n  mOutputs  = orig.mOutputs;\n\n  // connect to child objects\n  connectToChild();\n}\n\n\n/*\n * Assignment for SedDocument.\n */\nSedDocument\u0026\nSedDocument::operator=(const SedDocument\u0026 rhs)\n{\n  if (\u0026rhs != this)\n    {\n      SedBase::operator=(rhs);\n\n      setSedDocument(this);\n\n      mLevel  = rhs.mLevel;\n      mIsSetLevel  = rhs.mIsSetLevel;\n      mVersion  = rhs.mVersion;\n      mIsSetVersion  = rhs.mIsSetVersion;\n      mDataDescriptions  = rhs.mDataDescriptions;\n      mSimulations  = rhs.mSimulations;\n      mModels  = rhs.mModels;\n      mTasks  = rhs.mTasks;\n      mDataGenerators  = rhs.mDataGenerators;\n      mOutputs  = rhs.mOutputs;\n\n      // connect to child objects\n      connectToChild();\n    }\n\n  return *this;\n}\n\n\n/*\n * Clone for SedDocument.\n */\nSedDocument*\nSedDocument::clone() const\n{\n  return new SedDocument(*this);\n}\n\n\n/*\n * Destructor for SedDocument.\n */\nSedDocument::~SedDocument()\n{\n}\n\n\n/*\n * Returns the value of the \"level\" attribute of this SedDocument.\n */\nconst int\nSedDocument::getLevel() const\n{\n  return mLevel;\n}\n\n\n/*\n * Returns the value of the \"version\" attribute of this SedDocument.\n */\nconst int\nSedDocument::getVersion() const\n{\n  return mVersion;\n}\n\n\n/*\n * Returns true/false if level is set.\n */\nbool\nSedDocument::isSetLevel() const\n{\n  return mIsSetLevel;\n}\n\n\n/*\n * Returns true/false if version is set.\n */\nbool\nSedDocument::isSetVersion() const\n{\n  return mIsSetVersion;\n}\n\n\n/*\n * Sets level and returns value indicating success.\n */\nint\nSedDocument::setLevel(int level)\n{\n  mLevel = level;\n  mIsSetLevel = true;\n  return LIBSEDML_OPERATION_SUCCESS;\n}\n\n\n/*\n * Sets version and returns value indicating success.\n */\nint\nSedDocument::setVersion(int version)\n{\n  mVersion = version;\n  mIsSetVersion = true;\n  return LIBSEDML_OPERATION_SUCCESS;\n}\n\n\n/*\n * Unsets level and returns value indicating success.\n */\nint\nSedDocument::unsetLevel()\n{\n  mLevel = SEDML_INT_MAX;\n  mIsSetLevel = false;\n\n  if (isSetLevel() == false)\n    {\n      return LIBSEDML_OPERATION_SUCCESS;\n    }\n  else\n    {\n      return LIBSEDML_OPERATION_FAILED;\n    }\n}\n\n\n/*\n * Unsets version and returns value indicating success.\n */\nint\nSedDocument::unsetVersion()\n{\n  mVersion = SEDML_INT_MAX;\n  mIsSetVersion = false;\n\n  if (isSetVersion() == false)\n    {\n      return LIBSEDML_OPERATION_SUCCESS;\n    }\n  else\n    {\n      return LIBSEDML_OPERATION_FAILED;\n    }\n}\n\n\n/*\n * Returns the  \"SedListOfDataDescriptions\" in this SedDocument object.\n */\nconst SedListOfDataDescriptions*\nSedDocument::getListOfDataDescriptions() const\n{\n  return \u0026mDataDescriptions;\n}\n\n\n/*\n * Removes the nth DataDescription from the SedListOfDataDescriptions.\n */\nSedDataDescription*\nSedDocument::removeDataDescription(unsigned int n)\n{\n  return mDataDescriptions.remove(n);\n}\n\n\n/*\n * Removes the a DataDescription with given id from the SedListOfDataDescriptions.\n */\nSedDataDescription*\nSedDocument::removeDataDescription(const std::string\u0026 sid)\n{\n  return mDataDescriptions.remove(sid);\n}\n\n\n/*\n * Return the nth DataDescription in the SedListOfDataDescriptions within this SedDocument.\n */\nSedDataDescription*\nSedDocument::getDataDescription(unsigned int n)\n{\n  return mDataDescriptions.get(n);\n}\n\n\n/*\n * Return the nth DataDescription in the SedListOfDataDescriptions within this SedDocument.\n */\nconst SedDataDescription*\nSedDocument::getDataDescription(unsigned int n) const\n{\n  return mDataDescriptions.get(n);\n}\n\n\n/*\n * Return a DataDescription from the SedListOfDataDescriptions by id.\n */\nSedDataDescription*\nSedDocument::getDataDescription(const std::string\u0026 sid)\n{\n  return mDataDescriptions.get(sid);\n}\n\n\n/*\n * Return a DataDescription from the SedListOfDataDescriptions by id.\n */\nconst SedDataDescription*\nSedDocument::getDataDescription(const std::string\u0026 sid) const\n{\n  return mDataDescriptions.get(sid);\n}\n\n\n/**\n * Adds a copy the given \"SedDataDescription\" to this SedDocument.\n *\n * @param sdd; the SedDataDescription object to add\n *\n * @return integer value indicating success/failure of the\n * function.  @if clike The value is drawn from the\n * enumeration #OperationReturnValues_t. @endif The possible values\n * returned by this function are:\n * @li LIBSEDML_OPERATION_SUCCESS\n * @li LIBSEDML_INVALID_ATTRIBUTE_VALUE\n */\nint\nSedDocument::addDataDescription(const SedDataDescription* sdd)\n{\n  if (sdd == NULL) return LIBSEDML_INVALID_ATTRIBUTE_VALUE;\n\n  mDataDescriptions.append(sdd);\n  return LIBSEDML_OPERATION_SUCCESS;\n}\n\n\n/**\n * Get the number of SedDataDescription objects in this SedDocument.\n *\n * @return the number of SedDataDescription objects in this SedDocument\n */\nunsigned int\nSedDocument::getNumDataDescriptions() const\n{\n  return mDataDescriptions.size();\n}\n\n/**\n * Creates a new SedDataDescription object, adds it to this SedDocuments\n * SedDocument and returns the SedDataDescription object created.\n *\n * @return a new SedDataDescription object instance\n *\n * @see addSedDataDescription(const SedDataDescription* sdd)\n */\nSedDataDescription*\nSedDocument::createDataDescription()\n{\n  SedDataDescription *temp = new SedDataDescription();\n\n  if (temp != NULL) mDataDescriptions.appendAndOwn(temp);\n\n  return temp;\n}\n\n/*\n * Returns the  \"SedListOfSimulations\" in this SedDocument object.\n */\nconst SedListOfSimulations*\nSedDocument::getListOfSimulations() const\n{\n  return \u0026mSimulations;\n}\n\n\n/*\n * Removes the nth Simulation from the SedListOfSimulations.\n */\nSedSimulation*\nSedDocument::removeSimulation(unsigned int n)\n{\n  return mSimulations.remove(n);\n}\n\n\n/*\n * Removes the a Simulation with given id from the SedListOfSimulations.\n */\nSedSimulation*\nSedDocument::removeSimulation(const std::string\u0026 sid)\n{\n  return mSimulations.remove(sid);\n}\n\n\n/*\n * Return the nth Simulation in the SedListOfSimulations within this SedDocument.\n */\nSedSimulation*\nSedDocument::getSimulation(unsigned int n)\n{\n  return mSimulations.get(n);\n}\n\n\n/*\n * Return the nth Simulation in the SedListOfSimulations within this SedDocument.\n */\nconst SedSimulation*\nSedDocument::getSimulation(unsigned int n) const\n{\n  return mSimulations.get(n);\n}\n\n\n/*\n * Return a Simulation from the SedListOfSimulations by id.\n */\nSedSimulation*\nSedDocument::getSimulation(const std::string\u0026 sid)\n{\n  return mSimulations.get(sid);\n}\n\n\n/*\n * Return a Simulation from the SedListOfSimulations by id.\n */\nconst SedSimulation*\nSedDocument::getSimulation(const std::string\u0026 sid) const\n{\n  return mSimulations.get(sid);\n}\n\n\n/**\n * Adds a copy the given \"SedSimulation\" to this SedDocument.\n *\n * @param ss; the SedSimulation object to add\n *\n * @return integer value indicating success/failure of the\n * function.  @if clike The value is drawn from the\n * enumeration #OperationReturnValues_t. @endif The possible values\n * returned by this function are:\n * @li LIBSEDML_OPERATION_SUCCESS\n * @li LIBSEDML_INVALID_ATTRIBUTE_VALUE\n */\nint\nSedDocument::addSimulation(const SedSimulation* ss)\n{\n  if (ss == NULL) return LIBSEDML_INVALID_ATTRIBUTE_VALUE;\n\n  mSimulations.append(ss);\n  return LIBSEDML_OPERATION_SUCCESS;\n}\n\n\n/**\n * Get the number of SedSimulation objects in this SedDocument.\n *\n * @return the number of SedSimulation objects in this SedDocument\n */\nunsigned int\nSedDocument::getNumSimulations() const\n{\n  return mSimulations.size();\n}\n\n/**\n * Creates a new SedUniformTimeCourse object, adds it to this SedDocuments\n * SedDocument and returns the SedUniformTimeCourse object created.\n *\n * @return a new SedUniformTimeCourse object instance\n *\n * @see addUniformTimeCourse(const SedSimulation* ss)\n */\nSedUniformTimeCourse*\nSedDocument::createUniformTimeCourse()\n{\n  SedUniformTimeCourse *temp = new SedUniformTimeCourse();\n\n  if (temp != NULL) mSimulations.appendAndOwn(temp);\n\n  return temp;\n}\n\n/**\n * Creates a new SedOneStep object, adds it to this SedDocuments\n * SedDocument and returns the SedOneStep object created.\n *\n * @return a new SedOneStep object instance\n *\n * @see addOneStep(const SedSimulation* ss)\n */\nSedOneStep*\nSedDocument::createOneStep()\n{\n  SedOneStep *temp = new SedOneStep();\n\n  if (temp != NULL) mSimulations.appendAndOwn(temp);\n\n  return temp;\n}\n\n/**\n * Creates a new SedSteadyState object, adds it to this SedDocuments\n * SedDocument and returns the SedSteadyState object created.\n *\n * @return a new SedSteadyState object instance\n *\n * @see addSteadyState(const SedSimulation* ss)\n */\nSedSteadyState*\nSedDocument::createSteadyState()\n{\n  SedSteadyState *temp = new SedSteadyState();\n\n  if (temp != NULL) mSimulations.appendAndOwn(temp);\n\n  return temp;\n}\n\n/*\n * Returns the  \"SedListOfModels\" in this SedDocument object.\n */\nconst SedListOfModels*\nSedDocument::getListOfModels() const\n{\n  return \u0026mModels;\n}\n\n\n/*\n * Removes the nth Model from the SedListOfModels.\n */\nSedModel*\nSedDocument::removeModel(unsigned int n)\n{\n  return mModels.remove(n);\n}\n\n\n/*\n * Removes the a Model with given id from the SedListOfModels.\n */\nSedModel*\nSedDocument::removeModel(const std::string\u0026 sid)\n{\n  return mModels.remove(sid);\n}\n\n\n/*\n * Return the nth Model in the SedListOfModels within this SedDocument.\n */\nSedModel*\nSedDocument::getModel(unsigned int n)\n{\n  return mModels.get(n);\n}\n\n\n/*\n * Return the nth Model in the SedListOfModels within this SedDocument.\n */\nconst SedModel*\nSedDocument::getModel(unsigned int n) const\n{\n  return mModels.get(n);\n}\n\n\n/*\n * Return a Model from the SedListOfModels by id.\n */\nSedModel*\nSedDocument::getModel(const std::string\u0026 sid)\n{\n  return mModels.get(sid);\n}\n\n\n/*\n * Return a Model from the SedListOfModels by id.\n */\nconst SedModel*\nSedDocument::getModel(const std::string\u0026 sid) const\n{\n  return mModels.get(sid);\n}\n\n\n/**\n * Adds a copy the given \"SedModel\" to this SedDocument.\n *\n * @param sm; the SedModel object to add\n *\n * @return integer value indicating success/failure of the\n * function.  @if clike The value is drawn from the\n * enumeration #OperationReturnValues_t. @endif The possible values\n * returned by this function are:\n * @li LIBSEDML_OPERATION_SUCCESS\n * @li LIBSEDML_INVALID_ATTRIBUTE_VALUE\n */\nint\nSedDocument::addModel(const SedModel* sm)\n{\n  if (sm == NULL) return LIBSEDML_INVALID_ATTRIBUTE_VALUE;\n\n  mModels.append(sm);\n  return LIBSEDML_OPERATION_SUCCESS;\n}\n\n\n/**\n * Get the number of SedModel objects in this SedDocument.\n *\n * @return the number of SedModel objects in this SedDocument\n */\nunsigned int\nSedDocument::getNumModels() const\n{\n  return mModels.size();\n}\n\n/**\n * Creates a new SedModel object, adds it to this SedDocuments\n * SedDocument and returns the SedModel object created.\n *\n * @return a new SedModel object instance\n *\n * @see addSedModel(const SedModel* sm)\n */\nSedModel*\nSedDocument::createModel()\n{\n  SedModel *temp = new SedModel();\n\n  if (temp != NULL) mModels.appendAndOwn(temp);\n\n  return temp;\n}\n\n/*\n * Returns the  \"SedListOfTasks\" in this SedDocument object.\n */\nconst SedListOfTasks*\nSedDocument::getListOfTasks() const\n{\n  return \u0026mTasks;\n}\n\n\n/*\n * Removes the nth Task from the SedListOfTasks.\n */\nSedTask*\nSedDocument::removeTask(unsigned int n)\n{\n  return mTasks.remove(n);\n}\n\n\n/*\n * Removes the a Task with given id from the SedListOfTasks.\n */\nSedTask*\nSedDocument::removeTask(const std::string\u0026 sid)\n{\n  return mTasks.remove(sid);\n}\n\n\n/*\n * Return the nth Task in the SedListOfTasks within this SedDocument.\n */\nSedTask*\nSedDocument::getTask(unsigned int n)\n{\n  return mTasks.get(n);\n}\n\n\n/*\n * Return the nth Task in the SedListOfTasks within this SedDocument.\n */\nconst SedTask*\nSedDocument::getTask(unsigned int n) const\n{\n  return mTasks.get(n);\n}\n\n\n/*\n * Return a Task from the SedListOfTasks by id.\n */\nSedTask*\nSedDocument::getTask(const std::string\u0026 sid)\n{\n  return mTasks.get(sid);\n}\n\n\n/*\n * Return a Task from the SedListOfTasks by id.\n */\nconst SedTask*\nSedDocument::getTask(const std::string\u0026 sid) const\n{\n  return mTasks.get(sid);\n}\n\n\n/**\n * Adds a copy the given \"SedTask\" to this SedDocument.\n *\n * @param st; the SedTask object to add\n *\n * @return integer value indicating success/failure of the\n * function.  @if clike The value is drawn from the\n * enumeration #OperationReturnValues_t. @endif The possible values\n * returned by this function are:\n * @li LIBSEDML_OPERATION_SUCCESS\n * @li LIBSEDML_INVALID_ATTRIBUTE_VALUE\n */\nint\nSedDocument::addTask(const SedTask* st)\n{\n  if (st == NULL) return LIBSEDML_INVALID_ATTRIBUTE_VALUE;\n\n  mTasks.append(st);\n  return LIBSEDML_OPERATION_SUCCESS;\n}\n\n\n/**\n * Get the number of SedTask objects in this SedDocument.\n *\n * @return the number of SedTask objects in this SedDocument\n */\nunsigned int\nSedDocument::getNumTasks() const\n{\n  return mTasks.size();\n}\n\n/**\n * Creates a new SedTask object, adds it to this SedDocuments\n * SedDocument and returns the SedTask object created.\n *\n * @return a new SedTask object instance\n *\n * @see addTask(const SedTask* st)\n */\nSedTask*\nSedDocument::createTask()\n{\n  SedTask *temp = new SedTask();\n\n  if (temp != NULL) mTasks.appendAndOwn(temp);\n\n  return temp;\n}\n\n/**\n * Creates a new SedRepeatedTask object, adds it to this SedDocuments\n * SedDocument and returns the SedRepeatedTask object created.\n *\n * @return a new SedRepeatedTask object instance\n *\n * @see addRepeatedTask(const SedTask* st)\n */\nSedRepeatedTask*\nSedDocument::createRepeatedTask()\n{\n  SedRepeatedTask *temp = new SedRepeatedTask();\n\n  if (temp != NULL) mTasks.appendAndOwn(temp);\n\n  return temp;\n}\n\n/*\n * Returns the  \"SedListOfDataGenerators\" in this SedDocument object.\n */\nconst SedListOfDataGenerators*\nSedDocument::getListOfDataGenerators() const\n{\n  return \u0026mDataGenerators;\n}\n\n\n/*\n * Removes the nth DataGenerator from the SedListOfDataGenerators.\n */\nSedDataGenerator*\nSedDocument::removeDataGenerator(unsigned int n)\n{\n  return mDataGenerators.remove(n);\n}\n\n\n/*\n * Removes the a DataGenerator with given id from the SedListOfDataGenerators.\n */\nSedDataGenerator*\nSedDocument::removeDataGenerator(const std::string\u0026 sid)\n{\n  return mDataGenerators.remove(sid);\n}\n\n\n/*\n * Return the nth DataGenerator in the SedListOfDataGenerators within this SedDocument.\n */\nSedDataGenerator*\nSedDocument::getDataGenerator(unsigned int n)\n{\n  return mDataGenerators.get(n);\n}\n\n\n/*\n * Return the nth DataGenerator in the SedListOfDataGenerators within this SedDocument.\n */\nconst SedDataGenerator*\nSedDocument::getDataGenerator(unsigned int n) const\n{\n  return mDataGenerators.get(n);\n}\n\n\n/*\n * Return a DataGenerator from the SedListOfDataGenerators by id.\n */\nSedDataGenerator*\nSedDocument::getDataGenerator(const std::string\u0026 sid)\n{\n  return mDataGenerators.get(sid);\n}\n\n\n/*\n * Return a DataGenerator from the SedListOfDataGenerators by id.\n */\nconst SedDataGenerator*\nSedDocument::getDataGenerator(const std::string\u0026 sid) const\n{\n  return mDataGenerators.get(sid);\n}\n\n\n/**\n * Adds a copy the given \"SedDataGenerator\" to this SedDocument.\n *\n * @param sdg; the SedDataGenerator object to add\n *\n * @return integer value indicating success/failure of the\n * function.  @if clike The value is drawn from the\n * enumeration #OperationReturnValues_t. @endif The possible values\n * returned by this function are:\n * @li LIBSEDML_OPERATION_SUCCESS\n * @li LIBSEDML_INVALID_ATTRIBUTE_VALUE\n */\nint\nSedDocument::addDataGenerator(const SedDataGenerator* sdg)\n{\n  if (sdg == NULL) return LIBSEDML_INVALID_ATTRIBUTE_VALUE;\n\n  mDataGenerators.append(sdg);\n  return LIBSEDML_OPERATION_SUCCESS;\n}\n\n\n/**\n * Get the number of SedDataGenerator objects in this SedDocument.\n *\n * @return the number of SedDataGenerator objects in this SedDocument\n */\nunsigned int\nSedDocument::getNumDataGenerators() const\n{\n  return mDataGenerators.size();\n}\n\n/**\n * Creates a new SedDataGenerator object, adds it to this SedDocuments\n * SedDocument and returns the SedDataGenerator object created.\n *\n * @return a new SedDataGenerator object instance\n *\n * @see addSedDataGenerator(const SedDataGenerator* sdg)\n */\nSedDataGenerator*\nSedDocument::createDataGenerator()\n{\n  SedDataGenerator *temp = new SedDataGenerator();\n\n  if (temp != NULL) mDataGenerators.appendAndOwn(temp);\n\n  return temp;\n}\n\n/*\n * Returns the  \"SedListOfOutputs\" in this SedDocument object.\n */\nconst SedListOfOutputs*\nSedDocument::getListOfOutputs() const\n{\n  return \u0026mOutputs;\n}\n\n\n/*\n * Removes the nth Output from the SedListOfOutputs.\n */\nSedOutput*\nSedDocument::removeOutput(unsigned int n)\n{\n  return mOutputs.remove(n);\n}\n\n\n/*\n * Removes the a Output with given id from the SedListOfOutputs.\n */\nSedOutput*\nSedDocument::removeOutput(const std::string\u0026 sid)\n{\n  return mOutputs.remove(sid);\n}\n\n\n/*\n * Return the nth Output in the SedListOfOutputs within this SedDocument.\n */\nSedOutput*\nSedDocument::getOutput(unsigned int n)\n{\n  return mOutputs.get(n);\n}\n\n\n/*\n * Return the nth Output in the SedListOfOutputs within this SedDocument.\n */\nconst SedOutput*\nSedDocument::getOutput(unsigned int n) const\n{\n  return mOutputs.get(n);\n}\n\n\n/*\n * Return a Output from the SedListOfOutputs by id.\n */\nSedOutput*\nSedDocument::getOutput(const std::string\u0026 sid)\n{\n  return mOutputs.get(sid);\n}\n\n\n/*\n * Return a Output from the SedListOfOutputs by id.\n */\nconst SedOutput*\nSedDocument::getOutput(const std::string\u0026 sid) const\n{\n  return mOutputs.get(sid);\n}\n\n\n/**\n * Adds a copy the given \"SedOutput\" to this SedDocument.\n *\n * @param so; the SedOutput object to add\n *\n * @return integer value indicating success/failure of the\n * function.  @if clike The value is drawn from the\n * enumeration #OperationReturnValues_t. @endif The possible values\n * returned by this function are:\n * @li LIBSEDML_OPERATION_SUCCESS\n * @li LIBSEDML_INVALID_ATTRIBUTE_VALUE\n */\nint\nSedDocument::addOutput(const SedOutput* so)\n{\n  if (so == NULL) return LIBSEDML_INVALID_ATTRIBUTE_VALUE;\n\n  mOutputs.append(so);\n  return LIBSEDML_OPERATION_SUCCESS;\n}\n\n\n/**\n * Get the number of SedOutput objects in this SedDocument.\n *\n * @return the number of SedOutput objects in this SedDocument\n */\nunsigned int\nSedDocument::getNumOutputs() const\n{\n  return mOutputs.size();\n}\n\n/**\n * Creates a new SedReport object, adds it to this SedDocuments\n * SedDocument and returns the SedReport object created.\n *\n * @return a new SedReport object instance\n *\n * @see addReport(const SedOutput* so)\n */\nSedReport*\nSedDocument::createReport()\n{\n  SedReport *temp = new SedReport();\n\n  if (temp != NULL) mOutputs.appendAndOwn(temp);\n\n  return temp;\n}\n\n/**\n * Creates a new SedPlot2D object, adds it to this SedDocuments\n * SedDocument and returns the SedPlot2D object created.\n *\n * @return a new SedPlot2D object instance\n *\n * @see addPlot2D(const SedOutput* so)\n */\nSedPlot2D*\nSedDocument::createPlot2D()\n{\n  SedPlot2D *temp = new SedPlot2D();\n\n  if (temp != NULL) mOutputs.appendAndOwn(temp);\n\n  return temp;\n}\n\n/**\n * Creates a new SedPlot3D object, adds it to this SedDocuments\n * SedDocument and returns the SedPlot3D object created.\n *\n * @return a new SedPlot3D object instance\n *\n * @see addPlot3D(const SedOutput* so)\n */\nSedPlot3D*\nSedDocument::createPlot3D()\n{\n  SedPlot3D *temp = new SedPlot3D();\n\n  if (temp != NULL) mOutputs.appendAndOwn(temp);\n\n  return temp;\n}\n\n/*\n * Returns the XML element name of this object\n */\nconst std::string\u0026\nSedDocument::getElementName() const\n{\n  static const string name = \"sedML\";\n  return name;\n}\n\n\n/**\n * return the SEDML object corresponding to next XMLToken.\n */\nSedBase*\nSedDocument::createObject(XMLInputStream\u0026 stream)\n{\n  SedBase* object = NULL;\n\n  const string\u0026 name   = stream.peek().getName();\n\n  if (name == \"listOfDataDescriptions\")\n    {\n      object = \u0026mDataDescriptions;\n    }\n\n  if (name == \"listOfSimulations\")\n    {\n      object = \u0026mSimulations;\n    }\n\n  if (name == \"listOfModels\")\n    {\n      object = \u0026mModels;\n    }\n\n  if (name == \"listOfTasks\")\n    {\n      object = \u0026mTasks;\n    }\n\n  if (name == \"listOfDataGenerators\")\n    {\n      object = \u0026mDataGenerators;\n    }\n\n  if (name == \"listOfOutputs\")\n    {\n      object = \u0026mOutputs;\n    }\n\n  connectToChild();\n\n  return object;\n}\n\n\n/*\n * Read values from the given XMLAttributes set into their specific fields.\n */\nvoid\nSedDocument::connectToChild()\n{\n  SedBase::connectToChild();\n\n  mDataDescriptions.connectToParent(this);\n  mSimulations.connectToParent(this);\n  mModels.connectToParent(this);\n  mTasks.connectToParent(this);\n  mDataGenerators.connectToParent(this);\n  mOutputs.connectToParent(this);\n}\n\n\n/*\n * Returns the libSEDML type code for this SEDML object.\n */\nint\nSedDocument::getTypeCode() const\n{\n  return SEDML_DOCUMENT;\n}\n\n\n/*\n * check if all the required attributes are set\n */\nbool\nSedDocument::hasRequiredAttributes() const\n{\n  bool allPresent = true;\n\n  if (isSetLevel() == false)\n    allPresent = false;\n\n  if (isSetVersion() == false)\n    allPresent = false;\n\n  return allPresent;\n}\n\n\n/*\n * check if all the required elements are set\n */\nbool\nSedDocument::hasRequiredElements() const\n{\n  bool allPresent = true;\n\n  return allPresent;\n}\n\n\n/** @cond doxygen-libsedml-internal */\n\n/*\n * write contained elements\n */\nvoid\nSedDocument::writeElements(XMLOutputStream\u0026 stream) const\n{\n  SedBase::writeElements(stream);\n\n  if (getNumDataDescriptions() \u003e 0)\n    {\n      mDataDescriptions.write(stream);\n    }\n\n  if (getNumSimulations() \u003e 0)\n    {\n      mSimulations.write(stream);\n    }\n\n  if (getNumModels() \u003e 0)\n    {\n      mModels.write(stream);\n    }\n\n  if (getNumTasks() \u003e 0)\n    {\n      mTasks.write(stream);\n    }\n\n  if (getNumDataGenerators() \u003e 0)\n    {\n      mDataGenerators.write(stream);\n    }\n\n  if (getNumOutputs() \u003e 0)\n    {\n      mOutputs.write(stream);\n    }\n}\n\n\n/** @endcond doxygen-libsedml-internal */\n\n\n/** @cond doxygen-libsedml-internal */\n\n/*\n * Accepts the given SedVisitor.\n */\nbool\nSedDocument::accept(SedVisitor\u0026 v) const\n{\n  return false;\n\n}\n\n\n/** @endcond doxygen-libsedml-internal */\n\n\n/** @cond doxygen-libsedml-internal */\n\n/*\n * Sets the parent SedDocument.\n */\nvoid\nSedDocument::setSedDocument(SedDocument* d)\n{\n  SedBase::setSedDocument(d);\n  mDataDescriptions.setSedDocument(d);\n  mSimulations.setSedDocument(d);\n  mModels.setSedDocument(d);\n  mTasks.setSedDocument(d);\n  mDataGenerators.setSedDocument(d);\n  mOutputs.setSedDocument(d);\n}\n\n\n/** @endcond doxygen-libsedml-internal */\n\n\n/** @cond doxygen-libsedml-internal */\n\n/*\n * Get the list of expected attributes for this element.\n */\nvoid\nSedDocument::addExpectedAttributes(ExpectedAttributes\u0026 attributes)\n{\n  SedBase::addExpectedAttributes(attributes);\n\n  attributes.add(\"level\");\n  attributes.add(\"version\");\n}\n\n\n/** @endcond doxygen-libsedml-internal */\n\n\n/** @cond doxygen-libsedml-internal */\n\n/*\n * Read values from the given XMLAttributes set into their specific fields.\n */\nvoid\nSedDocument::readAttributes(const XMLAttributes\u0026 attributes,\n                            const ExpectedAttributes\u0026 expectedAttributes)\n{\n  SedBase::readAttributes(attributes, expectedAttributes);\n\n  bool assigned = false;\n\n  //\n  // level int   ( use = \"required\" )\n  //\n  mIsSetLevel = attributes.readInto(\"level\", mLevel, getErrorLog(), true);\n\n  //\n  // version int   ( use = \"required\" )\n  //\n  mIsSetVersion = attributes.readInto(\"version\", mVersion, getErrorLog(), true);\n\n}\n\n\n/** @endcond doxygen-libsedml-internal */\n\n\n/** @cond doxygen-libsedml-internal */\n\n/*\n * Write values of XMLAttributes to the output stream.\n */\nvoid\nSedDocument::writeAttributes(XMLOutputStream\u0026 stream) const\n{\n  SedBase::writeAttributes(stream);\n\n  if (isSetLevel() == true)\n    stream.writeAttribute(\"level\", getPrefix(), mLevel);\n\n  if (isSetVersion() == true)\n    stream.writeAttribute(\"version\", getPrefix(), mVersion);\n\n}\n\n\n/** @endcond doxygen-libsedml-internal */\n\n\n/*\n * @return the nth error encountered during the parse of this\n * SedDocument or @c NULL if n \u003e getNumErrors() - 1.\n */\nconst SedError*\nSedDocument::getError(unsigned int n) const\n{\n  return mErrorLog.getError(n);\n}\n\n\n/*\n * @return the number of errors encountered during the parse of this\n * SedDocument.\n */\nunsigned int\nSedDocument::getNumErrors() const\n{\n  return mErrorLog.getNumErrors();\n}\n\n\nunsigned int\nSedDocument::getNumErrors(unsigned int severity) const\n{\n  return getErrorLog()-\u003egetNumFailsWithSeverity(severity);\n}\n\n\n/*\n * @return the SedErrorLog used to log errors during while reading and\n * validating Sed.\n */\nSedErrorLog*\nSedDocument::getErrorLog()\n{\n  return \u0026mErrorLog;\n}\n\n\n/*\n * @return the SedErrorLog used to log errors during while reading and\n * validating Sed.\n */\nconst SedErrorLog*\nSedDocument::getErrorLog() const\n{\n  return \u0026mErrorLog;\n}\n\n/*\n *\n * Subclasses should override this method to write their xmlns attriubutes\n * (if any) to the XMLOutputStream.  Be sure to call your parents implementation\n * of this method as well.\n *\n */\nvoid\nSedDocument::writeXMLNS(XMLOutputStream\u0026 stream) const\n{\n  // need to check that we have indeed a namespace set!\n  XMLNamespaces * thisNs = this-\u003egetNamespaces();\n\n  // the SED-ML namespace is missing - add it\n  if (thisNs == NULL)\n    {\n      XMLNamespaces xmlns;\n\n      if (getVersion() == 1)\n        xmlns.add(SEDML_XMLNS_L1V1);\n      else\n        xmlns.add(SEDML_XMLNS_L1V2);\n\n      mSedNamespaces-\u003esetNamespaces(\u0026xmlns);\n      thisNs = getNamespaces();\n    }\n  else if (thisNs-\u003egetLength() == 0)\n    {\n      if (getVersion() == 1)\n        thisNs-\u003eadd(SEDML_XMLNS_L1V1);\n      else if (getVersion() == 2)\n        thisNs-\u003eadd(SEDML_XMLNS_L1V2);\n      else\n        thisNs-\u003eadd(SEDML_XMLNS_L1V3);\n    }\n  else\n    {\n      // check that there is an SED-ML namespace\n      std::string sedmlURI = SedNamespaces::getSedNamespaceURI(getLevel(), getVersion());\n      std::string sedmlPrefix = thisNs-\u003egetPrefix(sedmlURI);\n\n      if (thisNs-\u003ehasNS(sedmlURI, sedmlPrefix) == false)\n        {\n          // the SED-ML ns is not present\n          std::string other = thisNs-\u003egetURI(sedmlPrefix);\n\n          if (other.empty() == false)\n            {\n              // there is another ns with the prefix that the SED-ML ns expects to have\n              //remove the this ns, add the sbml ns and\n              //add the new ns with a new prefix\n              thisNs-\u003eremove(sedmlPrefix);\n              thisNs-\u003eadd(sedmlURI, sedmlPrefix);\n              thisNs-\u003eadd(other, \"addedPrefix\");\n            }\n          else\n            {\n              thisNs-\u003eadd(sedmlURI, sedmlPrefix);\n            }\n        }\n    }\n\n  XMLNamespaces * xmlns = thisNs-\u003eclone();\n\n  if (xmlns != NULL)\n    {\n      stream \u003c\u003c *(xmlns);\n      delete xmlns;\n    }\n}\n\n/*\n  * @return the Namespaces associated with this SED-ML object\n  */\nXMLNamespaces*\nSedDocument::getNamespaces() const\n{\n  return mSedNamespaces-\u003egetNamespaces();\n}\n/**\n * write comments\n */\nLIBSEDML_EXTERN\nSedDocument_t *\nSedDocument_create(unsigned int level, unsigned int version)\n{\n  return new SedDocument(level, version);\n}\n\n\n/**\n * write comments\n */\nLIBSEDML_EXTERN\nvoid\nSedDocument_free(SedDocument_t * sd)\n{\n  if (sd != NULL)\n    delete sd;\n}\n\n\n/**\n * write comments\n */\nLIBSEDML_EXTERN\nSedDocument_t *\nSedDocument_clone(SedDocument_t * sd)\n{\n  if (sd != NULL)\n    {\n      return static_cast\u003cSedDocument_t*\u003e(sd-\u003eclone());\n    }\n  else\n    {\n      return NULL;\n    }\n}\n\n\n/**\n * write comments\n */\nLIBSEDML_EXTERN\nint\nSedDocument_getLevel(SedDocument_t * sd)\n{\n  return (sd != NULL) ? sd-\u003egetLevel() : SEDML_INT_MAX;\n}\n\n\n/**\n * write comments\n */\nLIBSEDML_EXTERN\nint\nSedDocument_getVersion(SedDocument_t * sd)\n{\n  return (sd != NULL) ? sd-\u003egetVersion() : SEDML_INT_MAX;\n}\n\n\n/**\n * write comments\n */\nLIBSEDML_EXTERN\nint\nSedDocument_isSetLevel(SedDocument_t * sd)\n{\n  return (sd != NULL) ? static_cast\u003cint\u003e(sd-\u003eisSetLevel()) : 0;\n}\n\n\n/**\n * write comments\n */\nLIBSEDML_EXTERN\nint\nSedDocument_isSetVersion(SedDocument_t * sd)\n{\n  return (sd != NULL) ? static_cast\u003cint\u003e(sd-\u003eisSetVersion()) : 0;\n}\n\n\n/**\n * write comments\n */\nLIBSEDML_EXTERN\nint\nSedDocument_setLevel(SedDocument_t * sd, int level)\n{\n  return (sd != NULL) ? sd-\u003esetLevel(level) : LIBSEDML_INVALID_OBJECT;\n}\n\n\n/**\n * write comments\n */\nLIBSEDML_EXTERN\nint\nSedDocument_setVersion(SedDocument_t * sd, int version)\n{\n  return (sd != NULL) ? sd-\u003esetVersion(version) : LIBSEDML_INVALID_OBJECT;\n}\n\n\n/**\n * write comments\n */\nLIBSEDML_EXTERN\nint\nSedDocument_unsetLevel(SedDocument_t * sd)\n{\n  return (sd != NULL) ? sd-\u003eunsetLevel() : LIBSEDML_INVALID_OBJECT;\n}\n\n\n/**\n * write comments\n */\nLIBSEDML_EXTERN\nint\nSedDocument_unsetVersion(SedDocument_t * sd)\n{\n  return (sd != NULL) ? sd-\u003eunsetVersion() : LIBSEDML_INVALID_OBJECT;\n}\n\n\nLIBSEDML_EXTERN\nint\nSedDocument_addDataDescription(SedDocument_t * sd, SedDataDescription_t * sdd)\n{\n  return (sd != NULL) ? sd-\u003eaddDataDescription(sdd) : LIBSBML_INVALID_OBJECT;\n}\n\nLIBSEDML_EXTERN\nSedDataDescription_t *\nSedDocument_createDataDescription(SedDocument_t * sd)\n{\n  return (sd != NULL) ? sd-\u003ecreateDataDescription() : NULL;\n}\n\nLIBSEDML_EXTERN\nSedListOf_t *\nSedDocument_getSedListOfDataDescriptions(SedDocument_t * sd)\n{\n  return (sd != NULL) ? (SedListOf_t *)sd-\u003egetListOfDataDescriptions() : NULL;\n}\n\nLIBSEDML_EXTERN\nSedDataDescription_t *\nSedDocument_getDataDescription(SedDocument_t * sd, unsigned int n)\n{\n  return (sd != NULL) ? sd-\u003egetDataDescription(n) : NULL;\n}\n\nLIBSEDML_EXTERN\nSedDataDescription_t *\nSedDocument_getDataDescriptionById(SedDocument_t * sd, const char * sid)\n{\n  return (sd != NULL) ? sd-\u003egetDataDescription(sid) : NULL;\n}\n\nLIBSEDML_EXTERN\nunsigned int\nSedDocument_getNumDataDescriptions(SedDocument_t * sd)\n{\n  return (sd != NULL) ? sd-\u003egetNumDataDescriptions() : SEDML_INT_MAX;\n}\n\nLIBSEDML_EXTERN\nSedDataDescription_t *\nSedDocument_removeDataDescription(SedDocument_t * sd, unsigned int n)\n{\n  return (sd != NULL) ? sd-\u003eremoveDataDescription(n) : NULL;\n}\n\nLIBSEDML_EXTERN\nSedDataDescription_t *\nSedDocument_removeDataDescriptionById(SedDocument_t * sd, const char * sid)\n{\n  return (sd != NULL) ? sd-\u003eremoveDataDescription(sid) : NULL;\n}\n\nLIBSEDML_EXTERN\nint\nSedDocument_addSimulation(SedDocument_t * sd, SedSimulation_t * ss)\n{\n  return (sd != NULL) ? sd-\u003eaddSimulation(ss) : LIBSBML_INVALID_OBJECT;\n}\n\nLIBSEDML_EXTERN\nSedUniformTimeCourse_t *\nSedDocument_createUniformTimeCourse(SedDocument_t * sd)\n{\n  return (sd != NULL) ? sd-\u003ecreateUniformTimeCourse() : NULL;\n}\n\nLIBSEDML_EXTERN\nSedOneStep_t *\nSedDocument_createOneStep(SedDocument_t * sd)\n{\n  return (sd != NULL) ? sd-\u003ecreateOneStep() : NULL;\n}\n\nLIBSEDML_EXTERN\nSedSteadyState_t *\nSedDocument_createSteadyState(SedDocument_t * sd)\n{\n  return (sd != NULL) ? sd-\u003ecreateSteadyState() : NULL;\n}\n\nLIBSEDML_EXTERN\nSedListOf_t *\nSedDocument_getSedListOfSimulations(SedDocument_t * sd)\n{\n  return (sd != NULL) ? (SedListOf_t *)sd-\u003egetListOfSimulations() : NULL;\n}\n\nLIBSEDML_EXTERN\nSedSimulation_t *\nSedDocument_getSimulation(SedDocument_t * sd, unsigned int n)\n{\n  return (sd != NULL) ? sd-\u003egetSimulation(n) : NULL;\n}\n\nLIBSEDML_EXTERN\nSedSimulation_t *\nSedDocument_getSimulationById(SedDocument_t * sd, const char * sid)\n{\n  return (sd != NULL) ? sd-\u003egetSimulation(sid) : NULL;\n}\n\nLIBSEDML_EXTERN\nunsigned int\nSedDocument_getNumSimulations(SedDocument_t * sd)\n{\n  return (sd != NULL) ? sd-\u003egetNumSimulations() : SEDML_INT_MAX;\n}\n\nLIBSEDML_EXTERN\nSedSimulation_t *\nSedDocument_removeSimulation(SedDocument_t * sd, unsigned int n)\n{\n  return (sd != NULL) ? sd-\u003eremoveSimulation(n) : NULL;\n}\n\nLIBSEDML_EXTERN\nSedSimulation_t *\nSedDocument_removeSimulationById(SedDocument_t * sd, const char * sid)\n{\n  return (sd != NULL) ? sd-\u003eremoveSimulation(sid) : NULL;\n}\n\nLIBSEDML_EXTERN\nint\nSedDocument_addModel(SedDocument_t * sd, SedModel_t * sm)\n{\n  return (sd != NULL) ? sd-\u003eaddModel(sm) : LIBSBML_INVALID_OBJECT;\n}\n\nLIBSEDML_EXTERN\nSedModel_t *\nSedDocument_createModel(SedDocument_t * sd)\n{\n  return (sd != NULL) ? sd-\u003ecreateModel() : NULL;\n}\n\nLIBSEDML_EXTERN\nSedListOf_t *\nSedDocument_getSedListOfModels(SedDocument_t * sd)\n{\n  return (sd != NULL) ? (SedListOf_t *)sd-\u003egetListOfModels() : NULL;\n}\n\nLIBSEDML_EXTERN\nSedModel_t *\nSedDocument_getModel(SedDocument_t * sd, unsigned int n)\n{\n  return (sd != NULL) ? sd-\u003egetModel(n) : NULL;\n}\n\nLIBSEDML_EXTERN\nSedModel_t *\nSedDocument_getModelById(SedDocument_t * sd, const char * sid)\n{\n  return (sd != NULL) ? sd-\u003egetModel(sid) : NULL;\n}\n\nLIBSEDML_EXTERN\nunsigned int\nSedDocument_getNumModels(SedDocument_t * sd)\n{\n  return (sd != NULL) ? sd-\u003egetNumModels() : SEDML_INT_MAX;\n}\n\nLIBSEDML_EXTERN\nSedModel_t *\nSedDocument_removeModel(SedDocument_t * sd, unsigned int n)\n{\n  return (sd != NULL) ? sd-\u003eremoveModel(n) : NULL;\n}\n\nLIBSEDML_EXTERN\nSedModel_t *\nSedDocument_removeModelById(SedDocument_t * sd, const char * sid)\n{\n  return (sd != NULL) ? sd-\u003eremoveModel(sid) : NULL;\n}\n\nLIBSEDML_EXTERN\nint\nSedDocument_addTask(SedDocument_t * sd, SedTask_t * st)\n{\n  return (sd != NULL) ? sd-\u003eaddTask(st) : LIBSBML_INVALID_OBJECT;\n}\n\nLIBSEDML_EXTERN\nSedTask_t *\nSedDocument_createTask(SedDocument_t * sd)\n{\n  return (sd != NULL) ? sd-\u003ecreateTask() : NULL;\n}\n\nLIBSEDML_EXTERN\nSedRepeatedTask_t *\nSedDocument_createRepeatedTask(SedDocument_t * sd)\n{\n  return (sd != NULL) ? sd-\u003ecreateRepeatedTask() : NULL;\n}\n\nLIBSEDML_EXTERN\nSedListOf_t *\nSedDocument_getSedListOfTasks(SedDocument_t * sd)\n{\n  return (sd != NULL) ? (SedListOf_t *)sd-\u003egetListOfTasks() : NULL;\n}\n\nLIBSEDML_EXTERN\nSedTask_t *\nSedDocument_getTask(SedDocument_t * sd, unsigned int n)\n{\n  return (sd != NULL) ? sd-\u003egetTask(n) : NULL;\n}\n\nLIBSEDML_EXTERN\nSedTask_t *\nSedDocument_getTaskById(SedDocument_t * sd, const char * sid)\n{\n  return (sd != NULL) ? sd-\u003egetTask(sid) : NULL;\n}\n\nLIBSEDML_EXTERN\nunsigned int\nSedDocument_getNumTasks(SedDocument_t * sd)\n{\n  return (sd != NULL) ? sd-\u003egetNumTasks() : SEDML_INT_MAX;\n}\n\nLIBSEDML_EXTERN\nSedTask_t *\nSedDocument_removeTask(SedDocument_t * sd, unsigned int n)\n{\n  return (sd != NULL) ? sd-\u003eremoveTask(n) : NULL;\n}\n\nLIBSEDML_EXTERN\nSedTask_t *\nSedDocument_removeTaskById(SedDocument_t * sd, const char * sid)\n{\n  return (sd != NULL) ? sd-\u003eremoveTask(sid) : NULL;\n}\n\nLIBSEDML_EXTERN\nint\nSedDocument_addDataGenerator(SedDocument_t * sd, SedDataGenerator_t * sdg)\n{\n  return (sd != NULL) ? sd-\u003eaddDataGenerator(sdg) : LIBSBML_INVALID_OBJECT;\n}\n\nLIBSEDML_EXTERN\nSedDataGenerator_t *\nSedDocument_createDataGenerator(SedDocument_t * sd)\n{\n  return (sd != NULL) ? sd-\u003ecreateDataGenerator() : NULL;\n}\n\nLIBSEDML_EXTERN\nSedListOf_t *\nSedDocument_getSedListOfDataGenerators(SedDocument_t * sd)\n{\n  return (sd != NULL) ? (SedListOf_t *)sd-\u003egetListOfDataGenerators() : NULL;\n}\n\nLIBSEDML_EXTERN\nSedDataGenerator_t *\nSedDocument_getDataGenerator(SedDocument_t * sd, unsigned int n)\n{\n  return (sd != NULL) ? sd-\u003egetDataGenerator(n) : NULL;\n}\n\nLIBSEDML_EXTERN\nSedDataGenerator_t *\nSedDocument_getDataGeneratorById(SedDocument_t * sd, const char * sid)\n{\n  return (sd != NULL) ? sd-\u003egetDataGenerator(sid) : NULL;\n}\n\nLIBSEDML_EXTERN\nunsigned int\nSedDocument_getNumDataGenerators(SedDocument_t * sd)\n{\n  return (sd != NULL) ? sd-\u003egetNumDataGenerators() : SEDML_INT_MAX;\n}\n\nLIBSEDML_EXTERN\nSedDataGenerator_t *\nSedDocument_removeDataGenerator(SedDocument_t * sd, unsigned int n)\n{\n  return (sd != NULL) ? sd-\u003eremoveDataGenerator(n) : NULL;\n}\n\nLIBSEDML_EXTERN\nSedDataGenerator_t *\nSedDocument_removeDataGeneratorById(SedDocument_t * sd, const char * sid)\n{\n  return (sd != NULL) ? sd-\u003eremoveDataGenerator(sid) : NULL;\n}\n\nLIBSEDML_EXTERN\nint\nSedDocument_addOutput(SedDocument_t * sd, SedOutput_t * so)\n{\n  return (sd != NULL) ? sd-\u003eaddOutput(so) : LIBSBML_INVALID_OBJECT;\n}\n\nLIBSEDML_EXTERN\nSedReport_t *\nSedDocument_createReport(SedDocument_t * sd)\n{\n  return (sd != NULL) ? sd-\u003ecreateReport() : NULL;\n}\n\nLIBSEDML_EXTERN\nSedPlot2D_t *\nSedDocument_createPlot2D(SedDocument_t * sd)\n{\n  return (sd != NULL) ? sd-\u003ecreatePlot2D() : NULL;\n}\n\nLIBSEDML_EXTERN\nSedPlot3D_t *\nSedDocument_createPlot3D(SedDocument_t * sd)\n{\n  return (sd != NULL) ? sd-\u003ecreatePlot3D() : NULL;\n}\n\nLIBSEDML_EXTERN\nSedListOf_t *\nSedDocument_getSedListOfOutputs(SedDocument_t * sd)\n{\n  return (sd != NULL) ? (SedListOf_t *)sd-\u003egetListOfOutputs() : NULL;\n}\n\nLIBSEDML_EXTERN\nSedOutput_t *\nSedDocument_getOutput(SedDocument_t * sd, unsigned int n)\n{\n  return (sd != NULL) ? sd-\u003egetOutput(n) : NULL;\n}\n\nLIBSEDML_EXTERN\nSedOutput_t *\nSedDocument_getOutputById(SedDocument_t * sd, const char * sid)\n{\n  return (sd != NULL) ? sd-\u003egetOutput(sid) : NULL;\n}\n\nLIBSEDML_EXTERN\nunsigned int\nSedDocument_getNumOutputs(SedDocument_t * sd)\n{\n  return (sd != NULL) ? sd-\u003egetNumOutputs() : SEDML_INT_MAX;\n}\n\nLIBSEDML_EXTERN\nSedOutput_t *\nSedDocument_removeOutput(SedDocument_t * sd, unsigned int n)\n{\n  return (sd != NULL) ? sd-\u003eremoveOutput(n) : NULL;\n}\n\nLIBSEDML_EXTERN\nSedOutput_t *\nSedDocument_removeOutputById(SedDocument_t * sd, const char * sid)\n{\n  return (sd != NULL) ? sd-\u003eremoveOutput(sid) : NULL;\n}\n\n/**\n * write comments\n */\nLIBSEDML_EXTERN\nint\nSedDocument_hasRequiredAttributes(SedDocument_t * sd)\n{\n  return (sd != NULL) ? static_cast\u003cint\u003e(sd-\u003ehasRequiredAttributes()) : 0;\n}\n\n\n/**\n * write comments\n */\nLIBSEDML_EXTERN\nint\nSedDocument_hasRequiredElements(SedDocument_t * sd)\n{\n  return (sd != NULL) ? static_cast\u003cint\u003e(sd-\u003ehasRequiredElements()) : 0;\n}\n\n\n\n\nLIBSEDML_CPP_NAMESPACE_END\n\n\n"}
{"repo_name":"dolphin-emu/dolphin","ref":"refs/heads/master","path":"Source/Core/VideoCommon/OnScreenDisplay.cpp","copies":"6","language":"C++","content":"// Copyright 2009 Dolphin Emulator Project\n// Licensed under GPLv2+\n// Refer to the license.txt file included.\n\n#include \"VideoCommon/OnScreenDisplay.h\"\n\n#include \u003calgorithm\u003e\n#include \u003cmap\u003e\n#include \u003cmutex\u003e\n#include \u003cstring\u003e\n\n#include \u003cfmt/format.h\u003e\n#include \u003cimgui.h\u003e\n\n#include \"Common/CommonTypes.h\"\n#include \"Common/Timer.h\"\n\n#include \"Core/ConfigManager.h\"\n\nnamespace OSD\n{\nconstexpr float LEFT_MARGIN = 10.0f;    // Pixels to the left of OSD messages.\nconstexpr float TOP_MARGIN = 10.0f;     // Pixels above the first OSD message.\nconstexpr float WINDOW_PADDING = 4.0f;  // Pixels between subsequent OSD messages.\n\nstruct Message\n{\n  Message() = default;\n  Message(std::string text_, u32 timestamp_, u32 color_)\n      : text(std::move(text_)), timestamp(timestamp_), color(color_)\n  {\n  }\n  std::string text;\n  u32 timestamp = 0;\n  u32 color = 0;\n};\nstatic std::multimap\u003cMessageType, Message\u003e s_messages;\nstatic std::mutex s_messages_mutex;\n\nstatic ImVec4 RGBAToImVec4(const u32 rgba)\n{\n  return ImVec4(static_cast\u003cfloat\u003e((rgba \u003e\u003e 16) \u0026 0xFF) / 255.0f,\n                static_cast\u003cfloat\u003e((rgba \u003e\u003e 8) \u0026 0xFF) / 255.0f,\n                static_cast\u003cfloat\u003e((rgba \u003e\u003e 0) \u0026 0xFF) / 255.0f,\n                static_cast\u003cfloat\u003e((rgba \u003e\u003e 24) \u0026 0xFF) / 255.0f);\n}\n\nstatic float DrawMessage(int index, const Message\u0026 msg, const ImVec2\u0026 position, int time_left)\n{\n  // We have to provide a window name, and these shouldn't be duplicated.\n  // So instead, we generate a name based on the number of messages drawn.\n  const std::string window_name = fmt::format(\"osd_{}\", index);\n\n  // The size must be reset, otherwise the length of old messages could influence new ones.\n  ImGui::SetNextWindowPos(position);\n  ImGui::SetNextWindowSize(ImVec2(0.0f, 0.0f));\n\n  // Gradually fade old messages away.\n  const float alpha = std::min(1.0f, std::max(0.0f, time_left / 1024.0f));\n  ImGui::PushStyleVar(ImGuiStyleVar_Alpha, alpha);\n\n  float window_height = 0.0f;\n  if (ImGui::Begin(window_name.c_str(), nullptr,\n                   ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoInputs |\n                       ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoSavedSettings |\n                       ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoNav |\n                       ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoFocusOnAppearing))\n  {\n    // Use %s in case message contains %.\n    ImGui::TextColored(RGBAToImVec4(msg.color), \"%s\", msg.text.c_str());\n    window_height =\n        ImGui::GetWindowSize().y + (WINDOW_PADDING * ImGui::GetIO().DisplayFramebufferScale.y);\n  }\n\n  ImGui::End();\n  ImGui::PopStyleVar();\n\n  return window_height;\n}\n\nvoid AddTypedMessage(MessageType type, std::string message, u32 ms, u32 rgba)\n{\n  std::lock_guard lock{s_messages_mutex};\n  s_messages.erase(type);\n  s_messages.emplace(type, Message(std::move(message), Common::Timer::GetTimeMs() + ms, rgba));\n}\n\nvoid AddMessage(std::string message, u32 ms, u32 rgba)\n{\n  std::lock_guard lock{s_messages_mutex};\n  s_messages.emplace(MessageType::Typeless,\n                     Message(std::move(message), Common::Timer::GetTimeMs() + ms, rgba));\n}\n\nvoid DrawMessages()\n{\n  if (!SConfig::GetInstance().bOnScreenDisplayMessages)\n    return;\n\n  {\n    std::lock_guard lock{s_messages_mutex};\n\n    const u32 now = Common::Timer::GetTimeMs();\n    float current_x = LEFT_MARGIN * ImGui::GetIO().DisplayFramebufferScale.x;\n    float current_y = TOP_MARGIN * ImGui::GetIO().DisplayFramebufferScale.y;\n    int index = 0;\n\n    auto it = s_messages.begin();\n    while (it != s_messages.end())\n    {\n      const Message\u0026 msg = it-\u003esecond;\n      const int time_left = static_cast\u003cint\u003e(msg.timestamp - now);\n      current_y += DrawMessage(index++, msg, ImVec2(current_x, current_y), time_left);\n\n      if (time_left \u003c= 0)\n        it = s_messages.erase(it);\n      else\n        ++it;\n    }\n  }\n}\n\nvoid ClearMessages()\n{\n  std::lock_guard lock{s_messages_mutex};\n  s_messages.clear();\n}\n}  // namespace OSD\n"}
{"repo_name":"asmaurya95/My-ACM-ICPC-Handbook","ref":"refs/heads/master","path":"Suffix Array/Naive Implementation.cpp","copies":"4","language":"C++","content":"/*Naive Algorithm for contsruction of suffix array of a given string\n  Time Complexity: O((N^2)logN)*/\n#include\u003ciostream\u003e\n#include\u003cstring\u003e\n#include\u003cmap\u003e\n#include\u003calgorithm\u003e\n#include\u003cvector\u003e\nusing namespace std;\nint main(){\n\tstring s;\n\tcin\u003e\u003es;\n\tmap\u003cstring,int\u003e m;\n\tvector \u003cstring\u003e ar;\n\tfor(int i=0;i\u003cs.size();i++){\n\t\tstring sstr=s.substr(i,s.size()-i);\n\t\tm[sstr]=i;\n\t\tar.push_back(sstr);\n\t}\n\tsort(ar.begin(),ar.end());\n\tfor(int i=0;i\u003car.size();i++){\n\t\tcout\u003c\u003cm[ar[i]]\u003c\u003cendl;\n\t}\n\treturn 0;\n}\n"}
{"repo_name":"stoman/HashCode2017Warmup","ref":"refs/heads/master","path":"loon/code/pathfinding.cpp","copies":"1","language":"C++","content":"#pragma once\n#include \"util.cpp\"\n#include \u003cset\u003e\n#include \u003ccmath\u003e\n\nstruct Coord {\n\tint r, c, h;\n};\n\nbool operator \u003c (const Coord \u0026a, const Coord \u0026b)\t{\n\tif (a.r != b.r)\n\t\treturn a.r \u003c b.r;\n\telse if (a.c != b.c)\n\t\treturn a.c \u003c b.c;\n\telse\n\t\treturn a.h \u003c b.h;\n}\n\ndouble compute_distance(double r1, double c1, double h, double r2, double c2, double r, double c)\t{\t\n\n\tif (r1 \u003c 0 || r1 \u003e= r || r2 \u003c 0 || r2 \u003e= r)\n\t\treturn 1e12;\n\n\tdouble dr = abs(r1-r2);\n\tdouble dc = min(abs(c1-c2),c-abs(c1-c2));\n\treturn sqrt(dr*dr+dc*dc) + 20.*(h-1.)/(sqrt(dr*dr+dc*dc)+1);\n}\n\nint check_cell_value(Input \u0026input, int r, int c) \t{\n\tc = (c + input.c) % input.c;\n\tif (r \u003e= 0 \u0026\u0026 r \u003c input.r)\n\t\treturn input.cell_field[r][c];\n\telse\n\t\treturn 0;\n}\n\nvoid check_cell(Input \u0026input, Coord cur, vector\u003cCoord\u003e\u0026 path, vector\u003cint\u003e\u0026 prev, set\u003cCoord\u003e\u0026 visited, vector\u003cdouble\u003e\u0026 dist, \n\t\t\t\t\tint idx, double r, double c, double alpha)\t{\n\n\tint dr = input.movement_r[cur.r][cur.c][cur.h];\n\tint dc = input.movement_c[cur.r][cur.c][cur.h];\n\tcur.r += dr;\n\tcur.c += dc;\n\tcur.c = (cur.c + input.c) % input.c;\t\n\t\n\t//double dinit = compute_distance(path[0].r,path[0].c,r,c,input.r,input.c);\n\t//double dcur =  compute_distance(    cur.r,    cur.c,r,c,input.r,input.c);\n\n\tif (visited.find(cur) != visited.end())// || (dinit+20. \u003c dcur \u0026\u0026 path.size() \u003e 1))\n\t\treturn;\t\t\n\t\n\tint cnt_cells = 0;\n\tfor (int i = -2; i \u003c= 2; i++)\n\t\t for (int j = -2; j \u003c= 2; j++)\n\t\t \tcnt_cells += check_cell_value(input,cur.r+i,cur.c+j);\n\t\n\tif (cnt_cells \u003e 12)\n\t\tdist.push_back(dist[idx]+alpha);\n\telse\n\t\tdist.push_back(dist[idx]+1.0);\n\tpath.push_back(cur);\n\tprev.push_back(idx);\n\tvisited.insert(cur);\n}\n\nvoid bfs(Input \u0026input, vector\u003cCoord\u003e\u0026 path, vector\u003cint\u003e\u0026 prev, double r, double c, int bfsdepth, double alpha)\t{\n\t\n\tset\u003cCoord\u003e visited;\n\tvector\u003cdouble\u003e dist;\n\tint idx = 0;\n\tdist.push_back(0);\n\tvisited.insert(path[idx]);\n\t\n\twhile (idx \u003c path.size())\t{\n\t\tCoord cur = path[idx];\n\t\t\n\t\t//cerr \u003c\u003c \"current balloon: \" \u003c\u003c cur.r \u003c\u003c ' ' \u003c\u003c cur.c \u003c\u003c ' ' \u003c\u003c cur.h \u003c\u003c endl;\n\t\t\n\t\tif (dist[idx] \u003e (double)bfsdepth)\n\t\t\tbreak;\n\t\t\n\t\t//if (path.size() \u003e 10000)\n\t\t//\tbreak;\n\t\t\n\t\t// out of bounds -\u003e stay there\n\t\tif (cur.r \u003e= input.r || cur.r \u003c 0)\t{\n\t\t\tpath.push_back(cur);\n\t\t\tprev.push_back(idx);\n\t\t\tdist.push_back(dist[idx]+1);\n\t\t}\n\t\t\n\t\t// fly on neighboring altitudes\n\t\telse\t{\n\t\t\tcheck_cell(input,cur,path,prev,visited,dist,idx,r,c,alpha);\n\t\t\t\n\t\t\tif (cur.h \u003e 1)\n\t\t\t{\n\t\t\t\tcur.h--;\n\t\t\t\tcheck_cell(input,cur,path,prev,visited,dist,idx,r,c,alpha);\n\t\t\t\tcur.h++;\n\t\t\t}\n\t\t\t\n\t\t\tif (cur.h \u003c input.a)\t\n\t\t\t{\n\t\t\t\tcur.h++;\n\t\t\t\tcheck_cell(input,cur,path,prev,visited,dist,idx,r,c,alpha);\n\t\t\t\tcur.h--;\n\t\t\t}\t\n\t\t}\n\t\tidx++;\n\t}\n}\n\nvoid append_path(Input\u0026 input, int balloon, vector\u003cCoord\u003e\u0026 path, vector\u003cint\u003e\u0026 prev, int idx_min)\t{\n\n\tvector\u003cCoord\u003e reversed_path;\n\tfor (int i = idx_min; i != 0; i = prev[i])\n\t\treversed_path.push_back(path[i]);\n\n\tfor (int i = reversed_path.size()-1; i \u003e= 0; i--)\n\t{\n\t\tinput.balloons[balloon].h.push_back(reversed_path[i].h);\n\t\tinput.balloons[balloon].r.push_back(reversed_path[i].r);\n\t\tinput.balloons[balloon].c.push_back(reversed_path[i].c);\n\n\t\tif (input.balloons[balloon].h.size() \u003e input.t)\n\t\t\tbreak;\n\t}\n\t\n}\n\nint choose_closest_point(Input \u0026input, vector\u003cCoord\u003e\u0026 path, double r, double c) \t{\n\tdouble mind = 1e10, curd;\n\tint idx_min = 0;\n\tfor (int i = 1; i \u003c path.size(); i++)\n\t{\n\t\tcurd = compute_distance(path[i].r,path[i].c,path[i].h,r,c,input.r,input.c);\n\t\tif (curd \u003c mind || idx_min == 0)\n\t\t{\n\t\t\tidx_min = i;\n\t\t\tmind = curd;\n\t\t}\n\t}\n\t\n\treturn idx_min;\n}\n\nbool check_horizontal_distance(double c1, double c2, double delta_c, double c)\t{\n\t\n\tif (delta_c \u003e c)\n\t\treturn true;\n\t\n\tc2 += delta_c;\n\tif (c2 \u003e c)\n\t\tc2 -= c;\n\n\tif (abs(c2-c1) \u003c c - abs(c2-c1))\n\t\treturn c1 \u003c c2;\n\telse\n\t\treturn c1 \u003e c2;\n}\n\nvoid pathfinding(Input\u0026 input, int balloon, double r, double c, double delta, int bfsdepth, double delta_c, double alpha=0.5) {\n\n\tbool step_done = false;\n\twhile (step_done == false  || \n\t\t   (input.balloons[balloon].h.size() \u003c= input.t \u0026\u0026  \n\t\t    compute_distance(input.balloons[balloon].r.back(),input.balloons[balloon].c.back(),input.balloons[balloon].h.back(),r,c,input.r,input.c) \u003e delta \u0026\u0026\n\t\t    check_horizontal_distance(input.balloons[balloon].c.back(),c,delta_c,input.c)) )\n\t{\n\t\tvector\u003cCoord\u003e path;\n\t\tvector\u003cint\u003e prev;\n\t\t// add starting cell\n\t\tCoord start;\n\t\t\n\t\tstart.r = input.balloons[balloon].r.back();\n\t\tstart.c = input.balloons[balloon].c.back();\n\t\tstart.h = input.balloons[balloon].h.back();\n\t\n\t\tpath.push_back(start);\n\t\tprev.push_back(-1);\n\t\t\n\t\tbfs(input,path,prev,r,c,bfsdepth,alpha);\n\n\t\tint idx_min = choose_closest_point(input,path,r,c);\n\n\t\tappend_path(input,balloon,path,prev,idx_min);\n\t\tstep_done = true;\n\t}\n\t// end of while\n\t\n\t// DEBUG OUTPUT\t\n\t/*bool inside = true, arrived = false;\n\tfor (int i = 0; i \u003c input.balloons[balloon].r.size(); i++)\n\t{\n\t\tint rc = input.balloons[balloon].r[i];\n\t\tint cc = input.balloons[balloon].c[i];\n\t\tif (!arrived \u0026\u0026 compute_distance(rc,cc,r,c,input.r,input.c) \u003c input.v)\n\t\t{\n\t\t\tcerr \u003c\u003c \"Ballon \" \u003c\u003c balloon \u003c\u003c \" has reached the center of its cluster.\\n\";\n\t\t\tarrived = true;\n\t\t}\n\t\t\n\t\tif (input.balloons[balloon].h[i] \u003e input.a || (input.balloons[balloon].h[i] \u003c 1 \u0026\u0026 i \u003e 0))\n\t\t\tcerr \u003c\u003c \"ERROR: balloon \" \u003c\u003c balloon \u003c\u003c \" violates the height constraints.\\n\";\n\t\t\n\t\tif (cc \u003c 0 || cc \u003e= input.c)\n\t\t\tcerr \u003c\u003c \"ERROR: coordiantes of balloon \" \u003c\u003c balloon \u003c\u003c \" do not satisfy column constraints.\\n\";\n\t\t\n\t\tif (inside \u0026\u0026 (rc \u003c 0 || rc \u003e= input.r))\n\t\t{\n\t\t\tcerr \u003c\u003c \"Ballon \" \u003c\u003c balloon \u003c\u003c \" was lost at turn \" \u003c\u003c i \u003c\u003c \".\\n\"; \n\t\t\tinside = false;\n\t\t}\n\t}//*/\n\t\n\t// VISULAIZATION OF THE PATH\n\t/*\n\tfor (int i = 0; i \u003c input.balloons[balloon].r.size()-1; i++)\n\t{\n\t\tint rc = input.balloons[balloon].r[i];\n\t\tint rn = input.balloons[balloon].r[i+1];\n\n\t\tint cc = input.balloons[balloon].c[i];\n\t\tint cn = input.balloons[balloon].c[i+1];\n\n\t\tif (abs(cc-cn) \u003e input.c - abs(cc-cn))\n\t\t\tcerr \u003c\u003c cc \u003c\u003c ' ' \u003c\u003c rc \u003c\u003c ' ' \u003c\u003c 0 \u003c\u003c ' ' \u003c\u003c 0 \u003c\u003c ' ' \u003c\u003c input.balloons[balloon].cluster_id / ((double)input.clusters.size()) \u003c\u003c endl;\n\t\telse\n\t\t\tcerr \u003c\u003c cc \u003c\u003c ' ' \u003c\u003c rc \u003c\u003c ' ' \u003c\u003c cn-cc \u003c\u003c ' ' \u003c\u003c rn-rc \u003c\u003c ' ' \u003c\u003c input.balloons[balloon].cluster_id / ((double)input.clusters.size()) \u003c\u003c endl;\n\t}*/\n}\n"}
{"repo_name":"gilleslabelle/sagetv","ref":"refs/heads/master","path":"third_party/codecs/faac/common/mp4v2/atom_dmax.cpp","copies":"35","language":"C++","content":"/*\n * The contents of this file are subject to the Mozilla Public\n * License Version 1.1 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of\n * the License at http://www.mozilla.org/MPL/\n * \n * Software distributed under the License is distributed on an \"AS\n * IS\" basis, WITHOUT WARRANTY OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * rights and limitations under the License.\n * \n * The Original Code is MPEG4IP.\n * \n * The Initial Developer of the Original Code is Cisco Systems Inc.\n * Portions created by Cisco Systems Inc. are\n * Copyright (C) Cisco Systems Inc. 2001.  All Rights Reserved.\n * \n * Contributor(s): \n *\t\tDave Mackie\t\tdmackie@cisco.com\n */\n\n#include \"mp4common.h\"\n\nMP4DmaxAtom::MP4DmaxAtom() \n\t: MP4Atom(\"dmax\")\n{\n\tAddProperty( // max packet duration \n\t\tnew MP4Integer32Property(\"milliSecs\"));\n}\n"}
{"repo_name":"zaclimon/android_kernel_samsung_kylepro","ref":"refs/heads/master","path":"tools/gator/daemon/LocalCapture.cpp","copies":"26","language":"C++","content":"/**\n * Copyright (C) ARM Limited 2010-2013. All rights reserved.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation.\n */\n\n#include \u003csys/stat.h\u003e\n#include \u003csys/types.h\u003e\n#include \u003cdirent.h\u003e\n#include \u003cstring.h\u003e\n#include \u003cstdlib.h\u003e\n#include \u003cunistd.h\u003e\n#include \"LocalCapture.h\"\n#include \"SessionData.h\"\n#include \"Logging.h\"\n#include \"OlyUtility.h\"\n#include \"EventsXML.h\"\n\nLocalCapture::LocalCapture() {}\n\nLocalCapture::~LocalCapture() {}\n\nvoid LocalCapture::createAPCDirectory(char* target_path) {\n\tgSessionData-\u003emAPCDir = createUniqueDirectory(target_path, \".apc\");\n\tif ((removeDirAndAllContents(gSessionData-\u003emAPCDir) != 0 || mkdir(gSessionData-\u003emAPCDir, S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH) != 0)) {\n\t\tlogg-\u003elogError(__FILE__, __LINE__, \"Unable to create directory %s\", gSessionData-\u003emAPCDir);\n\t\thandleException();\n\t}\n}\n\nvoid LocalCapture::write(char* string) {\n\tchar file[PATH_MAX];\n\n\t// Set full path\n\tsnprintf(file, PATH_MAX, \"%s/session.xml\", gSessionData-\u003emAPCDir);\n\n\t// Write the file\n\tif (util-\u003ewriteToDisk(file, string) \u003c 0) {\n\t\tlogg-\u003elogError(__FILE__, __LINE__, \"Error writing %s\\nPlease verify the path.\", file);\n\t\thandleException();\n\t}\n\n\t// Write events XML\n\tEventsXML eventsXML;\n\teventsXML.write(gSessionData-\u003emAPCDir);\n}\n\nchar* LocalCapture::createUniqueDirectory(const char* initialPath, const char* ending) {\n\tchar* output;\n\tchar path[PATH_MAX];\n\n\t// Ensure the path is an absolute path, i.e. starts with a slash\n\tif (initialPath == 0 || strlen(initialPath) == 0) {\n\t\tlogg-\u003elogError(__FILE__, __LINE__, \"Missing -o command line option required for a local capture.\");\n\t\thandleException();\n\t} else if (initialPath[0] != '/') {\n\t\tif (getcwd(path, PATH_MAX) == 0) {\n\t\t\tlogg-\u003elogMessage(\"Unable to retrieve the current working directory\");\n\t\t}\n\t\tstrncat(path, \"/\", PATH_MAX - strlen(path) - 1);\n\t\tstrncat(path, initialPath, PATH_MAX - strlen(path) - 1);\n\t} else {\n\t\tstrncpy(path, initialPath, PATH_MAX);\n\t\tpath[PATH_MAX - 1] = 0; // strncpy does not guarantee a null-terminated string\n\t}\n\n\t// Add ending if it is not already there\n\tif (strcmp(\u0026path[strlen(path) - strlen(ending)], ending) != 0) {\n\t\tstrncat(path, ending, PATH_MAX - strlen(path) - 1);\n\t}\n\n\toutput = strdup(path);\n\n\treturn output;\n}\n\nint LocalCapture::removeDirAndAllContents(char* path) {\n\tint error = 0;\n\tstruct stat mFileInfo;\n\t// Does the path exist?\n\tif (stat(path, \u0026mFileInfo) == 0) {\n\t\t// Is it a directory?\n\t\tif (mFileInfo.st_mode \u0026 S_IFDIR) {\n\t\t\tDIR * dir = opendir(path);\n\t\t\tdirent* entry = readdir(dir);\n\t\t\twhile (entry) {\n\t\t\t\tif (strcmp(entry-\u003ed_name, \".\") != 0 \u0026\u0026 strcmp(entry-\u003ed_name, \"..\") != 0) {\n\t\t\t\t\tchar* newpath = (char*)malloc(strlen(path) + strlen(entry-\u003ed_name) + 2);\n\t\t\t\t\tsprintf(newpath, \"%s/%s\", path, entry-\u003ed_name);\n\t\t\t\t\terror = removeDirAndAllContents(newpath);\n\t\t\t\t\tfree(newpath);\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tentry = readdir(dir);\n\t\t\t}\n\t\t\tclosedir(dir);\n\t\t\tif (error == 0) {\n\t\t\t\terror = rmdir(path);\n\t\t\t}\n\t\t} else {\n\t\t\terror = remove(path);\n\t\t}\n\t}\n\treturn error;\n}\n\nvoid LocalCapture::copyImages(ImageLinkList* ptr) {\n\tchar dstfilename[PATH_MAX];\n\n\twhile (ptr) {\n\t\tstrncpy(dstfilename, gSessionData-\u003emAPCDir, PATH_MAX);\n\t\tdstfilename[PATH_MAX - 1] = 0; // strncpy does not guarantee a null-terminated string\n\t\tif (gSessionData-\u003emAPCDir[strlen(gSessionData-\u003emAPCDir) - 1] != '/') {\n\t\t\tstrncat(dstfilename, \"/\", PATH_MAX - strlen(dstfilename) - 1);\n\t\t}\n\t\tstrncat(dstfilename, util-\u003egetFilePart(ptr-\u003epath), PATH_MAX - strlen(dstfilename) - 1);\n\t\tif (util-\u003ecopyFile(ptr-\u003epath, dstfilename)) {\n\t\t\tlogg-\u003elogMessage(\"copied file %s to %s\", ptr-\u003epath, dstfilename);\n\t\t} else {\n\t\t\tlogg-\u003elogMessage(\"copy of file %s to %s failed\", ptr-\u003epath, dstfilename);\n\t\t}\n\n\t\tptr = ptr-\u003enext;\n\t}\n}\n"}
{"repo_name":"patmarion/PCL","ref":"refs/heads/master","path":"sample_consensus/src/ransac.cpp","copies":"5","language":"C++","content":"/*\n * Software License Agreement (BSD License)\n *\n *  Point Cloud Library (PCL) - www.pointclouds.org\n *  Copyright (c) 2009-2012, Willow Garage, Inc.\n *\n *  All rights reserved.\n *\n *  Redistribution and use in source and binary forms, with or without\n *  modification, are permitted provided that the following conditions\n *  are met:\n *\n *   * Redistributions of source code must retain the above copyright\n *     notice, this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above\n *     copyright notice, this list of conditions and the following\n *     disclaimer in the documentation and/or other materials provided\n *     with the distribution.\n *   * Neither the name of Willow Garage, Inc. nor the names of its\n *     contributors may be used to endorse or promote products derived\n *     from this software without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n *  \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n *\n * $Id$\n *\n */\n\n#include \u003cpcl/impl/instantiate.hpp\u003e\n#include \u003cpcl/point_types.h\u003e\n#include \u003cpcl/sample_consensus/ransac.h\u003e\n#include \u003cpcl/sample_consensus/impl/ransac.hpp\u003e\n\n// Instantiations of specific point types\n#ifdef PCL_ONLY_CORE_POINT_TYPES\n  PCL_INSTANTIATE(RandomSampleConsensus, (pcl::PointXYZ)(pcl::PointXYZI)(pcl::PointXYZRGBA)(pcl::PointXYZRGB))\n#else\n PCL_INSTANTIATE(RandomSampleConsensus, PCL_XYZ_POINT_TYPES)\n#endif\n"}
{"repo_name":"JoseBarrales/mlnc","ref":"refs/heads/master","path":"src/test/rpc_tests.cpp","copies":"113","language":"C++","content":"#include \u003cboost/test/unit_test.hpp\u003e\n#include \u003cboost/foreach.hpp\u003e\n\n#include \"base58.h\"\n#include \"util.h\"\n#include \"bitcoinrpc.h\"\n\nusing namespace std;\nusing namespace json_spirit;\n\nBOOST_AUTO_TEST_SUITE(rpc_tests)\n\nstatic Array\ncreateArgs(int nRequired, const char* address1=NULL, const char* address2=NULL)\n{\n    Array result;\n    result.push_back(nRequired);\n    Array addresses;\n    if (address1) addresses.push_back(address1);\n    if (address2) addresses.push_back(address1);\n    result.push_back(addresses);\n    return result;\n}\n\n// This can be removed this when addmultisigaddress is enabled on main net:\nstruct TestNetFixture\n{\n    TestNetFixture() { fTestNet = true; }\n    ~TestNetFixture() { fTestNet = false; }\n};\n\nBOOST_FIXTURE_TEST_CASE(rpc_addmultisig, TestNetFixture)\n{\n    rpcfn_type addmultisig = tableRPC[\"addmultisigaddress\"]-\u003eactor;\n\n    // old, 65-byte-long:\n    const char* address1Hex = \"0434e3e09f49ea168c5bbf53f877ff4206923858aab7c7e1df25bc263978107c95e35065a27ef6f1b27222db0ec97e0e895eaca603d3ee0d4c060ce3d8a00286c8\";\n    // new, compressed:\n    const char* address2Hex = \"0388c2037017c62240b6b72ac1a2a5f94da790596ebd06177c8572752922165cb4\";\n\n    Value v;\n    CBitcoinAddress address;\n    BOOST_CHECK_NO_THROW(v = addmultisig(createArgs(1, address1Hex), false));\n    address.SetString(v.get_str());\n    BOOST_CHECK(address.IsValid() \u0026\u0026 address.IsScript());\n\n    BOOST_CHECK_NO_THROW(v = addmultisig(createArgs(1, address1Hex, address2Hex), false));\n    address.SetString(v.get_str());\n    BOOST_CHECK(address.IsValid() \u0026\u0026 address.IsScript());\n\n    BOOST_CHECK_NO_THROW(v = addmultisig(createArgs(2, address1Hex, address2Hex), false));\n    address.SetString(v.get_str());\n    BOOST_CHECK(address.IsValid() \u0026\u0026 address.IsScript());\n\n    BOOST_CHECK_THROW(addmultisig(createArgs(0), false), runtime_error);\n    BOOST_CHECK_THROW(addmultisig(createArgs(1), false), runtime_error);\n    BOOST_CHECK_THROW(addmultisig(createArgs(2, address1Hex), false), runtime_error);\n\n    BOOST_CHECK_THROW(addmultisig(createArgs(1, \"\"), false), runtime_error);\n    BOOST_CHECK_THROW(addmultisig(createArgs(1, \"NotAValidPubkey\"), false), runtime_error);\n\n    string short1(address1Hex, address1Hex+sizeof(address1Hex)-2); // last byte missing\n    BOOST_CHECK_THROW(addmultisig(createArgs(2, short1.c_str()), false), runtime_error);\n\n    string short2(address1Hex+2, address1Hex+sizeof(address1Hex)); // first byte missing\n    BOOST_CHECK_THROW(addmultisig(createArgs(2, short2.c_str()), false), runtime_error);\n}\n\nBOOST_AUTO_TEST_SUITE_END()\n"}
{"repo_name":"RazZziel/sc_pong","ref":"refs/heads/master","path":"src/scfont.cpp","copies":"1","language":"C++","content":"/***************************************************************************\n *   Copyright (C) 2006 by Ismael Barros (Raziel)                          *\n *   razielmine@gmail.com                                                  *\n *                                                                         *\n *   This program is free software; you can redistribute it and/or modify  *\n *   it under the terms of the GNU General Public License as published by  *\n *   the Free Software Foundation; either version 2 of the License, or     *\n *   (at your option) any later version.                                   *\n *                                                                         *\n *   This program is distributed in the hope that it will be useful,       *\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *\n *   GNU General Public License for more details.                          *\n *                                                                         *\n *   You should have received a copy of the GNU General Public License     *\n *   along with this program; if not, write to the                         *\n *   Free Software Foundation, Inc.,                                       *\n *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *\n ***************************************************************************/\n\n\n\n#include \u003cstdlib.h\u003e\n#include \u003cstring.h\u003e\n\n#include \"SDL/SDL.h\"\n#include \"SDL/SDL_image.h\"\n\n#include \"scfont.h\"\n\n\n\nScFont *ScLoadFont(const char *filename) {\n\t\n\tScFont *font = (ScFont*) malloc(sizeof(ScFont));\n\t\n\t/* Header */\n\t\n\tFILE *file = fopen(filename, \"r\");\n\tfread((void*)\u0026font-\u003eheader, sizeof(ScFontHeader), 1, file);\n\t\n\t//printf(\"%d %d %d %d\\n\", font-\u003eheader.maxWidth, font-\u003eheader.maxHeight, font-\u003eheader.lowIndex, font-\u003eheader.highIndex);\n\t\n\t/* Letters */\n\t\n\t// Offsets\n\t\n\tint n_offsets = font-\u003eheader.highIndex - font-\u003eheader.lowIndex;\n\tUint32 *offsets = (Uint32*) malloc(sizeof(Uint32)*(n_offsets+1)); // +1 to allocate EoF\n\t\n\tfseek(file, sizeof(ScFontHeader), SEEK_SET);\n\tfread((void*)offsets, sizeof(Uint32), n_offsets, file);\n\t\n\tfseek(file, 0, SEEK_END);\n\toffsets[n_offsets] = ftell(file);  // End of file\n\t\n\t// Letters\n\t\n\tfont-\u003eletters = (ScLetter*) malloc(sizeof(ScLetter)*(n_offsets+1)); // +1 to allocate 1st character, the space\n\t\n\tfor (int i=1; i\u003c=n_offsets; i++) {\n\t\t\n\t\tif (offsets[i-1]) {\n\t\t\t\n\t\t\t/* Header */\n\t\t\t\n\t\t\tfseek(file, offsets[i-1], SEEK_SET);\n\t\t\tfread((void*)\u0026font-\u003eletters[i].header, sizeof(ScLetterHeader), 1, file);\n\t\t\t\n\t\t\t/*\n\t\t\tprintf(\"(%d) %d: %d %d %d %d\\n\", offsets[i-1], i + font-\u003eheader.lowIndex,\n\t\t\t\t\t\t\t\t\t\t\tfont-\u003eletters[i].header.x,\n\t\t\t\t\t\t\t\t\t\t\tfont-\u003eletters[i].header.y,\n\t\t\t\t\t\t\t\t\t\t\tfont-\u003eletters[i].header.w,\n\t\t\t\t\t\t\t\t\t\t\tfont-\u003eletters[i].header.h);\n\t\t\tgetchar();\n\t\t\t*/\n\t\t\t\n\t\t\t/* Pixels */\n\t\t\t\n\t\t\t// Searching first higher offset not equal to 0\n\t\t\t// (Some fonts lack some letters)\n\t\t\tint next_offset = offsets[i];\n\t\t\tfor (int o=0; !next_offset; o++) {\n\t\t\t\tnext_offset = offsets[i+o];\n\t\t\t}\n\t\t\t\n\t\t\tfont-\u003eletters[i].n_pixels = next_offset  - (offsets[i-1] + sizeof(ScLetterHeader)) - 1;\n\t\t\tfont-\u003eletters[i].pixels = (Uint8*) malloc(sizeof(Uint8)*font-\u003eletters[i].n_pixels);\n\t\t\t\n\t\t\tfseek(file, (offsets[i-1] + sizeof(ScLetterHeader)), SEEK_SET);\n\t\t\tfread((void*)font-\u003eletters[i].pixels, sizeof(Uint8), font-\u003eletters[i].n_pixels, file);\n\t\t\t\n\t\t} else\n\t\t\tfont-\u003eletters[i].n_pixels = -1;\n\t\t\n\t}\n\t\n\t// Space character will not be drawn, but will have a determined width\n\tfont-\u003eletters[0].n_pixels = 0;\n\tfont-\u003eletters[0].header.x = 0;\n\tfont-\u003eletters[0].header.y = 0;\n\tfont-\u003eletters[0].header.h = 0;\n\tfont-\u003eletters[0].header.w = font-\u003eheader.maxWidth/2; //font-\u003eletters[1].header.h-2;\n\t\n\tfree(offsets);\n\tfclose(file);\n\t\n\treturn font;\n\t\n}\n\nScPalette *ScLoadPalette(const char *filename) {\n\t\n\tScPalette *palette = (ScPalette*) malloc(sizeof(ScPalette));\n\t\n\tSDL_Surface *s_palette;\n\tif ((s_palette = SDL_DisplayFormat(IMG_Load(filename))) == NULL) {\n\t\tfprintf(stderr, \"ERROR: Cannot load palette '%s'\", filename);\n\t\texit(1);\n\t}\n\t\n\tmemcpy(*palette, s_palette-\u003epixels, s_palette-\u003eformat-\u003eBytesPerPixel*s_palette-\u003ew);\n\t\n\t/*\n\tfor (int i=0; i\u003cs_palette-\u003ew; i++) {\n\t\tSDL_Color c;\n\t\tSDL_GetRGB((*palette)[i], SDL_GetVideoSurface()-\u003eformat, \u0026c.r, \u0026c.g, \u0026c.b);\n\t\tprintf(\"%d - %d %d %d\\n\", i, c.r, c.g, c.b);\n\t}\n\tgetchar();\n\t*/\n\t\n\tSDL_FreeSurface(s_palette);\n\t\n\treturn palette;\n\t\n}\n\n\nSDL_Surface *ScRenderChar(unsigned const char car, ScFont *font, ScColor *color) {\n\t\n\tSDL_Surface *screen = SDL_GetVideoSurface();\n\t\n\tint index = car - font-\u003eheader.lowIndex;\n\t\n\tif ((car \u003c font-\u003eheader.lowIndex) || (car \u003e font-\u003eheader.highIndex) || (font-\u003eletters[index].n_pixels \u003c 0)) {\n\t\tfprintf(stderr, \"ERROR (ScRenderChar): Invalid character index %d\\n\", car);\n\t\treturn NULL;\n\t}\n\t\n\tSDL_Surface *letter = SDL_CreateRGBSurface(SDL_SWSURFACE,\n\t\t\tfont-\u003eletters[index].header.w, font-\u003eletters[index].header.h,\n\t\t\tscreen-\u003eformat-\u003eBitsPerPixel, screen-\u003eformat-\u003eRmask,\n\t\t\tscreen-\u003eformat-\u003eGmask, screen-\u003eformat-\u003eBmask,\n\t\t\tscreen-\u003eformat-\u003eAmask);\n\t\n\tif (font-\u003eletters[index].header.h \u003e 0) {\n\t\tchar *pixels = (char*) letter-\u003epixels - letter-\u003eformat-\u003eBytesPerPixel;\n\t\t\n\t\tfor (int p=0; p\u003cfont-\u003eletters[index].n_pixels; p++) {\n\t\t\t\n\t\t\tUint8 skip = font-\u003eletters[index].pixels[p] \u003e\u003e 3;       // 11111000\n\t\t\tUint8 gamma = font-\u003eletters[index].pixels[p] \u0026 7;       // 00000111\n\t\t\t\n\t\t\tpixels += skip * letter-\u003eformat-\u003eBytesPerPixel + letter-\u003eformat-\u003eBytesPerPixel;\n\t\t\t//printf(\"--%d\\n\", gamma);\n\t\t\tmemcpy(pixels, *color+gamma, letter-\u003eformat-\u003eBytesPerPixel);\n\t\t\t\n\t\t}\n\t\t\n\t\tSDL_SetColorKey(letter, SDL_SRCCOLORKEY|SDL_RLEACCEL, 0);\n\t\t\n\t}\n\t\n\tSDL_Surface *final_letter = SDL_CreateRGBSurface(SDL_SWSURFACE,\n\t\t\tfont-\u003eletters[index].header.w, font-\u003eheader.maxHeight,\n\t\t\tscreen-\u003eformat-\u003eBitsPerPixel, screen-\u003eformat-\u003eRmask,\n\t\t\tscreen-\u003eformat-\u003eGmask, screen-\u003eformat-\u003eBmask,\n\t\t\tscreen-\u003eformat-\u003eAmask);\n\t\n\t//SDL_Rect bleh = {0, 0, final_letter-\u003ew, final_letter-\u003eh};/\n\t//SDL_FillRect(final_letter, \u0026bleh, 0x000000FF);\n\t\n\tSDL_Rect offset = {font-\u003eletters[index].header.x, font-\u003eletters[index].header.y, 0, 0};\n\tSDL_BlitSurface(letter, NULL, final_letter, \u0026offset);\n\tSDL_FreeSurface(letter);\n\t\n\tSDL_SetColorKey(final_letter, SDL_SRCCOLORKEY|SDL_RLEACCEL, 0);\n\t\n\treturn final_letter;\n\t\n}\n\nint calculateWidth(const unsigned char *text, ScFont *font, char delim) {\n\t\n\tint width = 0;\n\t\n\twhile (*text) {                                                      //  \u003c- one exta pixel to space letters\n\t\tif (*text != delim) width += font-\u003eletters[*text - font-\u003eheader.lowIndex].header.w + 1;\n\t\ttext++;\n\t}\n\t\n\treturn width-1;\n\t\n}\n\nSDL_Surface *ScRenderText(const char *text, ScFont *font, ScColor *color, ScColor *color_hi, char delim) {\n\n\t/*\n\t\tRenders the selected 'text' with the selected 'font'.\n\t\tBy default, the text is rendered with 'color', but if a 'color_hi' and\n\t\ta 'delim'iter are specifyed, the characters surrounded by two occurences\n\t\tof 'delim' will be rendered in 'color_hi' (this is: they are highlighted).\n\t*/\n\n\tSDL_Surface *screen = SDL_GetVideoSurface();\n\t\n\tSDL_Surface *s_text = SDL_CreateRGBSurface(SDL_SWSURFACE,\n\t\t\t\t\t\tcalculateWidth((unsigned char*)text, font, delim), font-\u003eheader.maxHeight,\n\t\t\t\t\t\tscreen-\u003eformat-\u003eBitsPerPixel, screen-\u003eformat-\u003eRmask,\n\t\t\t\t\t\tscreen-\u003eformat-\u003eGmask, screen-\u003eformat-\u003eBmask,\n\t\t\t\t\t\tscreen-\u003eformat-\u003eAmask);\n\t\n\tSDL_SetColorKey(s_text, SDL_SRCCOLORKEY|SDL_RLEACCEL, 0);\n\t\n\tSDL_Surface *s_char;\n\t\n\tSDL_Rect offset = {0, 0, 0, 0};\n\t\n\tif (color_hi) {\n\t\t\n\t\tScColor *actual_color = color;\n\t\t\n\t\twhile(*text) {\n\t\t\t\n\t\t\t// Color change\n\t\t\tif (*text == delim) {\n\t\t\t\tif (actual_color == color)\n\t\t\t\t\tactual_color = color_hi;\n\t\t\t\telse\n\t\t\t\t\tactual_color = color;\n\t\t\t\t\n\t\t\t// Char rendering\n\t\t\t} else {\n\t\t\t\tif ((s_char = ScRenderChar(*text, font, actual_color))) {\n\t\t\t\t\tSDL_BlitSurface(s_char, NULL, s_text, \u0026offset);\n\t\t\t\t\toffset.x += s_char-\u003ew + 1;\n\t\t\t\t\tSDL_FreeSurface(s_char);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\ttext++;\n\t\t\t\n\t\t}\n\t\t\n\t} else {\n\t\t\n\t\twhile(*text) {\n\t\t\tif (*text != delim) {\n\t\t\t\tif ((s_char = ScRenderChar(*text, font, color))) {\n\t\t\t\t\tSDL_BlitSurface(s_char, NULL, s_text, \u0026offset);\n\t\t\t\t\toffset.x += s_char-\u003ew + 1;\n\t\t\t\t\tSDL_FreeSurface(s_char);\n\t\t\t\t}\n\t\t\t}\n\t\t\ttext++;\n\t\t}\n\t\t\n\t}\n\t\n\treturn s_text;\n\t\n}\n\nScColor *ScGetColor(const ScPalette *palette, int index) {\n\t\n\t/*\n\tfor (int i=0; i\u003c48; i++) {\n\t\tSDL_Color c;\n\t\tSDL_GetRGB((*palette)[i], SDL_GetVideoSurface()-\u003eformat, \u0026c.r, \u0026c.g, \u0026c.b);\n\t\tprintf(\"(%d %d %d) \", c.r, c.g, c.b);\n\t}\n\tprintf(\"\\n\");\n\t*/\n\t\n\tScColor *color = (ScColor*) malloc(sizeof(ScColor));\n\tmemcpy(*color, *palette + (index * MAX_GAMMA), sizeof(ScColor));\n\t\n\t/*\n\tprintf(\"\u003e%x %d\\n\", palette, index);\n\tfor (int i=0; i\u003c8; i++) {\n\t\tSDL_Color c;\n\t\tSDL_GetRGB((*color)[i], SDL_GetVideoSurface()-\u003eformat, \u0026c.r, \u0026c.g, \u0026c.b);\n\t\tprintf(\"(%d %d %d) \", c.r, c.g, c.b);\n\t}\n\tprintf(\"\\n\");\n\tgetchar();\n\t*/\n\t\n\treturn color;\n\t\n}\n\nvoid ScTestFont(ScFont *font, ScPalette *palette) {\n\t\n#define TEST_SDL\n\t\n\tSDL_Surface *screen = SDL_GetVideoSurface();\n\t\n\tSDL_FillRect(screen, NULL, SDL_MapRGB(SDL_GetVideoSurface()-\u003eformat, 255, 255, 255));\n\tSDL_Flip(screen);\n\t\n#ifdef TEST_SDL\n\t\n\tSDL_Rect offset = {10, 10, 0, 0};\n\tSDL_BlitSurface(ScRenderText(\"El veloz murci�ago hind\", font, ScGetColor(palette, 1)),\n\t\t\tNULL, screen, \u0026offset);\n\toffset.y += font-\u003eheader.maxHeight+2;\n\tSDL_BlitSurface(ScRenderText(\"Juiporentenderlas\", font, ScGetColor(palette, 5)),\n\t\t\tNULL, screen, \u0026offset);\n\toffset.y += font-\u003eheader.maxHeight+2;\n\tSDL_BlitSurface(ScRenderText(\"_S_ingle Player\", font, ScGetColor(palette, 1), ScGetColor(palette, 2), '_'),\n\t\t\tNULL, screen, \u0026offset);\n\toffset.y += font-\u003eheader.maxHeight+2;\n\t\n#endif\n\t\n\tfor (int i=font-\u003eheader.lowIndex; i\u003c=font-\u003eheader.highIndex; i++) {\n\t\t\n#ifdef TEST_SDL\n\t\t\n\t\tSDL_Surface *s_char = ScRenderChar(i, font, ScGetColor(palette, 2));\n\t\t\n\t\tif (s_char) {\n\t\t\tSDL_BlitSurface(s_char, NULL, screen, \u0026offset);\n\t\t\tSDL_FreeSurface(s_char);\n\t\t}\n\t\t\n\t\tif ((offset.x += font-\u003eheader.maxWidth+2) \u003e (screen-\u003ew - font-\u003eheader.maxWidth - 10)) {\n\t\t\toffset.x = 10;\n\t\t\toffset.y += font-\u003eheader.maxHeight+2;\n\t\t}\n\t\t\n\t\t\n#else\n\t\tint index = i - font-\u003eheader.lowIndex;\n\t\t\n\t\tint x = 1;\n\t\tfor (int p=0; p\u003cfont-\u003eletters[index].n_pixels; p++)\n\t\t\tprintf(\"%d \", (font-\u003eletters[i].pixels[p] \u003e\u003e 3));\n\t\tprintf(\"\\n\");\n\t\t\n\t\tfor (int p=0; p\u003cfont-\u003eletters[index].n_pixels; p++) {\n\t\t\t\n\t\t\tUint8 skip = font-\u003eletters[index].pixels[p] \u003e\u003e 3;\t// 11111000\n\t\t\tUint8 color = font-\u003eletters[index].pixels[p] \u0026 7;\t// 00000111\n\t\t\t\n\t\t\tfor (int j=0; j\u003cskip; j++) {\n\t\t\t\tprintf(\" \");\n\t\t\t\tif (x++ == font-\u003eletters[index].header.w) {\n\t\t\t\t\tprintf(\"\\n\");\n\t\t\t\t\tx = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"%d\", color);\n\t\t\t//printf(\"#\");\n\t\t\tif (x++ == font-\u003eletters[index].header.w) {\n\t\t\t\tprintf(\"\\n\");\n\t\t\t\tx = 1;\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t\tprintf(\"\\ntest end\\n\");\n\t\tgetchar();\n\t\t\n#endif\n\t\t\n\t}\n\t\n\tSDL_Flip(screen);\n\t*screen = *SDL_CreateRGBSurface(SDL_SWSURFACE, screen-\u003ew, screen-\u003eh,\n\t\t\t\t\tscreen-\u003eformat-\u003eBitsPerPixel, screen-\u003eformat-\u003eRmask,\n\t\t\t\t\tscreen-\u003eformat-\u003eGmask, screen-\u003eformat-\u003eBmask,\n\t\t\t\t\tscreen-\u003eformat-\u003eAmask);\n\t\n\tgetchar();\n\t\n}\n\n"}
{"repo_name":"boiled-sugar/mkvtoolnix","ref":"refs/heads/master","path":"src/output/p_mpeg4_p2.cpp","copies":"2","language":"C++","content":"/*\n   mkvmerge -- utility for splicing together matroska files\n   from component media subtypes\n\n   Distributed under the GPL v2\n   see the file COPYING for details\n   or visit http://www.gnu.org/copyleft/gpl.html\n\n   MPEG4 part 2 video output module\n\n   Written by Moritz Bunkus \u003cmoritz@bunkus.org\u003e.\n*/\n\n#include \"common/common_pch.h\"\n\n#include \"avilib.h\"\n#include \"common/codec.h\"\n#include \"common/endian.h\"\n#include \"common/hacks.h\"\n#include \"common/math.h\"\n#include \"common/strings/formatting.h\"\n#include \"merge/generic_reader.h\"\n#include \"merge/output_control.h\"\n#include \"output/p_mpeg4_p2.h\"\n\nmpeg4_p2_video_packetizer_c::\nmpeg4_p2_video_packetizer_c(generic_reader_c *p_reader,\n                            track_info_c \u0026p_ti,\n                            double fps,\n                            int width,\n                            int height,\n                            bool input_is_native)\n  : video_for_windows_packetizer_c(p_reader, p_ti, fps, width, height)\n  , m_timecodes_generated(0)\n  , m_previous_timecode(0)\n  , m_aspect_ratio_extracted(false)\n  , m_input_is_native(input_is_native)\n  , m_output_is_native(hack_engaged(ENGAGE_NATIVE_MPEG4) || input_is_native)\n  , m_size_extracted(false)\n{\n  if (!m_output_is_native)\n    m_timestamp_factory_application_mode = TFA_SHORT_QUEUEING;\n\n  else {\n    set_codec_id(MKV_V_MPEG4_ASP);\n    if (!m_input_is_native)\n      m_ti.m_private_data.reset();\n\n    // If no external timecode file has been specified then mkvmerge\n    // might have created a factory due to the --default-duration\n    // command line argument. This factory must be disabled for this\n    // packetizer because it takes care of handling the default\n    // duration/FPS itself.\n    if (m_ti.m_ext_timecodes.empty())\n      m_timestamp_factory.reset();\n\n    if (m_default_duration_forced)\n      m_fps = 1000000000.0 / m_htrack_default_duration;\n\n    else if (0.0 != m_fps)\n      m_htrack_default_duration = static_cast\u003cint64_t\u003e(1000000000ll / m_fps);\n\n    m_timestamp_factory_application_mode = TFA_FULL_QUEUEING;\n  }\n}\n\nmpeg4_p2_video_packetizer_c::~mpeg4_p2_video_packetizer_c() {\n  if (!debugging_c::requested(\"mpeg4_p2_statistics\"))\n    return;\n\n  mxinfo(boost::format(\"mpeg4_p2_video_packetizer_c statistics:\\n\"\n                       \"  # I frames:            %1%\\n\"\n                       \"  # P frames:            %2%\\n\"\n                       \"  # B frames:            %3%\\n\"\n                       \"  # NVOPs:               %4%\\n\"\n                       \"  # generated timecodes: %5%\\n\"\n                       \"  # dropped timecodes:   %6%\\n\")\n         % m_statistics.m_num_i_frames % m_statistics.m_num_p_frames % m_statistics.m_num_b_frames % m_statistics.m_num_n_vops\n         % m_statistics.m_num_generated_timecodes % m_statistics.m_num_dropped_timecodes);\n}\n\nint\nmpeg4_p2_video_packetizer_c::process(packet_cptr packet) {\n  extract_size(packet-\u003edata-\u003eget_buffer(), packet-\u003edata-\u003eget_size());\n  extract_aspect_ratio(packet-\u003edata-\u003eget_buffer(), packet-\u003edata-\u003eget_size());\n\n  int result = m_input_is_native == m_output_is_native ? video_for_windows_packetizer_c::process(packet)\n             : m_input_is_native                       ?                     process_native(packet)\n             :                                                               process_non_native(packet);\n\n  ++m_frames_output;\n\n  return result;\n}\n\nint\nmpeg4_p2_video_packetizer_c::process_non_native(packet_cptr packet) {\n  extract_config_data(packet);\n\n  // Add a timecode and a duration if they've been given.\n  if (-1 != packet-\u003etimecode) {\n    if (!m_default_duration_forced)\n      m_available_timecodes.push_back(timecode_duration_t(packet-\u003etimecode, packet-\u003eduration));\n\n    else {\n      m_available_timecodes.push_back(timecode_duration_t(m_timecodes_generated * m_htrack_default_duration, m_htrack_default_duration));\n      ++m_timecodes_generated;\n    }\n\n  } else if (0.0 == m_fps)\n    mxerror_tid(m_ti.m_fname, m_ti.m_id, Y(\"Cannot convert non-native MPEG4 video frames into native ones if the source container \"\n                                       \"provides neither timecodes nor a number of frames per second.\\n\"));\n\n  std::vector\u003cvideo_frame_t\u003e frames;\n  mpeg4::p2::find_frame_types(packet-\u003edata-\u003eget_buffer(), packet-\u003edata-\u003eget_size(), frames, m_config_data);\n\n  for (auto \u0026frame : frames) {\n    if (!frame.is_coded) {\n      ++m_statistics.m_num_n_vops;\n\n      int num_surplus_timecodes = static_cast\u003cint\u003e(m_available_timecodes.size()) - static_cast\u003cint\u003e(m_ref_frames.size() + m_b_frames.size());\n      if (0 \u003c num_surplus_timecodes) {\n        std::deque\u003ctimecode_duration_t\u003e::iterator start = m_available_timecodes.begin() + m_ref_frames.size() + m_b_frames.size();\n        std::deque\u003ctimecode_duration_t\u003e::iterator end   = start + num_surplus_timecodes;\n\n        if (0 != (m_ref_frames.size() + m_b_frames.size())) {\n          std::deque\u003ctimecode_duration_t\u003e::iterator last = m_available_timecodes.begin() + m_ref_frames.size() + m_b_frames.size() - 1;\n          std::deque\u003ctimecode_duration_t\u003e::iterator cur  = start;\n          while (cur != end) {\n            last-\u003em_duration = std::max(last-\u003em_duration, static_cast\u003cint64_t\u003e(0)) + std::max(cur-\u003em_duration, static_cast\u003cint64_t\u003e(0));\n            ++cur;\n          }\n        }\n\n        m_available_timecodes.erase(start, end);\n        m_statistics.m_num_dropped_timecodes += num_surplus_timecodes;\n      }\n\n      continue;\n    }\n\n    if (FRAME_TYPE_I == frame.type)\n      ++m_statistics.m_num_i_frames;\n    else if (FRAME_TYPE_P == frame.type)\n      ++m_statistics.m_num_p_frames;\n    else\n      ++m_statistics.m_num_b_frames;\n\n    // Maybe we can flush queued frames now. But only if we don't have\n    // a B frame.\n    if (FRAME_TYPE_B != frame.type)\n      flush_frames(false);\n\n    frame.data     = (unsigned char *)safememdup(packet-\u003edata-\u003eget_buffer() + frame.pos, frame.size);\n    frame.timecode = -1;\n\n    if (FRAME_TYPE_B == frame.type)\n      m_b_frames.push_back(frame);\n    else\n      m_ref_frames.push_back(frame);\n  }\n\n  m_previous_timecode = m_available_timecodes.back().m_timecode;\n\n  return FILE_STATUS_MOREDATA;\n}\n\nvoid\nmpeg4_p2_video_packetizer_c::extract_config_data(packet_cptr \u0026packet) {\n  if (m_ti.m_private_data)\n    return;\n\n  m_ti.m_private_data = memory_cptr{mpeg4::p2::parse_config_data(packet-\u003edata-\u003eget_buffer(), packet-\u003edata-\u003eget_size(), m_config_data)};\n  if (!m_ti.m_private_data)\n    mxerror_tid(m_ti.m_fname, m_ti.m_id, Y(\"Could not find the codec configuration data in the first MPEG-4 part 2 video frame. This track cannot be stored in native mode.\\n\"));\n\n  fix_codec_string();\n  set_codec_private(m_ti.m_private_data);\n  rerender_track_headers();\n}\n\nvoid\nmpeg4_p2_video_packetizer_c::fix_codec_string() {\n  static const unsigned char start_code[4] = {0x00, 0x00, 0x01, 0xb2};\n\n  if (!m_ti.m_private_data || (0 == m_ti.m_private_data-\u003eget_size()))\n    return;\n\n  auto private_data = m_ti.m_private_data-\u003eget_buffer();\n  int size = m_ti.m_private_data-\u003eget_size();\n  int i;\n  for (i = 0; 9 \u003c size;) {\n    if (memcmp(\u0026private_data[i], start_code, 4) != 0) {\n      ++i;\n      --size;\n      continue;\n    }\n\n    i    += 8;\n    size -= 8;\n    if (strncasecmp((const char *)\u0026private_data[i - 4], \"divx\", 4) != 0)\n      continue;\n\n    unsigned char *end_pos = (unsigned char *)memchr(\u0026private_data[i], 0, size);\n    if (!end_pos)\n      end_pos = \u0026private_data[i + size];\n\n    --end_pos;\n    if ('p' == *end_pos)\n      *end_pos = 'n';\n\n    return;\n  }\n}\n\nint\nmpeg4_p2_video_packetizer_c::process_native(packet_cptr) {\n  // Not implemented yet.\n  return FILE_STATUS_MOREDATA;\n}\n\n/** \\brief Handle frame sequences in which too few timecodes are available\n\n   This function gets called if mkvmerge wants to flush its frame queue\n   but it doesn't have enough timecodes and/or durations available for\n   each queued frame. This can happen in two cases:\n\n   1. A picture sequence is found that mkvmerge does not support. An\n      example: Two frames have been read. The first contained a\n      P and a B frame (that's OK so far), but the second one contained\n      another P or I frame without an intermediate dummy frame.\n\n   2. The end of the file has been reached but the frame queue contains\n      more frames than the timecode queue. For example: The last frame\n      contained two frames, a P and a B frame. Right afterwards the\n      end of the file is reached. In this case a dummy frame is missing.\n\n   Both cases can be solved if the source file provides a FPS for this\n   track. The other case is not supported.\n*/\nvoid\nmpeg4_p2_video_packetizer_c::generate_timecode_and_duration() {\n  if (0.0 \u003e= m_fps) {\n    // TODO: error\n    mxexit(1);\n  }\n\n  if (m_available_timecodes.empty()) {\n    m_previous_timecode = (int64_t)(m_previous_timecode + 1000000000.0 / m_fps);\n    m_available_timecodes.push_back(timecode_duration_t(m_previous_timecode, (int64_t)(1000000000.0 / m_fps)));\n\n    mxverb(3, boost::format(\"mpeg4_p2::flush_frames(): Needed new timecode %1%\\n\") % m_previous_timecode);\n    ++m_statistics.m_num_generated_timecodes;\n  }\n}\n\nvoid\nmpeg4_p2_video_packetizer_c::get_next_timecode_and_duration(int64_t \u0026timecode,\n                                                            int64_t \u0026duration) {\n  if (m_available_timecodes.empty())\n    generate_timecode_and_duration();\n\n  timecode = m_available_timecodes.front().m_timecode;\n  duration = m_available_timecodes.front().m_duration;\n\n  m_available_timecodes.pop_front();\n}\n\nvoid\nmpeg4_p2_video_packetizer_c::flush_frames(bool end_of_file) {\n  if (m_ref_frames.empty())\n    return;\n\n  if (m_ref_frames.size() == 1) {\n    video_frame_t \u0026frame = m_ref_frames.front();\n\n    // The first frame in the file. Only apply the timecode, nothing else.\n    if (-1 == frame.timecode) {\n      get_next_timecode_and_duration(frame.timecode, frame.duration);\n      add_packet(new packet_t(new memory_c(frame.data, frame.size, true), frame.timecode, frame.duration));\n    }\n    return;\n  }\n\n  video_frame_t \u0026bref_frame = m_ref_frames.front();\n  video_frame_t \u0026fref_frame = m_ref_frames.back();\n\n  for (auto \u0026frame : m_b_frames)\n    get_next_timecode_and_duration(frame.timecode, frame.duration);\n  get_next_timecode_and_duration(fref_frame.timecode, fref_frame.duration);\n\n  add_packet(new packet_t(new memory_c(fref_frame.data, fref_frame.size, true), fref_frame.timecode, fref_frame.duration, FRAME_TYPE_P == fref_frame.type ? bref_frame.timecode : VFT_IFRAME));\n  for (auto \u0026frame : m_b_frames)\n    add_packet(new packet_t(new memory_c(frame.data, frame.size, true), frame.timecode, frame.duration, bref_frame.timecode, fref_frame.timecode));\n\n  m_ref_frames.pop_front();\n  m_b_frames.clear();\n\n  if (end_of_file)\n    m_ref_frames.clear();\n}\n\nvoid\nmpeg4_p2_video_packetizer_c::flush_impl() {\n  flush_frames(true);\n}\n\nvoid\nmpeg4_p2_video_packetizer_c::extract_aspect_ratio(const unsigned char *buffer,\n                                                  int size) {\n  if (m_aspect_ratio_extracted)\n    return;\n\n  if ((0 != m_connected_to) || display_dimensions_or_aspect_ratio_set()) {\n    m_aspect_ratio_extracted = true;\n    return;\n  }\n\n  uint32_t num, den;\n  if (mpeg4::p2::extract_par(buffer, size, num, den)) {\n    m_aspect_ratio_extracted = true;\n    set_video_aspect_ratio((double)m_hvideo_pixel_width / (double)m_hvideo_pixel_height * (double)num / (double)den, false, OPTION_SOURCE_BITSTREAM);\n\n    generic_packetizer_c::set_headers();\n    rerender_track_headers();\n    mxinfo_tid(m_ti.m_fname, m_ti.m_id,\n               boost::format(Y(\"Extracted the aspect ratio information from the MPEG4 layer 2 video data and set the display dimensions to %1%/%2%.\\n\"))\n               % m_hvideo_display_width % m_hvideo_display_height);\n\n  } else if (50 \u003c= m_frames_output)\n    m_aspect_ratio_extracted = true;\n}\n\nvoid\nmpeg4_p2_video_packetizer_c::extract_size(const unsigned char *buffer,\n                                          int size) {\n  if (m_size_extracted)\n    return;\n\n  if (0 != m_connected_to) {\n    m_size_extracted = true;\n    return;\n  }\n\n  uint32_t xtr_width, xtr_height;\n\n  if (mpeg4::p2::extract_size(buffer, size, xtr_width, xtr_height)) {\n    m_size_extracted = true;\n\n    if (!m_reader-\u003em_appending \u0026\u0026 ((xtr_width != static_cast\u003cuint32_t\u003e(m_hvideo_pixel_width)) || (xtr_height != static_cast\u003cuint32_t\u003e(m_hvideo_pixel_height)))) {\n      set_video_pixel_width(xtr_width);\n      set_video_pixel_height(xtr_height);\n\n      if (!m_output_is_native \u0026\u0026 m_ti.m_private_data \u0026\u0026 (sizeof(alBITMAPINFOHEADER) \u003c= m_ti.m_private_data-\u003eget_size())) {\n        auto bih = reinterpret_cast\u003calBITMAPINFOHEADER *\u003e(m_ti.m_private_data-\u003eget_buffer());\n        put_uint32_le(\u0026bih-\u003ebi_width,  xtr_width);\n        put_uint32_le(\u0026bih-\u003ebi_height, xtr_height);\n        set_codec_private(m_ti.m_private_data);\n      }\n\n      m_hvideo_display_width  = -1;\n      m_hvideo_display_height = -1;\n\n      generic_packetizer_c::set_headers();\n      rerender_track_headers();\n\n      mxinfo_tid(m_ti.m_fname, m_ti.m_id,\n                 boost::format(Y(\"The extracted values for video width and height from the MPEG4 layer 2 video data bitstream differ from what the values \"\n                                 \"in the source container. The ones from the video data bitstream (%1%x%2%) will be used.\\n\")) % xtr_width % xtr_height);\n    }\n\n  } else if (50 \u003c= m_frames_output)\n    m_aspect_ratio_extracted = true;\n}\n"}
{"repo_name":"attackjz/Cocos2d-x_CustomSliderList","ref":"refs/heads/master","path":"CustomSliderList/cocos2d/cocos/platform/winrt/CCFreeTypeFont.cpp","copies":"92","language":"C++","content":"/****************************************************************************\n Copyright (c) 2013      cocos2d-x.org   http://cocos2d-x.org\n Copyright (c) Microsoft Open Technologies, Inc.\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n \n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n \n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n ****************************************************************************/\n\n#include \"CCFreeTypeFont.h\"\n#include \"base/CCDirector.h\"\n#include \"platform/CCFileUtils.h\"\n\n#if (CC_TARGET_PLATFORM != CC_PLATFORM_WP8)\n#include \u003cdwrite.h\u003e\n#endif\n#include \u003cmap\u003e\n#include \u003cstring\u003e\n#include \u003csstream\u003e\n#include \u003cvector\u003e\n#include \u003cmemory\u003e\n#include \u003calgorithm\u003e\n\nusing namespace std;\n\nNS_CC_BEGIN\n\nstatic map\u003cstd::string, FontBufferInfo\u003e s_fontsNames;\nstatic FT_Library s_FreeTypeLibrary = nullptr;\n\nCCFreeTypeFont::CCFreeTypeFont() \n    :m_space(\" \")\n    , m_face(nullptr)\n{\n\n}\n\nCCFreeTypeFont::~CCFreeTypeFont() \n{\n    reset();\n}\n\nvoid CCFreeTypeFont::reset()\n{\n    for(auto line:m_lines)\n    {\n        line-\u003eglyphs.clear();\n        delete line;\n    }\n\n    m_lines.clear();\n\n\tif(m_face)\n\t{\n\t\tFT_Done_Face(m_face);\n\t    m_face = nullptr;\n\t}\n}\n\nunsigned char* CCFreeTypeFont::initWithString(const char * text, const FontDefinition\u0026 textDefinition, Device::TextAlign align, int \u0026width, int \u0026height, ssize_t\u0026 dataLength)\n{\n\tFT_Error error = 0;\n\tssize_t size = 0;\n    unsigned char* pBuffer = nullptr;\n    unsigned char* data = nullptr;\n\n    Size winSize = Director::getInstance()-\u003egetWinSizeInPixels();\n    m_windowWidth = (int)winSize.width;\n\n    m_inWidth = textDefinition._dimensions.width;\n    m_inHeight = textDefinition._dimensions.height;\n\n    m_fontFillColorR = textDefinition._fontFillColor.r;\n    m_fontFillColorG = textDefinition._fontFillColor.g;\n    m_fontFillColorB = textDefinition._fontFillColor.b;\n\n#if 0\n    // check the cache for the font file buffer\n    auto ittFontNames = s_fontsNames.find(textDefinition._fontName);\n    if(ittFontNames != s_fontsNames.end()) \n    {\n        pBuffer = ittFontNames-\u003esecond.pBuffer;\n        size = ittFontNames-\u003esecond.size;\n    }  \n#endif // 0\n\n    \n\tif(!pBuffer)\n    {\n        // attempt to load font from Resources fonts folder\n        pBuffer = loadFont(textDefinition._fontName.c_str(), \u0026size);\n\t    if(!pBuffer)\n\t    {\n         // attempt to load font from System fonts folder\n            pBuffer = loadSystemFont(textDefinition._fontName.c_str(), \u0026size);\n\t    }\n        if(!pBuffer)\n        {\n            // attempt to load default font from Resources fonts folder\n\t\t    pBuffer = loadFont(\"Arial\", \u0026size);\n        }\n        if(!pBuffer)\n        {\n            // attempt to load default font from System fonts folder\n\t\t    pBuffer = loadSystemFont(\"Arial\", \u0026size);\n        }\n\n        if(!pBuffer) // font not found!\n        {\n            return false;\n        }\n\n#if 0\n        // cache the font file buffer\n        FontBufferInfo info;\n        info.pBuffer = pBuffer;\n        info.size = size;\n        s_fontsNames[textDefinition._fontName]=info;  \n#endif // 0\n\n    }\n\n    m_fontName = textDefinition._fontName;\n    m_text = text;\n\n\tif(!s_FreeTypeLibrary)\n\t{\n\t\terror = FT_Init_FreeType(\u0026s_FreeTypeLibrary);\n\t}\n\n\tif(!error \u0026\u0026 !m_face)\n\t{\n\t\terror = FT_New_Memory_Face(s_FreeTypeLibrary, pBuffer, size, 0, \u0026m_face);\n\t}\n\n    if(!error)\n    {\n        error = FT_Select_Charmap(m_face, FT_ENCODING_UNICODE);\n    }\n\n\n    if(!error)\n    {\n        error = FT_Set_Char_Size(m_face, textDefinition._fontSize \u003c\u003c 6, textDefinition._fontSize \u003c\u003c 6, 72, 72);\n    }\n\n    if(!error)\n    {\n\t    error = initGlyphs(text);\n    }\n\n    if (!error)\n    {\n        data = getBitmap(align, width, height, dataLength);\n    }\n\n    delete [] pBuffer;\n\n    reset();\n\n\treturn data;\n}\n\nunsigned char* CCFreeTypeFont::getBitmap(Device::TextAlign eAlignMask, int \u0026width, int \u0026height, ssize_t\u0026 dataLength)\n{\n    int lineNumber = 0;\n    int totalLines = m_lines.size();\n\n    m_width = m_inWidth ? m_inWidth : m_textWidth;\n    m_height = m_inHeight ? m_inHeight : m_textHeight;\n    \n    unsigned int size = m_width * m_height * 4;\n    unsigned char* pBuffer = new unsigned char[size];\n    dataLength = size;\n    if(!pBuffer)\n    {\n        dataLength = 0;\n        return nullptr;\n    }\n    memset(pBuffer, 0, size);\n\n    for (auto line = m_lines.begin() ; line != m_lines.end(); ++line)\n    {\n        FT_Vector pen = getPenForAlignment(*line, eAlignMask, lineNumber, totalLines);\n        drawText(*line, pBuffer, \u0026pen);\n        lineNumber++;\n    }\n    width = m_width;\n    height = m_height;\n\n    return pBuffer;\n}\n\nFT_Vector CCFreeTypeFont::getPenForAlignment(FTLineInfo* pInfo, Device::TextAlign eAlignMask,int lineNumber, int totalLines)\n{\n    FT_Error error = 0;\n    FT_Vector pen;\n    \n    int top;\n    int stringWidth  = pInfo-\u003ebbox.xMax - pInfo-\u003ebbox.xMin;\n    int maxLineNumber = totalLines - 1;\n    pen.x = 0;\n    pen.y = 0;\n\n    switch(eAlignMask)\n    {\n        case Device::TextAlign::TOP: // Horizontal center and vertical top.\n            pen.x = ((m_width  - stringWidth) / 2) - pInfo-\u003ebbox.xMin;\n            pen.y = pInfo-\u003ebbox.yMax + (lineNumber * m_lineHeight);\t\t    \n \t\t    break;\n\t\t\t\n        case Device::TextAlign::TOP_LEFT: // Horizontal left and vertical top.\n            pen.x -=pInfo-\u003ebbox.xMin;\n            pen.y = pInfo-\u003ebbox.yMax + (lineNumber * m_lineHeight);\t\t    \n \t\t    break;\n\n\t    case Device::TextAlign::TOP_RIGHT: // Horizontal right and vertical top.\n            pen.x = m_width - stringWidth - pInfo-\u003ebbox.xMin;\n            pen.y = pInfo-\u003ebbox.yMax + (lineNumber * m_lineHeight);\t\t    \n\t\t    break;\n \n\t    case Device::TextAlign::BOTTOM_RIGHT: // Horizontal right and vertical bottom.\n            pen.x = m_width - stringWidth - pInfo-\u003ebbox.xMin;\n            pen.y = m_height + pInfo-\u003ebbox.yMin - ((maxLineNumber - lineNumber) * m_lineHeight);\n\t\t    break;\n\n\t    case Device::TextAlign::BOTTOM: // Horizontal center and vertical bottom.\n            pen.x = ((m_width  - stringWidth) / 2) - pInfo-\u003ebbox.xMin;\n            pen.y = m_height + pInfo-\u003ebbox.yMin - ((maxLineNumber - lineNumber) * m_lineHeight);\n\t\t    break;\n\n\t    case Device::TextAlign::BOTTOM_LEFT: // Horizontal left and vertical bottom.\n            pen.x -=pInfo-\u003ebbox.xMin;\n            top = (m_height - m_textHeight) / 2;\n            pen.y = m_height + pInfo-\u003ebbox.yMin - ((maxLineNumber - lineNumber) * m_lineHeight);\n  \t\t    break;\n\n\t    case Device::TextAlign::CENTER: // Horizontal center and vertical center\n            pen.x = ((m_width  - stringWidth) / 2) - pInfo-\u003ebbox.xMin;\n            top = (m_height - m_textHeight) / 2;\n            pen.y = top + (lineNumber * m_lineHeight) + pInfo-\u003ebbox.yMax;\t\t    \n            break;\n\n\t    case Device::TextAlign::RIGHT: // Horizontal right and vertical center.\n            pen.x = m_width - stringWidth - pInfo-\u003ebbox.xMin;\n            top = (m_height - m_textHeight) / 2;\n            pen.y = top + (lineNumber * m_lineHeight) + pInfo-\u003ebbox.yMax;\t\t    \n  \t\t    break;\n\n\t    case Device::TextAlign::LEFT: // Horizontal left and vertical center.\n\t    default:\n            pen.x -=pInfo-\u003ebbox.xMin;\n            top = (m_height - m_textHeight) / 2;\n            pen.y = top + (lineNumber * m_lineHeight) + pInfo-\u003ebbox.yMax;\t\t    \n  \t\t    break;\n    }\n\n    return pen;\n}\n\nvoid  CCFreeTypeFont::drawText(FTLineInfo* pInfo, unsigned char* pBuffer, FT_Vector *pen)\n{\n\n    auto glyphs = pInfo-\u003eglyphs;\n    for (auto glyph = glyphs.begin() ; glyph != glyphs.end(); ++glyph)\n    {\n        FT_Glyph image = glyph-\u003eimage;\n        FT_Error error = FT_Glyph_To_Bitmap(\u0026image, FT_RENDER_MODE_NORMAL, 0, 1);\n        if (!error)\n        {\n            FT_BitmapGlyph  bit = (FT_BitmapGlyph)image;\n            draw_bitmap(pBuffer, \u0026bit-\u003ebitmap, pen-\u003ex + glyph-\u003epos.x + bit-\u003eleft,pen-\u003ey - bit-\u003etop);\n            FT_Done_Glyph(image);\n        }\n    }\n}\n\n\nvoid CCFreeTypeFont::draw_bitmap(unsigned char* pBuffer, FT_Bitmap*  bitmap, FT_Int x, FT_Int y)\n{\n    FT_Int  i, j, p, q;\n    FT_Int  x_max = x + bitmap-\u003ewidth;\n    FT_Int  y_max = y + bitmap-\u003erows;\n\n    for (i = x, p = 0; i \u003c x_max; i++, p++)\n    {\n        for ( j = y, q = 0; j \u003c y_max; j++, q++ )\n        {\n            if (i \u003c 0 || j \u003c 0 || i \u003e= m_width || j \u003e= m_height)\n                continue;\n\n            unsigned char value =  bitmap-\u003ebuffer[q * bitmap-\u003ewidth + p];\n\n            if(value \u003e 0)\n            {\n                FT_Int index = (j * m_width * 4) + (i * 4);\n                pBuffer[index++] = m_fontFillColorR;\n                pBuffer[index++] = m_fontFillColorG;\n                pBuffer[index++] = m_fontFillColorB;\n                pBuffer[index++] = value;\n           }\n        }\n    }  \n}\n\nvoid CCFreeTypeFont::endLine() \n{\n    if(m_currentLine)\n    {\n        m_lines.push_back(m_currentLine);\n        m_textWidth = std::max((long)m_textWidth,m_currentLine-\u003ebbox.xMax - m_currentLine-\u003ebbox.xMin);\n        m_textHeight += m_lineHeight;\n    }\n}\n\nvoid CCFreeTypeFont::newLine() \n{\n    m_currentLine = new FTLineInfo();\n    m_currentLine-\u003ewidth = 0;\n    m_currentLine-\u003epen.x = 0;\n    m_currentLine-\u003epen.y = 0;\n}\n\n\nFT_Error CCFreeTypeFont::addWord(const std::string\u0026 word) \n{\n\tstd::vector\u003cTGlyph\u003e glyphs; // glyphs for the word\n\tFT_BBox             bbox;   // bounding box containing all of the glyphs in the word\n    int maxWidth = m_inWidth ? m_inWidth : m_windowWidth;\n    std::string newWord;\n\n    if(m_currentLine-\u003ewidth \u003e 0) \n    {\n        newWord = ' ' + word;\n    } \n    else\n    {\n        newWord = word;\n    }\n\n    FT_Error error = initWordGlyphs(glyphs, newWord, m_currentLine-\u003epen);\n    if(!error) \n    {\n        compute_bbox(glyphs, \u0026bbox);\n        if(m_currentLine-\u003ewidth == 0 || bbox.xMax \u003c= maxWidth)\n        {\n            m_currentLine-\u003eglyphs.insert(m_currentLine-\u003eglyphs.end(),glyphs.begin(),glyphs.end());\n            if(m_currentLine-\u003ewidth == 0)\n            {\n                m_currentLine-\u003ebbox = bbox;\n            }\n            else\n            {\n                m_currentLine-\u003ebbox.xMax = bbox.xMax;\n            }\n            m_currentLine-\u003ewidth = m_currentLine-\u003ebbox.xMax - m_currentLine-\u003ebbox.xMin;\n        }\n        else \n        {\n            endLine();\n            newLine();\n            addWord(word);\n        }\n    }\n    return error;\n}\n\nFT_Error CCFreeTypeFont::initGlyphs(const char* text) \n{\n    FT_Error error = 0;\n    std::stringstream stringStream(text);\n    std::string line;\n    vector\u003cstd::string\u003e lines;\n    vector\u003cstd::string\u003e words;\n\n    m_textWidth = 0;\n    m_textHeight = 0;\n    // the height of a line of text based on the max height of a glyph in the font size\n    m_lineHeight = ((m_face-\u003esize-\u003emetrics.ascender) \u003e\u003e 6) - ((m_face-\u003esize-\u003emetrics.descender) \u003e\u003e 6);\n\n    m_lines.clear();\n\n    while(std::getline(stringStream, line) \u0026\u0026 !error) \n    {\n        newLine();\n\n        std::size_t prev = 0, pos;\n        while ((pos = line.find_first_of(\" \", prev)) != std::string::npos)\n        {\n            if (pos \u003e prev)\n            {\n                addWord(line.substr(prev, pos-prev));\n            }\n            prev = pos + 1;\n        }\n        if (prev \u003c line.length())\n        {\n            addWord(line.substr(prev, std::string::npos));\n        }\n        endLine();\n    }\n\n    return error;\n}\n\n// if linewidth \u003e m_inWidth\n// get words for line\n\nvoid CCFreeTypeFont::initWords(const char* text) \n{\n    std::stringstream stringStream(text);\n    std::string line;\n    vector\u003cstd::string\u003e lines;\n    vector\u003cstd::string\u003e words;\n\n    while(std::getline(stringStream, line)) \n    {\n        lines.push_back(line);\n    }\n\n    for (auto it = lines.begin() ; it != lines.end(); ++it)\n    {\n        std::size_t prev = 0, pos;\n        while ((pos = it-\u003efind_first_of(\" ';\", prev)) != std::string::npos)\n        {\n            if (pos \u003e prev)\n                words.push_back(it-\u003esubstr(prev, pos-prev));\n            prev = pos+1;\n        }\n        if (prev \u003c it-\u003elength())\n            words.push_back(it-\u003esubstr(prev, std::string::npos));\n    }\n\n    for (auto it = words.begin() ; it != words.end(); ++it)\n    {\n        std::string foo(*it);\n    }\n}\n\nFT_Error CCFreeTypeFont::initWordGlyphs(std::vector\u003cTGlyph\u003e\u0026 glyphs, const std::string\u0026 text, FT_Vector\u0026 pen) \n{\n\tFT_GlyphSlot\tslot = m_face-\u003eglyph; \n\tFT_UInt\t\t\tglyph_index;\n\tFT_UInt\t\t\tprevious = 0;\n\tFT_Error\t\terror = 0;\n\tPGlyph\t\t\tglyph;\n    unsigned int    numGlyphs = 0;\n    wchar_t *       pwszBuffer = nullptr;\n\n\tint num_chars = text.size();\n\tint nBufLen  = num_chars + 1;\t\t\t\n\tpwszBuffer = new wchar_t[nBufLen];\n    if(!pwszBuffer)\n    {\n        return -1;\n    }\n    \n    memset(pwszBuffer,0,nBufLen);\n    num_chars = MultiByteToWideChar(CP_UTF8, 0, text.c_str(), num_chars, pwszBuffer, nBufLen);\t\t\n    pwszBuffer[num_chars] = '\\0';\n\n    glyphs.clear();\n\tglyphs.resize(num_chars);\n\tFT_Bool useKerning = FT_HAS_KERNING(m_face);\n\n\tfor (int n = 0; n \u003c num_chars; n++)\n\t{\n\t\tglyph = \u0026glyphs[numGlyphs];\n\n\t\t/* convert character code to glyph index */\n        FT_ULong c = pwszBuffer[n];\n\t\tglyph_index = FT_Get_Char_Index(m_face, c);\n\n \t\tif (useKerning \u0026\u0026 previous \u0026\u0026 glyph_index)\n\t\t{\n\t\t\tFT_Vector  delta;\n\t\t\tFT_Get_Kerning(m_face, previous, glyph_index,\n\t\t\t\t\t\t\tFT_KERNING_DEFAULT, \u0026delta);\n\t\t\tpen.x += delta.x \u003e\u003e 6;\n\t\t}\n\n\t\t/* store current pen position */\n\t\tglyph-\u003epos = pen;\n\t\tglyph-\u003eindex = glyph_index;\n\n\t\t/* load glyph image into the slot without rendering */\n\t\terror = FT_Load_Glyph(m_face, glyph_index, FT_LOAD_DEFAULT);\n\t\tif (error)\n\t\t\tcontinue;  /* ignore errors, jump to next glyph */\n\n\t\t/* extract glyph image and store it in our table */\n\t\terror = FT_Get_Glyph(m_face-\u003eglyph, \u0026glyph-\u003eimage);\n\t\tif (error)\n\t\t\tcontinue;  /* ignore errors, jump to next glyph */\n\n\t\t /* translate the glyph image now */\n\t\tFT_Glyph_Transform(glyph-\u003eimage, 0, \u0026glyph-\u003epos);\n\n\t\t/* increment pen position */\n\t\tpen.x += slot-\u003eadvance.x \u003e\u003e 6;\n\n\t\t/* record current glyph index */\n\t\tprevious = glyph_index;\n\n\t\tnumGlyphs++;\n\t}\n\n    CC_SAFE_DELETE_ARRAY(pwszBuffer);\n\n\treturn error;\n}\n\nvoid  CCFreeTypeFont::compute_bbox(std::vector\u003cTGlyph\u003e\u0026 glyphs, FT_BBox  *abbox)\n{\n    FT_BBox bbox;\n    FT_BBox glyph_bbox;\n\n    /* initialize string bbox to \"empty\" values */\n    bbox.xMin = 32000;\n    bbox.xMax = -32000;\n\n    // use the max and min values for the entire font face\n    bbox.yMin = (m_face-\u003esize-\u003emetrics.descender) \u003e\u003e 6;\n    bbox.yMax = (m_face-\u003esize-\u003emetrics.ascender) \u003e\u003e 6;\n\n    /* for each glyph image, compute its bounding box, */\n    /* translate it, and grow the string bbox          */\n    for (auto glyph = glyphs.begin() ; glyph != glyphs.end(); ++glyph)\n    {\n        FT_Glyph_Get_CBox(glyph-\u003eimage, ft_glyph_bbox_pixels, \u0026glyph_bbox);\n\n        glyph_bbox.xMin += glyph-\u003epos.x;\n        glyph_bbox.xMax += glyph-\u003epos.x;\n        glyph_bbox.yMin += glyph-\u003epos.y;\n        glyph_bbox.yMax += glyph-\u003epos.y;\n\n        if (glyph_bbox.xMin \u003c bbox.xMin)\n            bbox.xMin = glyph_bbox.xMin;\n\n        if (glyph_bbox.yMin \u003c bbox.yMin)\n            bbox.yMin = glyph_bbox.yMin;\n\n        if (glyph_bbox.xMax \u003e bbox.xMax)\n            bbox.xMax = glyph_bbox.xMax;\n\n        if (glyph_bbox.yMax \u003e bbox.yMax)\n            bbox.yMax = glyph_bbox.yMax;\n    }\n\n    /* check that we really grew the string bbox */\n    if (bbox.xMin \u003e bbox.xMax)\n    {\n        bbox.xMin = 0;\n        bbox.yMin = 0;\n        bbox.xMax = 0;\n        bbox.yMax = 0;\n    }\n  \n    /* return string bbox */\n    *abbox = bbox;\n}\n\nunsigned char* CCFreeTypeFont::loadFont(const char *pFontName, ssize_t *size) \n{\n\tstd::string lowerCase(pFontName);\n\tstd::string path(pFontName);\n\n    for (unsigned int i = 0; i \u003c lowerCase.length(); ++i)\n    {\n        lowerCase[i] = tolower(lowerCase[i]);\n    }\n\n    if (std::string::npos == lowerCase.find(\"fonts/\"))\n    {\n        path = \"fonts/\";\n        path += pFontName;\n    }\n\n    if (std::string::npos == lowerCase.find(\".ttf\"))\n    {\n        path += \".ttf\";\n    }\n\n\tstd::string fullpath  = FileUtils::getInstance()-\u003efullPathForFilename(path.c_str());\n\treturn FileUtils::sharedFileUtils()-\u003egetFileData(fullpath.c_str(), \"rb\", size);\n}\n\nunsigned char* CCFreeTypeFont::loadSystemFont(const char *pFontName, ssize_t *size) \n{\n#if (CC_TARGET_PLATFORM == CC_PLATFORM_WP8)\n\treturn nullptr;\n#else\n    std::string aName(pFontName);\n    unsigned char* pBuffer = nullptr;\n    HRESULT hr = S_OK;\n\tIDWriteFactory *writeFactory = nullptr;\n\tIDWriteFontCollection *fontCollection = nullptr;\n\tIDWriteFontFamily *fontFamily = nullptr;\n\tIDWriteFont *matchingFont = nullptr;\n\tIDWriteFontFace *fontFace = nullptr;\n\tIDWriteFontFile *fontFile = nullptr;\n\tIDWriteFontFileLoader *fontFileLoader = nullptr;\n\tIDWriteFontFileStream *fontFileStream = nullptr;\n\tUINT32 index;\n\tBOOL exists;\n\tstd::wstring fontNameW;\n    const void *fontFileReferenceKey = nullptr;\n    UINT32 fontFileReferenceKeySize;            \n    void *fragmentContext = nullptr;\n \n    for (unsigned int i = 0; i \u003c aName.length(); ++i)\n    {\n        aName[i] = tolower(aName[i]);\n    }\n    fontNameW.assign(aName.begin(), aName.end());\n\n\t//create the factory\n\thr = DWriteCreateFactory(DWRITE_FACTORY_TYPE_SHARED, __uuidof(IDWriteFactory), reinterpret_cast\u003cIUnknown**\u003e(\u0026writeFactory));\n\n    if(SUCCEEDED(hr))\n    {\n\t    //obtain the fonts owned by the machine\n\t    hr  = writeFactory-\u003eGetSystemFontCollection(\u0026fontCollection, TRUE);\n    }\n\n\t//get the font \n    if(SUCCEEDED(hr))\n    {\n\t    hr = fontCollection-\u003eFindFamilyName(fontNameW.c_str(), \u0026index, \u0026exists);\n        if(SUCCEEDED(hr) \u0026\u0026 exists)\n        {\n\t        hr = fontCollection-\u003eGetFontFamily(index, \u0026fontFamily);\n\n            if(SUCCEEDED(hr))\n            {\n\t            hr = fontFamily-\u003eGetFirstMatchingFont(DWRITE_FONT_WEIGHT_REGULAR, DWRITE_FONT_STRETCH_NORMAL, DWRITE_FONT_STYLE_NORMAL, \u0026matchingFont);\n            }\n\n            if(SUCCEEDED(hr))\n            {\n\t            hr = matchingFont-\u003eCreateFontFace(\u0026fontFace);\n            }\n\n            if(SUCCEEDED(hr))\n            {\n\t            UINT32 numberOfFiles = 1;\n\t            hr = fontFace-\u003eGetFiles(\u0026numberOfFiles, \u0026fontFile);\n            }\n\n            if(SUCCEEDED(hr))\n            {\n\t            //create the font file stream\n               hr = fontFile-\u003eGetReferenceKey(\u0026fontFileReferenceKey, \u0026fontFileReferenceKeySize);\n            }\n\n            if(SUCCEEDED(hr))\n            {\n                hr = fontFile-\u003eGetLoader(\u0026fontFileLoader);\n            }\n\n            if(SUCCEEDED(hr))\n            {\n                hr = fontFileLoader-\u003eCreateStreamFromKey(fontFileReferenceKey, fontFileReferenceKeySize, \u0026fontFileStream);\n            }\n\n            if(SUCCEEDED(hr))\n            {\n\t            //finally get the font file dat\n\t            UINT64 fileSize;\n\t\t        const void *fragmentStart = nullptr;\n                hr = fontFileStream-\u003eGetFileSize(\u0026fileSize);\n\n                if(SUCCEEDED(hr))\n                {\n\t                hr = fontFileStream-\u003eReadFileFragment(\u0026fragmentStart, 0, fileSize, \u0026fragmentContext);\n                }\n\n                if(SUCCEEDED(hr))\n                {\n\t                pBuffer = (unsigned char*)malloc((size_t)fileSize);\n\t                memcpy(pBuffer, fragmentStart, (size_t)fileSize);      \n                    *size = (unsigned long)fileSize;\n                }\n            }\n        }\n    }\n\n\t//clean up all the DWrite stuff\n    if(fontFileStream)\n    {\n\t    fontFileStream-\u003eReleaseFileFragment(fragmentContext);\n\t    fontFileStream-\u003eRelease();\n    }\n    if(fontFileLoader)\n    {\n\t    fontFileLoader-\u003eRelease();\n    }\n    if(fontFile)\n    {\n\t    fontFile-\u003eRelease();\n    }\n    if(fontFace)\n    {\n\t    fontFace-\u003eRelease();\n    }\n    if(matchingFont)\n    {\n\t    matchingFont-\u003eRelease();\n    }\n    if(fontFamily)\n    {\n\t    fontFamily-\u003eRelease();\n    }\n    if(fontCollection)\n    {\n\t    fontCollection-\u003eRelease();\n    }\n    if(writeFactory)\n    {\n\t    writeFactory-\u003eRelease();\n    }\n\n    return pBuffer;\n#endif\n}\n\nNS_CC_END\n\n"}
{"repo_name":"SlavaRa/coreclr","ref":"refs/heads/master","path":"src/binder/variables.cpp","copies":"14","language":"C++","content":"// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\n// See the LICENSE file in the project root for more information.\n// ============================================================\n//\n// Variables.cpp\n//\n\n\n//\n// Implements the Variables class\n//\n// ============================================================\n\n#include \"variables.hpp\"\n\n#include \"ex.h\"\n\nnamespace BINDER_SPACE\n{\n#ifdef FEATURE_VERSIONING_LOG\n    namespace\n    {\n        HRESULT CheckFileExistence(LPCWSTR pwzFile, LPDWORD pdwAttrib)\n        {\n            HRESULT hr = S_FALSE;\n            DWORD dwRet = 0;\n\n            _ASSERTE(pwzFile \u0026\u0026 pdwAttrib);\n\n            *pdwAttrib = 0;\n\n            dwRet = WszGetFileAttributes(pwzFile);\n            if (dwRet == INVALID_FILE_ATTRIBUTES)\n            {\n                hr = HRESULT_FROM_GetLastError();\n\n                if ((hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)) ||\n                    (hr == HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND)))\n                {\n                    GO_WITH_HRESULT(S_FALSE);\n                }\n            }\n            else\n            {\n                *pdwAttrib = dwRet;\n                GO_WITH_HRESULT(S_OK);\n            }\n\n        Exit:\n            return hr;\n        }\n    };\n#endif // FEATURE_VERSIONING_LOG\n\n    Variables *g_BinderVariables = NULL;\n\n    Variables::Variables()\n    {\n        // Nothing to do here\n    }\n\n    Variables::~Variables()\n    {\n        // Nothing to do here\n    }\n\n    HRESULT Variables::Init()\n    {\n        HRESULT hr = S_OK;\n\n        EX_TRY\n        {\n            // ApplicationContext string constants\n            \n            // AssemblyBinder string constants\n            httpURLPrefix.SetLiteral(W(\"http://\"));\n\n            // AssemblyName string constants\n            architectureMSIL.SetLiteral(W(\"MSIL\"));\n            architectureX86.SetLiteral(W(\"x86\"));\n            architectureAMD64.SetLiteral(W(\"AMD64\"));\n            architectureARM.SetLiteral(W(\"ARM\"));\n            architectureARM64.SetLiteral(W(\"ARM64\"));\n            cultureNeutral.SetLiteral(W(\"neutral\"));\n            mscorlib.SetLiteral(W(\"mscorlib\"));\n            emptyString.Clear();\n\n#ifdef FEATURE_VERSIONING_LOG\n            REGUTIL::CORConfigLevel kCorConfigLevel =\n                static_cast\u003cREGUTIL::CORConfigLevel\u003e(REGUTIL::COR_CONFIG_ENV |\n                                                     REGUTIL::COR_CONFIG_FUSION);\n\n            DWORD dwLoggingNeeded = REGUTIL::GetConfigDWORD_DontUse_(CLRConfig::EXTERNAL_ForceLog,\n                                                            0,\n                                                            kCorConfigLevel,\n                                                            TRUE);\n            fLoggingNeeded = (dwLoggingNeeded ? TRUE : FALSE);\n\n            NewArrayHolder\u003cWCHAR\u003e pwzLogDirectory = REGUTIL::GetConfigString_DontUse_(CLRConfig::INTERNAL_LogPath,\n                                                              TRUE,\n                                                              kCorConfigLevel,\n                                                              FALSE /* fUsePerfCache */);\n\n            // When no directory is specified, we can't log.\n            if (pwzLogDirectory == NULL)\n            {\n                fLoggingNeeded = FALSE;\n            }\n            else\n            {\n                DWORD dwAttr = 0;\n\n                // If we do not get a regular directory, then we can't log either\n                hr = CheckFileExistence(pwzLogDirectory, \u0026dwAttr);\n                if ((hr == S_OK) \u0026\u0026 ((dwAttr \u0026 FILE_ATTRIBUTE_DIRECTORY) != 0))\n                {\n                    logPath.Set(pwzLogDirectory);\n                }\n                else\n                {\n                    // Any failure here simply yields no logging.\n                    hr = S_OK;\n                    fLoggingNeeded = FALSE;\n                }\n            }\n#endif // FEATURE_VERSIONING_LOG\n        }\n        EX_CATCH_HRESULT(hr);\n\n        return hr;\n    }\n};\n"}
{"repo_name":"jmanday/Master","ref":"refs/heads/master","path":"TFM/library/boost_1_63_0/libs/icl/test/fastest_split_interval_set_/fastest_split_interval_set.cpp","copies":"58","language":"C++","content":"/*-----------------------------------------------------------------------------+    \nCopyright (c) 2008-2009: Joachim Faulhaber\n+------------------------------------------------------------------------------+\n   Distributed under the Boost Software License, Version 1.0.\n      (See accompanying file LICENCE.txt or copy at\n           http://www.boost.org/LICENSE_1_0.txt)\n+-----------------------------------------------------------------------------*/\n#define BOOST_TEST_MODULE icl::split_interval_set unit test\n#include \u003clibs/icl/test/disable_test_warnings.hpp\u003e\n#include \u003cstring\u003e\n#include \u003cboost/mpl/list.hpp\u003e\n#include \"../unit_test_unwarned.hpp\"\n\n\n// interval instance types\n#include \"../test_type_lists.hpp\"\n#include \"../test_value_maker.hpp\"\n\n#include \u003cboost/icl/split_interval_set.hpp\u003e\n\nusing namespace std;\nusing namespace boost;\nusing namespace unit_test;\nusing namespace boost::icl;\n\n// -----------------------------------------------------------------------------\n// test_interval_set_shared are tests that should give identical results for all\n// interval_sets: interval_set, separate_interval_set and split_interval_set.\n#include \"../test_interval_set_shared.hpp\"\n\n#define INTERVAL_SET split_interval_set \n#include \"../fastest_interval_set_cases.hpp\"\n\n\n"}
{"repo_name":"ThomasLee969/video_classifier","ref":"refs/heads/master","path":"workspace/mexopencv/src/+cv/cornerHarris.cpp","copies":"2","language":"C++","content":"/**\n * @file cornerHarris.cpp\n * @brief mex interface for cv::cornerHarris\n * @ingroup imgproc\n * @author Kota Yamaguchi\n * @date 2011\n */\n#include \"mexopencv.hpp\"\nusing namespace std;\nusing namespace cv;\n\n/**\n * Main entry called from Matlab\n * @param nlhs number of left-hand-side arguments\n * @param plhs pointers to mxArrays in the left-hand-side\n * @param nrhs number of right-hand-side arguments\n * @param prhs pointers to mxArrays in the right-hand-side\n */\nvoid mexFunction(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])\n{\n    // Check the number of arguments\n    nargchk(nrhs\u003e=1 \u0026\u0026 (nrhs%2)==1 \u0026\u0026 nlhs\u003c=1);\n\n    // Argument vector\n    vector\u003cMxArray\u003e rhs(prhs, prhs+nrhs);\n\n    // Option processing\n    int blockSize = 5;\n    int ksize = 3;\n    double k = 0.04;\n    int borderType = cv::BORDER_DEFAULT;\n    for (int i=1; i\u003cnrhs; i+=2) {\n        string key(rhs[i].toString());\n        if (key==\"BlockSize\")\n            blockSize = rhs[i+1].toInt();\n        else if (key==\"KSize\")\n            ksize = rhs[i+1].toInt();\n        else if (key==\"K\")\n            k = rhs[i+1].toDouble();\n        else if (key==\"BorderType\")\n            borderType = BorderType[rhs[i+1].toString()];\n        else\n            mexErrMsgIdAndTxt(\"mexopencv:error\",\"Unrecognized option\");\n    }\n\n    // Process\n    Mat src(rhs[0].toMat(rhs[0].isUint8() ? CV_8U : CV_32F)), dst;\n    cornerHarris(src, dst, blockSize, ksize, k, borderType);\n    plhs[0] = MxArray(dst);\n}\n"}
{"repo_name":"Tomcc/dolphin","ref":"refs/heads/master","path":"Source/Core/Core/HW/EXI/EXI_DeviceAGP.cpp","copies":"63","language":"C++","content":"// Copyright 2015 Dolphin Emulator Project\n// Licensed under GPLv2+\n// Refer to the license.txt file included.\n\n#include \"Core/HW/EXI/EXI_DeviceAGP.h\"\n\n#include \u003calgorithm\u003e\n#include \u003cmemory\u003e\n#include \u003cstring\u003e\n#include \u003cvector\u003e\n\n#include \"Common/ChunkFile.h\"\n#include \"Common/CommonTypes.h\"\n#include \"Common/File.h\"\n#include \"Common/Logging/Log.h\"\n#include \"Common/StringUtil.h\"\n#include \"Core/ConfigManager.h\"\n\nnamespace ExpansionInterface\n{\nCEXIAgp::CEXIAgp(int index)\n{\n  m_slot = index;\n\n  // Create the ROM\n  m_rom_size = 0;\n\n  LoadRom();\n\n  m_address = 0;\n}\n\nCEXIAgp::~CEXIAgp()\n{\n  std::string path;\n  std::string filename;\n  std::string ext;\n  std::string gbapath;\n  SplitPath(m_slot == 0 ? SConfig::GetInstance().m_strGbaCartA :\n                          SConfig::GetInstance().m_strGbaCartB,\n            \u0026path, \u0026filename, \u0026ext);\n  gbapath = path + filename;\n\n  SaveFileFromEEPROM(gbapath + \".sav\");\n}\n\nvoid CEXIAgp::CRC8(const u8* data, u32 size)\n{\n  for (u32 it = 0; it \u003c size; it++)\n  {\n    u8 crc = 0;\n    m_hash = m_hash ^ data[it];\n    if (m_hash \u0026 1)\n      crc ^= 0x5e;\n    if (m_hash \u0026 2)\n      crc ^= 0xbc;\n    if (m_hash \u0026 4)\n      crc ^= 0x61;\n    if (m_hash \u0026 8)\n      crc ^= 0xc2;\n    if (m_hash \u0026 0x10)\n      crc ^= 0x9d;\n    if (m_hash \u0026 0x20)\n      crc ^= 0x23;\n    if (m_hash \u0026 0x40)\n      crc ^= 0x46;\n    if (m_hash \u0026 0x80)\n      crc ^= 0x8c;\n    m_hash = crc;\n  }\n}\n\nvoid CEXIAgp::LoadRom()\n{\n  // Load whole ROM dump\n  std::string path;\n  std::string filename;\n  std::string ext;\n  std::string gbapath;\n  SplitPath(m_slot == 0 ? SConfig::GetInstance().m_strGbaCartA :\n                          SConfig::GetInstance().m_strGbaCartB,\n            \u0026path, \u0026filename, \u0026ext);\n  gbapath = path + filename;\n  LoadFileToROM(gbapath + ext);\n  INFO_LOG(EXPANSIONINTERFACE, \"Loaded GBA rom: %s card: %d\", gbapath.c_str(), m_slot);\n  LoadFileToEEPROM(gbapath + \".sav\");\n  INFO_LOG(EXPANSIONINTERFACE, \"Loaded GBA sav: %s card: %d\", gbapath.c_str(), m_slot);\n}\n\nvoid CEXIAgp::LoadFileToROM(const std::string\u0026 filename)\n{\n  File::IOFile pStream(filename, \"rb\");\n  if (pStream)\n  {\n    u64 filesize = pStream.GetSize();\n    m_rom_size = filesize \u0026 0xFFFFFFFF;\n    m_rom_mask = (m_rom_size - 1);\n\n    m_rom.resize(m_rom_size);\n\n    pStream.ReadBytes(m_rom.data(), filesize);\n  }\n  else\n  {\n    // dummy rom data\n    m_rom.resize(0x2000);\n  }\n}\n\nvoid CEXIAgp::LoadFileToEEPROM(const std::string\u0026 filename)\n{\n  // Technically one of EEPROM, Flash, SRAM, FRAM\n  File::IOFile pStream(filename, \"rb\");\n  if (pStream)\n  {\n    u64 filesize = pStream.GetSize();\n    m_eeprom_size = filesize \u0026 0xFFFFFFFF;\n    m_eeprom_mask = (m_eeprom_size - 1);\n\n    m_eeprom.resize(m_eeprom_size);\n    pStream.ReadBytes(m_eeprom.data(), filesize);\n    if ((m_eeprom_size == 512) || (m_eeprom_size == 8192))\n    {\n      // Handle endian read - could be done with byte access in 0xAE commands instead\n      for (u32 index = 0; index \u003c (m_eeprom_size / 8); index++)\n      {\n        u64 NewVal = 0;\n        for (u32 indexb = 0; indexb \u003c 8; indexb++)\n          NewVal = (NewVal \u003c\u003c 0x8) | m_eeprom[index * 8 + indexb];\n        ((u64*)(m_eeprom.data()))[index] = NewVal;\n      }\n      m_eeprom_add_end = (m_eeprom_size == 512 ? (2 + 6) : (2 + 14));\n      m_eeprom_add_mask = (m_eeprom_size == 512 ? 0x3F : 0x3FF);\n      m_eeprom_read_mask = (m_eeprom_size == 512 ? 0x80 : 0x8000);\n      m_eeprom_status_mask = (m_rom_size == 0x2000000 ? 0x1FFFF00 : 0x1000000);\n    }\n    else\n      m_eeprom_status_mask = 0;\n  }\n  else\n  {\n    m_eeprom_size = 0;\n    m_eeprom.clear();\n  }\n}\n\nvoid CEXIAgp::SaveFileFromEEPROM(const std::string\u0026 filename)\n{\n  File::IOFile pStream(filename, \"wb\");\n  if (pStream)\n  {\n    if ((m_eeprom_size == 512) || (m_eeprom_size == 8192))\n    {\n      // Handle endian write - could be done with byte access in 0xAE commands instead\n      std::vector\u003cu8\u003e temp_eeprom(m_eeprom_size);\n      for (u32 index = 0; index \u003c (m_eeprom_size / 8); index++)\n      {\n        u64 NewVal = ((u64*)(m_eeprom.data()))[index];\n        for (u32 indexb = 0; indexb \u003c 8; indexb++)\n          temp_eeprom[index * 8 + (7 - indexb)] = (NewVal \u003e\u003e (indexb * 8)) \u0026 0xFF;\n      }\n      pStream.WriteBytes(temp_eeprom.data(), m_eeprom_size);\n    }\n    else\n    {\n      pStream.WriteBytes(m_eeprom.data(), m_eeprom_size);\n    }\n  }\n}\n\nu32 CEXIAgp::ImmRead(u32 _uSize)\n{\n  u32 uData = 0;\n  u8 RomVal1, RomVal2, RomVal3, RomVal4;\n\n  switch (m_current_cmd)\n  {\n  case 0xAE000000:       // Clock handshake?\n    uData = 0x5AAA5517;  // 17 is precalculated hash\n    m_current_cmd = 0;\n    break;\n  case 0xAE010000:  // Init?\n    uData = (m_return_pos == 0) ? 0x01020304 :\n                                  0xF0020304;  // F0 is precalculated hash, 020304 is left over\n    if (m_return_pos == 1)\n      m_current_cmd = 0;\n    else\n      m_return_pos = 1;\n    break;\n  case 0xAE020000:  // Read 2 bytes with 24 bit address\n    if (m_eeprom_write_status \u0026\u0026 ((m_rw_offset \u0026 m_eeprom_status_mask) == m_eeprom_status_mask) \u0026\u0026\n        (m_eeprom_status_mask != 0))\n    {\n      RomVal1 = 0x1;\n      RomVal2 = 0x0;\n    }\n    else\n    {\n      RomVal1 = m_rom[(m_rw_offset++) \u0026 m_rom_mask];\n      RomVal2 = m_rom[(m_rw_offset++) \u0026 m_rom_mask];\n    }\n    CRC8(\u0026RomVal2, 1);\n    CRC8(\u0026RomVal1, 1);\n    uData = (RomVal2 \u003c\u003c 24) | (RomVal1 \u003c\u003c 16) | (m_hash \u003c\u003c 8);\n    m_current_cmd = 0;\n    break;\n  case 0xAE030000:  // read the next 4 bytes out of 0x10000 group\n    if (_uSize == 1)\n    {\n      uData = 0xFF000000;\n      m_current_cmd = 0;\n    }\n    else\n    {\n      RomVal1 = m_rom[(m_rw_offset++) \u0026 m_rom_mask];\n      RomVal2 = m_rom[(m_rw_offset++) \u0026 m_rom_mask];\n      RomVal3 = m_rom[(m_rw_offset++) \u0026 m_rom_mask];\n      RomVal4 = m_rom[(m_rw_offset++) \u0026 m_rom_mask];\n      CRC8(\u0026RomVal2, 1);\n      CRC8(\u0026RomVal1, 1);\n      CRC8(\u0026RomVal4, 1);\n      CRC8(\u0026RomVal3, 1);\n      uData = (RomVal2 \u003c\u003c 24) | (RomVal1 \u003c\u003c 16) | (RomVal4 \u003c\u003c 8) | (RomVal3);\n    }\n    break;\n  case 0xAE040000:  // read 1 byte from 16 bit address\n    // ToDo: Flash special handling\n    if (m_eeprom_size == 0)\n      RomVal1 = 0xFF;\n    else\n      RomVal1 = (m_eeprom.data())[m_eeprom_pos];\n    CRC8(\u0026RomVal1, 1);\n    uData = (RomVal1 \u003c\u003c 24) | (m_hash \u003c\u003c 16);\n    m_current_cmd = 0;\n    break;\n  case 0xAE0B0000:  // read 1 bit from DMA with 6 or 14 bit address\n    // Change to byte access instead of endian file access?\n    RomVal1 = EE_READ_FALSE;\n    if ((m_eeprom_size != 0) \u0026\u0026 (m_eeprom_pos \u003e= EE_IGNORE_BITS) \u0026\u0026\n        ((((u64*)m_eeprom.data())[(m_eeprom_cmd \u003e\u003e 1) \u0026 m_eeprom_add_mask]) \u003e\u003e\n         ((EE_DATA_BITS - 1) - (m_eeprom_pos - EE_IGNORE_BITS))) \u0026\n            0x1)\n    {\n      RomVal1 = EE_READ_TRUE;\n    }\n    RomVal2 = 0;\n    CRC8(\u0026RomVal2, 1);\n    CRC8(\u0026RomVal1, 1);\n    uData = (RomVal2 \u003c\u003c 24) | (RomVal1 \u003c\u003c 16) | (m_hash \u003c\u003c 8);\n    m_eeprom_pos++;\n    m_current_cmd = 0;\n    break;\n  case 0xAE070000:  // complete write 1 byte from 16 bit address\n  case 0xAE0C0000:  // complete write 1 bit from dma with 6 or 14 bit address\n    uData = m_hash \u003c\u003c 24;\n    m_current_cmd = 0;\n    break;\n  default:\n    uData = 0x0;\n    m_current_cmd = 0;\n    break;\n  }\n  DEBUG_LOG(EXPANSIONINTERFACE, \"AGP read %x\", uData);\n  return uData;\n}\n\nvoid CEXIAgp::ImmWrite(u32 _uData, u32 _uSize)\n{\n  // 0x00 = Execute current command?\n  if ((_uSize == 1) \u0026\u0026 ((_uData \u0026 0xFF000000) == 0))\n    return;\n\n  u8 HashCmd;\n  u64 Mask;\n  DEBUG_LOG(EXPANSIONINTERFACE, \"AGP command %x\", _uData);\n  switch (m_current_cmd)\n  {\n  case 0xAE020000:  // set up 24 bit address for read 2 bytes\n  case 0xAE030000:  // set up 24 bit address for read (0x10000 byte group)\n    // 25 bit address shifted one bit right = 24 bits\n    m_rw_offset = ((_uData \u0026 0xFFFFFF00) \u003e\u003e (8 - 1));\n    m_return_pos = 0;\n    HashCmd = (_uData \u0026 0xFF000000) \u003e\u003e 24;\n    CRC8(\u0026HashCmd, 1);\n    HashCmd = (_uData \u0026 0x00FF0000) \u003e\u003e 16;\n    CRC8(\u0026HashCmd, 1);\n    HashCmd = (_uData \u0026 0x0000FF00) \u003e\u003e 8;\n    CRC8(\u0026HashCmd, 1);\n    break;\n  case 0xAE040000:  // set up 16 bit address for read 1 byte\n    // ToDo: Flash special handling\n    m_eeprom_pos = ((_uData \u0026 0xFFFF0000) \u003e\u003e 0x10) \u0026 m_eeprom_mask;\n    HashCmd = (_uData \u0026 0xFF000000) \u003e\u003e 24;\n    CRC8(\u0026HashCmd, 1);\n    HashCmd = (_uData \u0026 0x00FF0000) \u003e\u003e 16;\n    CRC8(\u0026HashCmd, 1);\n    break;\n  case 0xAE070000:  // write 1 byte from 16 bit address\n    // ToDo: Flash special handling\n    m_eeprom_pos = ((_uData \u0026 0xFFFF0000) \u003e\u003e 0x10) \u0026 m_eeprom_mask;\n    if (m_eeprom_size != 0)\n      ((m_eeprom.data()))[(m_eeprom_pos)] = (_uData \u0026 0x0000FF00) \u003e\u003e 0x8;\n    HashCmd = (_uData \u0026 0xFF000000) \u003e\u003e 24;\n    CRC8(\u0026HashCmd, 1);\n    HashCmd = (_uData \u0026 0x00FF0000) \u003e\u003e 16;\n    CRC8(\u0026HashCmd, 1);\n    HashCmd = (_uData \u0026 0x0000FF00) \u003e\u003e 8;\n    CRC8(\u0026HashCmd, 1);\n    break;\n  case 0xAE0C0000:  // write 1 bit from dma with 6 or 14 bit address\n    if ((m_eeprom_pos \u003c m_eeprom_add_end) ||\n        (m_eeprom_pos == ((m_eeprom_cmd \u0026 m_eeprom_read_mask) ? m_eeprom_add_end :\n                                                                m_eeprom_add_end + EE_DATA_BITS)))\n    {\n      Mask = (1ULL \u003c\u003c (m_eeprom_add_end - std::min(m_eeprom_pos, m_eeprom_add_end)));\n      if ((_uData \u003e\u003e 16) \u0026 0x1)\n        m_eeprom_cmd |= Mask;\n      else\n        m_eeprom_cmd \u0026= ~Mask;\n      if (m_eeprom_pos == m_eeprom_add_end + EE_DATA_BITS)\n      {\n        // Change to byte access instead of endian file access?\n        if (m_eeprom_size != 0)\n          ((u64*)(m_eeprom.data()))[(m_eeprom_cmd \u003e\u003e 1) \u0026 m_eeprom_add_mask] = m_eeprom_data;\n        m_eeprom_write_status = true;\n      }\n    }\n    else\n    {\n      Mask = (1ULL \u003c\u003c (m_eeprom_add_end + EE_DATA_BITS - 1 - m_eeprom_pos));\n      if ((_uData \u003e\u003e 16) \u0026 0x1)\n        m_eeprom_data |= Mask;\n      else\n        m_eeprom_data \u0026= ~Mask;\n    }\n    m_eeprom_pos++;\n    m_return_pos = 0;\n    HashCmd = (_uData \u0026 0xFF000000) \u003e\u003e 24;\n    CRC8(\u0026HashCmd, 1);\n    HashCmd = (_uData \u0026 0x00FF0000) \u003e\u003e 16;\n    CRC8(\u0026HashCmd, 1);\n    break;\n  case 0xAE0B0000:\n    m_eeprom_write_status = false;\n    break;\n  case 0xAE000000:\n  case 0xAE010000:\n  case 0xAE090000:                  // start DMA\n    m_eeprom_write_status = false;  // ToDo: Verify with hardware which commands disable EEPROM CS\n  // Fall-through intentional\n  case 0xAE0A0000:  // end DMA\n    m_eeprom_pos = 0;\n  // Fall-through intentional\n  default:\n    m_current_cmd = _uData;\n    m_return_pos = 0;\n    m_hash = 0xFF;\n    HashCmd = (_uData \u0026 0x00FF0000) \u003e\u003e 16;\n    CRC8(\u0026HashCmd, 1);\n    break;\n  }\n}\n\nvoid CEXIAgp::DoState(PointerWrap\u0026 p)\n{\n  p.Do(m_slot);\n  p.Do(m_address);\n  p.Do(m_current_cmd);\n  p.Do(m_eeprom);\n  p.Do(m_eeprom_cmd);\n  p.Do(m_eeprom_data);\n  p.Do(m_eeprom_mask);\n  p.Do(m_eeprom_pos);\n  p.Do(m_eeprom_size);\n  p.Do(m_eeprom_add_end);\n  p.Do(m_eeprom_add_mask);\n  p.Do(m_eeprom_read_mask);\n  p.Do(m_eeprom_status_mask);\n  p.Do(m_eeprom_write_status);\n  p.Do(m_hash);\n  p.Do(m_position);\n  p.Do(m_return_pos);\n  p.Do(m_rom);\n  p.Do(m_rom_mask);\n  p.Do(m_rom_size);\n  p.Do(m_rw_offset);\n}\n}  // namespace ExpansionInterface\n"}
{"repo_name":"nawawi/wkhtmltopdf","ref":"refs/heads/master","path":"webkit/Source/WebCore/bindings/js/JSDocumentCustom.cpp","copies":"4","language":"C++","content":"/*\n * Copyright (C) 2007, 2008, 2009, 2011 Apple Inc. All rights reserved.\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Library General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Library General Public License for more details.\n *\n * You should have received a copy of the GNU Library General Public License\n * along with this library; see the file COPYING.LIB.  If not, write to\n * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n * Boston, MA 02110-1301, USA.\n */\n\n#include \"config.h\"\n#include \"JSDocument.h\"\n\n#include \"ExceptionCode.h\"\n#include \"Frame.h\"\n#include \"FrameLoader.h\"\n#include \"HTMLDocument.h\"\n#include \"JSCanvasRenderingContext2D.h\"\n#if ENABLE(WEBGL)\n#include \"JSWebGLRenderingContext.h\"\n#endif\n#include \"JSDOMWindowCustom.h\"\n#include \"JSHTMLDocument.h\"\n#include \"JSLocation.h\"\n#include \"JSTouch.h\"\n#include \"JSTouchList.h\"\n#include \"Location.h\"\n#include \"ScriptController.h\"\n#include \"TouchList.h\"\n\n#if ENABLE(SVG)\n#include \"JSSVGDocument.h\"\n#include \"SVGDocument.h\"\n#endif\n\n#include \u003cwtf/GetPtr.h\u003e\n\nusing namespace JSC;\n\nnamespace WebCore {\n\nJSValue JSDocument::location(ExecState* exec) const\n{\n    Frame* frame = static_cast\u003cDocument*\u003e(impl())-\u003eframe();\n    if (!frame)\n        return jsNull();\n\n    Location* location = frame-\u003edocument()-\u003edomWindow()-\u003elocation();\n    if (JSDOMWrapper* wrapper = getCachedWrapper(currentWorld(exec), location))\n        return wrapper;\n\n    JSLocation* jsLocation = JSLocation::create(getDOMStructure\u003cJSLocation\u003e(exec, globalObject()), globalObject(), location);\n    cacheWrapper(currentWorld(exec), location, jsLocation);\n    return jsLocation;\n}\n\nvoid JSDocument::setLocation(ExecState* exec, JSValue value)\n{\n    Frame* frame = static_cast\u003cDocument*\u003e(impl())-\u003eframe();\n    if (!frame)\n        return;\n\n    String locationString = value.toString(exec)-\u003evalue(exec);\n    if (exec-\u003ehadException())\n        return;\n\n    if (Location* location = frame-\u003edocument()-\u003edomWindow()-\u003elocation())\n        location-\u003esetHref(locationString, activeDOMWindow(exec), firstDOMWindow(exec));\n}\n\nJSValue toJS(ExecState* exec, JSDOMGlobalObject* globalObject, Document* document)\n{\n    if (!document)\n        return jsNull();\n\n    JSDOMWrapper* wrapper = getCachedWrapper(currentWorld(exec), document);\n    if (wrapper)\n        return wrapper;\n\n    if (DOMWindow* domWindow = document-\u003edomWindow()) {\n        globalObject = toJSDOMWindow(toJS(exec, domWindow));\n        // Creating a wrapper for domWindow might have created a wrapper for document as well.\n        wrapper = getCachedWrapper(currentWorld(exec), document);\n        if (wrapper)\n            return wrapper;\n    }\n\n    if (document-\u003eisHTMLDocument())\n        wrapper = CREATE_DOM_WRAPPER(exec, globalObject, HTMLDocument, document);\n#if ENABLE(SVG)\n    else if (document-\u003eisSVGDocument())\n        wrapper = CREATE_DOM_WRAPPER(exec, globalObject, SVGDocument, document);\n#endif\n    else\n        wrapper = CREATE_DOM_WRAPPER(exec, globalObject, Document, document);\n\n    // Make sure the document is kept around by the window object, and works right with the\n    // back/forward cache.\n    if (!document-\u003eframe()) {\n        size_t nodeCount = 0;\n        for (Node* n = document; n; n = n-\u003etraverseNextNode())\n            nodeCount++;\n        \n        exec-\u003eheap()-\u003ereportExtraMemoryCost(nodeCount * sizeof(Node));\n    }\n\n    return wrapper;\n}\n\n#if ENABLE(TOUCH_EVENTS)\nJSValue JSDocument::createTouchList(ExecState* exec)\n{\n    RefPtr\u003cTouchList\u003e touchList = TouchList::create();\n\n    for (size_t i = 0; i \u003c exec-\u003eargumentCount(); i++)\n        touchList-\u003eappend(toTouch(exec-\u003eargument(i)));\n\n    return toJS(exec, globalObject(), touchList.release());\n}\n#endif\n\n} // namespace WebCore\n"}
{"repo_name":"eugene1g/phantomjs","ref":"refs/heads/master","path":"src/qt/qtwebkit/Source/WebCore/css/CSSSupportsRule.cpp","copies":"124","language":"C++","content":"/* Copyright (C) 2012 Motorola Mobility Inc. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above\n *    copyright notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the distribution.\n * 3. Neither the name of Motorola Mobility Inc. nor the names of its\n *    contributors may be used to endorse or promote products derived from this\n *    software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"config.h\"\n#include \"CSSSupportsRule.h\"\n\n#include \"CSSParser.h\"\n#include \"CSSRule.h\"\n#include \"CSSRuleList.h\"\n#include \"CSSStyleSheet.h\"\n#include \"ExceptionCode.h\"\n#include \"StyleRule.h\"\n#include \u003cwtf/text/StringBuilder.h\u003e\n\n#if ENABLE(CSS3_CONDITIONAL_RULES)\n\nnamespace WebCore {\n\nCSSSupportsRule::CSSSupportsRule(StyleRuleSupports* supportsRule, CSSStyleSheet* parent)\n    : CSSGroupingRule(supportsRule, parent)\n{\n}\n\nString CSSSupportsRule::cssText() const\n{\n    StringBuilder result;\n\n    result.append(\"@supports \");\n    result.append(conditionText());\n    result.append(\" {\\n\");\n    appendCssTextForItems(result);\n    result.append('}');\n\n    return result.toString();\n}\n\nString CSSSupportsRule::conditionText() const\n{\n    return toStyleRuleSupports(m_groupRule.get())-\u003econditionText();\n}\n\n} // namespace WebCore\n\n#endif\n"}
{"repo_name":"Hual/SA-MP-Plus","ref":"refs/heads/master","path":"Common/RakNet/VariableDeltaSerializer.cpp","copies":"7","language":"C++","content":"#include \"VariableDeltaSerializer.h\"\n\nusing namespace RakNet;\n\nVariableDeltaSerializer::VariableDeltaSerializer() {didComparisonThisTick=false;}\nVariableDeltaSerializer::~VariableDeltaSerializer() {RemoveRemoteSystemVariableHistory();}\n\nVariableDeltaSerializer::SerializationContext::SerializationContext() {variableHistoryIdentical=0; variableHistoryUnique=0;}\nVariableDeltaSerializer::SerializationContext::~SerializationContext() {}\n\nvoid VariableDeltaSerializer::OnMessageReceipt(RakNetGUID guid, uint32_t receiptId, bool messageArrived)\n{\n\t// Module?\n\tif (messageArrived)\n\t\tFreeVarsAssociatedWithReceipt(guid, receiptId);\n\telse\n\t\tDirtyAndFreeVarsAssociatedWithReceipt(guid, receiptId);\n\n}\n\nvoid VariableDeltaSerializer::BeginUnreliableAckedSerialize(SerializationContext *context, RakNetGUID _guid, BitStream *_bitStream, uint32_t _sendReceipt)\n{\n\tRakAssert(_guid!=UNASSIGNED_RAKNET_GUID);\n\tcontext-\u003eanyVariablesWritten=false;\n\tcontext-\u003eguid=_guid;\n\tcontext-\u003ebitStream=_bitStream;\n\tif (context-\u003evariableHistoryUnique==0)\n\t\tcontext-\u003evariableHistoryUnique=StartVariableHistoryWrite(_guid);\n\tcontext-\u003evariableHistory=context-\u003evariableHistoryUnique;\n\tcontext-\u003esendReceipt=_sendReceipt;\n\tcontext-\u003echangedVariables = AllocChangedVariablesList();\n\tcontext-\u003enewSystemSend=false;\n\tcontext-\u003eserializationMode=UNRELIABLE_WITH_ACK_RECEIPT;\n}\n\nvoid VariableDeltaSerializer::BeginUniqueSerialize(SerializationContext *context, RakNetGUID _guid, BitStream *_bitStream)\n{\n\tRakAssert(_guid!=UNASSIGNED_RAKNET_GUID);\n\tcontext-\u003eanyVariablesWritten=false;\n\tcontext-\u003eguid=_guid;\n\tcontext-\u003ebitStream=_bitStream;\n\tif (context-\u003evariableHistoryUnique==0)\n\t\tcontext-\u003evariableHistoryUnique=StartVariableHistoryWrite(_guid);\n\tcontext-\u003evariableHistory=context-\u003evariableHistoryUnique;\n\tcontext-\u003enewSystemSend=false;\n\n\tcontext-\u003eserializationMode=RELIABLE;\n}\n\n\nvoid VariableDeltaSerializer::BeginIdenticalSerialize(SerializationContext *context, bool _isFirstSendToRemoteSystem, BitStream *_bitStream)\n{\n\tcontext-\u003eanyVariablesWritten=false;\n\tcontext-\u003eguid=UNASSIGNED_RAKNET_GUID;\n\tcontext-\u003ebitStream=_bitStream;\n\tcontext-\u003eserializationMode=RELIABLE;\n\tif (context-\u003evariableHistoryIdentical==0)\n\t\tcontext-\u003evariableHistoryIdentical=StartVariableHistoryWrite(UNASSIGNED_RAKNET_GUID);\n\tcontext-\u003evariableHistory=context-\u003evariableHistoryIdentical;\n\tcontext-\u003enewSystemSend=_isFirstSendToRemoteSystem;\n}\n\nvoid VariableDeltaSerializer::EndSerialize(SerializationContext *context)\n{\n\tif (context-\u003eserializationMode==UNRELIABLE_WITH_ACK_RECEIPT)\n\t{\n\t\tif (context-\u003eanyVariablesWritten==false)\n\t\t{\n\t\t\tcontext-\u003ebitStream-\u003eReset();\n\t\t\tFreeChangedVariablesList(context-\u003echangedVariables);\n\t\t\treturn;\n\t\t}\n\n\t\tStoreChangedVariablesList(context-\u003evariableHistory, context-\u003echangedVariables, context-\u003esendReceipt);\n\t}\n\telse\n\t{\n\t\tif (context-\u003evariableHistoryIdentical)\n\t\t{\n\t\t\tif (didComparisonThisTick==false)\n\t\t\t{\n\t\t\t\tdidComparisonThisTick=true;\n\t\t\t\tidenticalSerializationBs.Reset();\n\n\t\t\t\tif (context-\u003eanyVariablesWritten==false)\n\t\t\t\t{\n\t\t\t\t\tcontext-\u003ebitStream-\u003eReset();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tidenticalSerializationBs.Write(context-\u003ebitStream);\n\t\t\t\tcontext-\u003ebitStream-\u003eResetReadPointer();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcontext-\u003ebitStream-\u003eWrite(\u0026identicalSerializationBs);\n\t\t\t\tidenticalSerializationBs.ResetReadPointer();\n\t\t\t}\n\t\t}\n\t\telse if (context-\u003eanyVariablesWritten==false)\n\t\t{\n\t\t\tcontext-\u003ebitStream-\u003eReset();\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nvoid VariableDeltaSerializer::BeginDeserialize(DeserializationContext *context, BitStream *_bitStream)\n{\n\tcontext-\u003ebitStream=_bitStream;\n}\n\nvoid VariableDeltaSerializer::EndDeserialize(DeserializationContext *context)\n{\n\t(void) context;\n}\n\nvoid VariableDeltaSerializer::AddRemoteSystemVariableHistory(RakNetGUID guid)\n{\n\t(void) guid;\n}\n\nvoid VariableDeltaSerializer::RemoveRemoteSystemVariableHistory(RakNetGUID guid)\n{\n\tunsigned int idx,idx2;\n\tidx = GetVarsWrittenPerRemoteSystemListIndex(guid);\n\tif (idx==(unsigned int)-1)\n\t\treturn;\n\n\tif (remoteSystemVariableHistoryList[idx]-\u003eguid==guid)\n\t{\n\t\t// Memory pool doesn't call destructor\n\t\tfor (idx2=0; idx2 \u003c remoteSystemVariableHistoryList[idx]-\u003eupdatedVariablesHistory.Size(); idx2++)\n\t\t{\n\t\t\tFreeChangedVariablesList(remoteSystemVariableHistoryList[idx]-\u003eupdatedVariablesHistory[idx2]);\n\t\t}\n\n\t\tdelete remoteSystemVariableHistoryList[idx];\n\t\tremoteSystemVariableHistoryList.RemoveAtIndexFast(idx);\n\t\treturn;\n\t}\n}\n\nint RakNet::VariableDeltaSerializer::UpdatedVariablesListPtrComp( const uint32_t \u0026key, ChangedVariablesList* const \u0026data )\n{\n\tif (key\u003cdata-\u003esendReceipt)\n\t\treturn -1;\n\tif (key==data-\u003esendReceipt)\n\t\treturn 0;\n\treturn 1;\n}\n\nvoid VariableDeltaSerializer::FreeVarsAssociatedWithReceipt(RakNetGUID guid, uint32_t receiptId)\n{\n\tunsigned int idx, idx2;\n\tidx = GetVarsWrittenPerRemoteSystemListIndex(guid);\n\tif (idx==(unsigned int)-1)\n\t\treturn;\n\n\tRemoteSystemVariableHistory* vprs = remoteSystemVariableHistoryList[idx];\n\tbool objectExists;\n\tidx2=vprs-\u003eupdatedVariablesHistory.GetIndexFromKey(receiptId,\u0026objectExists);\n\tif (objectExists)\n\t{\n\t\t// Free this history node\n\t\tFreeChangedVariablesList(vprs-\u003eupdatedVariablesHistory[idx2]);\n\t\tvprs-\u003eupdatedVariablesHistory.RemoveAtIndex(idx2);\n\t}\n}\n\nvoid VariableDeltaSerializer::DirtyAndFreeVarsAssociatedWithReceipt(RakNetGUID guid, uint32_t receiptId)\n{\n\tunsigned int idx, idx2;\n\tidx = GetVarsWrittenPerRemoteSystemListIndex(guid);\n\tif (idx==(unsigned int)-1)\n\t\treturn;\n\n\tRemoteSystemVariableHistory* vprs = remoteSystemVariableHistoryList[idx];\n\tbool objectExists;\n\tidx2=vprs-\u003eupdatedVariablesHistory.GetIndexFromKey(receiptId,\u0026objectExists);\n\tif (objectExists)\n\t{\n\t\t// 'Dirty' all variables sent this update, meaning they will be resent the next time Serialize() is called\n\t\tvprs-\u003evariableListDeltaTracker.FlagDirtyFromBitArray(vprs-\u003eupdatedVariablesHistory[idx2]-\u003ebitField);\n\n\t\t// Free this history node\n\t\tFreeChangedVariablesList(vprs-\u003eupdatedVariablesHistory[idx2]);\n\t\tvprs-\u003eupdatedVariablesHistory.RemoveAtIndex(idx2);\n\t}\n}\nunsigned int VariableDeltaSerializer::GetVarsWrittenPerRemoteSystemListIndex(RakNetGUID guid)\n{\n\tunsigned int idx;\n\tfor (idx=0; idx \u003c remoteSystemVariableHistoryList.Size(); idx++)\n\t{\n\t\tif (remoteSystemVariableHistoryList[idx]-\u003eguid==guid)\n\t\t\treturn idx;\n\t}\n\treturn (unsigned int) -1;\n}\nvoid VariableDeltaSerializer::RemoveRemoteSystemVariableHistory(void)\n{\n\tunsigned int idx,idx2;\n\tfor (idx=0; idx \u003c remoteSystemVariableHistoryList.Size(); idx++)\n\t{\n\t\tfor (idx2=0; idx2 \u003c remoteSystemVariableHistoryList[idx]-\u003eupdatedVariablesHistory.Size(); idx2++)\n\t\t{\n\t\t\tFreeChangedVariablesList(remoteSystemVariableHistoryList[idx]-\u003eupdatedVariablesHistory[idx2]);\n\t\t}\n\n\t\tdelete remoteSystemVariableHistoryList[idx];\n\t}\n\tremoteSystemVariableHistoryList.Clear(false,_FILE_AND_LINE_);\n}\n\nVariableDeltaSerializer::RemoteSystemVariableHistory* VariableDeltaSerializer::GetRemoteSystemVariableHistory(RakNetGUID guid)\n{\n\tunsigned int rshli = GetRemoteSystemHistoryListIndex(guid);\n\treturn remoteSystemVariableHistoryList[rshli];\n}\n\nVariableDeltaSerializer::ChangedVariablesList *VariableDeltaSerializer::AllocChangedVariablesList(void)\n{\n\tVariableDeltaSerializer::ChangedVariablesList *p = updatedVariablesMemoryPool.Allocate(_FILE_AND_LINE_);\n\tp-\u003ebitWriteIndex=0;\n\tp-\u003ebitField[0]=0;\n\treturn p;\n}\nvoid VariableDeltaSerializer::FreeChangedVariablesList(ChangedVariablesList *changedVariables)\n{\n\tupdatedVariablesMemoryPool.Release(changedVariables, _FILE_AND_LINE_);\n}\nvoid VariableDeltaSerializer::StoreChangedVariablesList(RemoteSystemVariableHistory *variableHistory, ChangedVariablesList *changedVariables, uint32_t sendReceipt)\n{\n\tchangedVariables-\u003esendReceipt=sendReceipt;\n\tvariableHistory-\u003eupdatedVariablesHistory.Insert(changedVariables-\u003esendReceipt,changedVariables,true,_FILE_AND_LINE_);\n}\n\nVariableDeltaSerializer::RemoteSystemVariableHistory *VariableDeltaSerializer::StartVariableHistoryWrite(RakNetGUID guid)\n{\n\tRemoteSystemVariableHistory *variableHistory;\n\n\tunsigned int rshli = GetRemoteSystemHistoryListIndex(guid);\n\tif (rshli==(unsigned int) -1)\n\t{\n\t\tvariableHistory = new RemoteSystemVariableHistory;\n\t\tvariableHistory-\u003eguid=guid;\n\t\tremoteSystemVariableHistoryList.Push(variableHistory,_FILE_AND_LINE_);\n\t}\n\telse\n\t{\n\t\tvariableHistory=remoteSystemVariableHistoryList[rshli];\n\t}\n\n\tvariableHistory-\u003evariableListDeltaTracker.StartWrite();\n\treturn variableHistory;\n}\nunsigned int VariableDeltaSerializer::GetRemoteSystemHistoryListIndex(RakNetGUID guid)\n{\n\t// Find the variable tracker for the target system\n\tunsigned int idx;\n\tfor (idx=0; idx \u003c remoteSystemVariableHistoryList.Size(); idx++)\n\t{\n\t\tif (remoteSystemVariableHistoryList[idx]-\u003eguid==guid)\n\t\t{\n\t\t\treturn idx;\n\t\t}\n\t}\n\treturn (unsigned int) -1;\n}\n\nvoid VariableDeltaSerializer::OnPreSerializeTick(void)\n{\n\tdidComparisonThisTick=false;\n}\n"}
{"repo_name":"mgsergio/omim","ref":"refs/heads/master","path":"base/osm_id.cpp","copies":"4","language":"C++","content":"#include \"base/osm_id.hpp\"\n\n#include \"base/assert.hpp\"\n\n#include \u003csstream\u003e\n\n\nnamespace osm\n{\n\n// Use 3 higher bits to encode type\nstatic const uint64_t NODE = 0x4000000000000000ULL;\nstatic const uint64_t WAY = 0x8000000000000000ULL;\nstatic const uint64_t RELATION = 0xC000000000000000ULL;\nstatic const uint64_t RESET = ~(NODE | WAY | RELATION);\n\nId::Id(uint64_t encodedId) : m_encodedId(encodedId)\n{\n}\n\nId Id::Node(uint64_t id)\n{\n  return Id( id | NODE );\n}\n\nId Id::Way(uint64_t id)\n{\n  return Id( id | WAY );\n}\n\nId Id::Relation(uint64_t id)\n{\n  return Id( id | RELATION );\n}\n\nuint64_t Id::OsmId() const\n{\n  return m_encodedId \u0026 RESET;\n}\n\nuint64_t Id::EncodedId() const\n{\n  return m_encodedId;\n}\n\nbool Id::IsNode() const\n{\n  return ((m_encodedId \u0026 NODE) == NODE);\n}\n\nbool Id::IsWay() const\n{\n  return ((m_encodedId \u0026 WAY) == WAY);\n}\n\nbool Id::IsRelation() const\n{\n  return ((m_encodedId \u0026 RELATION) == RELATION);\n}\n\nstd::string Id::Type() const\n{\n  if ((m_encodedId \u0026 RELATION) == RELATION)\n    return \"relation\";\n  else if ((m_encodedId \u0026 NODE) == NODE)\n    return \"node\";\n  else if ((m_encodedId \u0026 WAY) == WAY)\n    return \"way\";\n  else\n    return \"ERROR: Not initialized Osm ID\";\n}\n\nstd::string DebugPrint(osm::Id const \u0026 id)\n{\n  std::ostringstream stream;\n  stream \u003c\u003c id.Type() \u003c\u003c \" \" \u003c\u003c id.OsmId();\n  return stream.str();\n}\n}  // namespace osm\n"}
{"repo_name":"taiki-okano/Algorithm","ref":"refs/heads/master","path":"AOJ/AOJ0554.cpp","copies":"2","language":"C++","content":"#include \u003ccstdio\u003e\n\nint main(){\n\tint sum = 0;\n\tfor(int i = 0; i \u003c 4; ++i){\n\t\tint in;\n\t\tscanf(\"%d\", \u0026in);\n\t\tsum += in;\n\t}\n\tprintf(\"%d\\n\", sum / 60);\n\tprintf(\"%d\\n\", sum % 60);\n\treturn 0;\n}\n"}
{"repo_name":"wiltonlazary/arangodb","ref":"refs/heads/devel","path":"3rdParty/boost/1.61.0/libs/math/test/compile_test/sf_hypot_incl_test.cpp","copies":"62","language":"C++","content":"//  Copyright John Maddock 2006.\n//  Use, modification and distribution are subject to the\n//  Boost Software License, Version 1.0. (See accompanying file\n//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n//\n// Basic sanity check that header \u003cboost/math/special_functions/hypot.hpp\u003e\n// #includes all the files that it needs to.\n//\n#include \u003cboost/math/special_functions/hypot.hpp\u003e\n//\n// Note this header includes no other headers, this is\n// important if this test is to be meaningful:\n//\n#include \"test_compile_result.hpp\"\n\nvoid compile_and_link_test()\n{\n   check_result\u003cfloat\u003e(boost::math::hypot\u003cfloat\u003e(f, f));\n   check_result\u003cdouble\u003e(boost::math::hypot\u003cdouble\u003e(d, d));\n#ifndef BOOST_MATH_NO_LONG_DOUBLE_MATH_FUNCTIONS\n   check_result\u003clong double\u003e(boost::math::hypot\u003clong double\u003e(l, l));\n#endif\n}\n"}
{"repo_name":"hoangt/goblin-core","ref":"refs/heads/master","path":"riscv/llvm/3.5/llvm-3.5.0.src/lib/Target/Mips/MipsSEFrameLowering.cpp","copies":"9","language":"C++","content":"//===-- MipsSEFrameLowering.cpp - Mips32/64 Frame Information -------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n//\n// This file contains the Mips32/64 implementation of TargetFrameLowering class.\n//\n//===----------------------------------------------------------------------===//\n\n#include \"MipsSEFrameLowering.h\"\n#include \"MCTargetDesc/MipsBaseInfo.h\"\n#include \"MipsAnalyzeImmediate.h\"\n#include \"MipsMachineFunction.h\"\n#include \"MipsSEInstrInfo.h\"\n#include \"MipsSubtarget.h\"\n#include \"llvm/CodeGen/MachineFrameInfo.h\"\n#include \"llvm/CodeGen/MachineFunction.h\"\n#include \"llvm/CodeGen/MachineInstrBuilder.h\"\n#include \"llvm/CodeGen/MachineModuleInfo.h\"\n#include \"llvm/CodeGen/MachineRegisterInfo.h\"\n#include \"llvm/CodeGen/RegisterScavenging.h\"\n#include \"llvm/IR/DataLayout.h\"\n#include \"llvm/IR/Function.h\"\n#include \"llvm/Support/CommandLine.h\"\n#include \"llvm/Target/TargetOptions.h\"\n\nusing namespace llvm;\n\nnamespace {\ntypedef MachineBasicBlock::iterator Iter;\n\nstatic std::pair\u003cunsigned, unsigned\u003e getMFHiLoOpc(unsigned Src) {\n  if (Mips::ACC64RegClass.contains(Src))\n    return std::make_pair((unsigned)Mips::PseudoMFHI,\n                          (unsigned)Mips::PseudoMFLO);\n\n  if (Mips::ACC64DSPRegClass.contains(Src))\n    return std::make_pair((unsigned)Mips::MFHI_DSP, (unsigned)Mips::MFLO_DSP);\n\n  if (Mips::ACC128RegClass.contains(Src))\n    return std::make_pair((unsigned)Mips::PseudoMFHI64,\n                          (unsigned)Mips::PseudoMFLO64);\n\n  return std::make_pair(0, 0);\n}\n\n/// Helper class to expand pseudos.\nclass ExpandPseudo {\npublic:\n  ExpandPseudo(MachineFunction \u0026MF);\n  bool expand();\n\nprivate:\n  bool expandInstr(MachineBasicBlock \u0026MBB, Iter I);\n  void expandLoadCCond(MachineBasicBlock \u0026MBB, Iter I);\n  void expandStoreCCond(MachineBasicBlock \u0026MBB, Iter I);\n  void expandLoadACC(MachineBasicBlock \u0026MBB, Iter I, unsigned RegSize);\n  void expandStoreACC(MachineBasicBlock \u0026MBB, Iter I, unsigned MFHiOpc,\n                      unsigned MFLoOpc, unsigned RegSize);\n  bool expandCopy(MachineBasicBlock \u0026MBB, Iter I);\n  bool expandCopyACC(MachineBasicBlock \u0026MBB, Iter I, unsigned MFHiOpc,\n                     unsigned MFLoOpc);\n  bool expandBuildPairF64(MachineBasicBlock \u0026MBB,\n                          MachineBasicBlock::iterator I, bool FP64) const;\n  bool expandExtractElementF64(MachineBasicBlock \u0026MBB,\n                               MachineBasicBlock::iterator I, bool FP64) const;\n\n  MachineFunction \u0026MF;\n  MachineRegisterInfo \u0026MRI;\n};\n}\n\nExpandPseudo::ExpandPseudo(MachineFunction \u0026MF_)\n  : MF(MF_), MRI(MF.getRegInfo()) {}\n\nbool ExpandPseudo::expand() {\n  bool Expanded = false;\n\n  for (MachineFunction::iterator BB = MF.begin(), BBEnd = MF.end();\n       BB != BBEnd; ++BB)\n    for (Iter I = BB-\u003ebegin(), End = BB-\u003eend(); I != End;)\n      Expanded |= expandInstr(*BB, I++);\n\n  return Expanded;\n}\n\nbool ExpandPseudo::expandInstr(MachineBasicBlock \u0026MBB, Iter I) {\n  switch(I-\u003egetOpcode()) {\n  case Mips::LOAD_CCOND_DSP:\n    expandLoadCCond(MBB, I);\n    break;\n  case Mips::STORE_CCOND_DSP:\n    expandStoreCCond(MBB, I);\n    break;\n  case Mips::LOAD_ACC64:\n  case Mips::LOAD_ACC64DSP:\n    expandLoadACC(MBB, I, 4);\n    break;\n  case Mips::LOAD_ACC128:\n    expandLoadACC(MBB, I, 8);\n    break;\n  case Mips::STORE_ACC64:\n    expandStoreACC(MBB, I, Mips::PseudoMFHI, Mips::PseudoMFLO, 4);\n    break;\n  case Mips::STORE_ACC64DSP:\n    expandStoreACC(MBB, I, Mips::MFHI_DSP, Mips::MFLO_DSP, 4);\n    break;\n  case Mips::STORE_ACC128:\n    expandStoreACC(MBB, I, Mips::PseudoMFHI64, Mips::PseudoMFLO64, 8);\n    break;\n  case Mips::BuildPairF64:\n    if (expandBuildPairF64(MBB, I, false))\n      MBB.erase(I);\n    return false;\n  case Mips::BuildPairF64_64:\n    if (expandBuildPairF64(MBB, I, true))\n      MBB.erase(I);\n    return false;\n  case Mips::ExtractElementF64:\n    if (expandExtractElementF64(MBB, I, false))\n      MBB.erase(I);\n    return false;\n  case Mips::ExtractElementF64_64:\n    if (expandExtractElementF64(MBB, I, true))\n      MBB.erase(I);\n    return false;\n  case TargetOpcode::COPY:\n    if (!expandCopy(MBB, I))\n      return false;\n    break;\n  default:\n    return false;\n  }\n\n  MBB.erase(I);\n  return true;\n}\n\nvoid ExpandPseudo::expandLoadCCond(MachineBasicBlock \u0026MBB, Iter I) {\n  //  load $vr, FI\n  //  copy ccond, $vr\n\n  assert(I-\u003egetOperand(0).isReg() \u0026\u0026 I-\u003egetOperand(1).isFI());\n\n  const MipsSEInstrInfo \u0026TII =\n    *static_cast\u003cconst MipsSEInstrInfo*\u003e(MF.getTarget().getInstrInfo());\n  const MipsRegisterInfo \u0026RegInfo =\n    *static_cast\u003cconst MipsRegisterInfo*\u003e(MF.getTarget().getRegisterInfo());\n\n  const TargetRegisterClass *RC = RegInfo.intRegClass(4);\n  unsigned VR = MRI.createVirtualRegister(RC);\n  unsigned Dst = I-\u003egetOperand(0).getReg(), FI = I-\u003egetOperand(1).getIndex();\n\n  TII.loadRegFromStack(MBB, I, VR, FI, RC, \u0026RegInfo, 0);\n  BuildMI(MBB, I, I-\u003egetDebugLoc(), TII.get(TargetOpcode::COPY), Dst)\n    .addReg(VR, RegState::Kill);\n}\n\nvoid ExpandPseudo::expandStoreCCond(MachineBasicBlock \u0026MBB, Iter I) {\n  //  copy $vr, ccond\n  //  store $vr, FI\n\n  assert(I-\u003egetOperand(0).isReg() \u0026\u0026 I-\u003egetOperand(1).isFI());\n\n  const MipsSEInstrInfo \u0026TII =\n    *static_cast\u003cconst MipsSEInstrInfo*\u003e(MF.getTarget().getInstrInfo());\n  const MipsRegisterInfo \u0026RegInfo =\n    *static_cast\u003cconst MipsRegisterInfo*\u003e(MF.getTarget().getRegisterInfo());\n\n  const TargetRegisterClass *RC = RegInfo.intRegClass(4);\n  unsigned VR = MRI.createVirtualRegister(RC);\n  unsigned Src = I-\u003egetOperand(0).getReg(), FI = I-\u003egetOperand(1).getIndex();\n\n  BuildMI(MBB, I, I-\u003egetDebugLoc(), TII.get(TargetOpcode::COPY), VR)\n    .addReg(Src, getKillRegState(I-\u003egetOperand(0).isKill()));\n  TII.storeRegToStack(MBB, I, VR, true, FI, RC, \u0026RegInfo, 0);\n}\n\nvoid ExpandPseudo::expandLoadACC(MachineBasicBlock \u0026MBB, Iter I,\n                                 unsigned RegSize) {\n  //  load $vr0, FI\n  //  copy lo, $vr0\n  //  load $vr1, FI + 4\n  //  copy hi, $vr1\n\n  assert(I-\u003egetOperand(0).isReg() \u0026\u0026 I-\u003egetOperand(1).isFI());\n\n  const MipsSEInstrInfo \u0026TII =\n    *static_cast\u003cconst MipsSEInstrInfo*\u003e(MF.getTarget().getInstrInfo());\n  const MipsRegisterInfo \u0026RegInfo =\n    *static_cast\u003cconst MipsRegisterInfo*\u003e(MF.getTarget().getRegisterInfo());\n\n  const TargetRegisterClass *RC = RegInfo.intRegClass(RegSize);\n  unsigned VR0 = MRI.createVirtualRegister(RC);\n  unsigned VR1 = MRI.createVirtualRegister(RC);\n  unsigned Dst = I-\u003egetOperand(0).getReg(), FI = I-\u003egetOperand(1).getIndex();\n  unsigned Lo = RegInfo.getSubReg(Dst, Mips::sub_lo);\n  unsigned Hi = RegInfo.getSubReg(Dst, Mips::sub_hi);\n  DebugLoc DL = I-\u003egetDebugLoc();\n  const MCInstrDesc \u0026Desc = TII.get(TargetOpcode::COPY);\n\n  TII.loadRegFromStack(MBB, I, VR0, FI, RC, \u0026RegInfo, 0);\n  BuildMI(MBB, I, DL, Desc, Lo).addReg(VR0, RegState::Kill);\n  TII.loadRegFromStack(MBB, I, VR1, FI, RC, \u0026RegInfo, RegSize);\n  BuildMI(MBB, I, DL, Desc, Hi).addReg(VR1, RegState::Kill);\n}\n\nvoid ExpandPseudo::expandStoreACC(MachineBasicBlock \u0026MBB, Iter I,\n                                  unsigned MFHiOpc, unsigned MFLoOpc,\n                                  unsigned RegSize) {\n  //  mflo $vr0, src\n  //  store $vr0, FI\n  //  mfhi $vr1, src\n  //  store $vr1, FI + 4\n\n  assert(I-\u003egetOperand(0).isReg() \u0026\u0026 I-\u003egetOperand(1).isFI());\n\n  const MipsSEInstrInfo \u0026TII =\n    *static_cast\u003cconst MipsSEInstrInfo*\u003e(MF.getTarget().getInstrInfo());\n  const MipsRegisterInfo \u0026RegInfo =\n    *static_cast\u003cconst MipsRegisterInfo*\u003e(MF.getTarget().getRegisterInfo());\n\n  const TargetRegisterClass *RC = RegInfo.intRegClass(RegSize);\n  unsigned VR0 = MRI.createVirtualRegister(RC);\n  unsigned VR1 = MRI.createVirtualRegister(RC);\n  unsigned Src = I-\u003egetOperand(0).getReg(), FI = I-\u003egetOperand(1).getIndex();\n  unsigned SrcKill = getKillRegState(I-\u003egetOperand(0).isKill());\n  DebugLoc DL = I-\u003egetDebugLoc();\n\n  BuildMI(MBB, I, DL, TII.get(MFLoOpc), VR0).addReg(Src);\n  TII.storeRegToStack(MBB, I, VR0, true, FI, RC, \u0026RegInfo, 0);\n  BuildMI(MBB, I, DL, TII.get(MFHiOpc), VR1).addReg(Src, SrcKill);\n  TII.storeRegToStack(MBB, I, VR1, true, FI, RC, \u0026RegInfo, RegSize);\n}\n\nbool ExpandPseudo::expandCopy(MachineBasicBlock \u0026MBB, Iter I) {\n  unsigned Src = I-\u003egetOperand(1).getReg();\n  std::pair\u003cunsigned, unsigned\u003e Opcodes = getMFHiLoOpc(Src);\n\n  if (!Opcodes.first)\n    return false;\n\n  return expandCopyACC(MBB, I, Opcodes.first, Opcodes.second);\n}\n\nbool ExpandPseudo::expandCopyACC(MachineBasicBlock \u0026MBB, Iter I,\n                                 unsigned MFHiOpc, unsigned MFLoOpc) {\n  //  mflo $vr0, src\n  //  copy dst_lo, $vr0\n  //  mfhi $vr1, src\n  //  copy dst_hi, $vr1\n\n  const MipsSEInstrInfo \u0026TII =\n    *static_cast\u003cconst MipsSEInstrInfo*\u003e(MF.getTarget().getInstrInfo());\n  const MipsRegisterInfo \u0026RegInfo =\n    *static_cast\u003cconst MipsRegisterInfo*\u003e(MF.getTarget().getRegisterInfo());\n\n  unsigned Dst = I-\u003egetOperand(0).getReg(), Src = I-\u003egetOperand(1).getReg();\n  unsigned VRegSize = RegInfo.getMinimalPhysRegClass(Dst)-\u003egetSize() / 2;\n  const TargetRegisterClass *RC = RegInfo.intRegClass(VRegSize);\n  unsigned VR0 = MRI.createVirtualRegister(RC);\n  unsigned VR1 = MRI.createVirtualRegister(RC);\n  unsigned SrcKill = getKillRegState(I-\u003egetOperand(1).isKill());\n  unsigned DstLo = RegInfo.getSubReg(Dst, Mips::sub_lo);\n  unsigned DstHi = RegInfo.getSubReg(Dst, Mips::sub_hi);\n  DebugLoc DL = I-\u003egetDebugLoc();\n\n  BuildMI(MBB, I, DL, TII.get(MFLoOpc), VR0).addReg(Src);\n  BuildMI(MBB, I, DL, TII.get(TargetOpcode::COPY), DstLo)\n    .addReg(VR0, RegState::Kill);\n  BuildMI(MBB, I, DL, TII.get(MFHiOpc), VR1).addReg(Src, SrcKill);\n  BuildMI(MBB, I, DL, TII.get(TargetOpcode::COPY), DstHi)\n    .addReg(VR1, RegState::Kill);\n  return true;\n}\n\n/// This method expands the same instruction that MipsSEInstrInfo::\n/// expandBuildPairF64 does, for the case when ABI is fpxx and mthc1 is not\n/// available and the case where the ABI is FP64A. It is implemented here\n/// because frame indexes are eliminated before MipsSEInstrInfo::\n/// expandBuildPairF64 is called.\nbool ExpandPseudo::expandBuildPairF64(MachineBasicBlock \u0026MBB,\n                                      MachineBasicBlock::iterator I,\n                                      bool FP64) const {\n  // For fpxx and when mthc1 is not available, use:\n  //   spill + reload via ldc1\n  //\n  // The case where dmtc1 is available doesn't need to be handled here\n  // because it never creates a BuildPairF64 node.\n  //\n  // The FP64A ABI (fp64 with nooddspreg) must also use a spill/reload sequence\n  // for odd-numbered double precision values (because the lower 32-bits is\n  // transferred with mtc1 which is redirected to the upper half of the even\n  // register). Unfortunately, we have to make this decision before register\n  // allocation so for now we use a spill/reload sequence for all\n  // double-precision values in regardless of being an odd/even register.\n\n  const TargetMachine \u0026TM = MF.getTarget();\n  const MipsSubtarget \u0026Subtarget = TM.getSubtarget\u003cMipsSubtarget\u003e();\n  if ((Subtarget.isABI_FPXX() \u0026\u0026 !Subtarget.hasMTHC1()) ||\n      (FP64 \u0026\u0026 !Subtarget.useOddSPReg())) {\n    const MipsSEInstrInfo \u0026TII =\n      *static_cast\u003cconst MipsSEInstrInfo*\u003e(TM.getInstrInfo());\n    const MipsRegisterInfo \u0026TRI =\n      *static_cast\u003cconst MipsRegisterInfo*\u003e(TM.getRegisterInfo());\n\n    unsigned DstReg = I-\u003egetOperand(0).getReg();\n    unsigned LoReg = I-\u003egetOperand(1).getReg();\n    unsigned HiReg = I-\u003egetOperand(2).getReg();\n\n    // It should be impossible to have FGR64 on MIPS-II or MIPS32r1 (which are\n    // the cases where mthc1 is not available). 64-bit architectures and\n    // MIPS32r2 or later can use FGR64 though.\n    assert(Subtarget.isGP64bit() || Subtarget.hasMTHC1() ||\n           !Subtarget.isFP64bit());\n\n    const TargetRegisterClass *RC = \u0026Mips::GPR32RegClass;\n    const TargetRegisterClass *RC2 =\n        FP64 ? \u0026Mips::FGR64RegClass : \u0026Mips::AFGR64RegClass;\n\n    // We re-use the same spill slot each time so that the stack frame doesn't\n    // grow too much in functions with a large number of moves.\n    int FI = MF.getInfo\u003cMipsFunctionInfo\u003e()-\u003egetMoveF64ViaSpillFI(RC2);\n    TII.storeRegToStack(MBB, I, LoReg, I-\u003egetOperand(1).isKill(), FI, RC, \u0026TRI,\n                        0);\n    TII.storeRegToStack(MBB, I, HiReg, I-\u003egetOperand(2).isKill(), FI, RC, \u0026TRI,\n                        4);\n    TII.loadRegFromStack(MBB, I, DstReg, FI, RC2, \u0026TRI, 0);\n    return true;\n  }\n\n  return false;\n}\n\n/// This method expands the same instruction that MipsSEInstrInfo::\n/// expandExtractElementF64 does, for the case when ABI is fpxx and mfhc1 is not\n/// available and the case where the ABI is FP64A. It is implemented here\n/// because frame indexes are eliminated before MipsSEInstrInfo::\n/// expandExtractElementF64 is called.\nbool ExpandPseudo::expandExtractElementF64(MachineBasicBlock \u0026MBB,\n                                           MachineBasicBlock::iterator I,\n                                           bool FP64) const {\n  // For fpxx and when mfhc1 is not available, use:\n  //   spill + reload via ldc1\n  //\n  // The case where dmfc1 is available doesn't need to be handled here\n  // because it never creates a ExtractElementF64 node.\n  //\n  // The FP64A ABI (fp64 with nooddspreg) must also use a spill/reload sequence\n  // for odd-numbered double precision values (because the lower 32-bits is\n  // transferred with mfc1 which is redirected to the upper half of the even\n  // register). Unfortunately, we have to make this decision before register\n  // allocation so for now we use a spill/reload sequence for all\n  // double-precision values in regardless of being an odd/even register.\n\n  const TargetMachine \u0026TM = MF.getTarget();\n  const MipsSubtarget \u0026Subtarget = TM.getSubtarget\u003cMipsSubtarget\u003e();\n  if ((Subtarget.isABI_FPXX() \u0026\u0026 !Subtarget.hasMTHC1()) ||\n      (FP64 \u0026\u0026 !Subtarget.useOddSPReg())) {\n    const MipsSEInstrInfo \u0026TII =\n        *static_cast\u003cconst MipsSEInstrInfo *\u003e(TM.getInstrInfo());\n    const MipsRegisterInfo \u0026TRI =\n        *static_cast\u003cconst MipsRegisterInfo *\u003e(TM.getRegisterInfo());\n\n    unsigned DstReg = I-\u003egetOperand(0).getReg();\n    unsigned SrcReg = I-\u003egetOperand(1).getReg();\n    unsigned N = I-\u003egetOperand(2).getImm();\n\n    // It should be impossible to have FGR64 on MIPS-II or MIPS32r1 (which are\n    // the cases where mfhc1 is not available). 64-bit architectures and\n    // MIPS32r2 or later can use FGR64 though.\n    assert(Subtarget.isGP64bit() || Subtarget.hasMTHC1() ||\n           !Subtarget.isFP64bit());\n\n    const TargetRegisterClass *RC =\n        FP64 ? \u0026Mips::FGR64RegClass : \u0026Mips::AFGR64RegClass;\n    const TargetRegisterClass *RC2 = \u0026Mips::GPR32RegClass;\n\n    // We re-use the same spill slot each time so that the stack frame doesn't\n    // grow too much in functions with a large number of moves.\n    int FI = MF.getInfo\u003cMipsFunctionInfo\u003e()-\u003egetMoveF64ViaSpillFI(RC);\n    TII.storeRegToStack(MBB, I, SrcReg, I-\u003egetOperand(1).isKill(), FI, RC, \u0026TRI,\n                        0);\n    TII.loadRegFromStack(MBB, I, DstReg, FI, RC2, \u0026TRI, N * 4);\n    return true;\n  }\n\n  return false;\n}\n\nMipsSEFrameLowering::MipsSEFrameLowering(const MipsSubtarget \u0026STI)\n    : MipsFrameLowering(STI, STI.stackAlignment()) {}\n\nunsigned MipsSEFrameLowering::ehDataReg(unsigned I) const {\n  static const unsigned EhDataReg[] = {\n    Mips::A0, Mips::A1, Mips::A2, Mips::A3\n  };\n  static const unsigned EhDataReg64[] = {\n    Mips::A0_64, Mips::A1_64, Mips::A2_64, Mips::A3_64\n  };\n\n  return STI.isABI_N64() ? EhDataReg64[I] : EhDataReg[I];\n}\n\nvoid MipsSEFrameLowering::emitPrologue(MachineFunction \u0026MF) const {\n  MachineBasicBlock \u0026MBB   = MF.front();\n  MachineFrameInfo *MFI    = MF.getFrameInfo();\n  MipsFunctionInfo *MipsFI = MF.getInfo\u003cMipsFunctionInfo\u003e();\n\n  const MipsSEInstrInfo \u0026TII =\n    *static_cast\u003cconst MipsSEInstrInfo*\u003e(MF.getTarget().getInstrInfo());\n  const MipsRegisterInfo \u0026RegInfo =\n    *static_cast\u003cconst MipsRegisterInfo*\u003e(MF.getTarget().getRegisterInfo());\n\n  MachineBasicBlock::iterator MBBI = MBB.begin();\n  DebugLoc dl = MBBI != MBB.end() ? MBBI-\u003egetDebugLoc() : DebugLoc();\n  unsigned SP = STI.isABI_N64() ? Mips::SP_64 : Mips::SP;\n  unsigned FP = STI.isABI_N64() ? Mips::FP_64 : Mips::FP;\n  unsigned ZERO = STI.isABI_N64() ? Mips::ZERO_64 : Mips::ZERO;\n  unsigned ADDu = STI.isABI_N64() ? Mips::DADDu : Mips::ADDu;\n\n  // First, compute final stack size.\n  uint64_t StackSize = MFI-\u003egetStackSize();\n\n  // No need to allocate space on the stack.\n  if (StackSize == 0 \u0026\u0026 !MFI-\u003eadjustsStack()) return;\n\n  MachineModuleInfo \u0026MMI = MF.getMMI();\n  const MCRegisterInfo *MRI = MMI.getContext().getRegisterInfo();\n  MachineLocation DstML, SrcML;\n\n  // Adjust stack.\n  TII.adjustStackPtr(SP, -StackSize, MBB, MBBI);\n\n  // emit \".cfi_def_cfa_offset StackSize\"\n  unsigned CFIIndex = MMI.addFrameInst(\n      MCCFIInstruction::createDefCfaOffset(nullptr, -StackSize));\n  BuildMI(MBB, MBBI, dl, TII.get(TargetOpcode::CFI_INSTRUCTION))\n      .addCFIIndex(CFIIndex);\n\n  const std::vector\u003cCalleeSavedInfo\u003e \u0026CSI = MFI-\u003egetCalleeSavedInfo();\n\n  if (CSI.size()) {\n    // Find the instruction past the last instruction that saves a callee-saved\n    // register to the stack.\n    for (unsigned i = 0; i \u003c CSI.size(); ++i)\n      ++MBBI;\n\n    // Iterate over list of callee-saved registers and emit .cfi_offset\n    // directives.\n    for (std::vector\u003cCalleeSavedInfo\u003e::const_iterator I = CSI.begin(),\n           E = CSI.end(); I != E; ++I) {\n      int64_t Offset = MFI-\u003egetObjectOffset(I-\u003egetFrameIdx());\n      unsigned Reg = I-\u003egetReg();\n\n      // If Reg is a double precision register, emit two cfa_offsets,\n      // one for each of the paired single precision registers.\n      if (Mips::AFGR64RegClass.contains(Reg)) {\n        unsigned Reg0 =\n            MRI-\u003egetDwarfRegNum(RegInfo.getSubReg(Reg, Mips::sub_lo), true);\n        unsigned Reg1 =\n            MRI-\u003egetDwarfRegNum(RegInfo.getSubReg(Reg, Mips::sub_hi), true);\n\n        if (!STI.isLittle())\n          std::swap(Reg0, Reg1);\n\n        unsigned CFIIndex = MMI.addFrameInst(\n            MCCFIInstruction::createOffset(nullptr, Reg0, Offset));\n        BuildMI(MBB, MBBI, dl, TII.get(TargetOpcode::CFI_INSTRUCTION))\n            .addCFIIndex(CFIIndex);\n\n        CFIIndex = MMI.addFrameInst(\n            MCCFIInstruction::createOffset(nullptr, Reg1, Offset + 4));\n        BuildMI(MBB, MBBI, dl, TII.get(TargetOpcode::CFI_INSTRUCTION))\n            .addCFIIndex(CFIIndex);\n      } else if (Mips::FGR64RegClass.contains(Reg)) {\n        unsigned Reg0 = MRI-\u003egetDwarfRegNum(Reg, true);\n        unsigned Reg1 = MRI-\u003egetDwarfRegNum(Reg, true) + 1;\n\n        if (!STI.isLittle())\n          std::swap(Reg0, Reg1);\n\n        unsigned CFIIndex = MMI.addFrameInst(\n          MCCFIInstruction::createOffset(nullptr, Reg0, Offset));\n        BuildMI(MBB, MBBI, dl, TII.get(TargetOpcode::CFI_INSTRUCTION))\n            .addCFIIndex(CFIIndex);\n\n        CFIIndex = MMI.addFrameInst(\n          MCCFIInstruction::createOffset(nullptr, Reg1, Offset + 4));\n        BuildMI(MBB, MBBI, dl, TII.get(TargetOpcode::CFI_INSTRUCTION))\n            .addCFIIndex(CFIIndex);\n      } else {\n        // Reg is either in GPR32 or FGR32.\n        unsigned CFIIndex = MMI.addFrameInst(MCCFIInstruction::createOffset(\n            nullptr, MRI-\u003egetDwarfRegNum(Reg, 1), Offset));\n        BuildMI(MBB, MBBI, dl, TII.get(TargetOpcode::CFI_INSTRUCTION))\n            .addCFIIndex(CFIIndex);\n      }\n    }\n  }\n\n  if (MipsFI-\u003ecallsEhReturn()) {\n    const TargetRegisterClass *RC = STI.isABI_N64() ?\n        \u0026Mips::GPR64RegClass : \u0026Mips::GPR32RegClass;\n\n    // Insert instructions that spill eh data registers.\n    for (int I = 0; I \u003c 4; ++I) {\n      if (!MBB.isLiveIn(ehDataReg(I)))\n        MBB.addLiveIn(ehDataReg(I));\n      TII.storeRegToStackSlot(MBB, MBBI, ehDataReg(I), false,\n                              MipsFI-\u003egetEhDataRegFI(I), RC, \u0026RegInfo);\n    }\n\n    // Emit .cfi_offset directives for eh data registers.\n    for (int I = 0; I \u003c 4; ++I) {\n      int64_t Offset = MFI-\u003egetObjectOffset(MipsFI-\u003egetEhDataRegFI(I));\n      unsigned Reg = MRI-\u003egetDwarfRegNum(ehDataReg(I), true);\n      unsigned CFIIndex = MMI.addFrameInst(\n          MCCFIInstruction::createOffset(nullptr, Reg, Offset));\n      BuildMI(MBB, MBBI, dl, TII.get(TargetOpcode::CFI_INSTRUCTION))\n          .addCFIIndex(CFIIndex);\n    }\n  }\n\n  // if framepointer enabled, set it to point to the stack pointer.\n  if (hasFP(MF)) {\n    // Insert instruction \"move $fp, $sp\" at this location.\n    BuildMI(MBB, MBBI, dl, TII.get(ADDu), FP).addReg(SP).addReg(ZERO)\n      .setMIFlag(MachineInstr::FrameSetup);\n\n    // emit \".cfi_def_cfa_register $fp\"\n    unsigned CFIIndex = MMI.addFrameInst(MCCFIInstruction::createDefCfaRegister(\n        nullptr, MRI-\u003egetDwarfRegNum(FP, true)));\n    BuildMI(MBB, MBBI, dl, TII.get(TargetOpcode::CFI_INSTRUCTION))\n        .addCFIIndex(CFIIndex);\n  }\n}\n\nvoid MipsSEFrameLowering::emitEpilogue(MachineFunction \u0026MF,\n                                       MachineBasicBlock \u0026MBB) const {\n  MachineBasicBlock::iterator MBBI = MBB.getLastNonDebugInstr();\n  MachineFrameInfo *MFI            = MF.getFrameInfo();\n  MipsFunctionInfo *MipsFI = MF.getInfo\u003cMipsFunctionInfo\u003e();\n\n  const MipsSEInstrInfo \u0026TII =\n    *static_cast\u003cconst MipsSEInstrInfo*\u003e(MF.getTarget().getInstrInfo());\n  const MipsRegisterInfo \u0026RegInfo =\n    *static_cast\u003cconst MipsRegisterInfo*\u003e(MF.getTarget().getRegisterInfo());\n\n  DebugLoc dl = MBBI-\u003egetDebugLoc();\n  unsigned SP = STI.isABI_N64() ? Mips::SP_64 : Mips::SP;\n  unsigned FP = STI.isABI_N64() ? Mips::FP_64 : Mips::FP;\n  unsigned ZERO = STI.isABI_N64() ? Mips::ZERO_64 : Mips::ZERO;\n  unsigned ADDu = STI.isABI_N64() ? Mips::DADDu : Mips::ADDu;\n\n  // if framepointer enabled, restore the stack pointer.\n  if (hasFP(MF)) {\n    // Find the first instruction that restores a callee-saved register.\n    MachineBasicBlock::iterator I = MBBI;\n\n    for (unsigned i = 0; i \u003c MFI-\u003egetCalleeSavedInfo().size(); ++i)\n      --I;\n\n    // Insert instruction \"move $sp, $fp\" at this location.\n    BuildMI(MBB, I, dl, TII.get(ADDu), SP).addReg(FP).addReg(ZERO);\n  }\n\n  if (MipsFI-\u003ecallsEhReturn()) {\n    const TargetRegisterClass *RC = STI.isABI_N64() ?\n        \u0026Mips::GPR64RegClass : \u0026Mips::GPR32RegClass;\n\n    // Find first instruction that restores a callee-saved register.\n    MachineBasicBlock::iterator I = MBBI;\n    for (unsigned i = 0; i \u003c MFI-\u003egetCalleeSavedInfo().size(); ++i)\n      --I;\n\n    // Insert instructions that restore eh data registers.\n    for (int J = 0; J \u003c 4; ++J) {\n      TII.loadRegFromStackSlot(MBB, I, ehDataReg(J), MipsFI-\u003egetEhDataRegFI(J),\n                               RC, \u0026RegInfo);\n    }\n  }\n\n  // Get the number of bytes from FrameInfo\n  uint64_t StackSize = MFI-\u003egetStackSize();\n\n  if (!StackSize)\n    return;\n\n  // Adjust stack.\n  TII.adjustStackPtr(SP, StackSize, MBB, MBBI);\n}\n\nbool MipsSEFrameLowering::\nspillCalleeSavedRegisters(MachineBasicBlock \u0026MBB,\n                          MachineBasicBlock::iterator MI,\n                          const std::vector\u003cCalleeSavedInfo\u003e \u0026CSI,\n                          const TargetRegisterInfo *TRI) const {\n  MachineFunction *MF = MBB.getParent();\n  MachineBasicBlock *EntryBlock = MF-\u003ebegin();\n  const TargetInstrInfo \u0026TII = *MF-\u003egetTarget().getInstrInfo();\n\n  for (unsigned i = 0, e = CSI.size(); i != e; ++i) {\n    // Add the callee-saved register as live-in. Do not add if the register is\n    // RA and return address is taken, because it has already been added in\n    // method MipsTargetLowering::LowerRETURNADDR.\n    // It's killed at the spill, unless the register is RA and return address\n    // is taken.\n    unsigned Reg = CSI[i].getReg();\n    bool IsRAAndRetAddrIsTaken = (Reg == Mips::RA || Reg == Mips::RA_64)\n        \u0026\u0026 MF-\u003egetFrameInfo()-\u003eisReturnAddressTaken();\n    if (!IsRAAndRetAddrIsTaken)\n      EntryBlock-\u003eaddLiveIn(Reg);\n\n    // Insert the spill to the stack frame.\n    bool IsKill = !IsRAAndRetAddrIsTaken;\n    const TargetRegisterClass *RC = TRI-\u003egetMinimalPhysRegClass(Reg);\n    TII.storeRegToStackSlot(*EntryBlock, MI, Reg, IsKill,\n                            CSI[i].getFrameIdx(), RC, TRI);\n  }\n\n  return true;\n}\n\nbool\nMipsSEFrameLowering::hasReservedCallFrame(const MachineFunction \u0026MF) const {\n  const MachineFrameInfo *MFI = MF.getFrameInfo();\n\n  // Reserve call frame if the size of the maximum call frame fits into 16-bit\n  // immediate field and there are no variable sized objects on the stack.\n  // Make sure the second register scavenger spill slot can be accessed with one\n  // instruction.\n  return isInt\u003c16\u003e(MFI-\u003egetMaxCallFrameSize() + getStackAlignment()) \u0026\u0026\n    !MFI-\u003ehasVarSizedObjects();\n}\n\n// Eliminate ADJCALLSTACKDOWN, ADJCALLSTACKUP pseudo instructions\nvoid MipsSEFrameLowering::\neliminateCallFramePseudoInstr(MachineFunction \u0026MF, MachineBasicBlock \u0026MBB,\n                              MachineBasicBlock::iterator I) const {\n  const MipsSEInstrInfo \u0026TII =\n    *static_cast\u003cconst MipsSEInstrInfo*\u003e(MF.getTarget().getInstrInfo());\n\n  if (!hasReservedCallFrame(MF)) {\n    int64_t Amount = I-\u003egetOperand(0).getImm();\n\n    if (I-\u003egetOpcode() == Mips::ADJCALLSTACKDOWN)\n      Amount = -Amount;\n\n    unsigned SP = STI.isABI_N64() ? Mips::SP_64 : Mips::SP;\n    TII.adjustStackPtr(SP, Amount, MBB, I);\n  }\n\n  MBB.erase(I);\n}\n\nvoid MipsSEFrameLowering::\nprocessFunctionBeforeCalleeSavedScan(MachineFunction \u0026MF,\n                                     RegScavenger *RS) const {\n  MachineRegisterInfo \u0026MRI = MF.getRegInfo();\n  MipsFunctionInfo *MipsFI = MF.getInfo\u003cMipsFunctionInfo\u003e();\n  unsigned FP = STI.isABI_N64() ? Mips::FP_64 : Mips::FP;\n\n  // Mark $fp as used if function has dedicated frame pointer.\n  if (hasFP(MF))\n    MRI.setPhysRegUsed(FP);\n\n  // Create spill slots for eh data registers if function calls eh_return.\n  if (MipsFI-\u003ecallsEhReturn())\n    MipsFI-\u003ecreateEhDataRegsFI();\n\n  // Expand pseudo instructions which load, store or copy accumulators.\n  // Add an emergency spill slot if a pseudo was expanded.\n  if (ExpandPseudo(MF).expand()) {\n    // The spill slot should be half the size of the accumulator. If target is\n    // mips64, it should be 64-bit, otherwise it should be 32-bt.\n    const TargetRegisterClass *RC = STI.hasMips64() ?\n      \u0026Mips::GPR64RegClass : \u0026Mips::GPR32RegClass;\n    int FI = MF.getFrameInfo()-\u003eCreateStackObject(RC-\u003egetSize(),\n                                                  RC-\u003egetAlignment(), false);\n    RS-\u003eaddScavengingFrameIndex(FI);\n  }\n\n  // Set scavenging frame index if necessary.\n  uint64_t MaxSPOffset = MF.getInfo\u003cMipsFunctionInfo\u003e()-\u003egetIncomingArgSize() +\n    estimateStackSize(MF);\n\n  if (isInt\u003c16\u003e(MaxSPOffset))\n    return;\n\n  const TargetRegisterClass *RC = STI.isABI_N64() ?\n    \u0026Mips::GPR64RegClass : \u0026Mips::GPR32RegClass;\n  int FI = MF.getFrameInfo()-\u003eCreateStackObject(RC-\u003egetSize(),\n                                                RC-\u003egetAlignment(), false);\n  RS-\u003eaddScavengingFrameIndex(FI);\n}\n\nconst MipsFrameLowering *\nllvm::createMipsSEFrameLowering(const MipsSubtarget \u0026ST) {\n  return new MipsSEFrameLowering(ST);\n}\n"}
{"repo_name":"SignFinder/FaceCore","ref":"refs/heads/master","path":"src/server/game/Movement/MovementGenerators/PointMovementGenerator.cpp","copies":"34","language":"C++","content":"/*\n * Copyright (C) 2008-2013 TrinityCore \u003chttp://www.trinitycore.org/\u003e\n * Copyright (C) 2005-2009 MaNGOS \u003chttp://getmangos.com/\u003e\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the\n * Free Software Foundation; either version 2 of the License, or (at your\n * option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n * more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program. If not, see \u003chttp://www.gnu.org/licenses/\u003e.\n */\n\n#include \"PointMovementGenerator.h\"\n#include \"Errors.h\"\n#include \"Creature.h\"\n#include \"CreatureAI.h\"\n#include \"World.h\"\n#include \"MoveSplineInit.h\"\n#include \"MoveSpline.h\"\n#include \"Player.h\"\n\n//----- Point Movement Generator\ntemplate\u003cclass T\u003e\nvoid PointMovementGenerator\u003cT\u003e::DoInitialize(T* unit)\n{\n    if (!unit-\u003eIsStopped())\n        unit-\u003eStopMoving();\n\n    unit-\u003eAddUnitState(UNIT_STATE_ROAMING|UNIT_STATE_ROAMING_MOVE);\n\n    if (id == EVENT_CHARGE_PREPATH)\n        return;\n\n    Movement::MoveSplineInit init(unit);\n    init.MoveTo(i_x, i_y, i_z, m_generatePath);\n    if (speed \u003e 0.0f)\n        init.SetVelocity(speed);\n    init.Launch();\n}\n\ntemplate\u003cclass T\u003e\nbool PointMovementGenerator\u003cT\u003e::DoUpdate(T* unit, uint32 /*diff*/)\n{\n    if (!unit)\n        return false;\n\n    if (unit-\u003eHasUnitState(UNIT_STATE_ROOT | UNIT_STATE_STUNNED))\n    {\n        unit-\u003eClearUnitState(UNIT_STATE_ROAMING_MOVE);\n        return true;\n    }\n\n    unit-\u003eAddUnitState(UNIT_STATE_ROAMING_MOVE);\n\n    if (id != EVENT_CHARGE_PREPATH \u0026\u0026 i_recalculateSpeed \u0026\u0026 !unit-\u003emovespline-\u003eFinalized())\n    {\n        i_recalculateSpeed = false;\n        Movement::MoveSplineInit init(unit);\n        init.MoveTo(i_x, i_y, i_z, m_generatePath);\n        if (speed \u003e 0.0f) // Default value for point motion type is 0.0, if 0.0 spline will use GetSpeed on unit\n            init.SetVelocity(speed);\n        init.Launch();\n    }\n\n    return !unit-\u003emovespline-\u003eFinalized();\n}\n\ntemplate\u003cclass T\u003e\nvoid PointMovementGenerator\u003cT\u003e::DoFinalize(T* unit)\n{\n    if (unit-\u003eHasUnitState(UNIT_STATE_CHARGING))\n        unit-\u003eClearUnitState(UNIT_STATE_ROAMING | UNIT_STATE_ROAMING_MOVE);\n\n    if (unit-\u003emovespline-\u003eFinalized())\n        MovementInform(unit);\n}\n\ntemplate\u003cclass T\u003e\nvoid PointMovementGenerator\u003cT\u003e::DoReset(T* unit)\n{\n    if (!unit-\u003eIsStopped())\n        unit-\u003eStopMoving();\n\n    unit-\u003eAddUnitState(UNIT_STATE_ROAMING|UNIT_STATE_ROAMING_MOVE);\n}\n\ntemplate\u003cclass T\u003e\nvoid PointMovementGenerator\u003cT\u003e::MovementInform(T* /*unit*/)\n{\n}\n\ntemplate \u003c\u003e void PointMovementGenerator\u003cCreature\u003e::MovementInform(Creature* unit)\n{\n    if (unit-\u003eAI())\n        unit-\u003eAI()-\u003eMovementInform(POINT_MOTION_TYPE, id);\n}\n\ntemplate void PointMovementGenerator\u003cPlayer\u003e::DoInitialize(Player*);\ntemplate void PointMovementGenerator\u003cCreature\u003e::DoInitialize(Creature*);\ntemplate void PointMovementGenerator\u003cPlayer\u003e::DoFinalize(Player*);\ntemplate void PointMovementGenerator\u003cCreature\u003e::DoFinalize(Creature*);\ntemplate void PointMovementGenerator\u003cPlayer\u003e::DoReset(Player*);\ntemplate void PointMovementGenerator\u003cCreature\u003e::DoReset(Creature*);\ntemplate bool PointMovementGenerator\u003cPlayer\u003e::DoUpdate(Player*, uint32);\ntemplate bool PointMovementGenerator\u003cCreature\u003e::DoUpdate(Creature*, uint32);\n\nvoid AssistanceMovementGenerator::Finalize(Unit* unit)\n{\n    unit-\u003eToCreature()-\u003eSetNoCallAssistance(false);\n    unit-\u003eToCreature()-\u003eCallAssistance();\n    if (unit-\u003eisAlive())\n        unit-\u003eGetMotionMaster()-\u003eMoveSeekAssistanceDistract(sWorld-\u003egetIntConfig(CONFIG_CREATURE_FAMILY_ASSISTANCE_DELAY));\n}\n\nbool EffectMovementGenerator::Update(Unit* unit, uint32)\n{\n    return !unit-\u003emovespline-\u003eFinalized();\n}\n\nvoid EffectMovementGenerator::Finalize(Unit* unit)\n{\n    if (unit-\u003eGetTypeId() != TYPEID_UNIT)\n        return;\n\n    // Need restore previous movement since we have no proper states system\n    if (unit-\u003eisAlive() \u0026\u0026 !unit-\u003eHasUnitState(UNIT_STATE_CONFUSED | UNIT_STATE_FLEEING))\n    {\n        if (Unit* victim = unit-\u003egetVictim())\n            unit-\u003eGetMotionMaster()-\u003eMoveChase(victim);\n        else\n            unit-\u003eGetMotionMaster()-\u003eInitialize();\n    }\n\n    if (unit-\u003eToCreature()-\u003eAI())\n        unit-\u003eToCreature()-\u003eAI()-\u003eMovementInform(EFFECT_MOTION_TYPE, m_Id);\n}\n"}
{"repo_name":"cypsun/FreeCAD","ref":"refs/heads/master","path":"src/Mod/Robot/Gui/ViewProviderTrajectory.cpp","copies":"17","language":"C++","content":"/***************************************************************************\r\n *   Copyright (c) 2008 Jürgen Riegel (juergen.riegel@web.de)              *\r\n *                                                                         *\r\n *   This file is part of the FreeCAD CAx development system.              *\r\n *                                                                         *\r\n *   This library is free software; you can redistribute it and/or         *\r\n *   modify it under the terms of the GNU Library General Public           *\r\n *   License as published by the Free Software Foundation; either          *\r\n *   version 2 of the License, or (at your option) any later version.      *\r\n *                                                                         *\r\n *   This library  is distributed in the hope that it will be useful,      *\r\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *\r\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *\r\n *   GNU Library General Public License for more details.                  *\r\n *                                                                         *\r\n *   You should have received a copy of the GNU Library General Public     *\r\n *   License along with this library; see the file COPYING.LIB. If not,    *\r\n *   write to the Free Software Foundation, Inc., 59 Temple Place,         *\r\n *   Suite 330, Boston, MA  02111-1307, USA                                *\r\n *                                                                         *\r\n ***************************************************************************/\r\n\r\n\r\n#include \"PreCompiled.h\"\r\n\r\n#ifndef _PreComp_\n# include \u003cInventor/SoDB.h\u003e\r\n# include \u003cInventor/SoInput.h\u003e\r\n# include \u003cInventor/SbVec3f.h\u003e\r\n# include \u003cInventor/nodes/SoSeparator.h\u003e\r\n# include \u003cInventor/nodes/SoTransform.h\u003e\r\n# include \u003cInventor/nodes/SoSphere.h\u003e\r\n# include \u003cInventor/nodes/SoRotation.h\u003e\r\n# include \u003cInventor/actions/SoSearchAction.h\u003e\r\n# include \u003cInventor/draggers/SoJackDragger.h\u003e\r\n# include \u003cInventor/VRMLnodes/SoVRMLTransform.h\u003e\r\n# include \u003cInventor/nodes/SoBaseColor.h\u003e\r\n# include \u003cInventor/nodes/SoCoordinate3.h\u003e\r\n# include \u003cInventor/nodes/SoDrawStyle.h\u003e\r\n# include \u003cInventor/nodes/SoFaceSet.h\u003e\r\n# include \u003cInventor/nodes/SoLineSet.h\u003e\r\n# include \u003cInventor/nodes/SoMarkerSet.h\u003e\r\n# include \u003cInventor/nodes/SoShapeHints.h\u003e\r\n# include \u003cQFile\u003e\r\n#endif\r\n\r\n#include \"ViewProviderTrajectory.h\"\r\n\r\n#include \u003cMod/Robot/App/TrajectoryObject.h\u003e\r\n#include \u003cMod/Robot/App/Trajectory.h\u003e\r\n#include \u003cApp/Document.h\u003e\n#include \u003cBase/FileInfo.h\u003e\r\n#include \u003cBase/Stream.h\u003e\r\n#include \u003cBase/Console.h\u003e\r\n#include \u003csstream\u003e\r\nusing namespace Gui;\r\nusing namespace RobotGui;\r\nusing namespace Robot;\r\n\r\nPROPERTY_SOURCE(RobotGui::ViewProviderTrajectory, Gui::ViewProviderGeometryObject)\r\n\r\nViewProviderTrajectory::ViewProviderTrajectory()\r\n{\n    \n\tpcTrajectoryRoot = new Gui::SoFCSelection();\n    pcTrajectoryRoot-\u003ehighlightMode = Gui::SoFCSelection::OFF;\r\n    pcTrajectoryRoot-\u003eselectionMode = Gui::SoFCSelection::SEL_OFF;\r\n    //pcRobotRoot-\u003estyle = Gui::SoFCSelection::BOX;\r\n    pcTrajectoryRoot-\u003eref();\r\n\r\n    pcCoords = new SoCoordinate3();\r\n    pcCoords-\u003eref();\r\n    pcDrawStyle = new SoDrawStyle();\r\n    pcDrawStyle-\u003eref();\r\n    pcDrawStyle-\u003estyle = SoDrawStyle::LINES;\r\n    pcDrawStyle-\u003elineWidth = 2;\r\n\r\n    pcLines = new SoLineSet;\r\n    pcLines-\u003eref();\r\n\r\n\r\n}\r\n\r\nViewProviderTrajectory::~ViewProviderTrajectory()\r\n{\n    pcTrajectoryRoot-\u003eunref();\r\n    pcCoords-\u003eunref();\r\n    pcDrawStyle-\u003eunref();\r\n    pcLines-\u003eunref();\r\n\r\n}\r\n\r\nvoid ViewProviderTrajectory::attach(App::DocumentObject *pcObj)\r\n{\r\n    ViewProviderDocumentObject::attach(pcObj);\r\n\r\n    // Draw trajectory lines\r\n    SoSeparator* linesep = new SoSeparator;\r\n    SoBaseColor * basecol = new SoBaseColor;\r\n    basecol-\u003ergb.setValue( 1.0f, 0.5f, 0.0f );\r\n    linesep-\u003eaddChild(basecol);\r\n    linesep-\u003eaddChild(pcCoords);\r\n    linesep-\u003eaddChild(pcLines);\r\n\r\n    // Draw markers\r\n    SoBaseColor * markcol = new SoBaseColor;\r\n    markcol-\u003ergb.setValue( 1.0f, 1.0f, 0.0f );\r\n    SoMarkerSet* marker = new SoMarkerSet;\r\n    marker-\u003emarkerIndex=SoMarkerSet::CROSS_5_5;\r\n    linesep-\u003eaddChild(markcol);\r\n    linesep-\u003eaddChild(marker);\r\n\r\n    pcTrajectoryRoot-\u003eaddChild(linesep);\r\n\n    addDisplayMaskMode(pcTrajectoryRoot, \"Waypoints\");\n    pcTrajectoryRoot-\u003eobjectName = pcObj-\u003egetNameInDocument();\r\n    pcTrajectoryRoot-\u003edocumentName = pcObj-\u003egetDocument()-\u003egetName();\r\n    pcTrajectoryRoot-\u003esubElementName = \"Main\";\r\n\r\n}\r\n\nvoid ViewProviderTrajectory::setDisplayMode(const char* ModeName)\n{\n    if ( strcmp(\"Waypoints\",ModeName)==0 )\n        setDisplayMaskMode(\"Waypoints\");\n    ViewProviderGeometryObject::setDisplayMode( ModeName );\n}\n\nstd::vector\u003cstd::string\u003e ViewProviderTrajectory::getDisplayModes(void) const\n{\n    std::vector\u003cstd::string\u003e StrList;\n    StrList.push_back(\"Waypoints\");\n    return StrList;\n}\n\r\nvoid ViewProviderTrajectory::updateData(const App::Property* prop)\r\n{\r\n    Robot::TrajectoryObject* pcTracObj = static_cast\u003cRobot::TrajectoryObject*\u003e(pcObject);\r\n    if (prop == \u0026pcTracObj-\u003eTrajectory) {\r\n        const Trajectory \u0026trak = pcTracObj-\u003eTrajectory.getValue();\r\n\r\n        pcCoords-\u003epoint.deleteValues(0);\r\n        pcCoords-\u003epoint.setNum(trak.getSize());\r\n\r\n        for(unsigned int i=0;i\u003ctrak.getSize();++i){\r\n            Base::Vector3d pos = trak.getWaypoint(i).EndPos.getPosition();\r\n            pcCoords-\u003epoint.set1Value(i,pos.x,pos.y,pos.z);\r\n\r\n        }\r\n        pcLines-\u003enumVertices.set1Value(0, trak.getSize());\r\n\t}else if (prop == \u0026pcTracObj-\u003eBase) {\r\n        Base::Placement loc = *(\u0026pcTracObj-\u003eBase.getValue());\r\n    }\r\n\r\n}\r\n\r\n"}
{"repo_name":"MazZzinatus/storm","ref":"refs/heads/master","path":"src/test/storm-pars/utility/ModelInstantiatorTest.cpp","copies":"1","language":"C++","content":"#include \"gtest/gtest.h\"\n#include \"storm-config.h\"\n\n#ifdef STORM_HAVE_CARL\n\n#include \"storm/adapters/RationalFunctionAdapter.h\"\n#include\u003ccarl/numbers/numbers.h\u003e\n#include\u003ccarl/core/VariablePool.h\u003e\n\n\n#include \"storm/settings/SettingsManager.h\"\n#include \"storm/settings/modules/GeneralSettings.h\"\n\n#include \"storm-pars/utility/ModelInstantiator.h\"\n#include \"storm/api/storm.h\"\n#include \"storm/models/sparse/Model.h\"\n#include \"storm/models/sparse/Dtmc.h\"\n#include \"storm/models/sparse/Mdp.h\"\n\nTEST(ModelInstantiatorTest, BrpProb) {\n    carl::VariablePool::getInstance().clear();\n    \n    std::string programFile = STORM_TEST_RESOURCES_DIR \"/pdtmc/brp16_2.pm\";\n    std::string formulaAsString = \"P=? [F s=5 ]\";\n    \n    // Program and formula\n    storm::prism::Program program = storm::api::parseProgram(programFile);\n    program.checkValidity();\n    std::vector\u003cstd::shared_ptr\u003cstorm::logic::Formula const\u003e\u003e formulas = storm::api::extractFormulasFromProperties(storm::api::parsePropertiesForPrismProgram(formulaAsString, program));\n    ASSERT_TRUE(formulas.size()==1);\n    // Parametric model\n    storm::generator::NextStateGeneratorOptions options(*formulas.front());\n    std::shared_ptr\u003cstorm::models::sparse::Dtmc\u003cstorm::RationalFunction\u003e\u003e dtmc = storm::builder::ExplicitModelBuilder\u003cstorm::RationalFunction\u003e(program, options).build()-\u003eas\u003cstorm::models::sparse::Dtmc\u003cstorm::RationalFunction\u003e\u003e();\n    \n    storm::utility::ModelInstantiator\u003cstorm::models::sparse::Dtmc\u003cstorm::RationalFunction\u003e, storm::models::sparse::Dtmc\u003cdouble\u003e\u003e modelInstantiator(*dtmc);\n    EXPECT_FALSE(dtmc-\u003ehasRewardModel());\n    \n    {\n        std::map\u003cstorm::RationalFunctionVariable, storm::RationalFunctionCoefficient\u003e valuation;\n        storm::RationalFunctionVariable const\u0026 pL = carl::VariablePool::getInstance().findVariableWithName(\"pL\");\n        ASSERT_NE(pL, carl::Variable::NO_VARIABLE);\n        storm::RationalFunctionVariable const\u0026 pK = carl::VariablePool::getInstance().findVariableWithName(\"pK\");\n        ASSERT_NE(pK, carl::Variable::NO_VARIABLE);\n        valuation.insert(std::make_pair(pL, storm::utility::convertNumber\u003cstorm::RationalFunctionCoefficient\u003e(0.8)));\n        valuation.insert(std::make_pair(pK, storm::utility::convertNumber\u003cstorm::RationalFunctionCoefficient\u003e(0.9)));\n\n        storm::models::sparse::Dtmc\u003cdouble\u003e const\u0026 instantiated(modelInstantiator.instantiate(valuation));\n\n        ASSERT_EQ(dtmc-\u003egetTransitionMatrix().getRowGroupIndices(), instantiated.getTransitionMatrix().getRowGroupIndices());\n        for(std::size_t rowGroup = 0; rowGroup \u003c dtmc-\u003egetTransitionMatrix().getRowGroupCount(); ++rowGroup){\n            for(std::size_t row = dtmc-\u003egetTransitionMatrix().getRowGroupIndices()[rowGroup]; row \u003c dtmc-\u003egetTransitionMatrix().getRowGroupIndices()[rowGroup+1]; ++row){\n                auto instantiatedEntry = instantiated.getTransitionMatrix().getRow(row).begin();\n                for(auto const\u0026 paramEntry : dtmc-\u003egetTransitionMatrix().getRow(row)){\n                    EXPECT_EQ(paramEntry.getColumn(), instantiatedEntry-\u003egetColumn());\n                    double evaluatedValue = carl::toDouble(paramEntry.getValue().evaluate(valuation));\n                    EXPECT_EQ(evaluatedValue, instantiatedEntry-\u003egetValue());\n                    ++instantiatedEntry;\n                }\n                EXPECT_EQ(instantiated.getTransitionMatrix().getRow(row).end(),instantiatedEntry);\n            }\n        }\n        EXPECT_EQ(dtmc-\u003egetStateLabeling(), instantiated.getStateLabeling());\n        EXPECT_EQ(dtmc-\u003egetOptionalChoiceLabeling(), instantiated.getOptionalChoiceLabeling());\n\n        storm::modelchecker::SparseDtmcPrctlModelChecker\u003cstorm::models::sparse::Dtmc\u003cdouble\u003e\u003e modelchecker(instantiated);\n        std::unique_ptr\u003cstorm::modelchecker::CheckResult\u003e chkResult = modelchecker.check(*formulas[0]);\n        storm::modelchecker::ExplicitQuantitativeCheckResult\u003cdouble\u003e\u0026 quantitativeChkResult = chkResult-\u003easExplicitQuantitativeCheckResult\u003cdouble\u003e();\n        EXPECT_NEAR(0.2989278941, quantitativeChkResult[*instantiated.getInitialStates().begin()], storm::settings::getModule\u003cstorm::settings::modules::GeneralSettings\u003e().getPrecision());\n    }\n    \n    {\n        std::map\u003cstorm::RationalFunctionVariable, storm::RationalFunctionCoefficient\u003e valuation;\n        storm::RationalFunctionVariable const\u0026 pL = carl::VariablePool::getInstance().findVariableWithName(\"pL\");\n        ASSERT_NE(pL, carl::Variable::NO_VARIABLE);\n        storm::RationalFunctionVariable const\u0026 pK = carl::VariablePool::getInstance().findVariableWithName(\"pK\");\n        ASSERT_NE(pK, carl::Variable::NO_VARIABLE);\n        valuation.insert(std::make_pair(pL, storm::utility::one\u003cstorm::RationalFunctionCoefficient\u003e()));\n        valuation.insert(std::make_pair(pK, storm::utility::one\u003cstorm::RationalFunctionCoefficient\u003e()));\n\n        storm::models::sparse::Dtmc\u003cdouble\u003e const\u0026 instantiated(modelInstantiator.instantiate(valuation));\n\n        ASSERT_EQ(dtmc-\u003egetTransitionMatrix().getRowGroupIndices(), instantiated.getTransitionMatrix().getRowGroupIndices());\n        for(std::size_t rowGroup = 0; rowGroup \u003c dtmc-\u003egetTransitionMatrix().getRowGroupCount(); ++rowGroup){\n            for(std::size_t row = dtmc-\u003egetTransitionMatrix().getRowGroupIndices()[rowGroup]; row \u003c dtmc-\u003egetTransitionMatrix().getRowGroupIndices()[rowGroup+1]; ++row){\n                auto instantiatedEntry = instantiated.getTransitionMatrix().getRow(row).begin();\n                for(auto const\u0026 paramEntry : dtmc-\u003egetTransitionMatrix().getRow(row)){\n                    EXPECT_EQ(paramEntry.getColumn(), instantiatedEntry-\u003egetColumn());\n                    double evaluatedValue = carl::toDouble(paramEntry.getValue().evaluate(valuation));\n                    EXPECT_EQ(evaluatedValue, instantiatedEntry-\u003egetValue());\n                    ++instantiatedEntry;\n                }\n                EXPECT_EQ(instantiated.getTransitionMatrix().getRow(row).end(),instantiatedEntry);\n            }\n        }\n        EXPECT_EQ(dtmc-\u003egetStateLabeling(), instantiated.getStateLabeling());\n        EXPECT_EQ(dtmc-\u003egetOptionalChoiceLabeling(), instantiated.getOptionalChoiceLabeling());\n\n        storm::modelchecker::SparseDtmcPrctlModelChecker\u003cstorm::models::sparse::Dtmc\u003cdouble\u003e\u003e modelchecker(instantiated);\n        std::unique_ptr\u003cstorm::modelchecker::CheckResult\u003e chkResult = modelchecker.check(*formulas[0]);\n        storm::modelchecker::ExplicitQuantitativeCheckResult\u003cdouble\u003e\u0026 quantitativeChkResult = chkResult-\u003easExplicitQuantitativeCheckResult\u003cdouble\u003e();\n        EXPECT_EQ(0.0 , quantitativeChkResult[*instantiated.getInitialStates().begin()]);\n    }\n    \n    {\n        std::map\u003cstorm::RationalFunctionVariable, storm::RationalFunctionCoefficient\u003e valuation;\n        storm::RationalFunctionVariable const\u0026 pL = carl::VariablePool::getInstance().findVariableWithName(\"pL\");\n        ASSERT_NE(pL, carl::Variable::NO_VARIABLE);\n        storm::RationalFunctionVariable const\u0026 pK = carl::VariablePool::getInstance().findVariableWithName(\"pK\");\n        ASSERT_NE(pK, carl::Variable::NO_VARIABLE);\n        valuation.insert(std::make_pair(pL, storm::utility::one\u003cstorm::RationalFunctionCoefficient\u003e()));\n        valuation.insert(std::make_pair(pK, storm::utility::convertNumber\u003cstorm::RationalFunctionCoefficient\u003e(0.9)));\n\n        storm::models::sparse::Dtmc\u003cdouble\u003e const\u0026 instantiated(modelInstantiator.instantiate(valuation));\n\n        ASSERT_EQ(dtmc-\u003egetTransitionMatrix().getRowGroupIndices(), instantiated.getTransitionMatrix().getRowGroupIndices());\n        for(std::size_t rowGroup = 0; rowGroup \u003c dtmc-\u003egetTransitionMatrix().getRowGroupCount(); ++rowGroup){\n            for(std::size_t row = dtmc-\u003egetTransitionMatrix().getRowGroupIndices()[rowGroup]; row \u003c dtmc-\u003egetTransitionMatrix().getRowGroupIndices()[rowGroup+1]; ++row){\n                auto instantiatedEntry = instantiated.getTransitionMatrix().getRow(row).begin();\n                for(auto const\u0026 paramEntry : dtmc-\u003egetTransitionMatrix().getRow(row)){\n                    EXPECT_EQ(paramEntry.getColumn(), instantiatedEntry-\u003egetColumn());\n                    double evaluatedValue = carl::toDouble(paramEntry.getValue().evaluate(valuation));\n                    EXPECT_EQ(evaluatedValue, instantiatedEntry-\u003egetValue());\n                    ++instantiatedEntry;\n                }\n                EXPECT_EQ(instantiated.getTransitionMatrix().getRow(row).end(),instantiatedEntry);\n            }\n        }\n        EXPECT_EQ(dtmc-\u003egetStateLabeling(), instantiated.getStateLabeling());\n        EXPECT_EQ(dtmc-\u003egetOptionalChoiceLabeling(), instantiated.getOptionalChoiceLabeling());\n\n        storm::modelchecker::SparseDtmcPrctlModelChecker\u003cstorm::models::sparse::Dtmc\u003cdouble\u003e\u003e modelchecker(instantiated);\n        std::unique_ptr\u003cstorm::modelchecker::CheckResult\u003e chkResult = modelchecker.check(*formulas[0]);\n        storm::modelchecker::ExplicitQuantitativeCheckResult\u003cdouble\u003e\u0026 quantitativeChkResult = chkResult-\u003easExplicitQuantitativeCheckResult\u003cdouble\u003e();\n        EXPECT_NEAR(0.01588055832, quantitativeChkResult[*instantiated.getInitialStates().begin()], storm::settings::getModule\u003cstorm::settings::modules::GeneralSettings\u003e().getPrecision());\n    }\n}\n\nTEST(ModelInstantiatorTest, Brp_Rew) {\n    carl::VariablePool::getInstance().clear();\n    \n    std::string programFile = STORM_TEST_RESOURCES_DIR \"/pdtmc/brp16_2.pm\";\n    std::string formulaAsString = \"R=? [F ((s=5) | (s=0\u0026srep=3)) ]\";\n    \n    // Program and formula\n    storm::prism::Program program = storm::api::parseProgram(programFile);\n    program.checkValidity();\n    std::vector\u003cstd::shared_ptr\u003cstorm::logic::Formula const\u003e\u003e formulas = storm::api::extractFormulasFromProperties(storm::api::parsePropertiesForPrismProgram(formulaAsString, program));\n    ASSERT_TRUE(formulas.size()==1);\n    // Parametric model\n    storm::generator::NextStateGeneratorOptions options(*formulas.front());\n    std::shared_ptr\u003cstorm::models::sparse::Dtmc\u003cstorm::RationalFunction\u003e\u003e dtmc = storm::builder::ExplicitModelBuilder\u003cstorm::RationalFunction\u003e(program, options).build()-\u003eas\u003cstorm::models::sparse::Dtmc\u003cstorm::RationalFunction\u003e\u003e();\n\n    storm::utility::ModelInstantiator\u003cstorm::models::sparse::Dtmc\u003cstorm::RationalFunction\u003e, storm::models::sparse::Dtmc\u003cdouble\u003e\u003e modelInstantiator(*dtmc);\n    \n    {\n        std::map\u003cstorm::RationalFunctionVariable, storm::RationalFunctionCoefficient\u003e valuation;\n        storm::RationalFunctionVariable const\u0026 pL = carl::VariablePool::getInstance().findVariableWithName(\"pL\");\n        ASSERT_NE(pL, carl::Variable::NO_VARIABLE);\n        storm::RationalFunctionVariable const\u0026 pK = carl::VariablePool::getInstance().findVariableWithName(\"pK\");\n        ASSERT_NE(pK, carl::Variable::NO_VARIABLE);\n        storm::RationalFunctionVariable const\u0026 TOMsg = carl::VariablePool::getInstance().findVariableWithName(\"TOMsg\");\n        ASSERT_NE(pK, carl::Variable::NO_VARIABLE);\n        storm::RationalFunctionVariable const\u0026 TOAck = carl::VariablePool::getInstance().findVariableWithName(\"TOAck\");\n        ASSERT_NE(pK, carl::Variable::NO_VARIABLE);\n        valuation.insert(std::make_pair(pL, storm::utility::convertNumber\u003cstorm::RationalFunctionCoefficient\u003e(0.9)));\n        valuation.insert(std::make_pair(pK, storm::utility::convertNumber\u003cstorm::RationalFunctionCoefficient\u003e(0.3)));\n        valuation.insert(std::make_pair(TOMsg, storm::utility::convertNumber\u003cstorm::RationalFunctionCoefficient\u003e(0.3)));\n        valuation.insert(std::make_pair(TOAck, storm::utility::convertNumber\u003cstorm::RationalFunctionCoefficient\u003e(0.5)));\n\n        storm::models::sparse::Dtmc\u003cdouble\u003e const\u0026 instantiated(modelInstantiator.instantiate(valuation));\n\n        ASSERT_EQ(dtmc-\u003egetTransitionMatrix().getRowGroupIndices(), instantiated.getTransitionMatrix().getRowGroupIndices());\n        for(std::size_t rowGroup = 0; rowGroup \u003c dtmc-\u003egetTransitionMatrix().getRowGroupCount(); ++rowGroup){\n            for(std::size_t row = dtmc-\u003egetTransitionMatrix().getRowGroupIndices()[rowGroup]; row \u003c dtmc-\u003egetTransitionMatrix().getRowGroupIndices()[rowGroup+1]; ++row){\n                auto instantiatedEntry = instantiated.getTransitionMatrix().getRow(row).begin();\n                for(auto const\u0026 paramEntry : dtmc-\u003egetTransitionMatrix().getRow(row)){\n                    EXPECT_EQ(paramEntry.getColumn(), instantiatedEntry-\u003egetColumn());\n                    double evaluatedValue = carl::toDouble(paramEntry.getValue().evaluate(valuation));\n                    EXPECT_EQ(evaluatedValue, instantiatedEntry-\u003egetValue());\n                    ++instantiatedEntry;\n                }\n                EXPECT_EQ(instantiated.getTransitionMatrix().getRow(row).end(),instantiatedEntry);\n            }\n        }\n        ASSERT_TRUE(instantiated.hasUniqueRewardModel());\n        EXPECT_FALSE(instantiated.getUniqueRewardModel().hasStateRewards());\n        EXPECT_FALSE(instantiated.getUniqueRewardModel().hasTransitionRewards());\n        EXPECT_TRUE(instantiated.getUniqueRewardModel().hasStateActionRewards());\n        ASSERT_TRUE(dtmc-\u003egetUniqueRewardModel().hasStateActionRewards());\n        std::size_t stateActionEntries = dtmc-\u003egetUniqueRewardModel().getStateActionRewardVector().size();\n        ASSERT_EQ(stateActionEntries, instantiated.getUniqueRewardModel().getStateActionRewardVector().size());\n        for(std::size_t i =0; i\u003cstateActionEntries; ++i){\n            double evaluatedValue = carl::toDouble(dtmc-\u003egetUniqueRewardModel().getStateActionRewardVector()[i].evaluate(valuation));\n            EXPECT_EQ(evaluatedValue, instantiated.getUniqueRewardModel().getStateActionRewardVector()[i]);\n        }\n        EXPECT_EQ(dtmc-\u003egetStateLabeling(), instantiated.getStateLabeling());\n        EXPECT_EQ(dtmc-\u003egetOptionalChoiceLabeling(), instantiated.getOptionalChoiceLabeling());\n\n        storm::modelchecker::SparseDtmcPrctlModelChecker\u003cstorm::models::sparse::Dtmc\u003cdouble\u003e\u003e modelchecker(instantiated);\n        std::unique_ptr\u003cstorm::modelchecker::CheckResult\u003e chkResult = modelchecker.check(*formulas[0]);\n        storm::modelchecker::ExplicitQuantitativeCheckResult\u003cdouble\u003e\u0026 quantitativeChkResult = chkResult-\u003easExplicitQuantitativeCheckResult\u003cdouble\u003e();\n        EXPECT_NEAR(1.308324495, quantitativeChkResult[*instantiated.getInitialStates().begin()], storm::settings::getModule\u003cstorm::settings::modules::GeneralSettings\u003e().getPrecision());\n    }\n    \n}\n    \n\nTEST(ModelInstantiatorTest, Consensus) {\n    carl::VariablePool::getInstance().clear();\n    \n    std::string programFile = STORM_TEST_RESOURCES_DIR \"/pmdp/coin2_2.nm\";\n    std::string formulaAsString = \"Pmin=? [F \\\"finished\\\"\u0026\\\"all_coins_equal_1\\\" ]\";\n    \n    // Program and formula\n    storm::prism::Program program = storm::api::parseProgram(programFile);\n    program.checkValidity();\n    std::vector\u003cstd::shared_ptr\u003cstorm::logic::Formula const\u003e\u003e formulas = storm::api::extractFormulasFromProperties(storm::api::parsePropertiesForPrismProgram(formulaAsString, program));\n    ASSERT_TRUE(formulas.size()==1);\n    // Parametric model\n    storm::generator::NextStateGeneratorOptions options(*formulas.front());\n    std::shared_ptr\u003cstorm::models::sparse::Mdp\u003cstorm::RationalFunction\u003e\u003e mdp = storm::builder::ExplicitModelBuilder\u003cstorm::RationalFunction\u003e(program, options).build()-\u003eas\u003cstorm::models::sparse::Mdp\u003cstorm::RationalFunction\u003e\u003e();\n\n    storm::utility::ModelInstantiator\u003cstorm::models::sparse::Mdp\u003cstorm::RationalFunction\u003e, storm::models::sparse::Mdp\u003cdouble\u003e\u003e modelInstantiator(*mdp);\n    \n    std::map\u003cstorm::RationalFunctionVariable, storm::RationalFunctionCoefficient\u003e valuation;\n    storm::RationalFunctionVariable const\u0026 p1 = carl::VariablePool::getInstance().findVariableWithName(\"p1\");\n    ASSERT_NE(p1, carl::Variable::NO_VARIABLE);\n    storm::RationalFunctionVariable const\u0026 p2 = carl::VariablePool::getInstance().findVariableWithName(\"p2\");\n    ASSERT_NE(p2, carl::Variable::NO_VARIABLE);\n    valuation.insert(std::make_pair(p1, storm::utility::convertNumber\u003cstorm::RationalFunctionCoefficient\u003e(0.51)));\n    valuation.insert(std::make_pair(p2, storm::utility::convertNumber\u003cstorm::RationalFunctionCoefficient\u003e(0.49)));\n    storm::models::sparse::Mdp\u003cdouble\u003e const\u0026 instantiated(modelInstantiator.instantiate(valuation));\n\n    ASSERT_EQ(mdp-\u003egetTransitionMatrix().getRowGroupIndices(), instantiated.getTransitionMatrix().getRowGroupIndices());\n    for(std::size_t rowGroup = 0; rowGroup \u003c mdp-\u003egetTransitionMatrix().getRowGroupCount(); ++rowGroup){\n        for(std::size_t row = mdp-\u003egetTransitionMatrix().getRowGroupIndices()[rowGroup]; row \u003c mdp-\u003egetTransitionMatrix().getRowGroupIndices()[rowGroup+1]; ++row){\n            auto instantiatedEntry = instantiated.getTransitionMatrix().getRow(row).begin();\n            for(auto const\u0026 paramEntry : mdp-\u003egetTransitionMatrix().getRow(row)){\n                EXPECT_EQ(paramEntry.getColumn(), instantiatedEntry-\u003egetColumn());\n                double evaluatedValue = carl::toDouble(paramEntry.getValue().evaluate(valuation));\n                EXPECT_EQ(evaluatedValue, instantiatedEntry-\u003egetValue());\n                ++instantiatedEntry;\n            }\n            EXPECT_EQ(instantiated.getTransitionMatrix().getRow(row).end(),instantiatedEntry);\n        }\n    }\n    EXPECT_EQ(mdp-\u003egetStateLabeling(), instantiated.getStateLabeling());\n    EXPECT_EQ(mdp-\u003egetOptionalChoiceLabeling(), instantiated.getOptionalChoiceLabeling());\n\n    storm::modelchecker::SparseMdpPrctlModelChecker\u003cstorm::models::sparse::Mdp\u003cdouble\u003e\u003e modelchecker(instantiated);\n    std::unique_ptr\u003cstorm::modelchecker::CheckResult\u003e chkResult = modelchecker.check(*formulas[0]);\n    storm::modelchecker::ExplicitQuantitativeCheckResult\u003cdouble\u003e\u0026 quantitativeChkResult = chkResult-\u003easExplicitQuantitativeCheckResult\u003cdouble\u003e();\n    EXPECT_NEAR(0.3526577219, quantitativeChkResult[*instantiated.getInitialStates().begin()], storm::settings::getModule\u003cstorm::settings::modules::GeneralSettings\u003e().getPrecision());\n}\n\n#endif\n"}
{"repo_name":"fritsvanveen/QGIS","ref":"refs/heads/master","path":"src/gui/qgsnewhttpconnection.cpp","copies":"3","language":"C++","content":"/***************************************************************************\n    qgsnewhttpconnection.cpp -  selector for a new HTTP server for WMS, etc.\n                             -------------------\n    begin                : 3 April 2005\n    copyright            : (C) 2005 by Brendan Morley\n    email                : morb at ozemail dot com dot au\n ***************************************************************************/\n\n/***************************************************************************\n *                                                                         *\n *   This program is free software; you can redistribute it and/or modify  *\n *   it under the terms of the GNU General Public License as published by  *\n *   the Free Software Foundation; either version 2 of the License, or     *\n *   (at your option) any later version.                                   *\n *                                                                         *\n ***************************************************************************/\n#include \"qgsnewhttpconnection.h\"\n#include \"qgscontexthelp.h\"\n#include \"qgsauthconfigselect.h\"\n#include \u003cQSettings\u003e\n#include \u003cQMessageBox\u003e\n#include \u003cQUrl\u003e\n#include \u003cQPushButton\u003e\n#include \u003cQRegExpValidator\u003e\n\nQgsNewHttpConnection::QgsNewHttpConnection(\n  QWidget *parent, const QString\u0026 baseKey, const QString\u0026 connName, Qt::WindowFlags fl )\n    : QDialog( parent, fl )\n    , mBaseKey( baseKey )\n    , mOriginalConnName( connName )\n    , mAuthConfigSelect( nullptr )\n{\n  setupUi( this );\n\n  QString service = baseKey.mid( 18, 3 ).toUpper();\n  setWindowTitle( tr( \"Create a new %1 connection\" ).arg( service ) );\n\n  // It would be obviously much better to use mBaseKey also for credentials,\n  // but for some strange reason a different hardcoded key was used instead.\n  // WFS and WMS credentials were mixed with the same key WMS.\n  // Only WMS and WFS providers are using QgsNewHttpConnection at this moment\n  // using connection-wms and connection-wfs -\u003e parse credential key fro it.\n  mCredentialsBaseKey = mBaseKey.split( '-' ).last().toUpper();\n\n  txtName-\u003esetValidator( new QRegExpValidator( QRegExp( \"[^\\\\/]+\" ), txtName ) );\n\n  cmbDpiMode-\u003eclear();\n  cmbDpiMode-\u003eaddItem( tr( \"all\" ) );\n  cmbDpiMode-\u003eaddItem( tr( \"off\" ) );\n  cmbDpiMode-\u003eaddItem( tr( \"QGIS\" ) );\n  cmbDpiMode-\u003eaddItem( tr( \"UMN\" ) );\n  cmbDpiMode-\u003eaddItem( tr( \"GeoServer\" ) );\n\n  cmbVersion-\u003eclear();\n  cmbVersion-\u003eaddItem( tr( \"Auto-detect\" ) );\n  cmbVersion-\u003eaddItem( tr( \"1.0\" ) );\n  cmbVersion-\u003eaddItem( tr( \"1.1\" ) );\n  cmbVersion-\u003eaddItem( tr( \"2.0\" ) );\n\n  mAuthConfigSelect = new QgsAuthConfigSelect( this );\n  tabAuth-\u003einsertTab( 1, mAuthConfigSelect, tr( \"Configurations\" ) );\n\n  if ( !connName.isEmpty() )\n  {\n    // populate the dialog with the information stored for the connection\n    // populate the fields with the stored setting parameters\n\n    QSettings settings;\n\n    QString key = mBaseKey + connName;\n    QString credentialsKey = \"/Qgis/\" + mCredentialsBaseKey + '/' + connName;\n    txtName-\u003esetText( connName );\n    txtUrl-\u003esetText( settings.value( key + \"/url\" ).toString() );\n\n    cbxIgnoreGetMapURI-\u003esetChecked( settings.value( key + \"/ignoreGetMapURI\", false ).toBool() );\n    cbxIgnoreAxisOrientation-\u003esetChecked( settings.value( key + \"/ignoreAxisOrientation\", false ).toBool() );\n    cbxInvertAxisOrientation-\u003esetChecked( settings.value( key + \"/invertAxisOrientation\", false ).toBool() );\n    cbxIgnoreGetFeatureInfoURI-\u003esetChecked( settings.value( key + \"/ignoreGetFeatureInfoURI\", false ).toBool() );\n    cbxSmoothPixmapTransform-\u003esetChecked( settings.value( key + \"/smoothPixmapTransform\", false ).toBool() );\n\n    int dpiIdx;\n    switch ( settings.value( key + \"/dpiMode\", 7 ).toInt() )\n    {\n      case 0: // off\n        dpiIdx = 1;\n        break;\n      case 1: // QGIS\n        dpiIdx = 2;\n        break;\n      case 2: // UMN\n        dpiIdx = 3;\n        break;\n      case 4: // GeoServer\n        dpiIdx = 4;\n        break;\n      default: // other =\u003e all\n        dpiIdx = 0;\n        break;\n    }\n    cmbDpiMode-\u003esetCurrentIndex( dpiIdx );\n\n    QString version = settings.value( key + \"/version\" ).toString();\n    int versionIdx = 0; // AUTO\n    if ( version == \"1.0.0\" )\n      versionIdx = 1;\n    else if ( version == \"1.1.0\" )\n      versionIdx = 2;\n    else if ( version == \"2.0.0\" )\n      versionIdx = 3;\n    cmbVersion-\u003esetCurrentIndex( versionIdx );\n\n    txtReferer-\u003esetText( settings.value( key + \"/referer\" ).toString() );\n    txtMaxNumFeatures-\u003esetText( settings.value( key + \"/maxnumfeatures\" ).toString() );\n\n    txtUserName-\u003esetText( settings.value( credentialsKey + \"/username\" ).toString() );\n    txtPassword-\u003esetText( settings.value( credentialsKey + \"/password\" ).toString() );\n\n    QString authcfg = settings.value( credentialsKey + \"/authcfg\" ).toString();\n    mAuthConfigSelect-\u003esetConfigId( authcfg );\n    if ( !authcfg.isEmpty() )\n    {\n      tabAuth-\u003esetCurrentIndex( tabAuth-\u003eindexOf( mAuthConfigSelect ) );\n    }\n  }\n\n  if ( mBaseKey != \"/Qgis/connections-wms/\" )\n  {\n    if ( mBaseKey != \"/Qgis/connections-wcs/\" \u0026\u0026\n         mBaseKey != \"/Qgis/connections-wfs/\" )\n    {\n      cbxIgnoreAxisOrientation-\u003esetVisible( false );\n      cbxInvertAxisOrientation-\u003esetVisible( false );\n      mGroupBox-\u003elayout()-\u003eremoveWidget( cbxIgnoreAxisOrientation );\n      mGroupBox-\u003elayout()-\u003eremoveWidget( cbxInvertAxisOrientation );\n    }\n\n    if ( mBaseKey == \"/Qgis/connections-wfs/\" )\n    {\n      cbxIgnoreAxisOrientation-\u003esetText( tr( \"Ignore axis orientation (WFS 1.1/WFS 2.0)\" ) );\n    }\n\n    if ( mBaseKey == \"/Qgis/connections-wcs/\" )\n    {\n      cbxIgnoreGetMapURI-\u003esetText( tr( \"Ignore GetCoverage URI reported in capabilities\" ) );\n      cbxIgnoreAxisOrientation-\u003esetText( tr( \"Ignore axis orientation\" ) );\n    }\n    else\n    {\n      cbxIgnoreGetMapURI-\u003esetVisible( false );\n      cbxSmoothPixmapTransform-\u003esetVisible( false );\n      mGroupBox-\u003elayout()-\u003eremoveWidget( cbxIgnoreGetMapURI );\n      mGroupBox-\u003elayout()-\u003eremoveWidget( cbxSmoothPixmapTransform );\n    }\n\n    cbxIgnoreGetFeatureInfoURI-\u003esetVisible( false );\n    mGroupBox-\u003elayout()-\u003eremoveWidget( cbxIgnoreGetFeatureInfoURI );\n\n    cmbDpiMode-\u003esetVisible( false );\n    mGroupBox-\u003elayout()-\u003eremoveWidget( cmbDpiMode );\n    lblDpiMode-\u003esetVisible( false );\n    mGroupBox-\u003elayout()-\u003eremoveWidget( lblDpiMode );\n\n    txtReferer-\u003esetVisible( false );\n    mGroupBox-\u003elayout()-\u003eremoveWidget( txtReferer );\n    lblReferer-\u003esetVisible( false );\n    mGroupBox-\u003elayout()-\u003eremoveWidget( lblReferer );\n  }\n\n  if ( mBaseKey != \"/Qgis/connections-wfs/\" )\n  {\n    cmbVersion-\u003esetVisible( false );\n    mGroupBox-\u003elayout()-\u003eremoveWidget( cmbVersion );\n    lblMaxNumFeatures-\u003esetVisible( false );\n    mGroupBox-\u003elayout()-\u003eremoveWidget( lblMaxNumFeatures );\n    txtMaxNumFeatures-\u003esetVisible( false );\n    mGroupBox-\u003elayout()-\u003eremoveWidget( txtMaxNumFeatures );\n  }\n\n  // Adjust height\n  int w = width();\n  adjustSize();\n  resize( w, height() );\n\n  on_txtName_textChanged( connName );\n}\n\nQgsNewHttpConnection::~QgsNewHttpConnection()\n{\n}\n\nvoid QgsNewHttpConnection::on_txtName_textChanged( const QString \u0026text )\n{\n  Q_UNUSED( text );\n  buttonBox-\u003ebutton( QDialogButtonBox::Ok )-\u003esetDisabled( txtName-\u003etext().isEmpty() || txtUrl-\u003etext().isEmpty() );\n}\n\nvoid QgsNewHttpConnection::on_txtUrl_textChanged( const QString \u0026text )\n{\n  Q_UNUSED( text );\n  buttonBox-\u003ebutton( QDialogButtonBox::Ok )-\u003esetDisabled( txtName-\u003etext().isEmpty() || txtUrl-\u003etext().isEmpty() );\n}\n\nvoid QgsNewHttpConnection::accept()\n{\n  QSettings settings;\n  QString key = mBaseKey + txtName-\u003etext();\n  QString credentialsKey = \"/Qgis/\" + mCredentialsBaseKey + '/' + txtName-\u003etext();\n\n  // warn if entry was renamed to an existing connection\n  if (( mOriginalConnName.isNull() || mOriginalConnName.compare( txtName-\u003etext(), Qt::CaseInsensitive ) != 0 ) \u0026\u0026\n      settings.contains( key + \"/url\" ) \u0026\u0026\n      QMessageBox::question( this,\n                             tr( \"Save connection\" ),\n                             tr( \"Should the existing connection %1 be overwritten?\" ).arg( txtName-\u003etext() ),\n                             QMessageBox::Ok | QMessageBox::Cancel ) == QMessageBox::Cancel )\n  {\n    return;\n  }\n\n  if ( !txtPassword-\u003etext().isEmpty() \u0026\u0026\n       QMessageBox::question( this,\n                              tr( \"Saving passwords\" ),\n                              tr( \"WARNING: You have entered a password. It will be stored in plain text in your project files and in your home directory on Unix-like systems, or in your user profile on Windows. If you do not want this to happen, please press the Cancel button.\\nNote: giving the password is optional. It will be requested interactivly, when needed.\" ),\n                              QMessageBox::Ok | QMessageBox::Cancel ) == QMessageBox::Cancel )\n  {\n    return;\n  }\n\n  // on rename delete original entry first\n  if ( !mOriginalConnName.isNull() \u0026\u0026 mOriginalConnName != key )\n  {\n    settings.remove( mBaseKey + mOriginalConnName );\n    settings.remove( \"/Qgis/\" + mCredentialsBaseKey + '/' + mOriginalConnName );\n    settings.sync();\n  }\n\n  QUrl url( txtUrl-\u003etext().trimmed() );\n  const QList\u003c QPair\u003cQByteArray, QByteArray\u003e \u003e \u0026items = url.encodedQueryItems();\n  QHash\u003c QString, QPair\u003cQByteArray, QByteArray\u003e \u003e params;\n  for ( QList\u003c QPair\u003cQByteArray, QByteArray\u003e \u003e::const_iterator it = items.constBegin(); it != items.constEnd(); ++it )\n  {\n    params.insert( QString( it-\u003efirst ).toUpper(), *it );\n  }\n\n  if ( params[\"SERVICE\"].second.toUpper() == \"WMS\" ||\n       params[\"SERVICE\"].second.toUpper() == \"WFS\" ||\n       params[\"SERVICE\"].second.toUpper() == \"WCS\" )\n  {\n    url.removeEncodedQueryItem( params[\"SERVICE\"].first );\n    url.removeEncodedQueryItem( params[\"REQUEST\"].first );\n    url.removeEncodedQueryItem( params[\"FORMAT\"].first );\n  }\n\n  if ( url.encodedPath().isEmpty() )\n  {\n    url.setEncodedPath( \"/\" );\n  }\n\n  settings.setValue( key + \"/url\", url.toString() );\n\n  if ( mBaseKey == \"/Qgis/connections-wms/\" ||\n       mBaseKey == \"/Qgis/connections-wcs/\" ||\n       mBaseKey == \"/Qgis/connections-wfs/\" )\n  {\n    settings.setValue( key + \"/ignoreAxisOrientation\", cbxIgnoreAxisOrientation-\u003eisChecked() );\n    settings.setValue( key + \"/invertAxisOrientation\", cbxInvertAxisOrientation-\u003eisChecked() );\n  }\n\n  if ( mBaseKey == \"/Qgis/connections-wms/\" || mBaseKey == \"/Qgis/connections-wcs/\" )\n  {\n    settings.setValue( key + \"/ignoreGetMapURI\", cbxIgnoreGetMapURI-\u003eisChecked() );\n    settings.setValue( key + \"/smoothPixmapTransform\", cbxSmoothPixmapTransform-\u003eisChecked() );\n\n    int dpiMode = 0;\n    switch ( cmbDpiMode-\u003ecurrentIndex() )\n    {\n      case 0: // all =\u003e QGIS|UMN|GeoServer\n        dpiMode = 7;\n        break;\n      case 1: // off\n        dpiMode = 0;\n        break;\n      case 2: // QGIS\n        dpiMode = 1;\n        break;\n      case 3: // UMN\n        dpiMode = 2;\n        break;\n      case 4: // GeoServer\n        dpiMode = 4;\n        break;\n    }\n\n    settings.setValue( key + \"/dpiMode\", dpiMode );\n  }\n  if ( mBaseKey == \"/Qgis/connections-wms/\" )\n  {\n    settings.setValue( key + \"/ignoreGetFeatureInfoURI\", cbxIgnoreGetFeatureInfoURI-\u003eisChecked() );\n  }\n  if ( mBaseKey == \"/Qgis/connections-wfs/\" )\n  {\n    QString version = \"auto\";\n    switch ( cmbVersion-\u003ecurrentIndex() )\n    {\n      case 0:\n        version = \"auto\";\n        break;\n      case 1:\n        version = \"1.0.0\";\n        break;\n      case 2:\n        version = \"1.1.0\";\n        break;\n      case 3:\n        version = \"2.0.0\";\n        break;\n    }\n    settings.setValue( key + \"/version\", version );\n\n    settings.setValue( key + \"/maxnumfeatures\", txtMaxNumFeatures-\u003etext() );\n  }\n\n  settings.setValue( key + \"/referer\", txtReferer-\u003etext() );\n\n  settings.setValue( credentialsKey + \"/username\", txtUserName-\u003etext() );\n  settings.setValue( credentialsKey + \"/password\", txtPassword-\u003etext() );\n\n  settings.setValue( credentialsKey + \"/authcfg\", mAuthConfigSelect-\u003econfigId() );\n\n  settings.setValue( mBaseKey + \"/selected\", txtName-\u003etext() );\n\n  QDialog::accept();\n}\n"}
